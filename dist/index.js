/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 6570:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const currentNodeVersion = process.versions.node;
const semver = currentNodeVersion.split('.');
const [major] = [+semver[0]];

if (major < 12) {
  // eslint-disable-next-line no-console
  console.error(
      'You are running Node.js ' +
      currentNodeVersion +
      '.\n' +
      'Playwright requires Node.js 12 or higher. \n' +
      'Please update your version of Node.js.'
  );
  process.exit(1);
}

module.exports = __nccwpck_require__(2698);


/***/ }),

/***/ 5309:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BrowserServerLauncherImpl = void 0;

var _utilsBundle = __nccwpck_require__(1319);

var _clientHelper = __nccwpck_require__(6886);

var _utils = __nccwpck_require__(3557);

var _instrumentation = __nccwpck_require__(6686);

var _playwright = __nccwpck_require__(4506);

var _playwrightServer = __nccwpck_require__(7358);

var _helper = __nccwpck_require__(9175);

var _stackTrace = __nccwpck_require__(9030);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserServerLauncherImpl {
  constructor(browserName) {
    this._browserName = void 0;
    this._browserName = browserName;
  }

  async launchServer(options = {}) {
    const playwright = (0, _playwright.createPlaywright)('javascript'); // 1. Pre-launch the browser

    const metadata = (0, _instrumentation.serverSideCallMetadata)();
    const browser = await playwright[this._browserName].launch(metadata, { ...options,
      ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,
      ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
      env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : undefined
    }, toProtocolLogger(options.logger)).catch(e => {
      const log = _helper.helper.formatBrowserLogs(metadata.log);

      (0, _stackTrace.rewriteErrorMessage)(e, `${e.message} Failed to launch browser.${log}`);
      throw e;
    });
    let path = `/${(0, _utils.createGuid)()}`;
    if (options.wsPath) path = options.wsPath.startsWith('/') ? options.wsPath : `/${options.wsPath}`; // 2. Start the server

    const server = new _playwrightServer.PlaywrightServer('use-pre-launched-browser', {
      path,
      maxConcurrentConnections: Infinity,
      maxIncomingConnections: Infinity,
      enableSocksProxy: false,
      preLaunchedBrowser: browser
    });
    const wsEndpoint = await server.listen(options.port); // 3. Return the BrowserServer interface

    const browserServer = new _utilsBundle.ws.EventEmitter();

    browserServer.process = () => browser.options.browserProcess.process;

    browserServer.wsEndpoint = () => wsEndpoint;

    browserServer.close = () => browser.options.browserProcess.close();

    browserServer.kill = () => browser.options.browserProcess.kill();

    browserServer._disconnectForTest = () => server.close();

    browserServer._userDataDirForTest = browser._userDataDirForTest;

    browser.options.browserProcess.onclose = async (exitCode, signal) => {
      server.close();
      browserServer.emit('close', exitCode, signal);
    };

    return browserServer;
  }

}

exports.BrowserServerLauncherImpl = BrowserServerLauncherImpl;

function toProtocolLogger(logger) {
  return logger ? (direction, message) => {
    if (logger.isEnabled('protocol', 'verbose')) logger.log('protocol', 'verbose', (direction === 'send' ? 'SEND ► ' : '◀ RECV ') + JSON.stringify(message), [], {});
  } : undefined;
}

/***/ }),

/***/ 9996:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Accessibility = void 0;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function axNodeFromProtocol(axNode) {
  const result = { ...axNode,
    value: axNode.valueNumber !== undefined ? axNode.valueNumber : axNode.valueString,
    checked: axNode.checked === 'checked' ? true : axNode.checked === 'unchecked' ? false : axNode.checked,
    pressed: axNode.pressed === 'pressed' ? true : axNode.pressed === 'released' ? false : axNode.pressed,
    children: axNode.children ? axNode.children.map(axNodeFromProtocol) : undefined
  };
  delete result.valueNumber;
  delete result.valueString;
  return result;
}

class Accessibility {
  constructor(channel) {
    this._channel = void 0;
    this._channel = channel;
  }

  async snapshot(options = {}) {
    const root = options.root ? options.root._elementChannel : undefined;
    const result = await this._channel.accessibilitySnapshot({
      interestingOnly: options.interestingOnly,
      root
    });
    return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
  }

}

exports.Accessibility = Accessibility;

/***/ }),

/***/ 8068:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AndroidWebView = exports.AndroidSocket = exports.AndroidInput = exports.AndroidDevice = exports.Android = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _utils = __nccwpck_require__(3557);

var _events = __nccwpck_require__(8289);

var _browserContext = __nccwpck_require__(4096);

var _channelOwner = __nccwpck_require__(1578);

var _timeoutSettings = __nccwpck_require__(9053);

var _waiter = __nccwpck_require__(1145);

var _events2 = __nccwpck_require__(2361);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Android extends _channelOwner.ChannelOwner {
  static from(android) {
    return android._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._timeoutSettings = void 0;
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);

    this._channel.setDefaultTimeoutNoReply({
      timeout
    });
  }

  async devices(options = {}) {
    const {
      devices
    } = await this._channel.devices(options);
    return devices.map(d => AndroidDevice.from(d));
  }

}

exports.Android = Android;

class AndroidDevice extends _channelOwner.ChannelOwner {
  static from(androidDevice) {
    return androidDevice._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._timeoutSettings = void 0;
    this._webViews = new Map();
    this.input = void 0;
    this.input = new AndroidInput(this);
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(parent._timeoutSettings);

    this._channel.on('webViewAdded', ({
      webView
    }) => this._onWebViewAdded(webView));

    this._channel.on('webViewRemoved', ({
      socketName
    }) => this._onWebViewRemoved(socketName));
  }

  _onWebViewAdded(webView) {
    const view = new AndroidWebView(this, webView);

    this._webViews.set(webView.socketName, view);

    this.emit(_events.Events.AndroidDevice.WebView, view);
  }

  _onWebViewRemoved(socketName) {
    const view = this._webViews.get(socketName);

    this._webViews.delete(socketName);

    if (view) view.emit(_events.Events.AndroidWebView.Close);
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);

    this._channel.setDefaultTimeoutNoReply({
      timeout
    });
  }

  serial() {
    return this._initializer.serial;
  }

  model() {
    return this._initializer.model;
  }

  webViews() {
    return [...this._webViews.values()];
  }

  async webView(selector, options) {
    const predicate = v => {
      if (selector.pkg) return v.pkg() === selector.pkg;
      if (selector.socketName) return v._socketName() === selector.socketName;
      return false;
    };

    const webView = [...this._webViews.values()].find(predicate);
    if (webView) return webView;
    return this.waitForEvent('webview', { ...options,
      predicate
    });
  }

  async wait(selector, options) {
    await this._channel.wait({
      selector: toSelectorChannel(selector),
      ...options
    });
  }

  async fill(selector, text, options) {
    await this._channel.fill({
      selector: toSelectorChannel(selector),
      text,
      ...options
    });
  }

  async press(selector, key, options) {
    await this.tap(selector, options);
    await this.input.press(key);
  }

  async tap(selector, options) {
    await this._channel.tap({
      selector: toSelectorChannel(selector),
      ...options
    });
  }

  async drag(selector, dest, options) {
    await this._channel.drag({
      selector: toSelectorChannel(selector),
      dest,
      ...options
    });
  }

  async fling(selector, direction, options) {
    await this._channel.fling({
      selector: toSelectorChannel(selector),
      direction,
      ...options
    });
  }

  async longTap(selector, options) {
    await this._channel.longTap({
      selector: toSelectorChannel(selector),
      ...options
    });
  }

  async pinchClose(selector, percent, options) {
    await this._channel.pinchClose({
      selector: toSelectorChannel(selector),
      percent,
      ...options
    });
  }

  async pinchOpen(selector, percent, options) {
    await this._channel.pinchOpen({
      selector: toSelectorChannel(selector),
      percent,
      ...options
    });
  }

  async scroll(selector, direction, percent, options) {
    await this._channel.scroll({
      selector: toSelectorChannel(selector),
      direction,
      percent,
      ...options
    });
  }

  async swipe(selector, direction, percent, options) {
    await this._channel.swipe({
      selector: toSelectorChannel(selector),
      direction,
      percent,
      ...options
    });
  }

  async info(selector) {
    return (await this._channel.info({
      selector: toSelectorChannel(selector)
    })).info;
  }

  async screenshot(options = {}) {
    const {
      binary
    } = await this._channel.screenshot();
    if (options.path) await _fs.default.promises.writeFile(options.path, binary);
    return binary;
  }

  async close() {
    await this._channel.close();
    this.emit(_events.Events.AndroidDevice.Close);
  }

  async shell(command) {
    const {
      result
    } = await this._channel.shell({
      command
    });
    return result;
  }

  async open(command) {
    return AndroidSocket.from((await this._channel.open({
      command
    })).socket);
  }

  async installApk(file, options) {
    await this._channel.installApk({
      file: await loadFile(file),
      args: options && options.args
    });
  }

  async push(file, path, options) {
    await this._channel.push({
      file: await loadFile(file),
      path,
      mode: options ? options.mode : undefined
    });
  }

  async launchBrowser(options = {}) {
    const contextOptions = await (0, _browserContext.prepareBrowserContextParams)(options);
    const {
      context
    } = await this._channel.launchBrowser(contextOptions);
    return _browserContext.BrowserContext.from(context);
  }

  async waitForEvent(event, optionsOrPredicate = {}) {
    return this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);

      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;

      const waiter = _waiter.Waiter.createForEvent(this, event);

      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== _events.Events.AndroidDevice.Close) waiter.rejectOnEvent(this, _events.Events.AndroidDevice.Close, new Error('Device closed'));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }

}

exports.AndroidDevice = AndroidDevice;

class AndroidSocket extends _channelOwner.ChannelOwner {
  static from(androidDevice) {
    return androidDevice._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);

    this._channel.on('data', ({
      data
    }) => this.emit(_events.Events.AndroidSocket.Data, data));

    this._channel.on('close', () => this.emit(_events.Events.AndroidSocket.Close));
  }

  async write(data) {
    await this._channel.write({
      data
    });
  }

  async close() {
    await this._channel.close();
  }

}

exports.AndroidSocket = AndroidSocket;

async function loadFile(file) {
  if ((0, _utils.isString)(file)) return _fs.default.promises.readFile(file);
  return file;
}

class AndroidInput {
  constructor(device) {
    this._device = void 0;
    this._device = device;
  }

  async type(text) {
    await this._device._channel.inputType({
      text
    });
  }

  async press(key) {
    await this._device._channel.inputPress({
      key
    });
  }

  async tap(point) {
    await this._device._channel.inputTap({
      point
    });
  }

  async swipe(from, segments, steps) {
    await this._device._channel.inputSwipe({
      segments,
      steps
    });
  }

  async drag(from, to, steps) {
    await this._device._channel.inputDrag({
      from,
      to,
      steps
    });
  }

}

exports.AndroidInput = AndroidInput;

function toSelectorChannel(selector) {
  const {
    checkable,
    checked,
    clazz,
    clickable,
    depth,
    desc,
    enabled,
    focusable,
    focused,
    hasChild,
    hasDescendant,
    longClickable,
    pkg,
    res,
    scrollable,
    selected,
    text
  } = selector;

  const toRegex = value => {
    if (value === undefined) return undefined;
    if ((0, _utils.isRegExp)(value)) return value.source;
    return '^' + value.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d') + '$';
  };

  return {
    checkable,
    checked,
    clazz: toRegex(clazz),
    pkg: toRegex(pkg),
    desc: toRegex(desc),
    res: toRegex(res),
    text: toRegex(text),
    clickable,
    depth,
    enabled,
    focusable,
    focused,
    hasChild: hasChild ? {
      selector: toSelectorChannel(hasChild.selector)
    } : undefined,
    hasDescendant: hasDescendant ? {
      selector: toSelectorChannel(hasDescendant.selector),
      maxDepth: hasDescendant.maxDepth
    } : undefined,
    longClickable,
    scrollable,
    selected
  };
}

class AndroidWebView extends _events2.EventEmitter {
  constructor(device, data) {
    super();
    this._device = void 0;
    this._data = void 0;
    this._pagePromise = void 0;
    this._device = device;
    this._data = data;
  }

  pid() {
    return this._data.pid;
  }

  pkg() {
    return this._data.pkg;
  }

  _socketName() {
    return this._data.socketName;
  }

  async page() {
    if (!this._pagePromise) this._pagePromise = this._fetchPage();
    return this._pagePromise;
  }

  async _fetchPage() {
    const {
      context
    } = await this._device._channel.connectToWebView({
      socketName: this._data.socketName
    });
    return _browserContext.BrowserContext.from(context).pages()[0];
  }

}

exports.AndroidWebView = AndroidWebView;

/***/ }),

/***/ 5043:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Artifact = void 0;

var fs = _interopRequireWildcard(__nccwpck_require__(7147));

var _stream = __nccwpck_require__(8423);

var _fileUtils = __nccwpck_require__(6034);

var _channelOwner = __nccwpck_require__(1578);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Artifact extends _channelOwner.ChannelOwner {
  static from(channel) {
    return channel._object;
  }

  async pathAfterFinished() {
    if (this._connection.isRemote()) throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
    return (await this._channel.pathAfterFinished()).value || null;
  }

  async saveAs(path) {
    if (!this._connection.isRemote()) {
      await this._channel.saveAs({
        path
      });
      return;
    }

    const result = await this._channel.saveAsStream();

    const stream = _stream.Stream.from(result.stream);

    await (0, _fileUtils.mkdirIfNeeded)(path);
    await new Promise((resolve, reject) => {
      stream.stream().pipe(fs.createWriteStream(path)).on('finish', resolve).on('error', reject);
    });
  }

  async failure() {
    return (await this._channel.failure()).error || null;
  }

  async createReadStream() {
    const result = await this._channel.stream();
    if (!result.stream) return null;

    const stream = _stream.Stream.from(result.stream);

    return stream.stream();
  }

  async cancel() {
    return this._channel.cancel();
  }

  async delete() {
    return this._channel.delete();
  }

}

exports.Artifact = Artifact;

/***/ }),

/***/ 8960:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Browser = void 0;

var _browserContext = __nccwpck_require__(4096);

var _channelOwner = __nccwpck_require__(1578);

var _events = __nccwpck_require__(8289);

var _errors = __nccwpck_require__(542);

var _cdpSession = __nccwpck_require__(5128);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Browser extends _channelOwner.ChannelOwner {
  static from(browser) {
    return browser._object;
  }

  static fromNullable(browser) {
    return browser ? Browser.from(browser) : null;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._contexts = new Set();
    this._isConnected = true;
    this._closedPromise = void 0;
    this._shouldCloseConnectionOnClose = false;
    this._browserType = void 0;
    this._name = void 0;
    this._name = initializer.name;

    this._channel.on('close', () => this._didClose());

    this._closedPromise = new Promise(f => this.once(_events.Events.Browser.Disconnected, f));
  }

  _setBrowserType(browserType) {
    this._browserType = browserType;

    for (const context of this._contexts) context._setBrowserType(browserType);
  }

  browserType() {
    return this._browserType;
  }

  async newContext(options = {}) {
    return await this._innerNewContext(options, false);
  }

  async _newContextForReuse(options = {}) {
    for (const context of this._contexts) {
      var _this$_browserType$_o, _this$_browserType;

      await ((_this$_browserType$_o = (_this$_browserType = this._browserType)._onWillCloseContext) === null || _this$_browserType$_o === void 0 ? void 0 : _this$_browserType$_o.call(_this$_browserType, context));

      context._onClose();
    }

    this._contexts.clear();

    return await this._innerNewContext(options, true);
  }

  async _innerNewContext(options = {}, forReuse) {
    var _this$_browserType$_o2, _this$_browserType2;

    options = { ...this._browserType._defaultContextOptions,
      ...options
    };
    const contextOptions = await (0, _browserContext.prepareBrowserContextParams)(options);
    const response = forReuse ? await this._channel.newContextForReuse(contextOptions) : await this._channel.newContext(contextOptions);

    const context = _browserContext.BrowserContext.from(response.context);

    context._options = contextOptions;

    this._contexts.add(context);

    context._logger = options.logger || this._logger;

    context._setBrowserType(this._browserType);

    await ((_this$_browserType$_o2 = (_this$_browserType2 = this._browserType)._onDidCreateContext) === null || _this$_browserType$_o2 === void 0 ? void 0 : _this$_browserType$_o2.call(_this$_browserType2, context));
    return context;
  }

  contexts() {
    return [...this._contexts];
  }

  version() {
    return this._initializer.version;
  }

  async newPage(options = {}) {
    const context = await this.newContext(options);
    const page = await context.newPage();
    page._ownedContext = context;
    context._ownerPage = page;
    return page;
  }

  isConnected() {
    return this._isConnected;
  }

  async newBrowserCDPSession() {
    return _cdpSession.CDPSession.from((await this._channel.newBrowserCDPSession()).session);
  }

  async startTracing(page, options = {}) {
    await this._channel.startTracing({ ...options,
      page: page ? page._channel : undefined
    });
  }

  async stopTracing() {
    return (await this._channel.stopTracing()).binary;
  }

  async close() {
    try {
      if (this._shouldCloseConnectionOnClose) this._connection.close(_errors.kBrowserClosedError);else await this._channel.close();
      await this._closedPromise;
    } catch (e) {
      if ((0, _errors.isSafeCloseError)(e)) return;
      throw e;
    }
  }

  _didClose() {
    this._isConnected = false;
    this.emit(_events.Events.Browser.Disconnected, this);
  }

}

exports.Browser = Browser;

/***/ }),

/***/ 4096:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BrowserContext = void 0;
exports.prepareBrowserContextParams = prepareBrowserContextParams;

var _page = __nccwpck_require__(2374);

var _frame = __nccwpck_require__(1730);

var network = _interopRequireWildcard(__nccwpck_require__(6529));

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _channelOwner = __nccwpck_require__(1578);

var _clientHelper = __nccwpck_require__(6886);

var _browser = __nccwpck_require__(8960);

var _worker = __nccwpck_require__(395);

var _events = __nccwpck_require__(8289);

var _timeoutSettings = __nccwpck_require__(9053);

var _waiter = __nccwpck_require__(1145);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _errors = __nccwpck_require__(542);

var _cdpSession = __nccwpck_require__(5128);

var _tracing = __nccwpck_require__(2303);

var _artifact = __nccwpck_require__(5043);

var _fetch = __nccwpck_require__(3750);

var _clientInstrumentation = __nccwpck_require__(6389);

var _stackTrace = __nccwpck_require__(9030);

var _harRouter = __nccwpck_require__(4810);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserContext extends _channelOwner.ChannelOwner {
  static from(context) {
    return context._object;
  }

  static fromNullable(context) {
    return context ? BrowserContext.from(context) : null;
  }

  constructor(parent, type, guid, initializer) {
    var _this$_browser;

    super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
    this._pages = new Set();
    this._routes = [];
    this._browser = null;
    this._browserType = void 0;
    this._bindings = new Map();
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
    this._ownerPage = void 0;
    this._closedPromise = void 0;
    this._options = {};
    this.request = void 0;
    this.tracing = void 0;
    this._backgroundPages = new Set();
    this._serviceWorkers = new Set();
    this._isChromium = void 0;
    this._harRecorders = new Map();
    if (parent instanceof _browser.Browser) this._browser = parent;
    this._isChromium = ((_this$_browser = this._browser) === null || _this$_browser === void 0 ? void 0 : _this$_browser._name) === 'chromium';
    this.tracing = _tracing.Tracing.from(initializer.tracing);
    this.request = _fetch.APIRequestContext.from(initializer.requestContext);

    this._channel.on('bindingCall', ({
      binding
    }) => this._onBinding(_page.BindingCall.from(binding)));

    this._channel.on('close', () => this._onClose());

    this._channel.on('page', ({
      page
    }) => this._onPage(_page.Page.from(page)));

    this._channel.on('route', ({
      route,
      request
    }) => this._onRoute(network.Route.from(route), network.Request.from(request)));

    this._channel.on('backgroundPage', ({
      page
    }) => {
      const backgroundPage = _page.Page.from(page);

      this._backgroundPages.add(backgroundPage);

      this.emit(_events.Events.BrowserContext.BackgroundPage, backgroundPage);
    });

    this._channel.on('serviceWorker', ({
      worker
    }) => {
      const serviceWorker = _worker.Worker.from(worker);

      serviceWorker._context = this;

      this._serviceWorkers.add(serviceWorker);

      this.emit(_events.Events.BrowserContext.ServiceWorker, serviceWorker);
    });

    this._channel.on('request', ({
      request,
      page
    }) => this._onRequest(network.Request.from(request), _page.Page.fromNullable(page)));

    this._channel.on('requestFailed', ({
      request,
      failureText,
      responseEndTiming,
      page
    }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, _page.Page.fromNullable(page)));

    this._channel.on('requestFinished', params => this._onRequestFinished(params));

    this._channel.on('response', ({
      response,
      page
    }) => this._onResponse(network.Response.from(response), _page.Page.fromNullable(page)));

    this._closedPromise = new Promise(f => this.once(_events.Events.BrowserContext.Close, f));
  }

  _setBrowserType(browserType) {
    this._browserType = browserType;

    browserType._contexts.add(this);

    if (this._options.recordHar) this._harRecorders.set('', {
      path: this._options.recordHar.path,
      content: this._options.recordHar.content
    });
  }

  _onPage(page) {
    this._pages.add(page);

    this.emit(_events.Events.BrowserContext.Page, page);
    if (page._opener && !page._opener.isClosed()) page._opener.emit(_events.Events.Page.Popup, page);
  }

  _onRequest(request, page) {
    this.emit(_events.Events.BrowserContext.Request, request);
    if (page) page.emit(_events.Events.Page.Request, request);
  }

  _onResponse(response, page) {
    this.emit(_events.Events.BrowserContext.Response, response);
    if (page) page.emit(_events.Events.Page.Response, response);
  }

  _onRequestFailed(request, responseEndTiming, failureText, page) {
    request._failureText = failureText || null;
    if (request._timing) request._timing.responseEnd = responseEndTiming;
    this.emit(_events.Events.BrowserContext.RequestFailed, request);
    if (page) page.emit(_events.Events.Page.RequestFailed, request);
  }

  _onRequestFinished(params) {
    const {
      responseEndTiming
    } = params;
    const request = network.Request.from(params.request);
    const response = network.Response.fromNullable(params.response);

    const page = _page.Page.fromNullable(params.page);

    if (request._timing) request._timing.responseEnd = responseEndTiming;
    this.emit(_events.Events.BrowserContext.RequestFinished, request);
    if (page) page.emit(_events.Events.Page.RequestFinished, request);
    if (response) response._finishedPromise.resolve();
  }

  async _onRoute(route, request) {
    const routeHandlers = this._routes.slice();

    for (const routeHandler of routeHandlers) {
      if (!routeHandler.matches(request.url())) continue;
      if (routeHandler.willExpire()) this._routes.splice(this._routes.indexOf(routeHandler), 1);
      const handled = await routeHandler.handle(route, request);
      if (!this._routes.length) this._wrapApiCall(() => this._disableInterception(), true).catch(() => {});
      if (handled) return;
    }

    await route._innerContinue(true);
  }

  async _onBinding(bindingCall) {
    const func = this._bindings.get(bindingCall._initializer.name);

    if (!func) return;
    await bindingCall.call(func);
  }

  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);

    this._wrapApiCall(async () => {
      this._channel.setDefaultNavigationTimeoutNoReply({
        timeout
      }).catch(() => {});
    }, true);
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);

    this._wrapApiCall(async () => {
      this._channel.setDefaultTimeoutNoReply({
        timeout
      }).catch(() => {});
    }, true);
  }

  browser() {
    return this._browser;
  }

  pages() {
    return [...this._pages];
  }

  async newPage() {
    if (this._ownerPage) throw new Error('Please use browser.newContext()');
    return _page.Page.from((await this._channel.newPage()).page);
  }

  async cookies(urls) {
    if (!urls) urls = [];
    if (urls && typeof urls === 'string') urls = [urls];
    return (await this._channel.cookies({
      urls: urls
    })).cookies;
  }

  async addCookies(cookies) {
    await this._channel.addCookies({
      cookies
    });
  }

  async clearCookies() {
    await this._channel.clearCookies();
  }

  async grantPermissions(permissions, options) {
    await this._channel.grantPermissions({
      permissions,
      ...options
    });
  }

  async clearPermissions() {
    await this._channel.clearPermissions();
  }

  async setGeolocation(geolocation) {
    await this._channel.setGeolocation({
      geolocation: geolocation || undefined
    });
  }

  async setExtraHTTPHeaders(headers) {
    network.validateHeaders(headers);
    await this._channel.setExtraHTTPHeaders({
      headers: (0, _utils.headersObjectToArray)(headers)
    });
  }

  async setOffline(offline) {
    await this._channel.setOffline({
      offline
    });
  }

  async setHTTPCredentials(httpCredentials) {
    await this._channel.setHTTPCredentials({
      httpCredentials: httpCredentials || undefined
    });
  }

  async addInitScript(script, arg) {
    const source = await (0, _clientHelper.evaluationScript)(script, arg);
    await this._channel.addInitScript({
      source
    });
  }

  async exposeBinding(name, callback, options = {}) {
    await this._channel.exposeBinding({
      name,
      needsHandle: options.handle
    });

    this._bindings.set(name, callback);
  }

  async exposeFunction(name, callback) {
    await this._channel.exposeBinding({
      name
    });

    const binding = (source, ...args) => callback(...args);

    this._bindings.set(name, binding);
  }

  async route(url, handler, options = {}) {
    this._routes.unshift(new network.RouteHandler(this._options.baseURL, url, handler, options.times));

    if (this._routes.length === 1) await this._channel.setNetworkInterceptionEnabled({
      enabled: true
    });
  }

  async _recordIntoHAR(har, page, options = {}) {
    const {
      harId
    } = await this._channel.harStart({
      page: page === null || page === void 0 ? void 0 : page._channel,
      options: prepareRecordHarOptions({
        path: har,
        content: 'attach',
        mode: 'minimal',
        urlFilter: options.url
      })
    });

    this._harRecorders.set(harId, {
      path: har,
      content: 'attach'
    });
  }

  async routeFromHAR(har, options = {}) {
    if (options.update) {
      await this._recordIntoHAR(har, null, options);
      return;
    }

    const harRouter = await _harRouter.HarRouter.create(this._connection.localUtils(), har, options.notFound || 'abort', {
      urlMatch: options.url
    });
    harRouter.addContextRoute(this);
  }

  async unroute(url, handler) {
    this._routes = this._routes.filter(route => route.url !== url || handler && route.handler !== handler);
    if (!this._routes.length) await this._disableInterception();
  }

  async _disableInterception() {
    await this._channel.setNetworkInterceptionEnabled({
      enabled: false
    });
  }

  async waitForEvent(event, optionsOrPredicate = {}) {
    return this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);

      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;

      const waiter = _waiter.Waiter.createForEvent(this, event);

      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== _events.Events.BrowserContext.Close) waiter.rejectOnEvent(this, _events.Events.BrowserContext.Close, new Error('Context closed'));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }

  async storageState(options = {}) {
    const state = await this._channel.storageState();

    if (options.path) {
      await (0, _fileUtils.mkdirIfNeeded)(options.path);
      await _fs.default.promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');
    }

    return state;
  }

  backgroundPages() {
    return [...this._backgroundPages];
  }

  serviceWorkers() {
    return [...this._serviceWorkers];
  }

  async newCDPSession(page) {
    // channelOwner.ts's validation messages don't handle the pseudo-union type, so we're explicit here
    if (!(page instanceof _page.Page) && !(page instanceof _frame.Frame)) throw new Error('page: expected Page or Frame');
    const result = await this._channel.newCDPSession(page instanceof _page.Page ? {
      page: page._channel
    } : {
      frame: page._channel
    });
    return _cdpSession.CDPSession.from(result.session);
  }

  _onClose() {
    var _this$_browserType, _this$_browserType$_c;

    if (this._browser) this._browser._contexts.delete(this);
    (_this$_browserType = this._browserType) === null || _this$_browserType === void 0 ? void 0 : (_this$_browserType$_c = _this$_browserType._contexts) === null || _this$_browserType$_c === void 0 ? void 0 : _this$_browserType$_c.delete(this);
    this.emit(_events.Events.BrowserContext.Close, this);
  }

  async close() {
    try {
      await this._wrapApiCall(async () => {
        var _this$_browserType2, _this$_browserType2$_;

        await ((_this$_browserType2 = this._browserType) === null || _this$_browserType2 === void 0 ? void 0 : (_this$_browserType2$_ = _this$_browserType2._onWillCloseContext) === null || _this$_browserType2$_ === void 0 ? void 0 : _this$_browserType2$_.call(_this$_browserType2, this));

        for (const [harId, harParams] of this._harRecorders) {
          const har = await this._channel.harExport({
            harId
          });

          const artifact = _artifact.Artifact.from(har.artifact); // Server side will compress artifact if content is attach or if file is .zip.


          const isCompressed = harParams.content === 'attach' || harParams.path.endsWith('.zip');
          const needCompressed = harParams.path.endsWith('.zip');

          if (isCompressed && !needCompressed) {
            await artifact.saveAs(harParams.path + '.tmp');
            await this._connection.localUtils()._channel.harUnzip({
              zipFile: harParams.path + '.tmp',
              harFile: harParams.path
            });
          } else {
            await artifact.saveAs(harParams.path);
          }

          await artifact.delete();
        }
      }, true);
      await this._channel.close();
      await this._closedPromise;
    } catch (e) {
      if ((0, _errors.isSafeCloseError)(e)) return;
      throw e;
    }
  }

  async _enableRecorder(params) {
    await this._channel.recorderSupplementEnable(params);
  }

}

exports.BrowserContext = BrowserContext;

async function prepareStorageState(options) {
  if (typeof options.storageState !== 'string') return options.storageState;

  try {
    return JSON.parse(await _fs.default.promises.readFile(options.storageState, 'utf8'));
  } catch (e) {
    (0, _stackTrace.rewriteErrorMessage)(e, `Error reading storage state from ${options.storageState}:\n` + e.message);
    throw e;
  }
}

function prepareRecordHarOptions(options) {
  if (!options) return;
  return {
    path: options.path,
    content: options.content || (options.omitContent ? 'omit' : undefined),
    urlGlob: (0, _utils.isString)(options.urlFilter) ? options.urlFilter : undefined,
    urlRegexSource: (0, _utils.isRegExp)(options.urlFilter) ? options.urlFilter.source : undefined,
    urlRegexFlags: (0, _utils.isRegExp)(options.urlFilter) ? options.urlFilter.flags : undefined,
    mode: options.mode
  };
}

async function prepareBrowserContextParams(options) {
  if (options.videoSize && !options.videosPath) throw new Error(`"videoSize" option requires "videosPath" to be specified`);
  if (options.extraHTTPHeaders) network.validateHeaders(options.extraHTTPHeaders);
  const contextParams = { ...options,
    viewport: options.viewport === null ? undefined : options.viewport,
    noDefaultViewport: options.viewport === null,
    extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : undefined,
    storageState: await prepareStorageState(options),
    serviceWorkers: options.serviceWorkers,
    recordHar: prepareRecordHarOptions(options.recordHar)
  };

  if (!contextParams.recordVideo && options.videosPath) {
    contextParams.recordVideo = {
      dir: options.videosPath,
      size: options.videoSize
    };
  }

  return contextParams;
}

/***/ }),

/***/ 2450:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BrowserType = void 0;

var _browser3 = __nccwpck_require__(8960);

var _browserContext = __nccwpck_require__(4096);

var _channelOwner = __nccwpck_require__(1578);

var _connection = __nccwpck_require__(1776);

var _events = __nccwpck_require__(8289);

var _clientHelper = __nccwpck_require__(6886);

var _utils = __nccwpck_require__(3557);

var _errors = __nccwpck_require__(542);

var _timeoutRunner = __nccwpck_require__(803);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserType extends _channelOwner.ChannelOwner {
  constructor(...args) {
    super(...args);
    this._serverLauncher = void 0;
    this._contexts = new Set();
    this._playwright = void 0;
    this._defaultContextOptions = void 0;
    this._defaultLaunchOptions = void 0;
    this._onDidCreateContext = void 0;
    this._onWillCloseContext = void 0;
  }

  static from(browserType) {
    return browserType._object;
  }

  executablePath() {
    if (!this._initializer.executablePath) throw new Error('Browser is not supported on current platform');
    return this._initializer.executablePath;
  }

  name() {
    return this._initializer.name;
  }

  async launch(options = {}) {
    var _this$_defaultLaunchO;

    const logger = options.logger || ((_this$_defaultLaunchO = this._defaultLaunchOptions) === null || _this$_defaultLaunchO === void 0 ? void 0 : _this$_defaultLaunchO.logger);
    (0, _utils.assert)(!options.userDataDir, 'userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead');
    (0, _utils.assert)(!options.port, 'Cannot specify a port without launching as a server.');
    options = { ...this._defaultLaunchOptions,
      ...options
    };
    const launchOptions = { ...options,
      ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,
      ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
      env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : undefined
    };

    const browser = _browser3.Browser.from((await this._channel.launch(launchOptions)).browser);

    browser._logger = logger;

    browser._setBrowserType(this);

    return browser;
  }

  async launchServer(options = {}) {
    if (!this._serverLauncher) throw new Error('Launching server is not supported');
    options = { ...this._defaultLaunchOptions,
      ...options
    };
    return this._serverLauncher.launchServer(options);
  }

  async launchPersistentContext(userDataDir, options = {}) {
    var _this$_defaultLaunchO2, _this$_onDidCreateCon;

    const logger = options.logger || ((_this$_defaultLaunchO2 = this._defaultLaunchOptions) === null || _this$_defaultLaunchO2 === void 0 ? void 0 : _this$_defaultLaunchO2.logger);
    (0, _utils.assert)(!options.port, 'Cannot specify a port without launching as a server.');
    options = { ...this._defaultLaunchOptions,
      ...this._defaultContextOptions,
      ...options
    };
    const contextParams = await (0, _browserContext.prepareBrowserContextParams)(options);
    const persistentParams = { ...contextParams,
      ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : undefined,
      ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
      env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : undefined,
      channel: options.channel,
      userDataDir
    };
    const result = await this._channel.launchPersistentContext(persistentParams);

    const context = _browserContext.BrowserContext.from(result.context);

    context._options = contextParams;
    context._logger = logger;

    context._setBrowserType(this);

    await ((_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context));
    return context;
  }

  async connect(optionsOrWsEndpoint, options) {
    if (typeof optionsOrWsEndpoint === 'string') return this._connect(optionsOrWsEndpoint, options);
    (0, _utils.assert)(optionsOrWsEndpoint.wsEndpoint, 'options.wsEndpoint is required');
    return this._connect(optionsOrWsEndpoint.wsEndpoint, optionsOrWsEndpoint);
  }

  async _connect(wsEndpoint, params = {}) {
    const logger = params.logger;
    return await this._wrapApiCall(async () => {
      const deadline = params.timeout ? (0, _utils.monotonicTime)() + params.timeout : 0;
      let browser;
      const headers = {
        'x-playwright-browser': this.name(),
        ...params.headers
      };
      const connectParams = {
        wsEndpoint,
        headers,
        slowMo: params.slowMo,
        timeout: params.timeout
      };
      if (params.__testHookRedirectPortForwarding) connectParams.socksProxyRedirectPortForTest = params.__testHookRedirectPortForwarding;
      const {
        pipe
      } = await this._channel.connect(connectParams);

      const closePipe = () => pipe.close().catch(() => {});

      const connection = new _connection.Connection(this._connection.localUtils());
      connection.markAsRemote();
      connection.on('close', closePipe);
      let closeError;

      const onPipeClosed = () => {
        var _browser2;

        // Emulate all pages, contexts and the browser closing upon disconnect.
        for (const context of ((_browser = browser) === null || _browser === void 0 ? void 0 : _browser.contexts()) || []) {
          var _browser;

          for (const page of context.pages()) page._onClose();

          context._onClose();
        }

        (_browser2 = browser) === null || _browser2 === void 0 ? void 0 : _browser2._didClose();
        connection.close(closeError || _errors.kBrowserClosedError);
      };

      pipe.on('closed', onPipeClosed);

      connection.onmessage = message => pipe.send({
        message
      }).catch(onPipeClosed);

      pipe.on('message', ({
        message
      }) => {
        try {
          connection.dispatch(message);
        } catch (e) {
          closeError = e.toString();
          closePipe();
        }
      });
      const result = await (0, _timeoutRunner.raceAgainstTimeout)(async () => {
        // For tests.
        if (params.__testHookBeforeCreateBrowser) await params.__testHookBeforeCreateBrowser();
        const playwright = await connection.initializePlaywright();

        if (!playwright._initializer.preLaunchedBrowser) {
          closePipe();
          throw new Error('Malformed endpoint. Did you use launchServer method?');
        }

        playwright._setSelectors(this._playwright.selectors);

        browser = _browser3.Browser.from(playwright._initializer.preLaunchedBrowser);
        browser._logger = logger;
        browser._shouldCloseConnectionOnClose = true;

        browser._setBrowserType(this);

        browser.on(_events.Events.Browser.Disconnected, closePipe);
        return browser;
      }, deadline ? deadline - (0, _utils.monotonicTime)() : 0);

      if (!result.timedOut) {
        return result.result;
      } else {
        closePipe();
        throw new Error(`Timeout ${params.timeout}ms exceeded`);
      }
    });
  }

  connectOverCDP(endpointURLOrOptions, options) {
    if (typeof endpointURLOrOptions === 'string') return this._connectOverCDP(endpointURLOrOptions, options);
    const endpointURL = 'endpointURL' in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
    (0, _utils.assert)(endpointURL, 'Cannot connect over CDP without wsEndpoint.');
    return this.connectOverCDP(endpointURL, endpointURLOrOptions);
  }

  async _connectOverCDP(endpointURL, params = {}) {
    if (this.name() !== 'chromium') throw new Error('Connecting over CDP is only supported in Chromium.');
    const headers = params.headers ? (0, _utils.headersObjectToArray)(params.headers) : undefined;
    const result = await this._channel.connectOverCDP({
      endpointURL,
      headers,
      slowMo: params.slowMo,
      timeout: params.timeout
    });

    const browser = _browser3.Browser.from(result.browser);

    if (result.defaultContext) browser._contexts.add(_browserContext.BrowserContext.from(result.defaultContext));
    browser._logger = params.logger;

    browser._setBrowserType(this);

    return browser;
  }

}

exports.BrowserType = BrowserType;

/***/ }),

/***/ 5128:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CDPSession = void 0;

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CDPSession extends _channelOwner.ChannelOwner {
  static from(cdpSession) {
    return cdpSession._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);

    this._channel.on('event', ({
      method,
      params
    }) => {
      this.emit(method, params);
    });

    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }

  async send(method, params) {
    const result = await this._channel.send({
      method,
      params
    });
    return result.result;
  }

  async detach() {
    return this._channel.detach();
  }

}

exports.CDPSession = CDPSession;

/***/ }),

/***/ 1578:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ChannelOwner = void 0;

var _events = __nccwpck_require__(2361);

var _validator = __nccwpck_require__(7989);

var _debugLogger = __nccwpck_require__(2003);

var _stackTrace = __nccwpck_require__(9030);

var _utils = __nccwpck_require__(3557);

var _zones = __nccwpck_require__(4940);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChannelOwner extends _events.EventEmitter {
  constructor(parent, type, guid, initializer, instrumentation) {
    var _this$_parent;

    super();
    this._connection = void 0;
    this._parent = void 0;
    this._objects = new Map();
    this._type = void 0;
    this._guid = void 0;
    this._channel = void 0;
    this._initializer = void 0;
    this._logger = void 0;
    this._instrumentation = void 0;
    this.setMaxListeners(0);
    this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
    this._type = type;
    this._guid = guid;
    this._parent = parent instanceof ChannelOwner ? parent : undefined;
    this._instrumentation = instrumentation || ((_this$_parent = this._parent) === null || _this$_parent === void 0 ? void 0 : _this$_parent._instrumentation);

    this._connection._objects.set(guid, this);

    if (this._parent) {
      this._parent._objects.set(guid, this);

      this._logger = this._parent._logger;
    }

    this._channel = this._createChannel(new _events.EventEmitter());
    this._initializer = initializer;
  }

  _adopt(child) {
    child._parent._objects.delete(child._guid);

    this._objects.set(child._guid, child);

    child._parent = this;
  }

  _dispose() {
    // Clean up from parent and connection.
    if (this._parent) this._parent._objects.delete(this._guid);

    this._connection._objects.delete(this._guid); // Dispose all children.


    for (const object of [...this._objects.values()]) object._dispose();

    this._objects.clear();
  }

  _debugScopeState() {
    return {
      _guid: this._guid,
      objects: Array.from(this._objects.values()).map(o => o._debugScopeState())
    };
  }

  _createChannel(base) {
    const channel = new Proxy(base, {
      get: (obj, prop) => {
        if (typeof prop === 'string') {
          const validator = (0, _validator.maybeFindValidator)(this._type, prop, 'Params');

          if (validator) {
            return params => {
              return this._wrapApiCall(apiZone => {
                const {
                  stackTrace,
                  csi,
                  callCookie
                } = apiZone.reported ? {
                  csi: undefined,
                  callCookie: undefined,
                  stackTrace: null
                } : apiZone;
                apiZone.reported = true;
                if (csi && stackTrace && stackTrace.apiName) csi.onApiCallBegin(renderCallWithParams(stackTrace.apiName, params), stackTrace, callCookie);
                return this._connection.sendMessageToServer(this, this._type, prop, validator(params, '', {
                  tChannelImpl: tChannelImplToWire,
                  binary: this._connection.isRemote() ? 'toBase64' : 'buffer'
                }), stackTrace);
              });
            };
          }
        }

        return obj[prop];
      }
    });
    channel._object = this;
    return channel;
  }

  async _wrapApiCall(func, isInternal = false, customStackTrace) {
    const logger = this._logger;
    const stack = (0, _stackTrace.captureRawStack)();

    const apiZone = _zones.zones.zoneData('apiZone', stack);

    if (apiZone) return func(apiZone);
    const stackTrace = customStackTrace || (0, _stackTrace.captureStackTrace)(stack);
    if (isInternal) delete stackTrace.apiName;
    const csi = isInternal ? undefined : this._instrumentation;
    const callCookie = {};
    const {
      apiName,
      frameTexts
    } = stackTrace;

    try {
      logApiCall(logger, `=> ${apiName} started`, isInternal);
      const apiZone = {
        stackTrace,
        isInternal,
        reported: false,
        csi,
        callCookie
      };
      const result = await _zones.zones.run('apiZone', apiZone, async () => {
        return await func(apiZone);
      });
      csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie);
      logApiCall(logger, `<= ${apiName} succeeded`, isInternal);
      return result;
    } catch (e) {
      const innerError = (process.env.PWDEBUGIMPL || (0, _utils.isUnderTest)()) && e.stack ? '\n<inner error>\n' + e.stack : '';
      e.message = apiName + ': ' + e.message;
      e.stack = e.message + '\n' + frameTexts.join('\n') + innerError;
      csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie, e);
      logApiCall(logger, `<= ${apiName} failed`, isInternal);
      throw e;
    }
  }

  _toImpl() {
    var _this$_connection$toI, _this$_connection;

    return (_this$_connection$toI = (_this$_connection = this._connection).toImpl) === null || _this$_connection$toI === void 0 ? void 0 : _this$_connection$toI.call(_this$_connection, this);
  }

  toJSON() {
    // Jest's expect library tries to print objects sometimes.
    // RPC objects can contain links to lots of other objects,
    // which can cause jest to crash. Let's help it out
    // by just returning the important values.
    return {
      _type: this._type,
      _guid: this._guid
    };
  }

}

exports.ChannelOwner = ChannelOwner;

function logApiCall(logger, message, isNested) {
  if (isNested) return;
  if (logger && logger.isEnabled('api', 'info')) logger.log('api', 'info', message, [], {
    color: 'cyan'
  });

  _debugLogger.debugLogger.log('api', message);
}

const paramsToRender = ['url', 'selector', 'text', 'key'];

function renderCallWithParams(apiName, params) {
  const paramsArray = [];

  if (params) {
    for (const name of paramsToRender) {
      if (params[name]) paramsArray.push(params[name]);
    }
  }

  const paramsText = paramsArray.length ? '(' + paramsArray.join(', ') + ')' : '';
  return apiName + paramsText;
}

function tChannelImplToWire(names, arg, path, context) {
  if (arg._object instanceof ChannelOwner && (names === '*' || names.includes(arg._object._type))) return {
    guid: arg._object._guid
  };
  throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
}

/***/ }),

/***/ 6886:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.envObjectToArray = envObjectToArray;
exports.evaluationScript = evaluationScript;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _utils = __nccwpck_require__(3557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function envObjectToArray(env) {
  const result = [];

  for (const name in env) {
    if (!Object.is(env[name], undefined)) result.push({
      name,
      value: String(env[name])
    });
  }

  return result;
}

async function evaluationScript(fun, arg, addSourceUrl = true) {
  if (typeof fun === 'function') {
    const source = fun.toString();
    const argString = Object.is(arg, undefined) ? 'undefined' : JSON.stringify(arg);
    return `(${source})(${argString})`;
  }

  if (arg !== undefined) throw new Error('Cannot evaluate a string with arguments');
  if ((0, _utils.isString)(fun)) return fun;
  if (fun.content !== undefined) return fun.content;

  if (fun.path !== undefined) {
    let source = await _fs.default.promises.readFile(fun.path, 'utf8');
    if (addSourceUrl) source += '\n//# sourceURL=' + fun.path.replace(/\n/g, '');
    return source;
  }

  throw new Error('Either path or content property must be present');
}

/***/ }),

/***/ 6389:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createInstrumentation = createInstrumentation;

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createInstrumentation() {
  const listeners = [];
  return new Proxy({}, {
    get: (obj, prop) => {
      if (prop === 'addListener') return listener => listeners.push(listener);
      if (prop === 'removeListener') return listener => listeners.splice(listeners.indexOf(listener), 1);
      if (prop === 'removeAllListeners') return () => listeners.splice(0, listeners.length);
      if (!prop.startsWith('on')) return obj[prop];
      return async (...params) => {
        for (const listener of listeners) {
          var _prop, _ref;

          await ((_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params));
        }
      };
    }
  });
}

/***/ }),

/***/ 1776:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Connection = void 0;

var _browser = __nccwpck_require__(8960);

var _browserContext = __nccwpck_require__(4096);

var _browserType = __nccwpck_require__(2450);

var _channelOwner = __nccwpck_require__(1578);

var _elementHandle = __nccwpck_require__(9634);

var _frame = __nccwpck_require__(1730);

var _jsHandle = __nccwpck_require__(6594);

var _network = __nccwpck_require__(6529);

var _page = __nccwpck_require__(2374);

var _worker = __nccwpck_require__(395);

var _consoleMessage = __nccwpck_require__(359);

var _dialog = __nccwpck_require__(1468);

var _serializers = __nccwpck_require__(5644);

var _cdpSession = __nccwpck_require__(5128);

var _playwright = __nccwpck_require__(5983);

var _electron = __nccwpck_require__(1181);

var _stream = __nccwpck_require__(8423);

var _writableStream = __nccwpck_require__(4493);

var _debugLogger = __nccwpck_require__(2003);

var _selectors = __nccwpck_require__(6212);

var _android = __nccwpck_require__(8068);

var _artifact = __nccwpck_require__(5043);

var _events = __nccwpck_require__(2361);

var _jsonPipe = __nccwpck_require__(4772);

var _fetch = __nccwpck_require__(3750);

var _localUtils = __nccwpck_require__(3075);

var _tracing = __nccwpck_require__(2303);

var _validator = __nccwpck_require__(7989);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Root extends _channelOwner.ChannelOwner {
  constructor(connection) {
    super(connection, 'Root', '', {});
  }

  async initialize() {
    return _playwright.Playwright.from((await this._channel.initialize({
      sdkLanguage: 'javascript'
    })).playwright);
  }

}

class DummyChannelOwner extends _channelOwner.ChannelOwner {}

class Connection extends _events.EventEmitter {
  // Some connections allow resolving in-process dispatchers.
  constructor(localUtils) {
    super();
    this._objects = new Map();

    this.onmessage = message => {};

    this._lastId = 0;
    this._callbacks = new Map();
    this._rootObject = void 0;
    this._closedErrorMessage = void 0;
    this._isRemote = false;
    this._localUtils = void 0;
    this.toImpl = void 0;
    this._rootObject = new Root(this);
    this._localUtils = localUtils;
  }

  markAsRemote() {
    this._isRemote = true;
  }

  isRemote() {
    return this._isRemote;
  }

  localUtils() {
    return this._localUtils;
  }

  async initializePlaywright() {
    return await this._rootObject.initialize();
  }

  pendingProtocolCalls() {
    return Array.from(this._callbacks.values()).map(callback => callback.stackTrace).filter(Boolean);
  }

  getObjectWithKnownName(guid) {
    return this._objects.get(guid);
  }

  async sendMessageToServer(object, type, method, params, stackTrace) {
    if (this._closedErrorMessage) throw new Error(this._closedErrorMessage);
    const {
      apiName,
      frames
    } = stackTrace || {
      apiName: '',
      frames: []
    };
    const guid = object._guid;
    const id = ++this._lastId;
    const converted = {
      id,
      guid,
      method,
      params
    }; // Do not include metadata in debug logs to avoid noise.

    _debugLogger.debugLogger.log('channel:command', converted);

    const metadata = {
      stack: frames,
      apiName,
      internal: !apiName
    };
    this.onmessage({ ...converted,
      metadata
    });
    return await new Promise((resolve, reject) => this._callbacks.set(id, {
      resolve,
      reject,
      stackTrace,
      type,
      method
    }));
  }

  dispatch(message) {
    if (this._closedErrorMessage) return;
    const {
      id,
      guid,
      method,
      params,
      result,
      error
    } = message;

    if (id) {
      _debugLogger.debugLogger.log('channel:response', message);

      const callback = this._callbacks.get(id);

      if (!callback) throw new Error(`Cannot find command to respond: ${id}`);

      this._callbacks.delete(id);

      if (error && !result) {
        callback.reject((0, _serializers.parseError)(error));
      } else {
        const validator = (0, _validator.findValidator)(callback.type, callback.method, 'Result');
        callback.resolve(validator(result, '', {
          tChannelImpl: this._tChannelImplFromWire.bind(this),
          binary: this.isRemote() ? 'fromBase64' : 'buffer'
        }));
      }

      return;
    }

    _debugLogger.debugLogger.log('channel:event', message);

    if (method === '__create__') {
      this._createRemoteObject(guid, params.type, params.guid, params.initializer);

      return;
    }

    const object = this._objects.get(guid);

    if (!object) throw new Error(`Cannot find object to "${method}": ${guid}`);

    if (method === '__adopt__') {
      const child = this._objects.get(params.guid);

      if (!child) throw new Error(`Unknown new child: ${params.guid}`);

      object._adopt(child);

      return;
    }

    if (method === '__dispose__') {
      object._dispose();

      return;
    }

    const validator = (0, _validator.findValidator)(object._type, method, 'Event');

    object._channel.emit(method, validator(params, '', {
      tChannelImpl: this._tChannelImplFromWire.bind(this),
      binary: this.isRemote() ? 'fromBase64' : 'buffer'
    }));
  }

  close(errorMessage = 'Connection closed') {
    this._closedErrorMessage = errorMessage;

    for (const callback of this._callbacks.values()) callback.reject(new Error(errorMessage));

    this._callbacks.clear();

    this.emit('close');
  }

  _tChannelImplFromWire(names, arg, path, context) {
    if (arg && typeof arg === 'object' && typeof arg.guid === 'string') {
      const object = this._objects.get(arg.guid);

      if (!object) throw new Error(`Object with guid ${arg.guid} was not bound in the connection`);
      if (names !== '*' && !names.includes(object._type)) throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
      return object._channel;
    }

    throw new _validator.ValidationError(`${path}: expected channel ${names.toString()}`);
  }

  _createRemoteObject(parentGuid, type, guid, initializer) {
    const parent = this._objects.get(parentGuid);

    if (!parent) throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
    let result;
    const validator = (0, _validator.findValidator)(type, '', 'Initializer');
    initializer = validator(initializer, '', {
      tChannelImpl: this._tChannelImplFromWire.bind(this),
      binary: this.isRemote() ? 'fromBase64' : 'buffer'
    });

    switch (type) {
      case 'Android':
        result = new _android.Android(parent, type, guid, initializer);
        break;

      case 'AndroidSocket':
        result = new _android.AndroidSocket(parent, type, guid, initializer);
        break;

      case 'AndroidDevice':
        result = new _android.AndroidDevice(parent, type, guid, initializer);
        break;

      case 'APIRequestContext':
        result = new _fetch.APIRequestContext(parent, type, guid, initializer);
        break;

      case 'Artifact':
        result = new _artifact.Artifact(parent, type, guid, initializer);
        break;

      case 'BindingCall':
        result = new _page.BindingCall(parent, type, guid, initializer);
        break;

      case 'Browser':
        result = new _browser.Browser(parent, type, guid, initializer);
        break;

      case 'BrowserContext':
        result = new _browserContext.BrowserContext(parent, type, guid, initializer);
        break;

      case 'BrowserType':
        result = new _browserType.BrowserType(parent, type, guid, initializer);
        break;

      case 'CDPSession':
        result = new _cdpSession.CDPSession(parent, type, guid, initializer);
        break;

      case 'ConsoleMessage':
        result = new _consoleMessage.ConsoleMessage(parent, type, guid, initializer);
        break;

      case 'Dialog':
        result = new _dialog.Dialog(parent, type, guid, initializer);
        break;

      case 'Electron':
        result = new _electron.Electron(parent, type, guid, initializer);
        break;

      case 'ElectronApplication':
        result = new _electron.ElectronApplication(parent, type, guid, initializer);
        break;

      case 'ElementHandle':
        result = new _elementHandle.ElementHandle(parent, type, guid, initializer);
        break;

      case 'Frame':
        result = new _frame.Frame(parent, type, guid, initializer);
        break;

      case 'JSHandle':
        result = new _jsHandle.JSHandle(parent, type, guid, initializer);
        break;

      case 'JsonPipe':
        result = new _jsonPipe.JsonPipe(parent, type, guid, initializer);
        break;

      case 'LocalUtils':
        result = new _localUtils.LocalUtils(parent, type, guid, initializer);
        if (!this._localUtils) this._localUtils = result;
        break;

      case 'Page':
        result = new _page.Page(parent, type, guid, initializer);
        break;

      case 'Playwright':
        result = new _playwright.Playwright(parent, type, guid, initializer);
        break;

      case 'Request':
        result = new _network.Request(parent, type, guid, initializer);
        break;

      case 'Response':
        result = new _network.Response(parent, type, guid, initializer);
        break;

      case 'Route':
        result = new _network.Route(parent, type, guid, initializer);
        break;

      case 'Stream':
        result = new _stream.Stream(parent, type, guid, initializer);
        break;

      case 'Selectors':
        result = new _selectors.SelectorsOwner(parent, type, guid, initializer);
        break;

      case 'SocksSupport':
        result = new DummyChannelOwner(parent, type, guid, initializer);
        break;

      case 'Tracing':
        result = new _tracing.Tracing(parent, type, guid, initializer);
        break;

      case 'WebSocket':
        result = new _network.WebSocket(parent, type, guid, initializer);
        break;

      case 'Worker':
        result = new _worker.Worker(parent, type, guid, initializer);
        break;

      case 'WritableStream':
        result = new _writableStream.WritableStream(parent, type, guid, initializer);
        break;

      default:
        throw new Error('Missing type ' + type);
    }

    return result;
  }

}

exports.Connection = Connection;

/***/ }),

/***/ 359:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConsoleMessage = void 0;

var util = _interopRequireWildcard(__nccwpck_require__(3837));

var _jsHandle = __nccwpck_require__(6594);

var _channelOwner = __nccwpck_require__(1578);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConsoleMessage extends _channelOwner.ChannelOwner {
  static from(message) {
    return message._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  type() {
    return this._initializer.type;
  }

  text() {
    return this._initializer.text;
  }

  args() {
    return this._initializer.args.map(_jsHandle.JSHandle.from);
  }

  location() {
    return this._initializer.location;
  }

  [util.inspect.custom]() {
    return this.text();
  }

}

exports.ConsoleMessage = ConsoleMessage;

/***/ }),

/***/ 9679:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Coverage = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Coverage {
  constructor(channel) {
    this._channel = void 0;
    this._channel = channel;
  }

  async startJSCoverage(options = {}) {
    await this._channel.startJSCoverage(options);
  }

  async stopJSCoverage() {
    return (await this._channel.stopJSCoverage()).entries;
  }

  async startCSSCoverage(options = {}) {
    await this._channel.startCSSCoverage(options);
  }

  async stopCSSCoverage() {
    return (await this._channel.stopCSSCoverage()).entries;
  }

}

exports.Coverage = Coverage;

/***/ }),

/***/ 1468:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Dialog = void 0;

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dialog extends _channelOwner.ChannelOwner {
  static from(dialog) {
    return dialog._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  type() {
    return this._initializer.type;
  }

  message() {
    return this._initializer.message;
  }

  defaultValue() {
    return this._initializer.defaultValue;
  }

  async accept(promptText) {
    await this._channel.accept({
      promptText
    });
  }

  async dismiss() {
    await this._channel.dismiss();
  }

}

exports.Dialog = Dialog;

/***/ }),

/***/ 9551:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Download = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Download {
  constructor(page, url, suggestedFilename, artifact) {
    this._page = void 0;
    this._url = void 0;
    this._suggestedFilename = void 0;
    this._artifact = void 0;
    this._page = page;
    this._url = url;
    this._suggestedFilename = suggestedFilename;
    this._artifact = artifact;
  }

  page() {
    return this._page;
  }

  url() {
    return this._url;
  }

  suggestedFilename() {
    return this._suggestedFilename;
  }

  async path() {
    return this._artifact.pathAfterFinished();
  }

  async saveAs(path) {
    return this._artifact.saveAs(path);
  }

  async failure() {
    return this._artifact.failure();
  }

  async createReadStream() {
    return this._artifact.createReadStream();
  }

  async cancel() {
    return this._artifact.cancel();
  }

  async delete() {
    return this._artifact.delete();
  }

}

exports.Download = Download;

/***/ }),

/***/ 1181:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ElectronApplication = exports.Electron = void 0;

var _timeoutSettings = __nccwpck_require__(9053);

var _browserContext = __nccwpck_require__(4096);

var _channelOwner = __nccwpck_require__(1578);

var _clientHelper = __nccwpck_require__(6886);

var _events = __nccwpck_require__(8289);

var _jsHandle = __nccwpck_require__(6594);

var _waiter = __nccwpck_require__(1145);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Electron extends _channelOwner.ChannelOwner {
  static from(electron) {
    return electron._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  async launch(options = {}) {
    const params = { ...(await (0, _browserContext.prepareBrowserContextParams)(options)),
      env: (0, _clientHelper.envObjectToArray)(options.env ? options.env : process.env)
    };
    const app = ElectronApplication.from((await this._channel.launch(params)).electronApplication);
    app._context._options = params;
    return app;
  }

}

exports.Electron = Electron;

class ElectronApplication extends _channelOwner.ChannelOwner {
  static from(electronApplication) {
    return electronApplication._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._context = void 0;
    this._windows = new Set();
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
    this._context = _browserContext.BrowserContext.from(initializer.context);

    for (const page of this._context._pages) this._onPage(page);

    this._context.on(_events.Events.BrowserContext.Page, page => this._onPage(page));

    this._channel.on('close', () => this.emit(_events.Events.ElectronApplication.Close));
  }

  process() {
    return this._toImpl().process();
  }

  _onPage(page) {
    this._windows.add(page);

    this.emit(_events.Events.ElectronApplication.Window, page);
    page.once(_events.Events.Page.Close, () => this._windows.delete(page));
  }

  windows() {
    // TODO: add ElectronPage class inherting from Page.
    return [...this._windows];
  }

  async firstWindow() {
    if (this._windows.size) return this._windows.values().next().value;
    return this.waitForEvent('window');
  }

  context() {
    return this._context;
  }

  async close() {
    await this._channel.close();
  }

  async waitForEvent(event, optionsOrPredicate = {}) {
    return this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);

      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;

      const waiter = _waiter.Waiter.createForEvent(this, event);

      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== _events.Events.ElectronApplication.Close) waiter.rejectOnEvent(this, _events.Events.ElectronApplication.Close, new Error('Electron application closed'));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }

  async browserWindow(page) {
    const result = await this._channel.browserWindow({
      page: page._channel
    });
    return _jsHandle.JSHandle.from(result.handle);
  }

  async evaluate(pageFunction, arg) {
    const result = await this._channel.evaluateExpression({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async evaluateHandle(pageFunction, arg) {
    const result = await this._channel.evaluateExpressionHandle({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return _jsHandle.JSHandle.from(result.handle);
  }

}

exports.ElectronApplication = ElectronApplication;

/***/ }),

/***/ 9634:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ElementHandle = void 0;
exports.convertInputFiles = convertInputFiles;
exports.convertSelectOptionValues = convertSelectOptionValues;
exports.determineScreenshotType = determineScreenshotType;

var _frame = __nccwpck_require__(1730);

var _jsHandle = __nccwpck_require__(6594);

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _utilsBundle = __nccwpck_require__(1319);

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _writableStream = __nccwpck_require__(4493);

var _stream = __nccwpck_require__(2781);

var _util = __nccwpck_require__(3837);

var _debugLogger = __nccwpck_require__(2003);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pipelineAsync = (0, _util.promisify)(_stream.pipeline);

class ElementHandle extends _jsHandle.JSHandle {
  static from(handle) {
    return handle._object;
  }

  static fromNullable(handle) {
    return handle ? ElementHandle.from(handle) : null;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._elementChannel = void 0;
    this._elementChannel = this._channel;
  }

  asElement() {
    return this;
  }

  async ownerFrame() {
    return _frame.Frame.fromNullable((await this._elementChannel.ownerFrame()).frame);
  }

  async contentFrame() {
    return _frame.Frame.fromNullable((await this._elementChannel.contentFrame()).frame);
  }

  async getAttribute(name) {
    const value = (await this._elementChannel.getAttribute({
      name
    })).value;
    return value === undefined ? null : value;
  }

  async inputValue() {
    return (await this._elementChannel.inputValue()).value;
  }

  async textContent() {
    const value = (await this._elementChannel.textContent()).value;
    return value === undefined ? null : value;
  }

  async innerText() {
    return (await this._elementChannel.innerText()).value;
  }

  async innerHTML() {
    return (await this._elementChannel.innerHTML()).value;
  }

  async isChecked() {
    return (await this._elementChannel.isChecked()).value;
  }

  async isDisabled() {
    return (await this._elementChannel.isDisabled()).value;
  }

  async isEditable() {
    return (await this._elementChannel.isEditable()).value;
  }

  async isEnabled() {
    return (await this._elementChannel.isEnabled()).value;
  }

  async isHidden() {
    return (await this._elementChannel.isHidden()).value;
  }

  async isVisible() {
    return (await this._elementChannel.isVisible()).value;
  }

  async dispatchEvent(type, eventInit = {}) {
    await this._elementChannel.dispatchEvent({
      type,
      eventInit: (0, _jsHandle.serializeArgument)(eventInit)
    });
  }

  async scrollIntoViewIfNeeded(options = {}) {
    await this._elementChannel.scrollIntoViewIfNeeded(options);
  }

  async hover(options = {}) {
    await this._elementChannel.hover(options);
  }

  async click(options = {}) {
    return await this._elementChannel.click(options);
  }

  async dblclick(options = {}) {
    return await this._elementChannel.dblclick(options);
  }

  async tap(options = {}) {
    return await this._elementChannel.tap(options);
  }

  async selectOption(values, options = {}) {
    const result = await this._elementChannel.selectOption({ ...convertSelectOptionValues(values),
      ...options
    });
    return result.values;
  }

  async fill(value, options = {}) {
    return await this._elementChannel.fill({
      value,
      ...options
    });
  }

  async selectText(options = {}) {
    await this._elementChannel.selectText(options);
  }

  async setInputFiles(files, options = {}) {
    const frame = await this.ownerFrame();
    if (!frame) throw new Error('Cannot set input files to detached element');
    const converted = await convertInputFiles(files, frame.page().context());

    if (converted.files) {
      await this._elementChannel.setInputFiles({
        files: converted.files,
        ...options
      });
    } else {
      _debugLogger.debugLogger.log('api', 'switching to large files mode');

      await this._elementChannel.setInputFilePaths({ ...converted,
        ...options
      });
    }
  }

  async focus() {
    await this._elementChannel.focus();
  }

  async type(text, options = {}) {
    await this._elementChannel.type({
      text,
      ...options
    });
  }

  async press(key, options = {}) {
    await this._elementChannel.press({
      key,
      ...options
    });
  }

  async check(options = {}) {
    return await this._elementChannel.check(options);
  }

  async uncheck(options = {}) {
    return await this._elementChannel.uncheck(options);
  }

  async setChecked(checked, options) {
    if (checked) await this.check(options);else await this.uncheck(options);
  }

  async boundingBox() {
    const value = (await this._elementChannel.boundingBox()).value;
    return value === undefined ? null : value;
  }

  async screenshot(options = {}) {
    const copy = { ...options,
      mask: undefined
    };
    if (!copy.type) copy.type = determineScreenshotType(options);

    if (options.mask) {
      copy.mask = options.mask.map(locator => ({
        frame: locator._frame._channel,
        selector: locator._selector
      }));
    }

    const result = await this._elementChannel.screenshot(copy);

    if (options.path) {
      await (0, _fileUtils.mkdirIfNeeded)(options.path);
      await _fs.default.promises.writeFile(options.path, result.binary);
    }

    return result.binary;
  }

  async $(selector) {
    return ElementHandle.fromNullable((await this._elementChannel.querySelector({
      selector
    })).element);
  }

  async $$(selector) {
    const result = await this._elementChannel.querySelectorAll({
      selector
    });
    return result.elements.map(h => ElementHandle.from(h));
  }

  async $eval(selector, pageFunction, arg) {
    const result = await this._elementChannel.evalOnSelector({
      selector,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async $$eval(selector, pageFunction, arg) {
    const result = await this._elementChannel.evalOnSelectorAll({
      selector,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async waitForElementState(state, options = {}) {
    return await this._elementChannel.waitForElementState({
      state,
      ...options
    });
  }

  async waitForSelector(selector, options = {}) {
    const result = await this._elementChannel.waitForSelector({
      selector,
      ...options
    });
    return ElementHandle.fromNullable(result.element);
  }

}

exports.ElementHandle = ElementHandle;

function convertSelectOptionValues(values) {
  if (values === null) return {};
  if (!Array.isArray(values)) values = [values];
  if (!values.length) return {};

  for (let i = 0; i < values.length; i++) (0, _utils.assert)(values[i] !== null, `options[${i}]: expected object, got null`);

  if (values[0] instanceof ElementHandle) return {
    elements: values.map(v => v._elementChannel)
  };
  if ((0, _utils.isString)(values[0])) return {
    options: values.map(value => ({
      value
    }))
  };
  return {
    options: values
  };
}

async function convertInputFiles(files, context) {
  const items = Array.isArray(files) ? files.slice() : [files];
  const sizeLimit = 50 * 1024 * 1024;
  const hasLargeBuffer = items.find(item => typeof item === 'object' && item.buffer && item.buffer.byteLength > sizeLimit);
  if (hasLargeBuffer) throw new Error('Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.');
  const stats = await Promise.all(items.filter(_utils.isString).map(item => _fs.default.promises.stat(item)));
  const hasLargeFile = !!stats.find(s => s.size > sizeLimit);

  if (hasLargeFile) {
    if (context._connection.isRemote()) {
      const streams = await Promise.all(items.map(async item => {
        (0, _utils.assert)((0, _utils.isString)(item));
        const {
          writableStream: stream
        } = await context._channel.createTempFile({
          name: _path.default.basename(item)
        });

        const writable = _writableStream.WritableStream.from(stream);

        await pipelineAsync(_fs.default.createReadStream(item), writable.stream());
        return stream;
      }));
      return {
        streams
      };
    }

    return {
      localPaths: items.map(f => _path.default.resolve(f))
    };
  }

  const filePayloads = await Promise.all(items.map(async item => {
    if (typeof item === 'string') {
      return {
        name: _path.default.basename(item),
        buffer: await _fs.default.promises.readFile(item)
      };
    } else {
      return {
        name: item.name,
        mimeType: item.mimeType,
        buffer: item.buffer
      };
    }
  }));
  return {
    files: filePayloads
  };
}

function determineScreenshotType(options) {
  if (options.path) {
    const mimeType = _utilsBundle.mime.getType(options.path);

    if (mimeType === 'image/png') return 'png';else if (mimeType === 'image/jpeg') return 'jpeg';
    throw new Error(`path: unsupported mime type "${mimeType}"`);
  }

  return options.type;
}

/***/ }),

/***/ 8289:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Events = void 0;

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Events = {
  AndroidDevice: {
    WebView: 'webview',
    Close: 'close'
  },
  AndroidSocket: {
    Data: 'data',
    Close: 'close'
  },
  AndroidWebView: {
    Close: 'close'
  },
  Browser: {
    Disconnected: 'disconnected'
  },
  BrowserContext: {
    Close: 'close',
    Page: 'page',
    BackgroundPage: 'backgroundpage',
    ServiceWorker: 'serviceworker',
    Request: 'request',
    Response: 'response',
    RequestFailed: 'requestfailed',
    RequestFinished: 'requestfinished'
  },
  BrowserServer: {
    Close: 'close'
  },
  Page: {
    Close: 'close',
    Crash: 'crash',
    Console: 'console',
    Dialog: 'dialog',
    Download: 'download',
    FileChooser: 'filechooser',
    DOMContentLoaded: 'domcontentloaded',
    // Can't use just 'error' due to node.js special treatment of error events.
    // @see https://nodejs.org/api/events.html#events_error_events
    PageError: 'pageerror',
    Request: 'request',
    Response: 'response',
    RequestFailed: 'requestfailed',
    RequestFinished: 'requestfinished',
    FrameAttached: 'frameattached',
    FrameDetached: 'framedetached',
    FrameNavigated: 'framenavigated',
    Load: 'load',
    Popup: 'popup',
    WebSocket: 'websocket',
    Worker: 'worker'
  },
  WebSocket: {
    Close: 'close',
    Error: 'socketerror',
    FrameReceived: 'framereceived',
    FrameSent: 'framesent'
  },
  Worker: {
    Close: 'close'
  },
  ElectronApplication: {
    Close: 'close',
    Window: 'window'
  }
};
exports.Events = Events;

/***/ }),

/***/ 3750:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.APIResponse = exports.APIRequestContext = exports.APIRequest = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var util = _interopRequireWildcard(__nccwpck_require__(3837));

var _errors = __nccwpck_require__(542);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _channelOwner = __nccwpck_require__(1578);

var network = _interopRequireWildcard(__nccwpck_require__(6529));

var _clientInstrumentation = __nccwpck_require__(6389);

var _tracing = __nccwpck_require__(2303);

let _util$inspect$custom;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class APIRequest {
  // Instrumentation.
  constructor(playwright) {
    this._playwright = void 0;
    this._contexts = new Set();
    this._onDidCreateContext = void 0;
    this._onWillCloseContext = void 0;
    this._playwright = playwright;
  }

  async newContext(options = {}) {
    var _this$_onDidCreateCon;

    const storageState = typeof options.storageState === 'string' ? JSON.parse(await _fs.default.promises.readFile(options.storageState, 'utf8')) : options.storageState;
    const context = APIRequestContext.from((await this._playwright._channel.newRequest({ ...options,
      extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : undefined,
      storageState
    })).request);

    this._contexts.add(context);

    context._request = this;
    await ((_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context));
    return context;
  }

}

exports.APIRequest = APIRequest;

class APIRequestContext extends _channelOwner.ChannelOwner {
  static from(channel) {
    return channel._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
    this._request = void 0;
    this._tracing = void 0;
    this._tracing = _tracing.Tracing.from(initializer.tracing);
  }

  async dispose() {
    var _this$_request, _this$_request$_onWil, _this$_request2;

    await ((_this$_request = this._request) === null || _this$_request === void 0 ? void 0 : (_this$_request$_onWil = _this$_request._onWillCloseContext) === null || _this$_request$_onWil === void 0 ? void 0 : _this$_request$_onWil.call(_this$_request, this));
    await this._channel.dispose();
    (_this$_request2 = this._request) === null || _this$_request2 === void 0 ? void 0 : _this$_request2._contexts.delete(this);
  }

  async delete(url, options) {
    return this.fetch(url, { ...options,
      method: 'DELETE'
    });
  }

  async head(url, options) {
    return this.fetch(url, { ...options,
      method: 'HEAD'
    });
  }

  async get(url, options) {
    return this.fetch(url, { ...options,
      method: 'GET'
    });
  }

  async patch(url, options) {
    return this.fetch(url, { ...options,
      method: 'PATCH'
    });
  }

  async post(url, options) {
    return this.fetch(url, { ...options,
      method: 'POST'
    });
  }

  async put(url, options) {
    return this.fetch(url, { ...options,
      method: 'PUT'
    });
  }

  async fetch(urlOrRequest, options = {}) {
    return this._wrapApiCall(async () => {
      const request = urlOrRequest instanceof network.Request ? urlOrRequest : undefined;
      (0, _utils.assert)(request || typeof urlOrRequest === 'string', 'First argument must be either URL string or Request');
      (0, _utils.assert)((options.data === undefined ? 0 : 1) + (options.form === undefined ? 0 : 1) + (options.multipart === undefined ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      const url = request ? request.url() : urlOrRequest;
      const params = (0, _utils.objectToArray)(options.params);
      const method = options.method || (request === null || request === void 0 ? void 0 : request.method()); // Cannot call allHeaders() here as the request may be paused inside route handler.

      const headersObj = options.headers || (request === null || request === void 0 ? void 0 : request.headers());
      const headers = headersObj ? (0, _utils.headersObjectToArray)(headersObj) : undefined;
      let jsonData;
      let formData;
      let multipartData;
      let postDataBuffer;

      if (options.data !== undefined) {
        if ((0, _utils.isString)(options.data)) {
          if (isJsonContentType(headers)) jsonData = options.data;else postDataBuffer = Buffer.from(options.data, 'utf8');
        } else if (Buffer.isBuffer(options.data)) {
          postDataBuffer = options.data;
        } else if (typeof options.data === 'object' || typeof options.data === 'number' || typeof options.data === 'boolean') {
          jsonData = options.data;
        } else {
          throw new Error(`Unexpected 'data' type`);
        }
      } else if (options.form) {
        formData = (0, _utils.objectToArray)(options.form);
      } else if (options.multipart) {
        multipartData = []; // Convert file-like values to ServerFilePayload structs.

        for (const [name, value] of Object.entries(options.multipart)) {
          if ((0, _utils.isFilePayload)(value)) {
            const payload = value;
            if (!Buffer.isBuffer(payload.buffer)) throw new Error(`Unexpected buffer type of 'data.${name}'`);
            multipartData.push({
              name,
              file: filePayloadToJson(payload)
            });
          } else if (value instanceof _fs.default.ReadStream) {
            multipartData.push({
              name,
              file: await readStreamToJson(value)
            });
          } else {
            multipartData.push({
              name,
              value: String(value)
            });
          }
        }
      }

      if (postDataBuffer === undefined && jsonData === undefined && formData === undefined && multipartData === undefined) postDataBuffer = (request === null || request === void 0 ? void 0 : request.postDataBuffer()) || undefined;
      const result = await this._channel.fetch({
        url,
        params,
        method,
        headers,
        postData: postDataBuffer,
        jsonData,
        formData,
        multipartData,
        timeout: options.timeout,
        failOnStatusCode: options.failOnStatusCode,
        ignoreHTTPSErrors: options.ignoreHTTPSErrors
      });
      return new APIResponse(this, result.response);
    });
  }

  async storageState(options = {}) {
    const state = await this._channel.storageState();

    if (options.path) {
      await (0, _fileUtils.mkdirIfNeeded)(options.path);
      await _fs.default.promises.writeFile(options.path, JSON.stringify(state, undefined, 2), 'utf8');
    }

    return state;
  }

}

exports.APIRequestContext = APIRequestContext;
_util$inspect$custom = util.inspect.custom;

class APIResponse {
  constructor(context, initializer) {
    this._initializer = void 0;
    this._headers = void 0;
    this._request = void 0;
    this._request = context;
    this._initializer = initializer;
    this._headers = new network.RawHeaders(this._initializer.headers);
  }

  ok() {
    return this._initializer.status >= 200 && this._initializer.status <= 299;
  }

  url() {
    return this._initializer.url;
  }

  status() {
    return this._initializer.status;
  }

  statusText() {
    return this._initializer.statusText;
  }

  headers() {
    return this._headers.headers();
  }

  headersArray() {
    return this._headers.headersArray();
  }

  async body() {
    try {
      const result = await this._request._channel.fetchResponseBody({
        fetchUid: this._fetchUid()
      });
      if (result.binary === undefined) throw new Error('Response has been disposed');
      return result.binary;
    } catch (e) {
      if (e.message.includes(_errors.kBrowserOrContextClosedError)) throw new Error('Response has been disposed');
      throw e;
    }
  }

  async text() {
    const content = await this.body();
    return content.toString('utf8');
  }

  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }

  async dispose() {
    await this._request._channel.disposeAPIResponse({
      fetchUid: this._fetchUid()
    });
  }

  [_util$inspect$custom]() {
    const headers = this.headersArray().map(({
      name,
      value
    }) => `  ${name}: ${value}`);
    return `APIResponse: ${this.status()} ${this.statusText()}\n${headers.join('\n')}`;
  }

  _fetchUid() {
    return this._initializer.fetchUid;
  }

  async _fetchLog() {
    const {
      log
    } = await this._request._channel.fetchLog({
      fetchUid: this._fetchUid()
    });
    return log;
  }

}

exports.APIResponse = APIResponse;

function filePayloadToJson(payload) {
  return {
    name: payload.name,
    mimeType: payload.mimeType,
    buffer: payload.buffer
  };
}

async function readStreamToJson(stream) {
  const buffer = await new Promise((resolve, reject) => {
    const chunks = [];
    stream.on('data', chunk => chunks.push(chunk));
    stream.on('end', () => resolve(Buffer.concat(chunks)));
    stream.on('error', err => reject(err));
  });
  const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString('utf8') : stream.path;
  return {
    name: _path.default.basename(streamPath),
    buffer
  };
}

function isJsonContentType(headers) {
  if (!headers) return false;

  for (const {
    name,
    value
  } of headers) {
    if (name.toLocaleLowerCase() === 'content-type') return value === 'application/json';
  }

  return false;
}

/***/ }),

/***/ 7105:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileChooser = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileChooser {
  constructor(page, elementHandle, isMultiple) {
    this._page = void 0;
    this._elementHandle = void 0;
    this._isMultiple = void 0;
    this._page = page;
    this._elementHandle = elementHandle;
    this._isMultiple = isMultiple;
  }

  element() {
    return this._elementHandle;
  }

  isMultiple() {
    return this._isMultiple;
  }

  page() {
    return this._page;
  }

  async setFiles(files, options) {
    return this._elementHandle.setInputFiles(files, options);
  }

}

exports.FileChooser = FileChooser;

/***/ }),

/***/ 1730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Frame = void 0;
exports.verifyLoadState = verifyLoadState;

var _utils = __nccwpck_require__(3557);

var _channelOwner = __nccwpck_require__(1578);

var _locator = __nccwpck_require__(2495);

var _elementHandle = __nccwpck_require__(9634);

var _jsHandle = __nccwpck_require__(6594);

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var network = _interopRequireWildcard(__nccwpck_require__(6529));

var _events = __nccwpck_require__(2361);

var _waiter = __nccwpck_require__(1145);

var _events2 = __nccwpck_require__(8289);

var _types = __nccwpck_require__(7825);

var _netUtils = __nccwpck_require__(989);

var _debugLogger = __nccwpck_require__(2003);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Frame extends _channelOwner.ChannelOwner {
  static from(frame) {
    return frame._object;
  }

  static fromNullable(frame) {
    return frame ? Frame.from(frame) : null;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._eventEmitter = void 0;
    this._loadStates = void 0;
    this._parentFrame = null;
    this._url = '';
    this._name = '';
    this._detached = false;
    this._childFrames = new Set();
    this._page = void 0;
    this._eventEmitter = new _events.EventEmitter();

    this._eventEmitter.setMaxListeners(0);

    this._parentFrame = Frame.fromNullable(initializer.parentFrame);
    if (this._parentFrame) this._parentFrame._childFrames.add(this);
    this._name = initializer.name;
    this._url = initializer.url;
    this._loadStates = new Set(initializer.loadStates);

    this._channel.on('loadstate', event => {
      if (event.add) {
        this._loadStates.add(event.add);

        this._eventEmitter.emit('loadstate', event.add);
      }

      if (event.remove) this._loadStates.delete(event.remove);
      if (!this._parentFrame && event.add === 'load' && this._page) this._page.emit(_events2.Events.Page.Load, this._page);
      if (!this._parentFrame && event.add === 'domcontentloaded' && this._page) this._page.emit(_events2.Events.Page.DOMContentLoaded, this._page);
    });

    this._channel.on('navigated', event => {
      this._url = event.url;
      this._name = event.name;

      this._eventEmitter.emit('navigated', event);

      if (!event.error && this._page) this._page.emit(_events2.Events.Page.FrameNavigated, this);
    });
  }

  page() {
    return this._page;
  }

  async goto(url, options = {}) {
    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    return network.Response.fromNullable((await this._channel.goto({
      url,
      ...options,
      waitUntil
    })).response);
  }

  _setupNavigationWaiter(options) {
    const waiter = new _waiter.Waiter(this._page, '');
    if (this._page.isClosed()) waiter.rejectImmediately(new Error('Navigation failed because page was closed!'));
    waiter.rejectOnEvent(this._page, _events2.Events.Page.Close, new Error('Navigation failed because page was closed!'));
    waiter.rejectOnEvent(this._page, _events2.Events.Page.Crash, new Error('Navigation failed because page crashed!'));
    waiter.rejectOnEvent(this._page, _events2.Events.Page.FrameDetached, new Error('Navigating frame was detached!'), frame => frame === this);

    const timeout = this._page._timeoutSettings.navigationTimeout(options);

    waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
    return waiter;
  }

  async waitForNavigation(options = {}) {
    return this._page._wrapApiCall(async () => {
      const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);

      const waiter = this._setupNavigationWaiter(options);

      const toUrl = typeof options.url === 'string' ? ` to "${options.url}"` : '';
      waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
      const navigatedEvent = await waiter.waitForEvent(this._eventEmitter, 'navigated', event => {
        var _this$_page;

        // Any failed navigation results in a rejection.
        if (event.error) return true;
        waiter.log(`  navigated to "${event.url}"`);
        return (0, _netUtils.urlMatches)((_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page.context()._options.baseURL, event.url, options.url);
      });

      if (navigatedEvent.error) {
        const e = new Error(navigatedEvent.error);
        e.stack = '';
        await waiter.waitForPromise(Promise.reject(e));
      }

      if (!this._loadStates.has(waitUntil)) {
        await waiter.waitForEvent(this._eventEmitter, 'loadstate', s => {
          waiter.log(`  "${s}" event fired`);
          return s === waitUntil;
        });
      }

      const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
      const response = request ? await waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;
      waiter.dispose();
      return response;
    });
  }

  async waitForLoadState(state = 'load', options = {}) {
    state = verifyLoadState('state', state);
    if (this._loadStates.has(state)) return;
    return this._page._wrapApiCall(async () => {
      const waiter = this._setupNavigationWaiter(options);

      await waiter.waitForEvent(this._eventEmitter, 'loadstate', s => {
        waiter.log(`  "${s}" event fired`);
        return s === state;
      });
      waiter.dispose();
    });
  }

  async waitForURL(url, options = {}) {
    var _this$_page2;

    if ((0, _netUtils.urlMatches)((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2.context()._options.baseURL, this.url(), url)) return await this.waitForLoadState(options.waitUntil, options);
    await this.waitForNavigation({
      url,
      ...options
    });
  }

  async frameElement() {
    return _elementHandle.ElementHandle.from((await this._channel.frameElement()).element);
  }

  async evaluateHandle(pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
    const result = await this._channel.evaluateExpressionHandle({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return _jsHandle.JSHandle.from(result.handle);
  }

  async evaluate(pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
    const result = await this._channel.evaluateExpression({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async $(selector, options) {
    const result = await this._channel.querySelector({
      selector,
      ...options
    });
    return _elementHandle.ElementHandle.fromNullable(result.element);
  }

  async waitForSelector(selector, options = {}) {
    if (options.visibility) throw new Error('options.visibility is not supported, did you mean options.state?');
    if (options.waitFor && options.waitFor !== 'visible') throw new Error('options.waitFor is not supported, did you mean options.state?');
    const result = await this._channel.waitForSelector({
      selector,
      ...options
    });
    return _elementHandle.ElementHandle.fromNullable(result.element);
  }

  async dispatchEvent(selector, type, eventInit, options = {}) {
    await this._channel.dispatchEvent({
      selector,
      type,
      eventInit: (0, _jsHandle.serializeArgument)(eventInit),
      ...options
    });
  }

  async $eval(selector, pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
    const result = await this._channel.evalOnSelector({
      selector,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async $$eval(selector, pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
    const result = await this._channel.evalOnSelectorAll({
      selector,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async $$(selector) {
    const result = await this._channel.querySelectorAll({
      selector
    });
    return result.elements.map(e => _elementHandle.ElementHandle.from(e));
  }

  async _queryCount(selector) {
    return (await this._channel.queryCount({
      selector
    })).value;
  }

  async content() {
    return (await this._channel.content()).value;
  }

  async setContent(html, options = {}) {
    const waitUntil = verifyLoadState('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    await this._channel.setContent({
      html,
      ...options,
      waitUntil
    });
  }

  name() {
    return this._name || '';
  }

  url() {
    return this._url;
  }

  parentFrame() {
    return this._parentFrame;
  }

  childFrames() {
    return Array.from(this._childFrames);
  }

  isDetached() {
    return this._detached;
  }

  async addScriptTag(options = {}) {
    const copy = { ...options
    };

    if (copy.path) {
      copy.content = (await _fs.default.promises.readFile(copy.path)).toString();
      copy.content += '//# sourceURL=' + copy.path.replace(/\n/g, '');
    }

    return _elementHandle.ElementHandle.from((await this._channel.addScriptTag({ ...copy
    })).element);
  }

  async addStyleTag(options = {}) {
    const copy = { ...options
    };

    if (copy.path) {
      copy.content = (await _fs.default.promises.readFile(copy.path)).toString();
      copy.content += '/*# sourceURL=' + copy.path.replace(/\n/g, '') + '*/';
    }

    return _elementHandle.ElementHandle.from((await this._channel.addStyleTag({ ...copy
    })).element);
  }

  async click(selector, options = {}) {
    return await this._channel.click({
      selector,
      ...options
    });
  }

  async dblclick(selector, options = {}) {
    return await this._channel.dblclick({
      selector,
      ...options
    });
  }

  async dragAndDrop(source, target, options = {}) {
    return await this._channel.dragAndDrop({
      source,
      target,
      ...options
    });
  }

  async tap(selector, options = {}) {
    return await this._channel.tap({
      selector,
      ...options
    });
  }

  async fill(selector, value, options = {}) {
    return await this._channel.fill({
      selector,
      value,
      ...options
    });
  }

  async _highlight(selector) {
    return await this._channel.highlight({
      selector
    });
  }

  locator(selector, options) {
    return new _locator.Locator(this, selector, options);
  }

  frameLocator(selector) {
    return new _locator.FrameLocator(this, selector);
  }

  async focus(selector, options = {}) {
    await this._channel.focus({
      selector,
      ...options
    });
  }

  async textContent(selector, options = {}) {
    const value = (await this._channel.textContent({
      selector,
      ...options
    })).value;
    return value === undefined ? null : value;
  }

  async innerText(selector, options = {}) {
    return (await this._channel.innerText({
      selector,
      ...options
    })).value;
  }

  async innerHTML(selector, options = {}) {
    return (await this._channel.innerHTML({
      selector,
      ...options
    })).value;
  }

  async getAttribute(selector, name, options = {}) {
    const value = (await this._channel.getAttribute({
      selector,
      name,
      ...options
    })).value;
    return value === undefined ? null : value;
  }

  async inputValue(selector, options = {}) {
    return (await this._channel.inputValue({
      selector,
      ...options
    })).value;
  }

  async isChecked(selector, options = {}) {
    return (await this._channel.isChecked({
      selector,
      ...options
    })).value;
  }

  async isDisabled(selector, options = {}) {
    return (await this._channel.isDisabled({
      selector,
      ...options
    })).value;
  }

  async isEditable(selector, options = {}) {
    return (await this._channel.isEditable({
      selector,
      ...options
    })).value;
  }

  async isEnabled(selector, options = {}) {
    return (await this._channel.isEnabled({
      selector,
      ...options
    })).value;
  }

  async isHidden(selector, options = {}) {
    return (await this._channel.isHidden({
      selector,
      ...options
    })).value;
  }

  async isVisible(selector, options = {}) {
    return (await this._channel.isVisible({
      selector,
      ...options
    })).value;
  }

  async hover(selector, options = {}) {
    await this._channel.hover({
      selector,
      ...options
    });
  }

  async selectOption(selector, values, options = {}) {
    return (await this._channel.selectOption({
      selector,
      ...(0, _elementHandle.convertSelectOptionValues)(values),
      ...options
    })).values;
  }

  async setInputFiles(selector, files, options = {}) {
    const converted = await (0, _elementHandle.convertInputFiles)(files, this.page().context());

    if (converted.files) {
      await this._channel.setInputFiles({
        selector,
        files: converted.files,
        ...options
      });
    } else {
      _debugLogger.debugLogger.log('api', 'switching to large files mode');

      await this._channel.setInputFilePaths({
        selector,
        ...converted,
        ...options
      });
    }
  }

  async type(selector, text, options = {}) {
    await this._channel.type({
      selector,
      text,
      ...options
    });
  }

  async press(selector, key, options = {}) {
    await this._channel.press({
      selector,
      key,
      ...options
    });
  }

  async check(selector, options = {}) {
    await this._channel.check({
      selector,
      ...options
    });
  }

  async uncheck(selector, options = {}) {
    await this._channel.uncheck({
      selector,
      ...options
    });
  }

  async setChecked(selector, checked, options) {
    if (checked) await this.check(selector, options);else await this.uncheck(selector, options);
  }

  async waitForTimeout(timeout) {
    await this._channel.waitForTimeout({
      timeout
    });
  }

  async waitForFunction(pageFunction, arg, options = {}) {
    if (typeof options.polling === 'string') (0, _utils.assert)(options.polling === 'raf', 'Unknown polling option: ' + options.polling);
    const result = await this._channel.waitForFunction({ ...options,
      pollingInterval: options.polling === 'raf' ? undefined : options.polling,
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return _jsHandle.JSHandle.from(result.handle);
  }

  async title() {
    return (await this._channel.title()).value;
  }

}

exports.Frame = Frame;

function verifyLoadState(name, waitUntil) {
  if (waitUntil === 'networkidle0') waitUntil = 'networkidle';
  if (!_types.kLifecycleEvents.has(waitUntil)) throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
  return waitUntil;
}

/***/ }),

/***/ 4810:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HarRouter = void 0;

var _debugLogger = __nccwpck_require__(2003);

var _events = __nccwpck_require__(8289);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HarRouter {
  static async create(localUtils, file, notFoundAction, options) {
    const {
      harId,
      error
    } = await localUtils._channel.harOpen({
      file
    });
    if (error) throw new Error(error);
    return new HarRouter(localUtils, harId, notFoundAction, options);
  }

  constructor(localUtils, harId, notFoundAction, options) {
    this._localUtils = void 0;
    this._harId = void 0;
    this._notFoundAction = void 0;
    this._options = void 0;
    this._localUtils = localUtils;
    this._harId = harId;
    this._options = options;
    this._notFoundAction = notFoundAction;
  }

  async _handle(route) {
    const request = route.request();
    const response = await this._localUtils._channel.harLookup({
      harId: this._harId,
      url: request.url(),
      method: request.method(),
      headers: await request.headersArray(),
      postData: request.postDataBuffer() || undefined,
      isNavigationRequest: request.isNavigationRequest()
    });

    if (response.action === 'redirect') {
      _debugLogger.debugLogger.log('api', `HAR: ${route.request().url()} redirected to ${response.redirectURL}`);

      await route._redirectNavigationRequest(response.redirectURL);
      return;
    }

    if (response.action === 'fulfill') {
      await route.fulfill({
        status: response.status,
        headers: Object.fromEntries(response.headers.map(h => [h.name, h.value])),
        body: response.body
      });
      return;
    }

    if (response.action === 'error') _debugLogger.debugLogger.log('api', 'HAR: ' + response.message); // Report the error, but fall through to the default handler.

    if (this._notFoundAction === 'abort') {
      await route.abort();
      return;
    }

    await route.fallback();
  }

  async addContextRoute(context) {
    await context.route(this._options.urlMatch || '**/*', route => this._handle(route));
    context.once(_events.Events.BrowserContext.Close, () => this.dispose());
  }

  async addPageRoute(page) {
    await page.route(this._options.urlMatch || '**/*', route => this._handle(route));
    page.once(_events.Events.Page.Close, () => this.dispose());
  }

  dispose() {
    this._localUtils._channel.harClose({
      harId: this._harId
    }).catch(() => {});
  }

}

exports.HarRouter = HarRouter;

/***/ }),

/***/ 4507:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Keyboard {
  constructor(page) {
    this._page = void 0;
    this._page = page;
  }

  async down(key) {
    await this._page._channel.keyboardDown({
      key
    });
  }

  async up(key) {
    await this._page._channel.keyboardUp({
      key
    });
  }

  async insertText(text) {
    await this._page._channel.keyboardInsertText({
      text
    });
  }

  async type(text, options = {}) {
    await this._page._channel.keyboardType({
      text,
      ...options
    });
  }

  async press(key, options = {}) {
    await this._page._channel.keyboardPress({
      key,
      ...options
    });
  }

}

exports.Keyboard = Keyboard;

class Mouse {
  constructor(page) {
    this._page = void 0;
    this._page = page;
  }

  async move(x, y, options = {}) {
    await this._page._channel.mouseMove({
      x,
      y,
      ...options
    });
  }

  async down(options = {}) {
    await this._page._channel.mouseDown({ ...options
    });
  }

  async up(options = {}) {
    await this._page._channel.mouseUp(options);
  }

  async click(x, y, options = {}) {
    await this._page._channel.mouseClick({
      x,
      y,
      ...options
    });
  }

  async dblclick(x, y, options = {}) {
    await this.click(x, y, { ...options,
      clickCount: 2
    });
  }

  async wheel(deltaX, deltaY) {
    await this._page._channel.mouseWheel({
      deltaX,
      deltaY
    });
  }

}

exports.Mouse = Mouse;

class Touchscreen {
  constructor(page) {
    this._page = void 0;
    this._page = page;
  }

  async tap(x, y) {
    await this._page._channel.touchscreenTap({
      x,
      y
    });
  }

}

exports.Touchscreen = Touchscreen;

/***/ }),

/***/ 6594:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JSHandle = void 0;
exports.assertMaxArguments = assertMaxArguments;
exports.parseResult = parseResult;
exports.serializeArgument = serializeArgument;

var _channelOwner = __nccwpck_require__(1578);

var _serializers = __nccwpck_require__(5644);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JSHandle extends _channelOwner.ChannelOwner {
  static from(handle) {
    return handle._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._preview = void 0;
    this._preview = this._initializer.preview;

    this._channel.on('previewUpdated', ({
      preview
    }) => this._preview = preview);
  }

  async evaluate(pageFunction, arg) {
    const result = await this._channel.evaluateExpression({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: serializeArgument(arg)
    });
    return parseResult(result.value);
  }

  async evaluateHandle(pageFunction, arg) {
    const result = await this._channel.evaluateExpressionHandle({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: serializeArgument(arg)
    });
    return JSHandle.from(result.handle);
  }

  async getProperty(propertyName) {
    const result = await this._channel.getProperty({
      name: propertyName
    });
    return JSHandle.from(result.handle);
  }

  async getProperties() {
    const map = new Map();

    for (const {
      name,
      value
    } of (await this._channel.getPropertyList()).properties) map.set(name, JSHandle.from(value));

    return map;
  }

  async jsonValue() {
    return parseResult((await this._channel.jsonValue()).value);
  }

  asElement() {
    return null;
  }

  async dispose() {
    return await this._channel.dispose();
  }

  toString() {
    return this._preview;
  }

} // This function takes care of converting all JSHandles to their channels,
// so that generic channel serializer converts them to guids.


exports.JSHandle = JSHandle;

function serializeArgument(arg) {
  const handles = [];

  const pushHandle = channel => {
    handles.push(channel);
    return handles.length - 1;
  };

  const value = (0, _serializers.serializeValue)(arg, value => {
    if (value instanceof JSHandle) return {
      h: pushHandle(value._channel)
    };
    return {
      fallThrough: value
    };
  });
  return {
    value,
    handles
  };
}

function parseResult(value) {
  return (0, _serializers.parseSerializedValue)(value, undefined);
}

function assertMaxArguments(count, max) {
  if (count > max) throw new Error('Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.');
}

/***/ }),

/***/ 4772:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JsonPipe = void 0;

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JsonPipe extends _channelOwner.ChannelOwner {
  static from(jsonPipe) {
    return jsonPipe._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  channel() {
    return this._channel;
  }

}

exports.JsonPipe = JsonPipe;

/***/ }),

/***/ 3075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalUtils = void 0;

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocalUtils extends _channelOwner.ChannelOwner {
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

}

exports.LocalUtils = LocalUtils;

/***/ }),

/***/ 2495:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Locator = exports.FrameLocator = void 0;

var util = _interopRequireWildcard(__nccwpck_require__(3837));

var _utils = __nccwpck_require__(3557);

var _elementHandle = __nccwpck_require__(9634);

var _jsHandle = __nccwpck_require__(6594);

var _stringUtils = __nccwpck_require__(7517);

let _util$inspect$custom;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

_util$inspect$custom = util.inspect.custom;

class Locator {
  constructor(frame, selector, options) {
    this._frame = void 0;
    this._selector = void 0;
    this._frame = frame;
    this._selector = selector;

    if (options !== null && options !== void 0 && options.hasText) {
      const text = options.hasText;
      if ((0, _utils.isRegExp)(text)) this._selector += ` >> has=${JSON.stringify('text=' + text.toString())}`;else this._selector += ` >> :scope:has-text(${(0, _stringUtils.escapeWithQuotes)(text, '"')})`;
    }

    if (options !== null && options !== void 0 && options.has) {
      const locator = options.has;
      if (locator._frame !== frame) throw new Error(`Inner "has" locator must belong to the same frame.`);
      this._selector += ` >> has=` + JSON.stringify(locator._selector);
    }
  }

  async _withElement(task, timeout) {
    timeout = this._frame.page()._timeoutSettings.timeout({
      timeout
    });
    const deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
    return this._frame._wrapApiCall(async () => {
      const result = await this._frame._channel.waitForSelector({
        selector: this._selector,
        strict: true,
        state: 'attached',
        timeout
      });

      const handle = _elementHandle.ElementHandle.fromNullable(result.element);

      if (!handle) throw new Error(`Could not resolve ${this._selector} to DOM Element`);

      try {
        return await task(handle, deadline ? deadline - (0, _utils.monotonicTime)() : 0);
      } finally {
        await handle.dispose();
      }
    });
  }

  page() {
    return this._frame.page();
  }

  async boundingBox(options) {
    return this._withElement(h => h.boundingBox(), options === null || options === void 0 ? void 0 : options.timeout);
  }

  async check(options = {}) {
    return this._frame.check(this._selector, {
      strict: true,
      ...options
    });
  }

  async click(options = {}) {
    return this._frame.click(this._selector, {
      strict: true,
      ...options
    });
  }

  async dblclick(options = {}) {
    return this._frame.dblclick(this._selector, {
      strict: true,
      ...options
    });
  }

  async dispatchEvent(type, eventInit = {}, options) {
    return this._frame.dispatchEvent(this._selector, type, eventInit, {
      strict: true,
      ...options
    });
  }

  async dragTo(target, options = {}) {
    return this._frame.dragAndDrop(this._selector, target._selector, {
      strict: true,
      ...options
    });
  }

  async evaluate(pageFunction, arg, options) {
    return this._withElement(h => h.evaluate(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
  }

  async evaluateAll(pageFunction, arg) {
    return this._frame.$$eval(this._selector, pageFunction, arg);
  }

  async evaluateHandle(pageFunction, arg, options) {
    return this._withElement(h => h.evaluateHandle(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
  }

  async fill(value, options = {}) {
    return this._frame.fill(this._selector, value, {
      strict: true,
      ...options
    });
  }

  async _highlight() {
    // VS Code extension uses this one, keep it for now.
    return this._frame._highlight(this._selector);
  }

  async highlight() {
    return this._frame._highlight(this._selector);
  }

  locator(selector, options) {
    return new Locator(this._frame, this._selector + ' >> ' + selector, options);
  }

  frameLocator(selector) {
    return new FrameLocator(this._frame, this._selector + ' >> ' + selector);
  }

  filter(options) {
    return new Locator(this._frame, this._selector, options);
  }

  async elementHandle(options) {
    return await this._frame.waitForSelector(this._selector, {
      strict: true,
      state: 'attached',
      ...options
    });
  }

  async elementHandles() {
    return this._frame.$$(this._selector);
  }

  first() {
    return new Locator(this._frame, this._selector + ' >> nth=0');
  }

  last() {
    return new Locator(this._frame, this._selector + ` >> nth=-1`);
  }

  nth(index) {
    return new Locator(this._frame, this._selector + ` >> nth=${index}`);
  }

  async focus(options) {
    return this._frame.focus(this._selector, {
      strict: true,
      ...options
    });
  }

  async count() {
    return this._frame._queryCount(this._selector);
  }

  async getAttribute(name, options) {
    return this._frame.getAttribute(this._selector, name, {
      strict: true,
      ...options
    });
  }

  async hover(options = {}) {
    return this._frame.hover(this._selector, {
      strict: true,
      ...options
    });
  }

  async innerHTML(options) {
    return this._frame.innerHTML(this._selector, {
      strict: true,
      ...options
    });
  }

  async innerText(options) {
    return this._frame.innerText(this._selector, {
      strict: true,
      ...options
    });
  }

  async inputValue(options) {
    return this._frame.inputValue(this._selector, {
      strict: true,
      ...options
    });
  }

  async isChecked(options) {
    return this._frame.isChecked(this._selector, {
      strict: true,
      ...options
    });
  }

  async isDisabled(options) {
    return this._frame.isDisabled(this._selector, {
      strict: true,
      ...options
    });
  }

  async isEditable(options) {
    return this._frame.isEditable(this._selector, {
      strict: true,
      ...options
    });
  }

  async isEnabled(options) {
    return this._frame.isEnabled(this._selector, {
      strict: true,
      ...options
    });
  }

  async isHidden(options) {
    return this._frame.isHidden(this._selector, {
      strict: true,
      ...options
    });
  }

  async isVisible(options) {
    return this._frame.isVisible(this._selector, {
      strict: true,
      ...options
    });
  }

  async press(key, options = {}) {
    return this._frame.press(this._selector, key, {
      strict: true,
      ...options
    });
  }

  async screenshot(options = {}) {
    return this._withElement((h, timeout) => h.screenshot({ ...options,
      timeout
    }), options.timeout);
  }

  async scrollIntoViewIfNeeded(options = {}) {
    return this._withElement((h, timeout) => h.scrollIntoViewIfNeeded({ ...options,
      timeout
    }), options.timeout);
  }

  async selectOption(values, options = {}) {
    return this._frame.selectOption(this._selector, values, {
      strict: true,
      ...options
    });
  }

  async selectText(options = {}) {
    return this._withElement((h, timeout) => h.selectText({ ...options,
      timeout
    }), options.timeout);
  }

  async setChecked(checked, options) {
    if (checked) await this.check(options);else await this.uncheck(options);
  }

  async setInputFiles(files, options = {}) {
    return this._frame.setInputFiles(this._selector, files, {
      strict: true,
      ...options
    });
  }

  async tap(options = {}) {
    return this._frame.tap(this._selector, {
      strict: true,
      ...options
    });
  }

  async textContent(options) {
    return this._frame.textContent(this._selector, {
      strict: true,
      ...options
    });
  }

  async type(text, options = {}) {
    return this._frame.type(this._selector, text, {
      strict: true,
      ...options
    });
  }

  async uncheck(options = {}) {
    return this._frame.uncheck(this._selector, {
      strict: true,
      ...options
    });
  }

  async allInnerTexts() {
    return this._frame.$$eval(this._selector, ee => ee.map(e => e.innerText));
  }

  async allTextContents() {
    return this._frame.$$eval(this._selector, ee => ee.map(e => e.textContent || ''));
  }

  async waitFor(options) {
    await this._frame._channel.waitForSelector({
      selector: this._selector,
      strict: true,
      omitReturnValue: true,
      ...options
    });
  }

  async _expect(customStackTrace, expression, options) {
    return this._frame._wrapApiCall(async () => {
      const params = {
        selector: this._selector,
        expression,
        ...options,
        isNot: !!options.isNot
      };
      params.expectedValue = (0, _jsHandle.serializeArgument)(options.expectedValue);
      const result = await this._frame._channel.expect(params);
      if (result.received !== undefined) result.received = (0, _jsHandle.parseResult)(result.received);
      return result;
    }, false
    /* isInternal */
    , customStackTrace);
  }

  [_util$inspect$custom]() {
    return this.toString();
  }

  toString() {
    return `Locator@${this._selector}`;
  }

}

exports.Locator = Locator;

class FrameLocator {
  constructor(frame, selector) {
    this._frame = void 0;
    this._frameSelector = void 0;
    this._frame = frame;
    this._frameSelector = selector;
  }

  locator(selector, options) {
    return new Locator(this._frame, this._frameSelector + ' >> control=enter-frame >> ' + selector, options);
  }

  frameLocator(selector) {
    return new FrameLocator(this._frame, this._frameSelector + ' >> control=enter-frame >> ' + selector);
  }

  first() {
    return new FrameLocator(this._frame, this._frameSelector + ' >> nth=0');
  }

  last() {
    return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
  }

  nth(index) {
    return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);
  }

}

exports.FrameLocator = FrameLocator;

/***/ }),

/***/ 6529:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocket = exports.RouteHandler = exports.Route = exports.Response = exports.Request = exports.RawHeaders = void 0;
exports.validateHeaders = validateHeaders;

var _url = __nccwpck_require__(7310);

var _channelOwner = __nccwpck_require__(1578);

var _frame = __nccwpck_require__(1730);

var _worker = __nccwpck_require__(395);

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _utilsBundle = __nccwpck_require__(1319);

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

var _events = __nccwpck_require__(8289);

var _waiter = __nccwpck_require__(1145);

var _netUtils = __nccwpck_require__(989);

var _multimap = __nccwpck_require__(2391);

var _fetch = __nccwpck_require__(3750);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Request extends _channelOwner.ChannelOwner {
  static from(request) {
    return request._object;
  }

  static fromNullable(request) {
    return request ? Request.from(request) : null;
  }

  constructor(parent, type, guid, initializer) {
    var _initializer$postData;

    super(parent, type, guid, initializer);
    this._redirectedFrom = null;
    this._redirectedTo = null;
    this._failureText = null;
    this._provisionalHeaders = void 0;
    this._actualHeadersPromise = void 0;
    this._postData = void 0;
    this._timing = void 0;
    this._fallbackOverrides = {};
    this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);
    if (this._redirectedFrom) this._redirectedFrom._redirectedTo = this;
    this._provisionalHeaders = new RawHeaders(initializer.headers);
    this._postData = (_initializer$postData = initializer.postData) !== null && _initializer$postData !== void 0 ? _initializer$postData : null;
    this._timing = {
      startTime: 0,
      domainLookupStart: -1,
      domainLookupEnd: -1,
      connectStart: -1,
      secureConnectionStart: -1,
      connectEnd: -1,
      requestStart: -1,
      responseStart: -1,
      responseEnd: -1
    };
  }

  url() {
    return this._fallbackOverrides.url || this._initializer.url;
  }

  resourceType() {
    return this._initializer.resourceType;
  }

  method() {
    return this._fallbackOverrides.method || this._initializer.method;
  }

  postData() {
    if (this._fallbackOverrides.postData) return this._fallbackOverrides.postData.toString('utf-8');
    return this._postData ? this._postData.toString('utf8') : null;
  }

  postDataBuffer() {
    if (this._fallbackOverrides.postData) {
      if ((0, _utils.isString)(this._fallbackOverrides.postData)) return Buffer.from(this._fallbackOverrides.postData, 'utf-8');
      return this._fallbackOverrides.postData;
    }

    return this._postData;
  }

  postDataJSON() {
    const postData = this.postData();
    if (!postData) return null;
    const contentType = this.headers()['content-type'];

    if (contentType === 'application/x-www-form-urlencoded') {
      const entries = {};
      const parsed = new _url.URLSearchParams(postData);

      for (const [k, v] of parsed.entries()) entries[k] = v;

      return entries;
    }

    try {
      return JSON.parse(postData);
    } catch (e) {
      throw new Error('POST data is not a valid JSON object: ' + postData);
    }
  }
  /**
   * @deprecated
   */


  headers() {
    if (this._fallbackOverrides.headers) return RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers).headers();
    return this._provisionalHeaders.headers();
  }

  _context() {
    // TODO: make sure this works for service worker requests.
    return this.frame().page().context();
  }

  _actualHeaders() {
    if (this._fallbackOverrides.headers) return Promise.resolve(RawHeaders._fromHeadersObjectLossy(this._fallbackOverrides.headers));

    if (!this._actualHeadersPromise) {
      this._actualHeadersPromise = this._wrapApiCall(async () => {
        return new RawHeaders((await this._channel.rawRequestHeaders()).headers);
      });
    }

    return this._actualHeadersPromise;
  }

  async allHeaders() {
    return (await this._actualHeaders()).headers();
  }

  async headersArray() {
    return (await this._actualHeaders()).headersArray();
  }

  async headerValue(name) {
    return (await this._actualHeaders()).get(name);
  }

  async response() {
    return Response.fromNullable((await this._channel.response()).response);
  }

  async _internalResponse() {
    return this._wrapApiCall(async () => {
      return Response.fromNullable((await this._channel.response()).response);
    }, true);
  }

  frame() {
    if (!this._initializer.frame) {
      (0, _utils.assert)(this.serviceWorker());
      throw new Error('Service Worker requests do not have an associated frame.');
    }

    return _frame.Frame.from(this._initializer.frame);
  }

  serviceWorker() {
    return this._initializer.serviceWorker ? _worker.Worker.from(this._initializer.serviceWorker) : null;
  }

  isNavigationRequest() {
    return this._initializer.isNavigationRequest;
  }

  redirectedFrom() {
    return this._redirectedFrom;
  }

  redirectedTo() {
    return this._redirectedTo;
  }

  failure() {
    if (this._failureText === null) return null;
    return {
      errorText: this._failureText
    };
  }

  timing() {
    return this._timing;
  }

  async sizes() {
    const response = await this.response();
    if (!response) throw new Error('Unable to fetch sizes for failed request');
    return (await response._channel.sizes()).sizes;
  }

  _finalRequest() {
    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
  }

  _applyFallbackOverrides(overrides) {
    this._fallbackOverrides = { ...this._fallbackOverrides,
      ...overrides
    };
  }

  _fallbackOverridesForContinue() {
    return this._fallbackOverrides;
  }

}

exports.Request = Request;

class Route extends _channelOwner.ChannelOwner {
  static from(route) {
    return route._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._handlingPromise = null;
  }

  request() {
    return Request.from(this._initializer.request);
  }

  _raceWithTargetClose(promise) {
    var _this$request$service, _this$request$frame$_;

    // When page closes or crashes, we catch any potential rejects from this Route.
    // Note that page could be missing when routing popup's initial request that
    // does not have a Page initialized just yet.
    return Promise.race([promise, ((_this$request$service = this.request().serviceWorker()) === null || _this$request$service === void 0 ? void 0 : _this$request$service._closedPromise) || ((_this$request$frame$_ = this.request().frame()._page) === null || _this$request$frame$_ === void 0 ? void 0 : _this$request$frame$_._closedOrCrashedPromise) || Promise.resolve()]);
  }

  _startHandling() {
    this._handlingPromise = new _manualPromise.ManualPromise();
    return this._handlingPromise;
  }

  async fallback(options = {}) {
    this._checkNotHandled();

    this.request()._applyFallbackOverrides(options);

    this._reportHandled(false);
  }

  async abort(errorCode) {
    this._checkNotHandled();

    await this._raceWithTargetClose(this._channel.abort({
      errorCode
    }));

    this._reportHandled(true);
  }

  async _redirectNavigationRequest(url) {
    this._checkNotHandled();

    await this._raceWithTargetClose(this._channel.redirectNavigationRequest({
      url
    }));

    this._reportHandled(true);
  }

  async fulfill(options = {}) {
    this._checkNotHandled();

    await this._wrapApiCall(async () => {
      await this._innerFulfill(options);

      this._reportHandled(true);
    });
  }

  async _innerFulfill(options = {}) {
    let fetchResponseUid;
    let {
      status: statusOption,
      headers: headersOption,
      body
    } = options;

    if (options.response instanceof _fetch.APIResponse) {
      var _statusOption, _headersOption;

      (_statusOption = statusOption) !== null && _statusOption !== void 0 ? _statusOption : statusOption = options.response.status();
      (_headersOption = headersOption) !== null && _headersOption !== void 0 ? _headersOption : headersOption = options.response.headers();

      if (body === undefined && options.path === undefined) {
        if (options.response._request._connection === this._connection) fetchResponseUid = options.response._fetchUid();else body = await options.response.body();
      }
    }

    let isBase64 = false;
    let length = 0;

    if (options.path) {
      const buffer = await _fs.default.promises.readFile(options.path);
      body = buffer.toString('base64');
      isBase64 = true;
      length = buffer.length;
    } else if ((0, _utils.isString)(body)) {
      isBase64 = false;
      length = Buffer.byteLength(body);
    } else if (body) {
      length = body.length;
      body = body.toString('base64');
      isBase64 = true;
    }

    const headers = {};

    for (const header of Object.keys(headersOption || {})) headers[header.toLowerCase()] = String(headersOption[header]);

    if (options.contentType) headers['content-type'] = String(options.contentType);else if (options.path) headers['content-type'] = _utilsBundle.mime.getType(options.path) || 'application/octet-stream';
    if (length && !('content-length' in headers)) headers['content-length'] = String(length);
    await this._raceWithTargetClose(this._channel.fulfill({
      status: statusOption || 200,
      headers: (0, _utils.headersObjectToArray)(headers),
      body,
      isBase64,
      fetchResponseUid
    }));
  }

  async continue(options = {}) {
    this._checkNotHandled();

    this.request()._applyFallbackOverrides(options);

    await this._innerContinue();

    this._reportHandled(true);
  }

  _checkNotHandled() {
    if (!this._handlingPromise) throw new Error('Route is already handled!');
  }

  _reportHandled(done) {
    const chain = this._handlingPromise;
    this._handlingPromise = null;
    chain.resolve(done);
  }

  async _innerContinue(internal = false) {
    const options = this.request()._fallbackOverridesForContinue();

    return await this._wrapApiCall(async () => {
      const postDataBuffer = (0, _utils.isString)(options.postData) ? Buffer.from(options.postData, 'utf8') : options.postData;
      await this._raceWithTargetClose(this._channel.continue({
        url: options.url,
        method: options.method,
        headers: options.headers ? (0, _utils.headersObjectToArray)(options.headers) : undefined,
        postData: postDataBuffer
      }));
    }, !!internal);
  }

}

exports.Route = Route;

class Response extends _channelOwner.ChannelOwner {
  static from(response) {
    return response._object;
  }

  static fromNullable(response) {
    return response ? Response.from(response) : null;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._provisionalHeaders = void 0;
    this._actualHeadersPromise = void 0;
    this._request = void 0;
    this._finishedPromise = new _manualPromise.ManualPromise();
    this._provisionalHeaders = new RawHeaders(initializer.headers);
    this._request = Request.from(this._initializer.request);
    Object.assign(this._request._timing, this._initializer.timing);
  }

  url() {
    return this._initializer.url;
  }

  ok() {
    // Status 0 is for file:// URLs
    return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
  }

  status() {
    return this._initializer.status;
  }

  statusText() {
    return this._initializer.statusText;
  }

  fromServiceWorker() {
    return this._initializer.fromServiceWorker;
  }
  /**
   * @deprecated
   */


  headers() {
    return this._provisionalHeaders.headers();
  }

  async _actualHeaders() {
    if (!this._actualHeadersPromise) {
      this._actualHeadersPromise = (async () => {
        return new RawHeaders((await this._channel.rawResponseHeaders()).headers);
      })();
    }

    return this._actualHeadersPromise;
  }

  async allHeaders() {
    return (await this._actualHeaders()).headers();
  }

  async headersArray() {
    return (await this._actualHeaders()).headersArray().slice();
  }

  async headerValue(name) {
    return (await this._actualHeaders()).get(name);
  }

  async headerValues(name) {
    return (await this._actualHeaders()).getAll(name);
  }

  async finished() {
    return this._finishedPromise.then(() => null);
  }

  async body() {
    return (await this._channel.body()).binary;
  }

  async text() {
    const content = await this.body();
    return content.toString('utf8');
  }

  async json() {
    const content = await this.text();
    return JSON.parse(content);
  }

  request() {
    return this._request;
  }

  frame() {
    return this._request.frame();
  }

  async serverAddr() {
    return (await this._channel.serverAddr()).value || null;
  }

  async securityDetails() {
    return (await this._channel.securityDetails()).value || null;
  }

}

exports.Response = Response;

class WebSocket extends _channelOwner.ChannelOwner {
  static from(webSocket) {
    return webSocket._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._page = void 0;
    this._isClosed = void 0;
    this._isClosed = false;
    this._page = parent;

    this._channel.on('frameSent', event => {
      if (event.opcode === 1) this.emit(_events.Events.WebSocket.FrameSent, {
        payload: event.data
      });else if (event.opcode === 2) this.emit(_events.Events.WebSocket.FrameSent, {
        payload: Buffer.from(event.data, 'base64')
      });
    });

    this._channel.on('frameReceived', event => {
      if (event.opcode === 1) this.emit(_events.Events.WebSocket.FrameReceived, {
        payload: event.data
      });else if (event.opcode === 2) this.emit(_events.Events.WebSocket.FrameReceived, {
        payload: Buffer.from(event.data, 'base64')
      });
    });

    this._channel.on('socketError', ({
      error
    }) => this.emit(_events.Events.WebSocket.Error, error));

    this._channel.on('close', () => {
      this._isClosed = true;
      this.emit(_events.Events.WebSocket.Close, this);
    });
  }

  url() {
    return this._initializer.url;
  }

  isClosed() {
    return this._isClosed;
  }

  async waitForEvent(event, optionsOrPredicate = {}) {
    return this._wrapApiCall(async () => {
      const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);

      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;

      const waiter = _waiter.Waiter.createForEvent(this, event);

      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== _events.Events.WebSocket.Error) waiter.rejectOnEvent(this, _events.Events.WebSocket.Error, new Error('Socket error'));
      if (event !== _events.Events.WebSocket.Close) waiter.rejectOnEvent(this, _events.Events.WebSocket.Close, new Error('Socket closed'));
      waiter.rejectOnEvent(this._page, _events.Events.Page.Close, new Error('Page closed'));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }

}

exports.WebSocket = WebSocket;

function validateHeaders(headers) {
  for (const key of Object.keys(headers)) {
    const value = headers[key];
    if (!Object.is(value, undefined) && !(0, _utils.isString)(value)) throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
  }
}

class RouteHandler {
  constructor(baseURL, url, handler, times = Number.MAX_SAFE_INTEGER) {
    this.handledCount = 0;
    this._baseURL = void 0;
    this._times = void 0;
    this.url = void 0;
    this.handler = void 0;
    this._baseURL = baseURL;
    this._times = times;
    this.url = url;
    this.handler = handler;
  }

  matches(requestURL) {
    return (0, _netUtils.urlMatches)(this._baseURL, requestURL, this.url);
  }

  async handle(route, request) {
    ++this.handledCount;

    const handledPromise = route._startHandling(); // Extract handler into a variable to avoid [RouteHandler.handler] in the stack.


    const handler = this.handler;
    const [handled] = await Promise.all([handledPromise, handler(route, request)]);
    return handled;
  }

  willExpire() {
    return this.handledCount + 1 >= this._times;
  }

}

exports.RouteHandler = RouteHandler;

class RawHeaders {
  static _fromHeadersObjectLossy(headers) {
    const headersArray = Object.entries(headers).map(([name, value]) => ({
      name,
      value
    })).filter(header => header.value !== undefined);
    return new RawHeaders(headersArray);
  }

  constructor(headers) {
    this._headersArray = void 0;
    this._headersMap = new _multimap.MultiMap();
    this._headersArray = headers;

    for (const header of headers) this._headersMap.set(header.name.toLowerCase(), header.value);
  }

  get(name) {
    const values = this.getAll(name);
    if (!values || !values.length) return null;
    return values.join(name.toLowerCase() === 'set-cookie' ? '\n' : ', ');
  }

  getAll(name) {
    return [...this._headersMap.get(name.toLowerCase())];
  }

  headers() {
    const result = {};

    for (const name of this._headersMap.keys()) result[name] = this.get(name);

    return result;
  }

  headersArray() {
    return this._headersArray;
  }

}

exports.RawHeaders = RawHeaders;

/***/ }),

/***/ 2374:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Page = exports.BindingCall = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _errors = __nccwpck_require__(542);

var _netUtils = __nccwpck_require__(989);

var _timeoutSettings = __nccwpck_require__(9053);

var _serializers = __nccwpck_require__(5644);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _accessibility = __nccwpck_require__(9996);

var _artifact = __nccwpck_require__(5043);

var _channelOwner = __nccwpck_require__(1578);

var _clientHelper = __nccwpck_require__(6886);

var _consoleMessage = __nccwpck_require__(359);

var _coverage = __nccwpck_require__(9679);

var _dialog = __nccwpck_require__(1468);

var _download = __nccwpck_require__(9551);

var _elementHandle = __nccwpck_require__(9634);

var _events = __nccwpck_require__(8289);

var _fileChooser = __nccwpck_require__(7105);

var _frame = __nccwpck_require__(1730);

var _harRouter = __nccwpck_require__(4810);

var _input = __nccwpck_require__(4507);

var _jsHandle = __nccwpck_require__(6594);

var _network = __nccwpck_require__(6529);

var _video = __nccwpck_require__(4359);

var _waiter = __nccwpck_require__(1145);

var _worker = __nccwpck_require__(395);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Page extends _channelOwner.ChannelOwner {
  static from(page) {
    return page._object;
  }

  static fromNullable(page) {
    return page ? Page.from(page) : null;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._browserContext = void 0;
    this._ownedContext = void 0;
    this._mainFrame = void 0;
    this._frames = new Set();
    this._workers = new Set();
    this._closed = false;
    this._closedOrCrashedPromise = void 0;
    this._viewportSize = void 0;
    this._routes = [];
    this.accessibility = void 0;
    this.coverage = void 0;
    this.keyboard = void 0;
    this.mouse = void 0;
    this.request = void 0;
    this.touchscreen = void 0;
    this._bindings = new Map();
    this._timeoutSettings = void 0;
    this._video = null;
    this._opener = void 0;
    this._browserContext = parent;
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(this._browserContext._timeoutSettings);
    this.accessibility = new _accessibility.Accessibility(this._channel);
    this.keyboard = new _input.Keyboard(this);
    this.mouse = new _input.Mouse(this);
    this.request = this._browserContext.request;
    this.touchscreen = new _input.Touchscreen(this);
    this._mainFrame = _frame.Frame.from(initializer.mainFrame);
    this._mainFrame._page = this;

    this._frames.add(this._mainFrame);

    this._viewportSize = initializer.viewportSize || null;
    this._closed = initializer.isClosed;
    this._opener = Page.fromNullable(initializer.opener);

    this._channel.on('bindingCall', ({
      binding
    }) => this._onBinding(BindingCall.from(binding)));

    this._channel.on('close', () => this._onClose());

    this._channel.on('console', ({
      message
    }) => this.emit(_events.Events.Page.Console, _consoleMessage.ConsoleMessage.from(message)));

    this._channel.on('crash', () => this._onCrash());

    this._channel.on('dialog', ({
      dialog
    }) => {
      const dialogObj = _dialog.Dialog.from(dialog);

      if (!this.emit(_events.Events.Page.Dialog, dialogObj)) {
        if (dialogObj.type() === 'beforeunload') dialog.accept({}).catch(() => {});else dialog.dismiss().catch(() => {});
      }
    });

    this._channel.on('download', ({
      url,
      suggestedFilename,
      artifact
    }) => {
      const artifactObject = _artifact.Artifact.from(artifact);

      this.emit(_events.Events.Page.Download, new _download.Download(this, url, suggestedFilename, artifactObject));
    });

    this._channel.on('fileChooser', ({
      element,
      isMultiple
    }) => this.emit(_events.Events.Page.FileChooser, new _fileChooser.FileChooser(this, _elementHandle.ElementHandle.from(element), isMultiple)));

    this._channel.on('frameAttached', ({
      frame
    }) => this._onFrameAttached(_frame.Frame.from(frame)));

    this._channel.on('frameDetached', ({
      frame
    }) => this._onFrameDetached(_frame.Frame.from(frame)));

    this._channel.on('pageError', ({
      error
    }) => this.emit(_events.Events.Page.PageError, (0, _serializers.parseError)(error)));

    this._channel.on('route', ({
      route,
      request
    }) => this._onRoute(_network.Route.from(route), _network.Request.from(request)));

    this._channel.on('video', ({
      artifact
    }) => {
      const artifactObject = _artifact.Artifact.from(artifact);

      this._forceVideo()._artifactReady(artifactObject);
    });

    this._channel.on('webSocket', ({
      webSocket
    }) => this.emit(_events.Events.Page.WebSocket, _network.WebSocket.from(webSocket)));

    this._channel.on('worker', ({
      worker
    }) => this._onWorker(_worker.Worker.from(worker)));

    this.coverage = new _coverage.Coverage(this._channel);
    this._closedOrCrashedPromise = Promise.race([new Promise(f => this.once(_events.Events.Page.Close, f)), new Promise(f => this.once(_events.Events.Page.Crash, f))]);
  }

  _onFrameAttached(frame) {
    frame._page = this;

    this._frames.add(frame);

    if (frame._parentFrame) frame._parentFrame._childFrames.add(frame);
    this.emit(_events.Events.Page.FrameAttached, frame);
  }

  _onFrameDetached(frame) {
    this._frames.delete(frame);

    frame._detached = true;
    if (frame._parentFrame) frame._parentFrame._childFrames.delete(frame);
    this.emit(_events.Events.Page.FrameDetached, frame);
  }

  async _onRoute(route, request) {
    const routeHandlers = this._routes.slice();

    for (const routeHandler of routeHandlers) {
      if (!routeHandler.matches(request.url())) continue;
      if (routeHandler.willExpire()) this._routes.splice(this._routes.indexOf(routeHandler), 1);
      const handled = await routeHandler.handle(route, request);
      if (!this._routes.length) this._wrapApiCall(() => this._disableInterception(), true).catch(() => {});
      if (handled) return;
    }

    await this._browserContext._onRoute(route, request);
  }

  async _onBinding(bindingCall) {
    const func = this._bindings.get(bindingCall._initializer.name);

    if (func) {
      await bindingCall.call(func);
      return;
    }

    await this._browserContext._onBinding(bindingCall);
  }

  _onWorker(worker) {
    this._workers.add(worker);

    worker._page = this;
    this.emit(_events.Events.Page.Worker, worker);
  }

  _onClose() {
    this._closed = true;

    this._browserContext._pages.delete(this);

    this._browserContext._backgroundPages.delete(this);

    this.emit(_events.Events.Page.Close, this);
  }

  _onCrash() {
    this.emit(_events.Events.Page.Crash, this);
  }

  context() {
    return this._browserContext;
  }

  async opener() {
    if (!this._opener || this._opener.isClosed()) return null;
    return this._opener;
  }

  mainFrame() {
    return this._mainFrame;
  }

  frame(frameSelector) {
    const name = (0, _utils.isString)(frameSelector) ? frameSelector : frameSelector.name;
    const url = (0, _utils.isObject)(frameSelector) ? frameSelector.url : undefined;
    (0, _utils.assert)(name || url, 'Either name or url matcher should be specified');
    return this.frames().find(f => {
      if (name) return f.name() === name;
      return (0, _netUtils.urlMatches)(this._browserContext._options.baseURL, f.url(), url);
    }) || null;
  }

  frames() {
    return [...this._frames];
  }

  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);

    this._wrapApiCall(async () => {
      this._channel.setDefaultNavigationTimeoutNoReply({
        timeout
      }).catch(() => {});
    }, true);
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);

    this._wrapApiCall(async () => {
      this._channel.setDefaultTimeoutNoReply({
        timeout
      }).catch(() => {});
    }, true);
  }

  _forceVideo() {
    if (!this._video) this._video = new _video.Video(this, this._connection);
    return this._video;
  }

  video() {
    // Note: we are creating Video object lazily, because we do not know
    // BrowserContextOptions when constructing the page - it is assigned
    // too late during launchPersistentContext.
    if (!this._browserContext._options.recordVideo) return null;
    return this._forceVideo();
  }

  async $(selector, options) {
    return this._mainFrame.$(selector, options);
  }

  async waitForSelector(selector, options) {
    return this._mainFrame.waitForSelector(selector, options);
  }

  async dispatchEvent(selector, type, eventInit, options) {
    return this._mainFrame.dispatchEvent(selector, type, eventInit, options);
  }

  async evaluateHandle(pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
    return this._mainFrame.evaluateHandle(pageFunction, arg);
  }

  async $eval(selector, pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
    return this._mainFrame.$eval(selector, pageFunction, arg);
  }

  async $$eval(selector, pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
    return this._mainFrame.$$eval(selector, pageFunction, arg);
  }

  async $$(selector) {
    return this._mainFrame.$$(selector);
  }

  async addScriptTag(options = {}) {
    return this._mainFrame.addScriptTag(options);
  }

  async addStyleTag(options = {}) {
    return this._mainFrame.addStyleTag(options);
  }

  async exposeFunction(name, callback) {
    await this._channel.exposeBinding({
      name
    });

    const binding = (source, ...args) => callback(...args);

    this._bindings.set(name, binding);
  }

  async exposeBinding(name, callback, options = {}) {
    await this._channel.exposeBinding({
      name,
      needsHandle: options.handle
    });

    this._bindings.set(name, callback);
  }

  async setExtraHTTPHeaders(headers) {
    (0, _network.validateHeaders)(headers);
    await this._channel.setExtraHTTPHeaders({
      headers: (0, _utils.headersObjectToArray)(headers)
    });
  }

  url() {
    return this._mainFrame.url();
  }

  async content() {
    return this._mainFrame.content();
  }

  async setContent(html, options) {
    return this._mainFrame.setContent(html, options);
  }

  async goto(url, options) {
    return this._mainFrame.goto(url, options);
  }

  async reload(options = {}) {
    const waitUntil = (0, _frame.verifyLoadState)('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    return _network.Response.fromNullable((await this._channel.reload({ ...options,
      waitUntil
    })).response);
  }

  async waitForLoadState(state, options) {
    return this._mainFrame.waitForLoadState(state, options);
  }

  async waitForNavigation(options) {
    return this._mainFrame.waitForNavigation(options);
  }

  async waitForURL(url, options) {
    return this._mainFrame.waitForURL(url, options);
  }

  async waitForRequest(urlOrPredicate, options = {}) {
    const predicate = request => {
      if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate)) return (0, _netUtils.urlMatches)(this._browserContext._options.baseURL, request.url(), urlOrPredicate);
      return urlOrPredicate(request);
    };

    const trimmedUrl = trimUrl(urlOrPredicate);
    const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : undefined;
    return this._waitForEvent(_events.Events.Page.Request, {
      predicate,
      timeout: options.timeout
    }, logLine);
  }

  async waitForResponse(urlOrPredicate, options = {}) {
    const predicate = response => {
      if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate)) return (0, _netUtils.urlMatches)(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
      return urlOrPredicate(response);
    };

    const trimmedUrl = trimUrl(urlOrPredicate);
    const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : undefined;
    return this._waitForEvent(_events.Events.Page.Response, {
      predicate,
      timeout: options.timeout
    }, logLine);
  }

  async waitForEvent(event, optionsOrPredicate = {}) {
    return this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
  }

  async _waitForEvent(event, optionsOrPredicate, logLine) {
    return this._wrapApiCall(async () => {
      const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === 'function' ? {} : optionsOrPredicate);

      const predicate = typeof optionsOrPredicate === 'function' ? optionsOrPredicate : optionsOrPredicate.predicate;

      const waiter = _waiter.Waiter.createForEvent(this, event);

      if (logLine) waiter.log(logLine);
      waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
      if (event !== _events.Events.Page.Crash) waiter.rejectOnEvent(this, _events.Events.Page.Crash, new Error('Page crashed'));
      if (event !== _events.Events.Page.Close) waiter.rejectOnEvent(this, _events.Events.Page.Close, new Error('Page closed'));
      const result = await waiter.waitForEvent(this, event, predicate);
      waiter.dispose();
      return result;
    });
  }

  async goBack(options = {}) {
    const waitUntil = (0, _frame.verifyLoadState)('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    return _network.Response.fromNullable((await this._channel.goBack({ ...options,
      waitUntil
    })).response);
  }

  async goForward(options = {}) {
    const waitUntil = (0, _frame.verifyLoadState)('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    return _network.Response.fromNullable((await this._channel.goForward({ ...options,
      waitUntil
    })).response);
  }

  async emulateMedia(options = {}) {
    await this._channel.emulateMedia({
      media: options.media === null ? 'null' : options.media,
      colorScheme: options.colorScheme === null ? 'null' : options.colorScheme,
      reducedMotion: options.reducedMotion === null ? 'null' : options.reducedMotion,
      forcedColors: options.forcedColors === null ? 'null' : options.forcedColors
    });
  }

  async setViewportSize(viewportSize) {
    this._viewportSize = viewportSize;
    await this._channel.setViewportSize({
      viewportSize
    });
  }

  viewportSize() {
    return this._viewportSize;
  }

  async evaluate(pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
    return this._mainFrame.evaluate(pageFunction, arg);
  }

  async addInitScript(script, arg) {
    const source = await (0, _clientHelper.evaluationScript)(script, arg);
    await this._channel.addInitScript({
      source
    });
  }

  async route(url, handler, options = {}) {
    this._routes.unshift(new _network.RouteHandler(this._browserContext._options.baseURL, url, handler, options.times));

    if (this._routes.length === 1) await this._channel.setNetworkInterceptionEnabled({
      enabled: true
    });
  }

  async routeFromHAR(har, options = {}) {
    if (options.update) {
      await this._browserContext._recordIntoHAR(har, this, options);
      return;
    }

    const harRouter = await _harRouter.HarRouter.create(this._connection.localUtils(), har, options.notFound || 'abort', {
      urlMatch: options.url
    });
    harRouter.addPageRoute(this);
  }

  async unroute(url, handler) {
    this._routes = this._routes.filter(route => route.url !== url || handler && route.handler !== handler);
    if (!this._routes.length) await this._disableInterception();
  }

  async _disableInterception() {
    await this._channel.setNetworkInterceptionEnabled({
      enabled: false
    });
  }

  async screenshot(options = {}) {
    const copy = { ...options,
      mask: undefined
    };
    if (!copy.type) copy.type = (0, _elementHandle.determineScreenshotType)(options);

    if (options.mask) {
      copy.mask = options.mask.map(locator => ({
        frame: locator._frame._channel,
        selector: locator._selector
      }));
    }

    const result = await this._channel.screenshot(copy);

    if (options.path) {
      await (0, _fileUtils.mkdirIfNeeded)(options.path);
      await _fs.default.promises.writeFile(options.path, result.binary);
    }

    return result.binary;
  }

  async _expectScreenshot(customStackTrace, options) {
    return this._wrapApiCall(async () => {
      var _options$screenshotOp, _options$screenshotOp2;

      const mask = (_options$screenshotOp = options.screenshotOptions) !== null && _options$screenshotOp !== void 0 && _options$screenshotOp.mask ? (_options$screenshotOp2 = options.screenshotOptions) === null || _options$screenshotOp2 === void 0 ? void 0 : _options$screenshotOp2.mask.map(locator => ({
        frame: locator._frame._channel,
        selector: locator._selector
      })) : undefined;
      const locator = options.locator ? {
        frame: options.locator._frame._channel,
        selector: options.locator._selector
      } : undefined;
      return await this._channel.expectScreenshot({ ...options,
        isNot: !!options.isNot,
        locator,
        screenshotOptions: { ...options.screenshotOptions,
          mask
        }
      });
    }, false
    /* isInternal */
    , customStackTrace);
  }

  async title() {
    return this._mainFrame.title();
  }

  async bringToFront() {
    await this._channel.bringToFront();
  }

  async close(options = {
    runBeforeUnload: undefined
  }) {
    try {
      if (this._ownedContext) await this._ownedContext.close();else await this._channel.close(options);
    } catch (e) {
      if ((0, _errors.isSafeCloseError)(e)) return;
      throw e;
    }
  }

  isClosed() {
    return this._closed;
  }

  async click(selector, options) {
    return this._mainFrame.click(selector, options);
  }

  async dragAndDrop(source, target, options) {
    return this._mainFrame.dragAndDrop(source, target, options);
  }

  async dblclick(selector, options) {
    return this._mainFrame.dblclick(selector, options);
  }

  async tap(selector, options) {
    return this._mainFrame.tap(selector, options);
  }

  async fill(selector, value, options) {
    return this._mainFrame.fill(selector, value, options);
  }

  locator(selector, options) {
    return this.mainFrame().locator(selector, options);
  }

  frameLocator(selector) {
    return this.mainFrame().frameLocator(selector);
  }

  async focus(selector, options) {
    return this._mainFrame.focus(selector, options);
  }

  async textContent(selector, options) {
    return this._mainFrame.textContent(selector, options);
  }

  async innerText(selector, options) {
    return this._mainFrame.innerText(selector, options);
  }

  async innerHTML(selector, options) {
    return this._mainFrame.innerHTML(selector, options);
  }

  async getAttribute(selector, name, options) {
    return this._mainFrame.getAttribute(selector, name, options);
  }

  async inputValue(selector, options) {
    return this._mainFrame.inputValue(selector, options);
  }

  async isChecked(selector, options) {
    return this._mainFrame.isChecked(selector, options);
  }

  async isDisabled(selector, options) {
    return this._mainFrame.isDisabled(selector, options);
  }

  async isEditable(selector, options) {
    return this._mainFrame.isEditable(selector, options);
  }

  async isEnabled(selector, options) {
    return this._mainFrame.isEnabled(selector, options);
  }

  async isHidden(selector, options) {
    return this._mainFrame.isHidden(selector, options);
  }

  async isVisible(selector, options) {
    return this._mainFrame.isVisible(selector, options);
  }

  async hover(selector, options) {
    return this._mainFrame.hover(selector, options);
  }

  async selectOption(selector, values, options) {
    return this._mainFrame.selectOption(selector, values, options);
  }

  async setInputFiles(selector, files, options) {
    return this._mainFrame.setInputFiles(selector, files, options);
  }

  async type(selector, text, options) {
    return this._mainFrame.type(selector, text, options);
  }

  async press(selector, key, options) {
    return this._mainFrame.press(selector, key, options);
  }

  async check(selector, options) {
    return this._mainFrame.check(selector, options);
  }

  async uncheck(selector, options) {
    return this._mainFrame.uncheck(selector, options);
  }

  async setChecked(selector, checked, options) {
    return this._mainFrame.setChecked(selector, checked, options);
  }

  async waitForTimeout(timeout) {
    return this._mainFrame.waitForTimeout(timeout);
  }

  async waitForFunction(pageFunction, arg, options) {
    return this._mainFrame.waitForFunction(pageFunction, arg, options);
  }

  workers() {
    return [...this._workers];
  }

  on(event, listener) {
    if (event === _events.Events.Page.FileChooser && !this.listenerCount(event)) this._channel.setFileChooserInterceptedNoReply({
      intercepted: true
    });
    super.on(event, listener);
    return this;
  }

  addListener(event, listener) {
    if (event === _events.Events.Page.FileChooser && !this.listenerCount(event)) this._channel.setFileChooserInterceptedNoReply({
      intercepted: true
    });
    super.addListener(event, listener);
    return this;
  }

  prependListener(event, listener) {
    if (event === _events.Events.Page.FileChooser && !this.listenerCount(event)) this._channel.setFileChooserInterceptedNoReply({
      intercepted: true
    });
    super.prependListener(event, listener);
    return this;
  }

  off(event, listener) {
    super.off(event, listener);
    if (event === _events.Events.Page.FileChooser && !this.listenerCount(event)) this._channel.setFileChooserInterceptedNoReply({
      intercepted: false
    });
    return this;
  }

  removeListener(event, listener) {
    super.removeListener(event, listener);
    if (event === _events.Events.Page.FileChooser && !this.listenerCount(event)) this._channel.setFileChooserInterceptedNoReply({
      intercepted: false
    });
    return this;
  }

  async pause() {
    if (!(__nccwpck_require__(1405).url)()) await this.context()._channel.pause();
  }

  async pdf(options = {}) {
    const transportOptions = { ...options
    };
    if (transportOptions.margin) transportOptions.margin = { ...transportOptions.margin
    };
    if (typeof options.width === 'number') transportOptions.width = options.width + 'px';
    if (typeof options.height === 'number') transportOptions.height = options.height + 'px';

    for (const margin of ['top', 'right', 'bottom', 'left']) {
      const index = margin;
      if (options.margin && typeof options.margin[index] === 'number') transportOptions.margin[index] = transportOptions.margin[index] + 'px';
    }

    const result = await this._channel.pdf(transportOptions);

    if (options.path) {
      await _fs.default.promises.mkdir(_path.default.dirname(options.path), {
        recursive: true
      });
      await _fs.default.promises.writeFile(options.path, result.pdf);
    }

    return result.pdf;
  }

}

exports.Page = Page;

class BindingCall extends _channelOwner.ChannelOwner {
  static from(channel) {
    return channel._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  async call(func) {
    try {
      const frame = _frame.Frame.from(this._initializer.frame);

      const source = {
        context: frame._page.context(),
        page: frame._page,
        frame
      };
      let result;
      if (this._initializer.handle) result = await func(source, _jsHandle.JSHandle.from(this._initializer.handle));else result = await func(source, ...this._initializer.args.map(_jsHandle.parseResult));

      this._channel.resolve({
        result: (0, _jsHandle.serializeArgument)(result)
      }).catch(() => {});
    } catch (e) {
      this._channel.reject({
        error: (0, _serializers.serializeError)(e)
      }).catch(() => {});
    }
  }

}

exports.BindingCall = BindingCall;

function trimEnd(s) {
  if (s.length > 50) s = s.substring(0, 50) + '\u2026';
  return s;
}

function trimUrl(param) {
  if ((0, _utils.isRegExp)(param)) return `/${trimEnd(param.source)}/${param.flags}`;
  if ((0, _utils.isString)(param)) return `"${trimEnd(param)}"`;
}

/***/ }),

/***/ 5983:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Playwright = void 0;

var _errors = __nccwpck_require__(542);

var _android = __nccwpck_require__(8068);

var _browserType = __nccwpck_require__(2450);

var _channelOwner = __nccwpck_require__(1578);

var _electron = __nccwpck_require__(1181);

var _fetch = __nccwpck_require__(3750);

var _selectors = __nccwpck_require__(6212);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Playwright extends _channelOwner.ChannelOwner {
  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._android = void 0;
    this._electron = void 0;
    this.chromium = void 0;
    this.firefox = void 0;
    this.webkit = void 0;
    this.devices = void 0;
    this.selectors = void 0;
    this.request = void 0;
    this.errors = void 0;
    this._socksProxyHandler = void 0;
    this.request = new _fetch.APIRequest(this);
    this.chromium = _browserType.BrowserType.from(initializer.chromium);
    this.chromium._playwright = this;
    this.firefox = _browserType.BrowserType.from(initializer.firefox);
    this.firefox._playwright = this;
    this.webkit = _browserType.BrowserType.from(initializer.webkit);
    this.webkit._playwright = this;
    this._android = _android.Android.from(initializer.android);
    this._electron = _electron.Electron.from(initializer.electron);
    this.devices = {};

    for (const {
      name,
      descriptor
    } of initializer.deviceDescriptors) this.devices[name] = descriptor;

    this.selectors = new _selectors.Selectors();
    this.errors = {
      TimeoutError: _errors.TimeoutError
    };

    const selectorsOwner = _selectors.SelectorsOwner.from(initializer.selectors);

    this.selectors._addChannel(selectorsOwner);

    this._connection.on('close', () => {
      var _this$_socksProxyHand;

      this.selectors._removeChannel(selectorsOwner);

      (_this$_socksProxyHand = this._socksProxyHandler) === null || _this$_socksProxyHand === void 0 ? void 0 : _this$_socksProxyHand.cleanup();
    });

    global._playwrightInstance = this;
  }

  async _hideHighlight() {
    await this._channel.hideHighlight();
  }

  _setSelectors(selectors) {
    const selectorsOwner = _selectors.SelectorsOwner.from(this._initializer.selectors);

    this.selectors._removeChannel(selectorsOwner);

    this.selectors = selectors;

    this.selectors._addChannel(selectorsOwner);
  }

  static from(channel) {
    return channel._object;
  }

}

exports.Playwright = Playwright;

/***/ }),

/***/ 6212:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SelectorsOwner = exports.Selectors = void 0;

var _clientHelper = __nccwpck_require__(6886);

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Selectors {
  constructor() {
    this._channels = new Set();
    this._registrations = [];
  }

  async register(name, script, options = {}) {
    const source = await (0, _clientHelper.evaluationScript)(script, undefined, false);
    const params = { ...options,
      name,
      source
    };

    for (const channel of this._channels) await channel._channel.register(params);

    this._registrations.push(params);
  }

  _addChannel(channel) {
    this._channels.add(channel);

    for (const params of this._registrations) {
      // This should not fail except for connection closure, but just in case we catch.
      channel._channel.register(params).catch(e => {});
    }
  }

  _removeChannel(channel) {
    this._channels.delete(channel);
  }

}

exports.Selectors = Selectors;

class SelectorsOwner extends _channelOwner.ChannelOwner {
  static from(browser) {
    return browser._object;
  }

}

exports.SelectorsOwner = SelectorsOwner;

/***/ }),

/***/ 8423:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Stream = void 0;

var _stream = __nccwpck_require__(2781);

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Stream extends _channelOwner.ChannelOwner {
  static from(Stream) {
    return Stream._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  stream() {
    return new StreamImpl(this._channel);
  }

}

exports.Stream = Stream;

class StreamImpl extends _stream.Readable {
  constructor(channel) {
    super();
    this._channel = void 0;
    this._channel = channel;
  }

  async _read(size) {
    const result = await this._channel.read({
      size
    });
    if (result.binary.byteLength) this.push(result.binary);else this.push(null);
  }

  _destroy(error, callback) {
    // Stream might be destroyed after the connection was closed.
    this._channel.close().catch(e => null);

    super._destroy(error, callback);
  }

}

/***/ }),

/***/ 2303:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Tracing = void 0;

var _artifact = __nccwpck_require__(5043);

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tracing extends _channelOwner.ChannelOwner {
  static from(channel) {
    return channel._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  async start(options = {}) {
    await this._wrapApiCall(async () => {
      await this._channel.tracingStart(options);
      await this._channel.tracingStartChunk({
        title: options.title
      });
    });
  }

  async startChunk(options = {}) {
    await this._channel.tracingStartChunk(options);
  }

  async stopChunk(options = {}) {
    await this._doStopChunk(options.path);
  }

  async stop(options = {}) {
    await this._wrapApiCall(async () => {
      await this._doStopChunk(options.path);
      await this._channel.tracingStop();
    });
  }

  async _doStopChunk(filePath) {
    var _result$sourceEntries;

    const isLocal = !this._connection.isRemote();
    let mode = 'doNotSave';

    if (filePath) {
      if (isLocal) mode = 'compressTraceAndSources';else mode = 'compressTrace';
    }

    const result = await this._channel.tracingStopChunk({
      mode
    });

    if (!filePath) {
      // Not interested in artifacts.
      return;
    } // The artifact may be missing if the browser closed while stopping tracing.


    if (!result.artifact) return; // Save trace to the final local file.

    const artifact = _artifact.Artifact.from(result.artifact);

    await artifact.saveAs(filePath);
    await artifact.delete(); // Add local sources to the remote trace if necessary.

    if ((_result$sourceEntries = result.sourceEntries) !== null && _result$sourceEntries !== void 0 && _result$sourceEntries.length) await this._connection.localUtils()._channel.zip({
      zipFile: filePath,
      entries: result.sourceEntries
    });
  }

}

exports.Tracing = Tracing;

/***/ }),

/***/ 7825:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.kLifecycleEvents = void 0;

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle', 'commit']);
exports.kLifecycleEvents = kLifecycleEvents;

/***/ }),

/***/ 4359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Video = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Video {
  constructor(page, connection) {
    this._artifact = null;

    this._artifactCallback = artifact => {};

    this._isRemote = false;
    this._isRemote = connection.isRemote();
    this._artifact = Promise.race([new Promise(f => this._artifactCallback = f), page._closedOrCrashedPromise.then(() => null)]);
  }

  _artifactReady(artifact) {
    this._artifactCallback(artifact);
  }

  async path() {
    if (this._isRemote) throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
    const artifact = await this._artifact;
    if (!artifact) throw new Error('Page did not produce any video frames');
    return artifact._initializer.absolutePath;
  }

  async saveAs(path) {
    const artifact = await this._artifact;
    if (!artifact) throw new Error('Page did not produce any video frames');
    return artifact.saveAs(path);
  }

  async delete() {
    const artifact = await this._artifact;
    if (artifact) await artifact.delete();
  }

}

exports.Video = Video;

/***/ }),

/***/ 1145:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Waiter = void 0;

var _stackTrace = __nccwpck_require__(9030);

var _errors = __nccwpck_require__(542);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Waiter {
  constructor(channelOwner, event) {
    this._dispose = void 0;
    this._failures = [];
    this._immediateError = void 0;
    this._logs = [];
    this._channelOwner = void 0;
    this._waitId = void 0;
    this._error = void 0;
    this._waitId = (0, _utils.createGuid)();
    this._channelOwner = channelOwner;

    this._channelOwner._channel.waitForEventInfo({
      info: {
        waitId: this._waitId,
        phase: 'before',
        event
      }
    }).catch(() => {});

    this._dispose = [() => this._channelOwner._wrapApiCall(async () => {
      await this._channelOwner._channel.waitForEventInfo({
        info: {
          waitId: this._waitId,
          phase: 'after',
          error: this._error
        }
      });
    }, true).catch(() => {})];
  }

  static createForEvent(channelOwner, event) {
    return new Waiter(channelOwner, event);
  }

  async waitForEvent(emitter, event, predicate) {
    const {
      promise,
      dispose
    } = waitForEvent(emitter, event, predicate);
    return this.waitForPromise(promise, dispose);
  }

  rejectOnEvent(emitter, event, error, predicate) {
    const {
      promise,
      dispose
    } = waitForEvent(emitter, event, predicate);

    this._rejectOn(promise.then(() => {
      throw error;
    }), dispose);
  }

  rejectOnTimeout(timeout, message) {
    if (!timeout) return;
    const {
      promise,
      dispose
    } = waitForTimeout(timeout);

    this._rejectOn(promise.then(() => {
      throw new _errors.TimeoutError(message);
    }), dispose);
  }

  rejectImmediately(error) {
    this._immediateError = error;
  }

  dispose() {
    for (const dispose of this._dispose) dispose();
  }

  async waitForPromise(promise, dispose) {
    try {
      if (this._immediateError) throw this._immediateError;
      const result = await Promise.race([promise, ...this._failures]);
      if (dispose) dispose();
      return result;
    } catch (e) {
      if (dispose) dispose();
      this._error = e.message;
      this.dispose();
      (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(this._logs));
      throw e;
    }
  }

  log(s) {
    this._logs.push(s);

    this._channelOwner._wrapApiCall(async () => {
      await this._channelOwner._channel.waitForEventInfo({
        info: {
          waitId: this._waitId,
          phase: 'log',
          message: s
        }
      }).catch(() => {});
    }, true);
  }

  _rejectOn(promise, dispose) {
    this._failures.push(promise);

    if (dispose) this._dispose.push(dispose);
  }

}

exports.Waiter = Waiter;

function waitForEvent(emitter, event, predicate) {
  let listener;
  const promise = new Promise((resolve, reject) => {
    listener = async eventArg => {
      try {
        if (predicate && !(await predicate(eventArg))) return;
        emitter.removeListener(event, listener);
        resolve(eventArg);
      } catch (e) {
        emitter.removeListener(event, listener);
        reject(e);
      }
    };

    emitter.addListener(event, listener);
  });

  const dispose = () => emitter.removeListener(event, listener);

  return {
    promise,
    dispose
  };
}

function waitForTimeout(timeout) {
  let timeoutId;
  const promise = new Promise(resolve => timeoutId = setTimeout(resolve, timeout));

  const dispose = () => clearTimeout(timeoutId);

  return {
    promise,
    dispose
  };
}

function formatLogRecording(log) {
  if (!log.length) return '';
  const header = ` logs `;
  const headerLength = 60;
  const leftLength = (headerLength - header.length) / 2;
  const rightLength = headerLength - header.length - leftLength;
  return `\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\n${log.join('\n')}\n${'='.repeat(headerLength)}`;
}

/***/ }),

/***/ 395:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Worker = void 0;

var _events = __nccwpck_require__(8289);

var _channelOwner = __nccwpck_require__(1578);

var _jsHandle = __nccwpck_require__(6594);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Worker extends _channelOwner.ChannelOwner {
  // Set for web workers.
  // Set for service workers.
  static from(worker) {
    return worker._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
    this._page = void 0;
    this._context = void 0;
    this._closedPromise = void 0;

    this._channel.on('close', () => {
      if (this._page) this._page._workers.delete(this);
      if (this._context) this._context._serviceWorkers.delete(this);
      this.emit(_events.Events.Worker.Close, this);
    });

    this._closedPromise = new Promise(f => this.once(_events.Events.Worker.Close, f));
  }

  url() {
    return this._initializer.url;
  }

  async evaluate(pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
    const result = await this._channel.evaluateExpression({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return (0, _jsHandle.parseResult)(result.value);
  }

  async evaluateHandle(pageFunction, arg) {
    (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
    const result = await this._channel.evaluateExpressionHandle({
      expression: String(pageFunction),
      isFunction: typeof pageFunction === 'function',
      arg: (0, _jsHandle.serializeArgument)(arg)
    });
    return _jsHandle.JSHandle.from(result.handle);
  }

}

exports.Worker = Worker;

/***/ }),

/***/ 4493:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WritableStream = void 0;

var _stream = __nccwpck_require__(2781);

var _channelOwner = __nccwpck_require__(1578);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WritableStream extends _channelOwner.ChannelOwner {
  static from(Stream) {
    return Stream._object;
  }

  constructor(parent, type, guid, initializer) {
    super(parent, type, guid, initializer);
  }

  stream() {
    return new WritableStreamImpl(this._channel);
  }

}

exports.WritableStream = WritableStream;

class WritableStreamImpl extends _stream.Writable {
  constructor(channel) {
    super();
    this._channel = void 0;
    this._channel = channel;
  }

  async _write(chunk, encoding, callback) {
    const error = await this._channel.write({
      binary: typeof chunk === 'string' ? Buffer.from(chunk) : chunk
    }).catch(e => e);
    callback(error || null);
  }

  async _final(callback) {
    // Stream might be destroyed after the connection was closed.
    const error = await this._channel.close().catch(e => e);
    callback(error || null);
  }

}

/***/ }),

/***/ 2003:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.debugLogger = exports.RecentLogsCollector = void 0;

var _utilsBundle = __nccwpck_require__(1319);

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const debugLoggerColorMap = {
  'api': 45,
  // cyan
  'protocol': 34,
  // green
  'install': 34,
  // green
  'download': 34,
  // green
  'browser': 0,
  // reset
  'proxy': 92,
  // purple
  'error': 160,
  // red,
  'channel:command': 33,
  // blue
  'channel:response': 202,
  // orange
  'channel:event': 207 // magenta

};

class DebugLogger {
  constructor() {
    this._debuggers = new Map();

    if (process.env.DEBUG_FILE) {
      const ansiRegex = new RegExp(['[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)', '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|'), 'g');

      const stream = _fs.default.createWriteStream(process.env.DEBUG_FILE);

      _utilsBundle.debug.log = data => {
        stream.write(data.replace(ansiRegex, ''));
        stream.write('\n');
      };
    }
  }

  log(name, message) {
    let cachedDebugger = this._debuggers.get(name);

    if (!cachedDebugger) {
      cachedDebugger = (0, _utilsBundle.debug)(`pw:${name}`);

      this._debuggers.set(name, cachedDebugger);

      cachedDebugger.color = debugLoggerColorMap[name];
    }

    cachedDebugger(message);
  }

  isEnabled(name) {
    return _utilsBundle.debug.enabled(`pw:${name}`);
  }

}

const debugLogger = new DebugLogger();
exports.debugLogger = debugLogger;
const kLogCount = 150;

class RecentLogsCollector {
  constructor() {
    this._logs = [];
  }

  log(message) {
    this._logs.push(message);

    if (this._logs.length === kLogCount * 2) this._logs.splice(0, kLogCount);
  }

  recentLogs() {
    if (this._logs.length > kLogCount) return this._logs.slice(-kLogCount);
    return this._logs;
  }

}

exports.RecentLogsCollector = RecentLogsCollector;

/***/ }),

/***/ 542:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TimeoutError = void 0;
exports.isSafeCloseError = isSafeCloseError;
exports.kBrowserOrContextClosedError = exports.kBrowserClosedError = void 0;

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }

}

class TimeoutError extends CustomError {}

exports.TimeoutError = TimeoutError;
const kBrowserClosedError = 'Browser has been closed';
exports.kBrowserClosedError = kBrowserClosedError;
const kBrowserOrContextClosedError = 'Target page, context or browser has been closed';
exports.kBrowserOrContextClosedError = kBrowserOrContextClosedError;

function isSafeCloseError(error) {
  return error.message.endsWith(kBrowserClosedError) || error.message.endsWith(kBrowserOrContextClosedError);
}

/***/ }),

/***/ 989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createSocket = createSocket;
exports.fetchData = fetchData;
exports.globToRegex = globToRegex;
exports.httpRequest = httpRequest;
exports.urlMatches = urlMatches;

var _http = _interopRequireDefault(__nccwpck_require__(3685));

var _https = _interopRequireDefault(__nccwpck_require__(5687));

var _net = _interopRequireDefault(__nccwpck_require__(1808));

var _utilsBundle = __nccwpck_require__(1319);

var URL = _interopRequireWildcard(__nccwpck_require__(7310));

var _utils = __nccwpck_require__(3557);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function createSocket(host, port) {
  return new Promise((resolve, reject) => {
    const socket = _net.default.createConnection({
      host,
      port
    });

    socket.on('connect', () => resolve(socket));
    socket.on('error', error => reject(error));
  });
}

function httpRequest(params, onResponse, onError) {
  const parsedUrl = URL.parse(params.url);
  let options = { ...parsedUrl
  };
  options.method = params.method || 'GET';
  options.headers = params.headers;
  const proxyURL = (0, _utilsBundle.getProxyForUrl)(params.url);

  if (proxyURL) {
    if (params.url.startsWith('http:')) {
      const proxy = URL.parse(proxyURL);
      options = {
        path: parsedUrl.href,
        host: proxy.hostname,
        port: proxy.port
      };
    } else {
      const parsedProxyURL = URL.parse(proxyURL);
      parsedProxyURL.secureProxy = parsedProxyURL.protocol === 'https:';
      options.agent = new _utilsBundle.HttpsProxyAgent(parsedProxyURL);
      options.rejectUnauthorized = false;
    }
  }

  const requestCallback = res => {
    const statusCode = res.statusCode || 0;
    if (statusCode >= 300 && statusCode < 400 && res.headers.location) httpRequest({ ...params,
      url: res.headers.location
    }, onResponse, onError);else onResponse(res);
  };

  const request = options.protocol === 'https:' ? _https.default.request(options, requestCallback) : _http.default.request(options, requestCallback);
  request.on('error', onError);

  if (params.timeout !== undefined) {
    const rejectOnTimeout = () => {
      onError(new Error(`Request to ${params.url} timed out after ${params.timeout}ms`));
      request.abort();
    };

    if (params.timeout <= 0) {
      rejectOnTimeout();
      return;
    }

    request.setTimeout(params.timeout, rejectOnTimeout);
  }

  request.end(params.data);
}

function fetchData(params, onError) {
  return new Promise((resolve, reject) => {
    httpRequest(params, async response => {
      if (response.statusCode !== 200) {
        const error = onError ? await onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
        reject(error);
        return;
      }

      let body = '';
      response.on('data', chunk => body += chunk);
      response.on('error', error => reject(error));
      response.on('end', () => resolve(body));
    }, reject);
  });
}

function urlMatches(baseURL, urlString, match) {
  if (match === undefined || match === '') return true;
  if ((0, _utils.isString)(match) && !match.startsWith('*')) match = (0, _utils.constructURLBasedOnBaseURL)(baseURL, match);
  if ((0, _utils.isString)(match)) match = globToRegex(match);
  if ((0, _utils.isRegExp)(match)) return match.test(urlString);
  if (typeof match === 'string' && match === urlString) return true;
  const url = parsedURL(urlString);
  if (!url) return false;
  if (typeof match === 'string') return url.pathname === match;
  if (typeof match !== 'function') throw new Error('url parameter should be string, RegExp or function');
  return match(url);
}

function parsedURL(url) {
  try {
    return new URL.URL(url);
  } catch (e) {
    return null;
  }
}

const escapeGlobChars = new Set(['/', '$', '^', '+', '.', '(', ')', '=', '!', '|']); // Note: this function is exported so it can be unit-tested.

function globToRegex(glob) {
  const tokens = ['^'];
  let inGroup;

  for (let i = 0; i < glob.length; ++i) {
    const c = glob[i];

    if (escapeGlobChars.has(c)) {
      tokens.push('\\' + c);
      continue;
    }

    if (c === '*') {
      const beforeDeep = glob[i - 1];
      let starCount = 1;

      while (glob[i + 1] === '*') {
        starCount++;
        i++;
      }

      const afterDeep = glob[i + 1];
      const isDeep = starCount > 1 && (beforeDeep === '/' || beforeDeep === undefined) && (afterDeep === '/' || afterDeep === undefined);

      if (isDeep) {
        tokens.push('((?:[^/]*(?:\/|$))*)');
        i++;
      } else {
        tokens.push('([^/]*)');
      }

      continue;
    }

    switch (c) {
      case '?':
        tokens.push('.');
        break;

      case '{':
        inGroup = true;
        tokens.push('(');
        break;

      case '}':
        inGroup = false;
        tokens.push(')');
        break;

      case ',':
        if (inGroup) {
          tokens.push('|');
          break;
        }

        tokens.push('\\' + c);
        break;

      default:
        tokens.push(c);
    }
  }

  tokens.push('$');
  return new RegExp(tokens.join(''));
}

/***/ }),

/***/ 1570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SocksProxyHandler = exports.SocksProxy = void 0;

var _dns = _interopRequireDefault(__nccwpck_require__(9523));

var _events = _interopRequireDefault(__nccwpck_require__(2361));

var _net = _interopRequireDefault(__nccwpck_require__(1808));

var _util = _interopRequireDefault(__nccwpck_require__(3837));

var _debugLogger = __nccwpck_require__(2003);

var _netUtils = __nccwpck_require__(989);

var _utils = __nccwpck_require__(3557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dnsLookupAsync = _util.default.promisify(_dns.default.lookup); // https://tools.ietf.org/html/rfc1928


var SocksAuth;

(function (SocksAuth) {
  SocksAuth[SocksAuth["NO_AUTHENTICATION_REQUIRED"] = 0] = "NO_AUTHENTICATION_REQUIRED";
  SocksAuth[SocksAuth["GSSAPI"] = 1] = "GSSAPI";
  SocksAuth[SocksAuth["USERNAME_PASSWORD"] = 2] = "USERNAME_PASSWORD";
  SocksAuth[SocksAuth["NO_ACCEPTABLE_METHODS"] = 255] = "NO_ACCEPTABLE_METHODS";
})(SocksAuth || (SocksAuth = {}));

var SocksAddressType;

(function (SocksAddressType) {
  SocksAddressType[SocksAddressType["IPv4"] = 1] = "IPv4";
  SocksAddressType[SocksAddressType["FqName"] = 3] = "FqName";
  SocksAddressType[SocksAddressType["IPv6"] = 4] = "IPv6";
})(SocksAddressType || (SocksAddressType = {}));

var SocksCommand;

(function (SocksCommand) {
  SocksCommand[SocksCommand["CONNECT"] = 1] = "CONNECT";
  SocksCommand[SocksCommand["BIND"] = 2] = "BIND";
  SocksCommand[SocksCommand["UDP_ASSOCIATE"] = 3] = "UDP_ASSOCIATE";
})(SocksCommand || (SocksCommand = {}));

var SocksReply;

(function (SocksReply) {
  SocksReply[SocksReply["Succeeded"] = 0] = "Succeeded";
  SocksReply[SocksReply["GeneralServerFailure"] = 1] = "GeneralServerFailure";
  SocksReply[SocksReply["NotAllowedByRuleSet"] = 2] = "NotAllowedByRuleSet";
  SocksReply[SocksReply["NetworkUnreachable"] = 3] = "NetworkUnreachable";
  SocksReply[SocksReply["HostUnreachable"] = 4] = "HostUnreachable";
  SocksReply[SocksReply["ConnectionRefused"] = 5] = "ConnectionRefused";
  SocksReply[SocksReply["TtlExpired"] = 6] = "TtlExpired";
  SocksReply[SocksReply["CommandNotSupported"] = 7] = "CommandNotSupported";
  SocksReply[SocksReply["AddressTypeNotSupported"] = 8] = "AddressTypeNotSupported";
})(SocksReply || (SocksReply = {}));

class SocksConnection {
  constructor(uid, socket, client) {
    this._buffer = Buffer.from([]);
    this._offset = 0;
    this._fence = 0;
    this._fenceCallback = void 0;
    this._socket = void 0;
    this._boundOnData = void 0;
    this._uid = void 0;
    this._client = void 0;
    this._uid = uid;
    this._socket = socket;
    this._client = client;
    this._boundOnData = this._onData.bind(this);
    socket.on('data', this._boundOnData);
    socket.on('close', () => this._onClose());
    socket.on('end', () => this._onClose());
    socket.on('error', () => this._onClose());

    this._run().catch(() => this._socket.end());
  }

  async _run() {
    (0, _utils.assert)(await this._authenticate());
    const {
      command,
      host,
      port
    } = await this._parseRequest();

    if (command !== SocksCommand.CONNECT) {
      this._writeBytes(Buffer.from([0x05, SocksReply.CommandNotSupported, 0x00, // RSV
      0x01, // IPv4
      0x00, 0x00, 0x00, 0x00, // Address
      0x00, 0x00 // Port
      ]));

      return;
    }

    this._socket.off('data', this._boundOnData);

    this._client.onSocketRequested({
      uid: this._uid,
      host,
      port
    });
  }

  async _authenticate() {
    // Request:
    // +----+----------+----------+
    // |VER | NMETHODS | METHODS  |
    // +----+----------+----------+
    // | 1  |    1     | 1 to 255 |
    // +----+----------+----------+
    // Response:
    // +----+--------+
    // |VER | METHOD |
    // +----+--------+
    // | 1  |   1    |
    // +----+--------+
    const version = await this._readByte();
    (0, _utils.assert)(version === 0x05, 'The VER field must be set to x05 for this version of the protocol, was ' + version);
    const nMethods = await this._readByte();
    (0, _utils.assert)(nMethods, 'No authentication methods specified');
    const methods = await this._readBytes(nMethods);

    for (const method of methods) {
      if (method === 0) {
        this._writeBytes(Buffer.from([version, method]));

        return true;
      }
    }

    this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));

    return false;
  }

  async _parseRequest() {
    // Request.
    // +----+-----+-------+------+----------+----------+
    // |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
    // +----+-----+-------+------+----------+----------+
    // | 1  |  1  | X'00' |  1   | Variable |    2     |
    // +----+-----+-------+------+----------+----------+
    // Response.
    // +----+-----+-------+------+----------+----------+
    // |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
    // +----+-----+-------+------+----------+----------+
    // | 1  |  1  | X'00' |  1   | Variable |    2     |
    // +----+-----+-------+------+----------+----------+
    const version = await this._readByte();
    (0, _utils.assert)(version === 0x05, 'The VER field must be set to x05 for this version of the protocol, was ' + version);
    const command = await this._readByte();
    await this._readByte(); // skip reserved.

    const addressType = await this._readByte();
    let host = '';

    switch (addressType) {
      case SocksAddressType.IPv4:
        host = (await this._readBytes(4)).join('.');
        break;

      case SocksAddressType.FqName:
        const length = await this._readByte();
        host = (await this._readBytes(length)).toString();
        break;

      case SocksAddressType.IPv6:
        const bytes = await this._readBytes(16);
        const tokens = [];

        for (let i = 0; i < 8; ++i) tokens.push(bytes.readUInt16BE(i * 2));

        host = tokens.join(':');
        break;
    }

    const port = (await this._readBytes(2)).readUInt16BE(0);
    this._buffer = Buffer.from([]);
    this._offset = 0;
    this._fence = 0;
    return {
      command,
      host,
      port
    };
  }

  async _readByte() {
    const buffer = await this._readBytes(1);
    return buffer[0];
  }

  async _readBytes(length) {
    this._fence = this._offset + length;
    if (!this._buffer || this._buffer.length < this._fence) await new Promise(f => this._fenceCallback = f);
    this._offset += length;
    return this._buffer.slice(this._offset - length, this._offset);
  }

  _writeBytes(buffer) {
    if (this._socket.writable) this._socket.write(buffer);
  }

  _onClose() {
    this._client.onSocketClosed({
      uid: this._uid
    });
  }

  _onData(buffer) {
    this._buffer = Buffer.concat([this._buffer, buffer]);

    if (this._fenceCallback && this._buffer.length >= this._fence) {
      const callback = this._fenceCallback;
      this._fenceCallback = undefined;
      callback();
    }
  }

  socketConnected(host, port) {
    this._writeBytes(Buffer.from([0x05, SocksReply.Succeeded, 0x00, // RSV
    0x01, // IPv4
    ...parseIP(host), // Address
    port << 8, port & 0xFF // Port
    ]));

    this._socket.on('data', data => this._client.onSocketData({
      uid: this._uid,
      data
    }));
  }

  socketFailed(errorCode) {
    const buffer = Buffer.from([0x05, 0, 0x00, // RSV
    0x01, // IPv4
    ...parseIP('0.0.0.0'), // Address
    0, 0 // Port
    ]);

    switch (errorCode) {
      case 'ENOENT':
      case 'ENOTFOUND':
      case 'ETIMEDOUT':
      case 'EHOSTUNREACH':
        buffer[1] = SocksReply.HostUnreachable;
        break;

      case 'ENETUNREACH':
        buffer[1] = SocksReply.NetworkUnreachable;
        break;

      case 'ECONNREFUSED':
        buffer[1] = SocksReply.ConnectionRefused;
        break;
    }

    this._writeBytes(buffer);

    this._socket.end();
  }

  sendData(data) {
    this._socket.write(data);
  }

  end() {
    this._socket.end();
  }

  error(error) {
    this._socket.destroy(new Error(error));
  }

}

function parseIP(address) {
  if (!_net.default.isIPv4(address)) throw new Error('IPv6 is not supported');
  return address.split('.', 4).map(t => +t);
}

class SocksProxy extends _events.default {
  constructor() {
    super();
    this._server = void 0;
    this._connections = new Map();
    this._server = new _net.default.Server(socket => {
      const uid = (0, _utils.createGuid)();
      const connection = new SocksConnection(uid, socket, this);

      this._connections.set(uid, connection);
    });
  }

  async listen(port) {
    return new Promise(f => {
      this._server.listen(port, () => {
        const port = this._server.address().port;

        _debugLogger.debugLogger.log('proxy', `Starting socks proxy server on port ${port}`);

        f(port);
      });
    });
  }

  async close() {
    await new Promise(f => this._server.close(f));
  }

  onSocketRequested(payload) {
    this.emit(SocksProxy.Events.SocksRequested, payload);
  }

  onSocketData(payload) {
    this.emit(SocksProxy.Events.SocksData, payload);
  }

  onSocketClosed(payload) {
    this.emit(SocksProxy.Events.SocksClosed, payload);
  }

  socketConnected({
    uid,
    host,
    port
  }) {
    var _this$_connections$ge;

    (_this$_connections$ge = this._connections.get(uid)) === null || _this$_connections$ge === void 0 ? void 0 : _this$_connections$ge.socketConnected(host, port);
  }

  socketFailed({
    uid,
    errorCode
  }) {
    var _this$_connections$ge2;

    (_this$_connections$ge2 = this._connections.get(uid)) === null || _this$_connections$ge2 === void 0 ? void 0 : _this$_connections$ge2.socketFailed(errorCode);
  }

  sendSocketData({
    uid,
    data
  }) {
    var _this$_connections$ge3;

    (_this$_connections$ge3 = this._connections.get(uid)) === null || _this$_connections$ge3 === void 0 ? void 0 : _this$_connections$ge3.sendData(data);
  }

  sendSocketEnd({
    uid
  }) {
    var _this$_connections$ge4;

    (_this$_connections$ge4 = this._connections.get(uid)) === null || _this$_connections$ge4 === void 0 ? void 0 : _this$_connections$ge4.end();
  }

  sendSocketError({
    uid,
    error
  }) {
    var _this$_connections$ge5;

    (_this$_connections$ge5 = this._connections.get(uid)) === null || _this$_connections$ge5 === void 0 ? void 0 : _this$_connections$ge5.error(error);
  }

}

exports.SocksProxy = SocksProxy;
SocksProxy.Events = {
  SocksRequested: 'socksRequested',
  SocksData: 'socksData',
  SocksClosed: 'socksClosed'
};

class SocksProxyHandler extends _events.default {
  constructor(redirectPortForTest) {
    super();
    this._sockets = new Map();
    this._redirectPortForTest = void 0;
    this._redirectPortForTest = redirectPortForTest;
  }

  cleanup() {
    for (const uid of this._sockets.keys()) this.socketClosed({
      uid
    });
  }

  async socketRequested({
    uid,
    host,
    port
  }) {
    if (host === 'local.playwright') host = '127.0.0.1'; // Node.js 17 does resolve localhost to ipv6

    if (host === 'localhost') host = '127.0.0.1';

    try {
      if (this._redirectPortForTest) port = this._redirectPortForTest;
      const {
        address
      } = await dnsLookupAsync(host);
      const socket = await (0, _netUtils.createSocket)(address, port);
      socket.on('data', data => {
        const payload = {
          uid,
          data
        };
        this.emit(SocksProxyHandler.Events.SocksData, payload);
      });
      socket.on('error', error => {
        const payload = {
          uid,
          error: error.message
        };
        this.emit(SocksProxyHandler.Events.SocksError, payload);

        this._sockets.delete(uid);
      });
      socket.on('end', () => {
        const payload = {
          uid
        };
        this.emit(SocksProxyHandler.Events.SocksEnd, payload);

        this._sockets.delete(uid);
      });
      const localAddress = socket.localAddress;
      const localPort = socket.localPort;

      this._sockets.set(uid, socket);

      const payload = {
        uid,
        host: localAddress,
        port: localPort
      };
      this.emit(SocksProxyHandler.Events.SocksConnected, payload);
    } catch (error) {
      const payload = {
        uid,
        errorCode: error.code
      };
      this.emit(SocksProxyHandler.Events.SocksFailed, payload);
    }
  }

  sendSocketData({
    uid,
    data
  }) {
    var _this$_sockets$get;

    (_this$_sockets$get = this._sockets.get(uid)) === null || _this$_sockets$get === void 0 ? void 0 : _this$_sockets$get.write(data);
  }

  socketClosed({
    uid
  }) {
    var _this$_sockets$get2;

    (_this$_sockets$get2 = this._sockets.get(uid)) === null || _this$_sockets$get2 === void 0 ? void 0 : _this$_sockets$get2.destroy();

    this._sockets.delete(uid);
  }

}

exports.SocksProxyHandler = SocksProxyHandler;
SocksProxyHandler.Events = {
  SocksConnected: 'socksConnected',
  SocksData: 'socksData',
  SocksError: 'socksError',
  SocksFailed: 'socksFailed',
  SocksEnd: 'socksEnd'
};

/***/ }),

/***/ 9053:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TimeoutSettings = exports.DEFAULT_TIMEOUT = exports.DEFAULT_LAUNCH_TIMEOUT = void 0;

var _utils = __nccwpck_require__(3557);

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_TIMEOUT = 30000;
exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
const DEFAULT_LAUNCH_TIMEOUT = 3 * 60 * 1000; // 3 minutes

exports.DEFAULT_LAUNCH_TIMEOUT = DEFAULT_LAUNCH_TIMEOUT;

class TimeoutSettings {
  constructor(parent) {
    this._parent = void 0;
    this._defaultTimeout = void 0;
    this._defaultNavigationTimeout = void 0;
    this._parent = parent;
  }

  setDefaultTimeout(timeout) {
    this._defaultTimeout = timeout;
  }

  setDefaultNavigationTimeout(timeout) {
    this._defaultNavigationTimeout = timeout;
  }

  navigationTimeout(options) {
    if (typeof options.timeout === 'number') return options.timeout;
    if (this._defaultNavigationTimeout !== undefined) return this._defaultNavigationTimeout;
    if ((0, _utils.debugMode)()) return 0;
    if (this._defaultTimeout !== undefined) return this._defaultTimeout;
    if (this._parent) return this._parent.navigationTimeout(options);
    return DEFAULT_TIMEOUT;
  }

  timeout(options) {
    if (typeof options.timeout === 'number') return options.timeout;
    if ((0, _utils.debugMode)()) return 0;
    if (this._defaultTimeout !== undefined) return this._defaultTimeout;
    if (this._parent) return this._parent.timeout(options);
    return DEFAULT_TIMEOUT;
  }

  static timeout(options) {
    if (typeof options.timeout === 'number') return options.timeout;
    if ((0, _utils.debugMode)()) return 0;
    return DEFAULT_TIMEOUT;
  }

  static launchTimeout(options) {
    if (typeof options.timeout === 'number') return options.timeout;
    if ((0, _utils.debugMode)()) return 0;
    return DEFAULT_LAUNCH_TIMEOUT;
  }

}

exports.TimeoutSettings = TimeoutSettings;

/***/ }),

/***/ 5110:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getClientLanguage = getClientLanguage;
exports.getPlaywrightVersion = getPlaywrightVersion;
exports.getUserAgent = getUserAgent;

var _child_process = __nccwpck_require__(2081);

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _linuxUtils = __nccwpck_require__(1665);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let cachedUserAgent;

function getUserAgent() {
  if (cachedUserAgent) return cachedUserAgent;

  try {
    cachedUserAgent = determineUserAgent();
  } catch (e) {
    cachedUserAgent = 'Playwright/unknown';
  }

  return cachedUserAgent;
}

function determineUserAgent() {
  let osIdentifier = 'unknown';
  let osVersion = 'unknown';

  if (process.platform === 'win32') {
    const version = _os.default.release().split('.');

    osIdentifier = 'windows';
    osVersion = `${version[0]}.${version[1]}`;
  } else if (process.platform === 'darwin') {
    const version = (0, _child_process.execSync)('sw_vers -productVersion', {
      stdio: ['ignore', 'pipe', 'ignore']
    }).toString().trim().split('.');
    osIdentifier = 'macOS';
    osVersion = `${version[0]}.${version[1]}`;
  } else if (process.platform === 'linux') {
    const distroInfo = (0, _linuxUtils.getLinuxDistributionInfoSync)();

    if (distroInfo) {
      osIdentifier = distroInfo.id || 'linux';
      osVersion = distroInfo.version || 'unknown';
    } else {
      // Linux distribution without /etc/os-release.
      // Default to linux/unknown.
      osIdentifier = 'linux';
    }
  }

  const additionalTokens = [];
  if (process.env.CI) additionalTokens.push('CI/1');
  const serializedTokens = additionalTokens.length ? ' ' + additionalTokens.join(' ') : '';
  const {
    langName,
    langVersion
  } = getClientLanguage();
  return `Playwright/${getPlaywrightVersion()} (${_os.default.arch()}; ${osIdentifier} ${osVersion}) ${langName}/${langVersion}${serializedTokens}`;
}

function getClientLanguage() {
  let langName = 'unknown';
  let langVersion = 'unknown';

  if (!process.env.PW_LANG_NAME) {
    langName = 'node';
    langVersion = process.version.substring(1).split('.').slice(0, 2).join('.');
  } else if (['node', 'python', 'java', 'csharp'].includes(process.env.PW_LANG_NAME)) {
    var _process$env$PW_LANG_;

    langName = process.env.PW_LANG_NAME;
    langVersion = (_process$env$PW_LANG_ = process.env.PW_LANG_NAME_VERSION) !== null && _process$env$PW_LANG_ !== void 0 ? _process$env$PW_LANG_ : 'unknown';
  }

  return {
    langName,
    langVersion
  };
}

function getPlaywrightVersion(majorMinorOnly = false) {
  const packageJson = __nccwpck_require__(9415);

  return majorMinorOnly ? packageJson.version.split('.').slice(0, 2).join('.') : packageJson.version;
}

/***/ }),

/***/ 4989:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.source = void 0;
const source = "\"use strict\";\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = \"'\") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\\"/g, '\"');\n  if (char === \"'\")\n    return char + escapedText.replace(/[']/g, \"\\\\'\") + char;\n  if (char === '\"')\n    return char + escapedText.replace(/[\"]/g, '\\\\\"') + char;\n  if (char === \"`\")\n    return char + escapedText.replace(/[`]/g, \"`\") + char;\n  throw new Error(\"Invalid escape char\");\n}\n\n// packages/playwright-core/src/server/injected/selectorUtils.ts\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === \"SCRIPT\" || element.nodeName === \"NOSCRIPT\" || element.nodeName === \"STYLE\" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: \"\", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = \"\";\n      if (root instanceof HTMLInputElement && (root.type === \"submit\" || root.type === \"button\")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || \"\";\n            currentImmediate += child.nodeValue || \"\";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = \"\";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kNthScore = 1e3;\nfunction generateSelector(injectedScript, targetElement, strict) {\n  injectedScript._evaluator.begin();\n  try {\n    targetElement = targetElement.closest(\"button,select,input,[role=button],[role=checkbox],[role=radio]\") || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, strict);\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement, strict);\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== \"/\");\n}\nfunction generateSelectorFor(injectedScript, targetElement, strict) {\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: \"css\", selector: \"html\", score: 1 }];\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map((token) => [token]) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildCandidates(injectedScript, element).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch, strict);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch, strict);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n  for (const attribute of [\"data-testid\", \"data-test-id\", \"data-test\"]) {\n    if (element.getAttribute(attribute))\n      candidates.push({ engine: \"css\", selector: `[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: 1 });\n  }\n  if (element.nodeName === \"INPUT\") {\n    const input = element;\n    if (input.placeholder)\n      candidates.push({ engine: \"css\", selector: `[placeholder=${quoteAttributeValue(input.placeholder)}]`, score: 10 });\n  }\n  if (element.getAttribute(\"aria-label\"))\n    candidates.push({ engine: \"css\", selector: `[aria-label=${quoteAttributeValue(element.getAttribute(\"aria-label\"))}]`, score: 10 });\n  if (element.getAttribute(\"alt\") && [\"APPLET\", \"AREA\", \"IMG\", \"INPUT\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[alt=${quoteAttributeValue(element.getAttribute(\"alt\"))}]`, score: 10 });\n  if (element.getAttribute(\"role\"))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[role=${quoteAttributeValue(element.getAttribute(\"role\"))}]`, score: 50 });\n  if (element.getAttribute(\"name\") && [\"BUTTON\", \"FORM\", \"FIELDSET\", \"FRAME\", \"IFRAME\", \"INPUT\", \"KEYGEN\", \"OBJECT\", \"OUTPUT\", \"SELECT\", \"TEXTAREA\", \"MAP\", \"META\", \"PARAM\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute(\"name\"))}]`, score: 50 });\n  if ([\"INPUT\", \"TEXTAREA\"].includes(element.nodeName) && element.getAttribute(\"type\") !== \"hidden\") {\n    if (element.getAttribute(\"type\"))\n      candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute(\"type\"))}]`, score: 50 });\n  }\n  if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: 50 });\n  const idAttr = element.getAttribute(\"id\");\n  if (idAttr && !isGuidLike(idAttr))\n    candidates.push({ engine: \"css\", selector: makeSelectorForId(idAttr), score: 100 });\n  candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: 200 });\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === \"SELECT\")\n    return [];\n  const text = elementText(injectedScript._evaluator._cacheText, element).full.trim().replace(/\\s+/g, \" \").substring(0, 80);\n  if (!text)\n    return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes('\"') || text.includes(\">>\") || text[0] === \"/\")\n    escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({ engine: \"text\", selector: escaped, score: 10 });\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLowerCase();\n    if (element.hasAttribute(\"role\"))\n      prefix += `[role=${quoteAttributeValue(element.getAttribute(\"role\"))}]`;\n    candidates.push({ engine: \"css\", selector: `${prefix}:has-text(\"${text}\")`, score: 30 });\n  }\n  return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n    return element.parentNode.host;\n  return null;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? \"#\" + id : `[id=\"${cssEscape(id)}\"]`;\n}\nfunction cssFallback(injectedScript, targetElement, strict) {\n  const kFallbackScore = 1e7;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(\" > \");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: \"css\", selector, score: kFallbackScore };\n    if (!strict)\n      return [token];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: \"nth\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = \"\";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = \".\" + cssEscape(classes.slice(0, i + 1).join(\".\"));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction quoteAttributeValue(text) {\n  return `\"${cssEscape(text).replace(/\\\\ /g, \" \")}\"`;\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = \"\";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== \"css\" || engine !== \"css\" || selector.startsWith(\":nth-match(\")))\n      parts.push(\">>\");\n    lastEngine = engine;\n    if (engine === \"css\")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(\" \");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch, strict) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const isStrictEnough = !strict || result.length === 1;\n    const index = result.indexOf(targetElement);\n    if (index === 0 && isStrictEnough) {\n      return tokens;\n    }\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: \"nth\", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === \"-\" || c === \"_\")\n      continue;\n    if (c >= \"a\" && c <= \"z\")\n      characterType = \"lower\";\n    else if (c >= \"A\" && c <= \"Z\")\n      characterType = \"upper\";\n    else if (c >= \"0\" && c <= \"9\")\n      characterType = \"digit\";\n    else\n      characterType = \"other\";\n    if (characterType === \"lower\" && lastCharacterType === \"upper\") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction cssEscape(s) {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return \"\\uFFFD\";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return \"\\\\\" + c.toString(16) + \" \";\n  if (i === 0 && c === 45 && s.length === 1)\n    return \"\\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return \"\\\\\" + s.charAt(i);\n}\n\n// packages/playwright-core/src/server/injected/consoleApi.ts\nfunction createLocator(injectedScript, initial, options) {\n  class Locator {\n    constructor(selector, options2) {\n      this.selector = selector;\n      if (options2 == null ? void 0 : options2.hasText) {\n        const text = options2.hasText;\n        if (text instanceof RegExp)\n          this.selector += ` >> :scope:text-matches(${escapeWithQuotes(text.source, '\"')}, \"${text.flags}\")`;\n        else\n          this.selector += ` >> :scope:has-text(${escapeWithQuotes(text)})`;\n      }\n      if (options2 == null ? void 0 : options2.has)\n        this.selector += ` >> has=` + JSON.stringify(options2.has.selector);\n      const parsed = injectedScript.parseSelector(this.selector);\n      this.element = injectedScript.querySelector(parsed, document, false);\n      this.elements = injectedScript.querySelectorAll(parsed, document);\n    }\n    locator(selector, options2) {\n      return new Locator(this.selector ? this.selector + \" >> \" + selector : selector, options2);\n    }\n  }\n  return new Locator(initial, options);\n}\nvar ConsoleAPI = class {\n  constructor(injectedScript) {\n    this._injectedScript = injectedScript;\n    if (window.playwright)\n      return;\n    window.playwright = {\n      $: (selector, strict) => this._querySelector(selector, !!strict),\n      $$: (selector) => this._querySelectorAll(selector),\n      locator: (selector, options) => createLocator(this._injectedScript, selector, options),\n      inspect: (selector) => this._inspect(selector),\n      selector: (element) => this._selector(element),\n      resume: () => this._resume()\n    };\n  }\n  _querySelector(selector, strict) {\n    if (typeof selector !== \"string\")\n      throw new Error(`Usage: playwright.query('Playwright >> selector').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelector(parsed, document, strict);\n  }\n  _querySelectorAll(selector) {\n    if (typeof selector !== \"string\")\n      throw new Error(`Usage: playwright.$$('Playwright >> selector').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelectorAll(parsed, document);\n  }\n  _inspect(selector) {\n    if (typeof selector !== \"string\")\n      throw new Error(`Usage: playwright.inspect('Playwright >> selector').`);\n    window.inspect(this._querySelector(selector, false));\n  }\n  _selector(element) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.selector(element).`);\n    return generateSelector(this._injectedScript, element, true).selector;\n  }\n  _resume() {\n    window.__pw_resume().catch(() => {\n    });\n  }\n};\nmodule.exports = ConsoleAPI;\n";
exports.source = source;

/***/ }),

/***/ 6390:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.source = void 0;
const source = "\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target, mod));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.js\nvar require_cssTokenizer = __commonJS({\n  \"packages/playwright-core/src/server/isomorphic/cssTokenizer.js\"(exports) {\n    \"use strict\";\n    var between = function(num, first, last) {\n      return num >= first && num <= last;\n    };\n    function digit(code) {\n      return between(code, 48, 57);\n    }\n    function hexdigit(code) {\n      return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n    }\n    function uppercaseletter(code) {\n      return between(code, 65, 90);\n    }\n    function lowercaseletter(code) {\n      return between(code, 97, 122);\n    }\n    function letter(code) {\n      return uppercaseletter(code) || lowercaseletter(code);\n    }\n    function nonascii(code) {\n      return code >= 128;\n    }\n    function namestartchar(code) {\n      return letter(code) || nonascii(code) || code == 95;\n    }\n    function namechar(code) {\n      return namestartchar(code) || digit(code) || code == 45;\n    }\n    function nonprintable(code) {\n      return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;\n    }\n    function newline(code) {\n      return code == 10;\n    }\n    function whitespace(code) {\n      return newline(code) || code == 9 || code == 32;\n    }\n    var maximumallowedcodepoint = 1114111;\n    var InvalidCharacterError = function(message) {\n      this.message = message;\n    };\n    InvalidCharacterError.prototype = new Error();\n    InvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n    function preprocess(str) {\n      var codepoints = [];\n      for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        if (code == 13 && str.charCodeAt(i + 1) == 10) {\n          code = 10;\n          i++;\n        }\n        if (code == 13 || code == 12)\n          code = 10;\n        if (code == 0)\n          code = 65533;\n        if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n          var lead = code - 55296;\n          var trail = str.charCodeAt(i + 1) - 56320;\n          code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n          i++;\n        }\n        codepoints.push(code);\n      }\n      return codepoints;\n    }\n    function stringFromCode(code) {\n      if (code <= 65535)\n        return String.fromCharCode(code);\n      code -= Math.pow(2, 16);\n      var lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n      var trail = code % Math.pow(2, 10) + 56320;\n      return String.fromCharCode(lead) + String.fromCharCode(trail);\n    }\n    function tokenize2(str) {\n      str = preprocess(str);\n      var i = -1;\n      var tokens = [];\n      var code;\n      var line = 0;\n      var column = 0;\n      var lastLineLength = 0;\n      var incrLineno = function() {\n        line += 1;\n        lastLineLength = column;\n        column = 0;\n      };\n      var locStart = { line, column };\n      var codepoint = function(i2) {\n        if (i2 >= str.length) {\n          return -1;\n        }\n        return str[i2];\n      };\n      var next = function(num) {\n        if (num === void 0)\n          num = 1;\n        if (num > 3)\n          throw \"Spec Error: no more than three codepoints of lookahead.\";\n        return codepoint(i + num);\n      };\n      var consume = function(num) {\n        if (num === void 0)\n          num = 1;\n        i += num;\n        code = codepoint(i);\n        if (newline(code))\n          incrLineno();\n        else\n          column += num;\n        return true;\n      };\n      var reconsume = function() {\n        i -= 1;\n        if (newline(code)) {\n          line -= 1;\n          column = lastLineLength;\n        } else {\n          column -= 1;\n        }\n        locStart.line = line;\n        locStart.column = column;\n        return true;\n      };\n      var eof = function(codepoint2) {\n        if (codepoint2 === void 0)\n          codepoint2 = code;\n        return codepoint2 == -1;\n      };\n      var donothing = function() {\n      };\n      var parseerror = function() {\n        console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");\n        return true;\n      };\n      var consumeAToken = function() {\n        consumeComments();\n        consume();\n        if (whitespace(code)) {\n          while (whitespace(next()))\n            consume();\n          return new WhitespaceToken2();\n        } else if (code == 34)\n          return consumeAStringToken();\n        else if (code == 35) {\n          if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n            var token = new HashToken2();\n            if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n              token.type = \"id\";\n            token.value = consumeAName();\n            return token;\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 36) {\n          if (next() == 61) {\n            consume();\n            return new SuffixMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 39)\n          return consumeAStringToken();\n        else if (code == 40)\n          return new OpenParenToken();\n        else if (code == 41)\n          return new CloseParenToken2();\n        else if (code == 42) {\n          if (next() == 61) {\n            consume();\n            return new SubstringMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 43) {\n          if (startsWithANumber()) {\n            reconsume();\n            return consumeANumericToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 44)\n          return new CommaToken2();\n        else if (code == 45) {\n          if (startsWithANumber()) {\n            reconsume();\n            return consumeANumericToken();\n          } else if (next(1) == 45 && next(2) == 62) {\n            consume(2);\n            return new CDCToken2();\n          } else if (startsWithAnIdentifier()) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 46) {\n          if (startsWithANumber()) {\n            reconsume();\n            return consumeANumericToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 58)\n          return new ColonToken2();\n        else if (code == 59)\n          return new SemicolonToken2();\n        else if (code == 60) {\n          if (next(1) == 33 && next(2) == 45 && next(3) == 45) {\n            consume(3);\n            return new CDOToken2();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 64) {\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n            return new AtKeywordToken2(consumeAName());\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 91)\n          return new OpenSquareToken2();\n        else if (code == 92) {\n          if (startsWithAValidEscape()) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else {\n            parseerror();\n            return new DelimToken2(code);\n          }\n        } else if (code == 93)\n          return new CloseSquareToken2();\n        else if (code == 94) {\n          if (next() == 61) {\n            consume();\n            return new PrefixMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 123)\n          return new OpenCurlyToken2();\n        else if (code == 124) {\n          if (next() == 61) {\n            consume();\n            return new DashMatchToken();\n          } else if (next() == 124) {\n            consume();\n            return new ColumnToken2();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 125)\n          return new CloseCurlyToken2();\n        else if (code == 126) {\n          if (next() == 61) {\n            consume();\n            return new IncludeMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (digit(code)) {\n          reconsume();\n          return consumeANumericToken();\n        } else if (namestartchar(code)) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else if (eof())\n          return new EOFToken2();\n        else\n          return new DelimToken2(code);\n      };\n      var consumeComments = function() {\n        while (next(1) == 47 && next(2) == 42) {\n          consume(2);\n          while (true) {\n            consume();\n            if (code == 42 && next() == 47) {\n              consume();\n              break;\n            } else if (eof()) {\n              parseerror();\n              return;\n            }\n          }\n        }\n      };\n      var consumeANumericToken = function() {\n        var num = consumeANumber();\n        if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n          var token = new DimensionToken();\n          token.value = num.value;\n          token.repr = num.repr;\n          token.type = num.type;\n          token.unit = consumeAName();\n          return token;\n        } else if (next() == 37) {\n          consume();\n          var token = new PercentageToken2();\n          token.value = num.value;\n          token.repr = num.repr;\n          return token;\n        } else {\n          var token = new NumberToken2();\n          token.value = num.value;\n          token.repr = num.repr;\n          token.type = num.type;\n          return token;\n        }\n      };\n      var consumeAnIdentlikeToken = function() {\n        var str2 = consumeAName();\n        if (str2.toLowerCase() == \"url\" && next() == 40) {\n          consume();\n          while (whitespace(next(1)) && whitespace(next(2)))\n            consume();\n          if (next() == 34 || next() == 39) {\n            return new FunctionToken2(str2);\n          } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {\n            return new FunctionToken2(str2);\n          } else {\n            return consumeAURLToken();\n          }\n        } else if (next() == 40) {\n          consume();\n          return new FunctionToken2(str2);\n        } else {\n          return new IdentToken2(str2);\n        }\n      };\n      var consumeAStringToken = function(endingCodePoint) {\n        if (endingCodePoint === void 0)\n          endingCodePoint = code;\n        var string = \"\";\n        while (consume()) {\n          if (code == endingCodePoint || eof()) {\n            return new StringToken2(string);\n          } else if (newline(code)) {\n            parseerror();\n            reconsume();\n            return new BadStringToken2();\n          } else if (code == 92) {\n            if (eof(next())) {\n              donothing();\n            } else if (newline(next())) {\n              consume();\n            } else {\n              string += stringFromCode(consumeEscape());\n            }\n          } else {\n            string += stringFromCode(code);\n          }\n        }\n      };\n      var consumeAURLToken = function() {\n        var token = new URLToken2(\"\");\n        while (whitespace(next()))\n          consume();\n        if (eof(next()))\n          return token;\n        while (consume()) {\n          if (code == 41 || eof()) {\n            return token;\n          } else if (whitespace(code)) {\n            while (whitespace(next()))\n              consume();\n            if (next() == 41 || eof(next())) {\n              consume();\n              return token;\n            } else {\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            }\n          } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {\n            parseerror();\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken2();\n          } else if (code == 92) {\n            if (startsWithAValidEscape()) {\n              token.value += stringFromCode(consumeEscape());\n            } else {\n              parseerror();\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            }\n          } else {\n            token.value += stringFromCode(code);\n          }\n        }\n      };\n      var consumeEscape = function() {\n        consume();\n        if (hexdigit(code)) {\n          var digits = [code];\n          for (var total = 0; total < 5; total++) {\n            if (hexdigit(next())) {\n              consume();\n              digits.push(code);\n            } else {\n              break;\n            }\n          }\n          if (whitespace(next()))\n            consume();\n          var value = parseInt(digits.map(function(x) {\n            return String.fromCharCode(x);\n          }).join(\"\"), 16);\n          if (value > maximumallowedcodepoint)\n            value = 65533;\n          return value;\n        } else if (eof()) {\n          return 65533;\n        } else {\n          return code;\n        }\n      };\n      var areAValidEscape = function(c1, c2) {\n        if (c1 != 92)\n          return false;\n        if (newline(c2))\n          return false;\n        return true;\n      };\n      var startsWithAValidEscape = function() {\n        return areAValidEscape(code, next());\n      };\n      var wouldStartAnIdentifier = function(c1, c2, c3) {\n        if (c1 == 45) {\n          return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);\n        } else if (namestartchar(c1)) {\n          return true;\n        } else if (c1 == 92) {\n          return areAValidEscape(c1, c2);\n        } else {\n          return false;\n        }\n      };\n      var startsWithAnIdentifier = function() {\n        return wouldStartAnIdentifier(code, next(1), next(2));\n      };\n      var wouldStartANumber = function(c1, c2, c3) {\n        if (c1 == 43 || c1 == 45) {\n          if (digit(c2))\n            return true;\n          if (c2 == 46 && digit(c3))\n            return true;\n          return false;\n        } else if (c1 == 46) {\n          if (digit(c2))\n            return true;\n          return false;\n        } else if (digit(c1)) {\n          return true;\n        } else {\n          return false;\n        }\n      };\n      var startsWithANumber = function() {\n        return wouldStartANumber(code, next(1), next(2));\n      };\n      var consumeAName = function() {\n        var result = \"\";\n        while (consume()) {\n          if (namechar(code)) {\n            result += stringFromCode(code);\n          } else if (startsWithAValidEscape()) {\n            result += stringFromCode(consumeEscape());\n          } else {\n            reconsume();\n            return result;\n          }\n        }\n      };\n      var consumeANumber = function() {\n        var repr = [];\n        var type = \"integer\";\n        if (next() == 43 || next() == 45) {\n          consume();\n          repr += stringFromCode(code);\n        }\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n        if (next(1) == 46 && digit(next(2))) {\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          type = \"number\";\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n        }\n        var c1 = next(1), c2 = next(2), c3 = next(3);\n        if ((c1 == 69 || c1 == 101) && digit(c2)) {\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          type = \"number\";\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n        } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          type = \"number\";\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n        }\n        var value = convertAStringToANumber(repr);\n        return { type, value, repr };\n      };\n      var convertAStringToANumber = function(string) {\n        return +string;\n      };\n      var consumeTheRemnantsOfABadURL = function() {\n        while (consume()) {\n          if (code == 41 || eof()) {\n            return;\n          } else if (startsWithAValidEscape()) {\n            consumeEscape();\n            donothing();\n          } else {\n            donothing();\n          }\n        }\n      };\n      var iterationCount = 0;\n      while (!eof(next())) {\n        tokens.push(consumeAToken());\n        iterationCount++;\n        if (iterationCount > str.length * 2)\n          return \"I'm infinite-looping!\";\n      }\n      return tokens;\n    }\n    function CSSParserToken() {\n      throw \"Abstract Base Class\";\n    }\n    CSSParserToken.prototype.toJSON = function() {\n      return { token: this.tokenType };\n    };\n    CSSParserToken.prototype.toString = function() {\n      return this.tokenType;\n    };\n    CSSParserToken.prototype.toSource = function() {\n      return \"\" + this;\n    };\n    function BadStringToken2() {\n      return this;\n    }\n    BadStringToken2.prototype = Object.create(CSSParserToken.prototype);\n    BadStringToken2.prototype.tokenType = \"BADSTRING\";\n    function BadURLToken2() {\n      return this;\n    }\n    BadURLToken2.prototype = Object.create(CSSParserToken.prototype);\n    BadURLToken2.prototype.tokenType = \"BADURL\";\n    function WhitespaceToken2() {\n      return this;\n    }\n    WhitespaceToken2.prototype = Object.create(CSSParserToken.prototype);\n    WhitespaceToken2.prototype.tokenType = \"WHITESPACE\";\n    WhitespaceToken2.prototype.toString = function() {\n      return \"WS\";\n    };\n    WhitespaceToken2.prototype.toSource = function() {\n      return \" \";\n    };\n    function CDOToken2() {\n      return this;\n    }\n    CDOToken2.prototype = Object.create(CSSParserToken.prototype);\n    CDOToken2.prototype.tokenType = \"CDO\";\n    CDOToken2.prototype.toSource = function() {\n      return \"<!--\";\n    };\n    function CDCToken2() {\n      return this;\n    }\n    CDCToken2.prototype = Object.create(CSSParserToken.prototype);\n    CDCToken2.prototype.tokenType = \"CDC\";\n    CDCToken2.prototype.toSource = function() {\n      return \"-->\";\n    };\n    function ColonToken2() {\n      return this;\n    }\n    ColonToken2.prototype = Object.create(CSSParserToken.prototype);\n    ColonToken2.prototype.tokenType = \":\";\n    function SemicolonToken2() {\n      return this;\n    }\n    SemicolonToken2.prototype = Object.create(CSSParserToken.prototype);\n    SemicolonToken2.prototype.tokenType = \";\";\n    function CommaToken2() {\n      return this;\n    }\n    CommaToken2.prototype = Object.create(CSSParserToken.prototype);\n    CommaToken2.prototype.tokenType = \",\";\n    function GroupingToken() {\n      throw \"Abstract Base Class\";\n    }\n    GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n    function OpenCurlyToken2() {\n      this.value = \"{\";\n      this.mirror = \"}\";\n      return this;\n    }\n    OpenCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n    OpenCurlyToken2.prototype.tokenType = \"{\";\n    function CloseCurlyToken2() {\n      this.value = \"}\";\n      this.mirror = \"{\";\n      return this;\n    }\n    CloseCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n    CloseCurlyToken2.prototype.tokenType = \"}\";\n    function OpenSquareToken2() {\n      this.value = \"[\";\n      this.mirror = \"]\";\n      return this;\n    }\n    OpenSquareToken2.prototype = Object.create(GroupingToken.prototype);\n    OpenSquareToken2.prototype.tokenType = \"[\";\n    function CloseSquareToken2() {\n      this.value = \"]\";\n      this.mirror = \"[\";\n      return this;\n    }\n    CloseSquareToken2.prototype = Object.create(GroupingToken.prototype);\n    CloseSquareToken2.prototype.tokenType = \"]\";\n    function OpenParenToken() {\n      this.value = \"(\";\n      this.mirror = \")\";\n      return this;\n    }\n    OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n    OpenParenToken.prototype.tokenType = \"(\";\n    function CloseParenToken2() {\n      this.value = \")\";\n      this.mirror = \"(\";\n      return this;\n    }\n    CloseParenToken2.prototype = Object.create(GroupingToken.prototype);\n    CloseParenToken2.prototype.tokenType = \")\";\n    function IncludeMatchToken() {\n      return this;\n    }\n    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    IncludeMatchToken.prototype.tokenType = \"~=\";\n    function DashMatchToken() {\n      return this;\n    }\n    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    DashMatchToken.prototype.tokenType = \"|=\";\n    function PrefixMatchToken() {\n      return this;\n    }\n    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    PrefixMatchToken.prototype.tokenType = \"^=\";\n    function SuffixMatchToken() {\n      return this;\n    }\n    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SuffixMatchToken.prototype.tokenType = \"$=\";\n    function SubstringMatchToken() {\n      return this;\n    }\n    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SubstringMatchToken.prototype.tokenType = \"*=\";\n    function ColumnToken2() {\n      return this;\n    }\n    ColumnToken2.prototype = Object.create(CSSParserToken.prototype);\n    ColumnToken2.prototype.tokenType = \"||\";\n    function EOFToken2() {\n      return this;\n    }\n    EOFToken2.prototype = Object.create(CSSParserToken.prototype);\n    EOFToken2.prototype.tokenType = \"EOF\";\n    EOFToken2.prototype.toSource = function() {\n      return \"\";\n    };\n    function DelimToken2(code) {\n      this.value = stringFromCode(code);\n      return this;\n    }\n    DelimToken2.prototype = Object.create(CSSParserToken.prototype);\n    DelimToken2.prototype.tokenType = \"DELIM\";\n    DelimToken2.prototype.toString = function() {\n      return \"DELIM(\" + this.value + \")\";\n    };\n    DelimToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      return json;\n    };\n    DelimToken2.prototype.toSource = function() {\n      if (this.value == \"\\\\\")\n        return \"\\\\\\n\";\n      else\n        return this.value;\n    };\n    function StringValuedToken() {\n      throw \"Abstract Base Class\";\n    }\n    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n    StringValuedToken.prototype.ASCIIMatch = function(str) {\n      return this.value.toLowerCase() == str.toLowerCase();\n    };\n    StringValuedToken.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      return json;\n    };\n    function IdentToken2(val) {\n      this.value = val;\n    }\n    IdentToken2.prototype = Object.create(StringValuedToken.prototype);\n    IdentToken2.prototype.tokenType = \"IDENT\";\n    IdentToken2.prototype.toString = function() {\n      return \"IDENT(\" + this.value + \")\";\n    };\n    IdentToken2.prototype.toSource = function() {\n      return escapeIdent(this.value);\n    };\n    function FunctionToken2(val) {\n      this.value = val;\n      this.mirror = \")\";\n    }\n    FunctionToken2.prototype = Object.create(StringValuedToken.prototype);\n    FunctionToken2.prototype.tokenType = \"FUNCTION\";\n    FunctionToken2.prototype.toString = function() {\n      return \"FUNCTION(\" + this.value + \")\";\n    };\n    FunctionToken2.prototype.toSource = function() {\n      return escapeIdent(this.value) + \"(\";\n    };\n    function AtKeywordToken2(val) {\n      this.value = val;\n    }\n    AtKeywordToken2.prototype = Object.create(StringValuedToken.prototype);\n    AtKeywordToken2.prototype.tokenType = \"AT-KEYWORD\";\n    AtKeywordToken2.prototype.toString = function() {\n      return \"AT(\" + this.value + \")\";\n    };\n    AtKeywordToken2.prototype.toSource = function() {\n      return \"@\" + escapeIdent(this.value);\n    };\n    function HashToken2(val) {\n      this.value = val;\n      this.type = \"unrestricted\";\n    }\n    HashToken2.prototype = Object.create(StringValuedToken.prototype);\n    HashToken2.prototype.tokenType = \"HASH\";\n    HashToken2.prototype.toString = function() {\n      return \"HASH(\" + this.value + \")\";\n    };\n    HashToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      return json;\n    };\n    HashToken2.prototype.toSource = function() {\n      if (this.type == \"id\") {\n        return \"#\" + escapeIdent(this.value);\n      } else {\n        return \"#\" + escapeHash(this.value);\n      }\n    };\n    function StringToken2(val) {\n      this.value = val;\n    }\n    StringToken2.prototype = Object.create(StringValuedToken.prototype);\n    StringToken2.prototype.tokenType = \"STRING\";\n    StringToken2.prototype.toString = function() {\n      return '\"' + escapeString(this.value) + '\"';\n    };\n    function URLToken2(val) {\n      this.value = val;\n    }\n    URLToken2.prototype = Object.create(StringValuedToken.prototype);\n    URLToken2.prototype.tokenType = \"URL\";\n    URLToken2.prototype.toString = function() {\n      return \"URL(\" + this.value + \")\";\n    };\n    URLToken2.prototype.toSource = function() {\n      return 'url(\"' + escapeString(this.value) + '\")';\n    };\n    function NumberToken2() {\n      this.value = null;\n      this.type = \"integer\";\n      this.repr = \"\";\n    }\n    NumberToken2.prototype = Object.create(CSSParserToken.prototype);\n    NumberToken2.prototype.tokenType = \"NUMBER\";\n    NumberToken2.prototype.toString = function() {\n      if (this.type == \"integer\")\n        return \"INT(\" + this.value + \")\";\n      return \"NUMBER(\" + this.value + \")\";\n    };\n    NumberToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      json.repr = this.repr;\n      return json;\n    };\n    NumberToken2.prototype.toSource = function() {\n      return this.repr;\n    };\n    function PercentageToken2() {\n      this.value = null;\n      this.repr = \"\";\n    }\n    PercentageToken2.prototype = Object.create(CSSParserToken.prototype);\n    PercentageToken2.prototype.tokenType = \"PERCENTAGE\";\n    PercentageToken2.prototype.toString = function() {\n      return \"PERCENTAGE(\" + this.value + \")\";\n    };\n    PercentageToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.repr = this.repr;\n      return json;\n    };\n    PercentageToken2.prototype.toSource = function() {\n      return this.repr + \"%\";\n    };\n    function DimensionToken() {\n      this.value = null;\n      this.type = \"integer\";\n      this.repr = \"\";\n      this.unit = \"\";\n    }\n    DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\n    DimensionToken.prototype.toString = function() {\n      return \"DIM(\" + this.value + \",\" + this.unit + \")\";\n    };\n    DimensionToken.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      json.repr = this.repr;\n      json.unit = this.unit;\n      return json;\n    };\n    DimensionToken.prototype.toSource = function() {\n      var source = this.repr;\n      var unit = escapeIdent(this.unit);\n      if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 48, 57))) {\n        unit = \"\\\\65 \" + unit.slice(1, unit.length);\n      }\n      return source + unit;\n    };\n    function escapeIdent(string) {\n      string = \"\" + string;\n      var result = \"\";\n      var firstcode = string.charCodeAt(0);\n      for (var i = 0; i < string.length; i++) {\n        var code = string.charCodeAt(i);\n        if (code == 0) {\n          throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n        }\n        if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {\n          result += \"\\\\\" + code.toString(16) + \" \";\n        } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n          result += string[i];\n        } else {\n          result += \"\\\\\" + string[i];\n        }\n      }\n      return result;\n    }\n    function escapeHash(string) {\n      string = \"\" + string;\n      var result = \"\";\n      var firstcode = string.charCodeAt(0);\n      for (var i = 0; i < string.length; i++) {\n        var code = string.charCodeAt(i);\n        if (code == 0) {\n          throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n        }\n        if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n          result += string[i];\n        } else {\n          result += \"\\\\\" + code.toString(16) + \" \";\n        }\n      }\n      return result;\n    }\n    function escapeString(string) {\n      string = \"\" + string;\n      var result = \"\";\n      for (var i = 0; i < string.length; i++) {\n        var code = string.charCodeAt(i);\n        if (code == 0) {\n          throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n        }\n        if (between(code, 1, 31) || code == 127) {\n          result += \"\\\\\" + code.toString(16) + \" \";\n        } else if (code == 34 || code == 92) {\n          result += \"\\\\\" + string[i];\n        } else {\n          result += string[i];\n        }\n      }\n      return result;\n    }\n    exports.tokenize = tokenize2;\n    exports.IdentToken = IdentToken2;\n    exports.FunctionToken = FunctionToken2;\n    exports.AtKeywordToken = AtKeywordToken2;\n    exports.HashToken = HashToken2;\n    exports.StringToken = StringToken2;\n    exports.BadStringToken = BadStringToken2;\n    exports.URLToken = URLToken2;\n    exports.BadURLToken = BadURLToken2;\n    exports.DelimToken = DelimToken2;\n    exports.NumberToken = NumberToken2;\n    exports.PercentageToken = PercentageToken2;\n    exports.DimensionToken = DimensionToken;\n    exports.IncludeMatchToken = IncludeMatchToken;\n    exports.DashMatchToken = DashMatchToken;\n    exports.PrefixMatchToken = PrefixMatchToken;\n    exports.SuffixMatchToken = SuffixMatchToken;\n    exports.SubstringMatchToken = SubstringMatchToken;\n    exports.ColumnToken = ColumnToken2;\n    exports.WhitespaceToken = WhitespaceToken2;\n    exports.CDOToken = CDOToken2;\n    exports.CDCToken = CDCToken2;\n    exports.ColonToken = ColonToken2;\n    exports.SemicolonToken = SemicolonToken2;\n    exports.CommaToken = CommaToken2;\n    exports.OpenParenToken = OpenParenToken;\n    exports.CloseParenToken = CloseParenToken2;\n    exports.OpenSquareToken = OpenSquareToken2;\n    exports.CloseSquareToken = CloseSquareToken2;\n    exports.OpenCurlyToken = OpenCurlyToken2;\n    exports.CloseCurlyToken = CloseCurlyToken2;\n    exports.EOFToken = EOFToken2;\n    exports.CSSParserToken = CSSParserToken;\n    exports.GroupingToken = GroupingToken;\n  }\n});\n\n// packages/playwright-core/src/server/injected/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/server/injected/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith(\"/\"))\n      selector = \".\" + selector;\n    const result = [];\n    const document2 = root instanceof Document ? root : root.ownerDocument;\n    if (!document2)\n      return result;\n    const it = document2.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/playwright-core/src/server/injected/domUtils.ts\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css2) {\n  while (element) {\n    const closest = element.closest(css2);\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction isElementVisible(element) {\n  if (!element.ownerDocument || !element.ownerDocument.defaultView)\n    return true;\n  const style = element.ownerDocument.defaultView.getComputedStyle(element);\n  if (!style || style.visibility === \"hidden\")\n    return false;\n  if (style.display === \"contents\") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isElementVisible(child))\n        return true;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return true;\n    }\n    return false;\n  }\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction isVisibleTextNode(node) {\n  const range = document.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\n\n// packages/playwright-core/src/server/injected/selectorUtils.ts\nfunction matchesComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttributePart(obj, attr);\n}\nfunction matchesAttributePart(value, attr) {\n  const objValue = typeof value === \"string\" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === \"string\" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === \"<truthy>\")\n    return !!objValue;\n  if (attr.op === \"=\") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === \"string\" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== \"string\" || typeof attrValue !== \"string\")\n    return false;\n  if (attr.op === \"*=\")\n    return objValue.includes(attrValue);\n  if (attr.op === \"^=\")\n    return objValue.startsWith(attrValue);\n  if (attr.op === \"$=\")\n    return objValue.endsWith(attrValue);\n  if (attr.op === \"|=\")\n    return objValue === attrValue || objValue.startsWith(attrValue + \"-\");\n  if (attr.op === \"~=\")\n    return objValue.split(\" \").includes(attrValue);\n  return false;\n}\nfunction createLaxTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, \" \").toLowerCase();\n  return (elementText2) => {\n    const s = elementText2.full.trim().replace(/\\s+/g, \" \").toLowerCase();\n    return s.includes(text);\n  };\n}\nfunction createStrictTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, \" \");\n  return (elementText2) => {\n    if (!text && !elementText2.immediate.length)\n      return true;\n    return elementText2.immediate.some((s) => s.trim().replace(/\\s+/g, \" \") === text);\n  };\n}\nfunction createRegexTextMatcher(source, flags) {\n  const re = new RegExp(source, flags);\n  return (elementText2) => {\n    return re.test(elementText2.full);\n  };\n}\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === \"SCRIPT\" || element.nodeName === \"NOSCRIPT\" || element.nodeName === \"STYLE\" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: \"\", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = \"\";\n      if (root instanceof HTMLInputElement && (root.type === \"submit\" || root.type === \"button\")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || \"\";\n            currentImmediate += child.nodeValue || \"\";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = \"\";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(cache, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return \"none\";\n  if (!matcher(elementText(cache, element)))\n    return \"none\";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(cache, child)))\n      return \"selfAndChildren\";\n  }\n  if (element.shadowRoot && matcher(elementText(cache, element.shadowRoot)))\n    return \"selfAndChildren\";\n  return \"self\";\n}\n\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\nvar css = __toESM(require_cssTokenizer());\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = css.tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof css.EOFToken))\n      tokens.push(new css.EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector \"${selector}\"`;\n    const index = (e.stack || \"\").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || token instanceof css.URLToken || token instanceof css.PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token \"${unsupportedToken.toSource()}\" while parsing selector \"${selector}\"`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token \"${tokens[pos].toSource()}\" while parsing selector \"${selector}\"`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof css.WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof css.IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof css.StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof css.NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof css.CommaToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof css.CloseParenToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof css.DelimToken && tokens[p].value === \"*\";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof css.EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof css.DelimToken && [\">\", \"+\", \"~\"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: \"scope\", args: [] }] }, combinator: \"\" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: \"\" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: \"\", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = \"\";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === \".\") {\n        pos++;\n        if (isIdent())\n          rawCSSString += \".\" + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof css.ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += \":\" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof css.FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof css.OpenSquareToken) {\n        rawCSSString += \"[\";\n        pos++;\n        while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof css.CloseSquareToken))\n          throw unexpected();\n        rawCSSString += \"]\";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = \"\";\n    while (!isCloseParen() && !isEOF())\n      s += tokens[pos++].toSource();\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw new InvalidSelectorError(`Error while parsing selector \"${selector}\"`);\n  if (result.some((arg) => typeof arg !== \"object\" || !(\"simples\" in arg)))\n    throw new InvalidSelectorError(`Error while parsing selector \"${selector}\"`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/server/isomorphic/selectorParser.ts\nvar kNestedSelectorNames = /* @__PURE__ */ new Set([\"has\", \"left-of\", \"right-of\", \"above\", \"below\", \"near\"]);\nvar kNestedSelectorNamesWithDistance = /* @__PURE__ */ new Set([\"left-of\", \"right-of\", \"above\", \"below\", \"near\"]);\nvar customCSSNames = /* @__PURE__ */ new Set([\"not\", \"is\", \"where\", \"has\", \"scope\", \"light\", \"visible\", \"text\", \"text-matches\", \"text-is\", \"has-text\", \"above\", \"below\", \"right-of\", \"left-of\", \"near\", \"nth-match\"]);\nfunction parseSelector(selector) {\n  const result = parseSelectorString(selector);\n  const parts = result.parts.map((part) => {\n    if (part.name === \"css\" || part.name === \"css:light\") {\n      if (part.name === \"css:light\")\n        part.body = \":light(\" + part.body + \")\";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      return {\n        name: \"css\",\n        body: parsedCSS.selector,\n        source: part.body\n      };\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      let distance;\n      try {\n        const unescaped = JSON.parse(\"[\" + part.body + \"]\");\n        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== \"string\")\n          throw new Error(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped[0];\n        if (unescaped.length === 2) {\n          if (typeof unescaped[1] !== \"number\" || !kNestedSelectorNamesWithDistance.has(part.name))\n            throw new Error(`Malformed selector: ${part.name}=` + part.body);\n          distance = unescaped[1];\n        }\n      } catch (e) {\n        throw new Error(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const result2 = { name: part.name, source: part.body, body: { parsed: parseSelector(innerSelector), distance } };\n      if (result2.body.parsed.parts.some((part2) => part2.name === \"control\" && part2.body === \"enter-frame\"))\n        throw new Error(`Frames are not allowed inside \"${part.name}\" selectors`);\n      return result2;\n    }\n    return { ...part, source: part.body };\n  });\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new Error(`\"${parts[0].name}\" selector cannot be first`);\n  return {\n    capture: result.capture,\n    parts\n  };\n}\nfunction stringifySelector(selector) {\n  if (typeof selector === \"string\")\n    return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === \"css\" ? \"\" : p.name + \"=\";\n    return `${i === selector.capture ? \"*\" : \"\"}${prefix}${p.source}`;\n  }).join(\" >> \");\n}\nfunction allEngineNames(selector) {\n  const result = /* @__PURE__ */ new Set();\n  const visit = (selector2) => {\n    for (const part of selector2.parts) {\n      result.add(part.name);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body.parsed);\n    }\n  };\n  visit(selector);\n  return result;\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf(\"=\");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === '\"' && part[part.length - 1] === '\"') {\n      name = \"text\";\n      body = part;\n    } else if (part.length > 1 && part[0] === \"'\" && part[part.length - 1] === \"'\") {\n      name = \"text\";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith(\"..\")) {\n      name = \"xpath\";\n      body = part;\n    } else {\n      name = \"css\";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === \"*\") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(\">>\")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === \"\\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === '\"' || c === \"'\" || c === \"`\") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === \">\" && selector[index + 1] === \">\") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\nfunction parseAttributeSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || \"\";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new Error(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new Error(`Error while parsing selector \\`${selector}\\` - unexpected symbol \"${next()}\" at position ${wp}` + (stage ? \" during \" + stage : \"\"));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= \"\\x80\" || char >= \"0\" && char <= \"9\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\" || char >= \"0\" && char <= \"9\" || char === \"_\" || char === \"-\";\n  }\n  function readIdentifier() {\n    let result2 = \"\";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError(\"parsing quoted string\");\n    while (!EOL && next() !== quote) {\n      if (next() === \"\\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError(\"parsing quoted string\");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== \"/\")\n      syntaxError(\"parsing regular expression\");\n    let source = \"\";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === \"\\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError(\"parsing regular expressiion\");\n      } else if (inClass && next() === \"]\") {\n        inClass = false;\n      } else if (!inClass && next() === \"[\") {\n        inClass = true;\n      } else if (!inClass && next() === \"/\") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== \"/\")\n      syntaxError(\"parsing regular expression\");\n    let flags = \"\";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new Error(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = \"\";\n    skipSpaces();\n    if (next() === `'` || next() === `\"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError(\"parsing property path\");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = \"\";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== \"=\")\n      op += eat1();\n    if (![\"=\", \"*=\", \"^=\", \"$=\", \"|=\", \"~=\"].includes(op))\n      syntaxError(\"parsing operator\");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === \".\") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === \"]\") {\n      eat1();\n      return { name: jsonPath.join(\".\"), jsonPath, op: \"<truthy>\", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === \"/\") {\n      if (operator !== \"=\")\n        throw new Error(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `'` || next() === `\"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === \"i\" || next() === \"I\") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === \"s\" || next() === \"S\") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = \"\";\n      while (!EOL && (isCSSNameChar(next()) || next() === \"+\" || next() === \".\"))\n        value += eat1();\n      if (value === \"true\") {\n        value = true;\n      } else if (value === \"false\") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError(\"parsing attribute value\");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== \"]\")\n      syntaxError(\"parsing attribute value\");\n    eat1();\n    if (operator !== \"=\" && typeof value !== \"string\")\n      throw new Error(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join(\".\"), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: \"\",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === \"[\") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new Error(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/reactSelectorEngine.ts\nfunction getComponentName(reactElement) {\n  if (typeof reactElement.type === \"function\")\n    return reactElement.type.displayName || reactElement.type.name || \"Anonymous\";\n  if (typeof reactElement.type === \"string\")\n    return reactElement.type;\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === \"string\")\n      return elementType;\n    if (typeof elementType === \"function\")\n      return elementType.displayName || elementType.name || \"Anonymous\";\n  }\n  return \"\";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === \"function\" || typeof elementType === \"string\";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = reactElement.memoizedProps || ((_a = reactElement._currentElement) == null ? void 0 : _a.props);\n  if (!props || typeof props === \"string\")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = reactElement.stateNode || reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode);\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    const rootKey = Object.keys(node).find((key) => key.startsWith(\"__reactContainer\"));\n    if (rootKey) {\n      roots.push(node[rootKey].stateNode.current);\n    } else if (node.hasOwnProperty(\"_reactRootContainer\")) {\n      roots.push(node._reactRootContainer._internalRoot.current);\n    }\n    if (node instanceof Element && node.hasAttribute(\"data-reactroot\")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith(\"__reactInternalInstance\") || key.startsWith(\"__reactFiber\"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar ReactEngine = {\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const reactRoots = findReactRoots(document);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n};\n\n// packages/playwright-core/src/server/injected/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, \"\").replace(/\\\\/g, \"/\");\n  let result = normalized.substring(normalized.lastIndexOf(\"/\") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : \"\";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, \".vue\"));\n  }\n  function saveComponentName(instance2, key) {\n    instance2.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance2) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance2.type || {});\n    if (name)\n      return name;\n    if (instance2.root === instance2)\n      return \"Root\";\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components)\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\n        return saveComponentName(instance2, key);\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components)\n      if (instance2.appContext.components[key] === instance2.type)\n        return saveComponentName(instance2, key);\n    return \"Anonymous Component\";\n  }\n  function isBeingDestroyed(instance2) {\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\n  }\n  function isFragment(instance2) {\n    return instance2.subTree.type.toString() === \"Symbol(Fragment)\";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance2) {\n    if (isFragment(instance2))\n      return getFragmentRootElements(instance2.subTree);\n    return [instance2.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance2),\n      props: instance2.props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction buildComponentsTreeVue2(instance) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, \".vue\"));\n  }\n  function getInstanceName(instance2) {\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\n    if (name)\n      return name;\n    return instance2.$root === instance2 ? \"Root\" : \"Anonymous Component\";\n  }\n  function getInternalInstanceChildren(instance2) {\n    if (instance2.$children)\n      return instance2.$children;\n    if (Array.isArray(instance2.subTree.children))\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\n      rootElements: [instance2.$el],\n      props: instance2._props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = /* @__PURE__ */ new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar VueEngine = {\n  queryAll(scope, selector) {\n    const { name, attributes } = parseAttributeSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!matchesComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n};\n\n// packages/playwright-core/src/server/injected/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute(\"aria-label\") || e.hasAttribute(\"aria-labelledby\");\n}\nvar kAncestorPreventingLandmark = \"article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]\";\nvar kGlobalAriaAttributes = [\n  \"aria-atomic\",\n  \"aria-busy\",\n  \"aria-controls\",\n  \"aria-current\",\n  \"aria-describedby\",\n  \"aria-details\",\n  \"aria-disabled\",\n  \"aria-dropeffect\",\n  \"aria-errormessage\",\n  \"aria-flowto\",\n  \"aria-grabbed\",\n  \"aria-haspopup\",\n  \"aria-hidden\",\n  \"aria-invalid\",\n  \"aria-keyshortcuts\",\n  \"aria-label\",\n  \"aria-labelledby\",\n  \"aria-live\",\n  \"aria-owns\",\n  \"aria-relevant\",\n  \"aria-roledescription\"\n];\nfunction hasGlobalAriaAttribute(e) {\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\n}\nvar kImplicitRoleByTagName = {\n  \"A\": (e) => {\n    return e.hasAttribute(\"href\") ? \"link\" : null;\n  },\n  \"AREA\": (e) => {\n    return e.hasAttribute(\"href\") ? \"link\" : null;\n  },\n  \"ARTICLE\": () => \"article\",\n  \"ASIDE\": () => \"complementary\",\n  \"BLOCKQUOTE\": () => \"blockquote\",\n  \"BUTTON\": () => \"button\",\n  \"CAPTION\": () => \"caption\",\n  \"CODE\": () => \"code\",\n  \"DATALIST\": () => \"listbox\",\n  \"DD\": () => \"definition\",\n  \"DEL\": () => \"deletion\",\n  \"DETAILS\": () => \"group\",\n  \"DFN\": () => \"term\",\n  \"DIALOG\": () => \"dialog\",\n  \"DT\": () => \"term\",\n  \"EM\": () => \"emphasis\",\n  \"FIELDSET\": () => \"group\",\n  \"FIGURE\": () => \"figure\",\n  \"FOOTER\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \"contentinfo\",\n  \"FORM\": (e) => hasExplicitAccessibleName(e) ? \"form\" : null,\n  \"H1\": () => \"heading\",\n  \"H2\": () => \"heading\",\n  \"H3\": () => \"heading\",\n  \"H4\": () => \"heading\",\n  \"H5\": () => \"heading\",\n  \"H6\": () => \"heading\",\n  \"HEADER\": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : \"banner\",\n  \"HR\": () => \"separator\",\n  \"HTML\": () => \"document\",\n  \"IMG\": (e) => e.getAttribute(\"alt\") === \"\" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute(\"tabindex\")))) ? \"presentation\" : \"img\",\n  \"INPUT\": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === \"search\")\n      return e.hasAttribute(\"list\") ? \"combobox\" : \"searchbox\";\n    if ([\"email\", \"tel\", \"text\", \"url\", \"\"].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute(\"list\"))[0];\n      return list && list.tagName === \"DATALIST\" ? \"combobox\" : \"textbox\";\n    }\n    if (type === \"hidden\")\n      return \"\";\n    return {\n      \"button\": \"button\",\n      \"checkbox\": \"checkbox\",\n      \"image\": \"button\",\n      \"number\": \"spinbutton\",\n      \"radio\": \"radio\",\n      \"range\": \"slider\",\n      \"reset\": \"button\",\n      \"submit\": \"button\"\n    }[type] || \"textbox\";\n  },\n  \"INS\": () => \"insertion\",\n  \"LI\": () => \"listitem\",\n  \"MAIN\": () => \"main\",\n  \"MARK\": () => \"mark\",\n  \"MATH\": () => \"math\",\n  \"MENU\": () => \"list\",\n  \"METER\": () => \"meter\",\n  \"NAV\": () => \"navigation\",\n  \"OL\": () => \"list\",\n  \"OPTGROUP\": () => \"group\",\n  \"OPTION\": () => \"option\",\n  \"OUTPUT\": () => \"status\",\n  \"P\": () => \"paragraph\",\n  \"PROGRESS\": () => \"progressbar\",\n  \"SECTION\": (e) => hasExplicitAccessibleName(e) ? \"region\" : null,\n  \"SELECT\": (e) => e.hasAttribute(\"multiple\") || e.size > 1 ? \"listbox\" : \"combobox\",\n  \"STRONG\": () => \"strong\",\n  \"SUB\": () => \"subscript\",\n  \"SUP\": () => \"superscript\",\n  \"TABLE\": () => \"table\",\n  \"TBODY\": () => \"rowgroup\",\n  \"TD\": (e) => {\n    const table = closestCrossShadow(e, \"table\");\n    const role = table ? getExplicitAriaRole(table) : \"\";\n    return role === \"grid\" || role === \"treegrid\" ? \"gridcell\" : \"cell\";\n  },\n  \"TEXTAREA\": () => \"textbox\",\n  \"TFOOT\": () => \"rowgroup\",\n  \"TH\": (e) => {\n    if (e.getAttribute(\"scope\") === \"col\")\n      return \"columnheader\";\n    if (e.getAttribute(\"scope\") === \"row\")\n      return \"rowheader\";\n    const table = closestCrossShadow(e, \"table\");\n    const role = table ? getExplicitAriaRole(table) : \"\";\n    return role === \"grid\" || role === \"treegrid\" ? \"gridcell\" : \"cell\";\n  },\n  \"THEAD\": () => \"rowgroup\",\n  \"TIME\": () => \"time\",\n  \"TR\": () => \"row\",\n  \"UL\": () => \"list\"\n};\nvar kPresentationInheritanceParents = {\n  \"DD\": [\"DL\", \"DIV\"],\n  \"DIV\": [\"DL\"],\n  \"DT\": [\"DL\", \"DIV\"],\n  \"LI\": [\"OL\", \"UL\"],\n  \"TBODY\": [\"TABLE\"],\n  \"TD\": [\"TR\"],\n  \"TFOOT\": [\"TABLE\"],\n  \"TH\": [\"TR\"],\n  \"THEAD\": [\"TABLE\"],\n  \"TR\": [\"THEAD\", \"TBODY\", \"TFOOT\", \"TABLE\"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || \"\";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\n    if (!parents || !parent || !parents.includes(parent.tagName))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === \"none\" || parentExplicitRole === \"presentation\") && !hasPresentationConflictResolution(parent))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar allRoles = [\n  \"alert\",\n  \"alertdialog\",\n  \"application\",\n  \"article\",\n  \"banner\",\n  \"blockquote\",\n  \"button\",\n  \"caption\",\n  \"cell\",\n  \"checkbox\",\n  \"code\",\n  \"columnheader\",\n  \"combobox\",\n  \"command\",\n  \"complementary\",\n  \"composite\",\n  \"contentinfo\",\n  \"definition\",\n  \"deletion\",\n  \"dialog\",\n  \"directory\",\n  \"document\",\n  \"emphasis\",\n  \"feed\",\n  \"figure\",\n  \"form\",\n  \"generic\",\n  \"grid\",\n  \"gridcell\",\n  \"group\",\n  \"heading\",\n  \"img\",\n  \"input\",\n  \"insertion\",\n  \"landmark\",\n  \"link\",\n  \"list\",\n  \"listbox\",\n  \"listitem\",\n  \"log\",\n  \"main\",\n  \"marquee\",\n  \"math\",\n  \"meter\",\n  \"menu\",\n  \"menubar\",\n  \"menuitem\",\n  \"menuitemcheckbox\",\n  \"menuitemradio\",\n  \"navigation\",\n  \"none\",\n  \"note\",\n  \"option\",\n  \"paragraph\",\n  \"presentation\",\n  \"progressbar\",\n  \"radio\",\n  \"radiogroup\",\n  \"range\",\n  \"region\",\n  \"roletype\",\n  \"row\",\n  \"rowgroup\",\n  \"rowheader\",\n  \"scrollbar\",\n  \"search\",\n  \"searchbox\",\n  \"section\",\n  \"sectionhead\",\n  \"select\",\n  \"separator\",\n  \"slider\",\n  \"spinbutton\",\n  \"status\",\n  \"strong\",\n  \"structure\",\n  \"subscript\",\n  \"superscript\",\n  \"switch\",\n  \"tab\",\n  \"table\",\n  \"tablist\",\n  \"tabpanel\",\n  \"term\",\n  \"textbox\",\n  \"time\",\n  \"timer\",\n  \"toolbar\",\n  \"tooltip\",\n  \"tree\",\n  \"treegrid\",\n  \"treeitem\",\n  \"widget\",\n  \"window\"\n];\nvar abstractRoles = [\"command\", \"composite\", \"input\", \"landmark\", \"range\", \"roletype\", \"section\", \"sectionhead\", \"select\", \"structure\", \"widget\", \"window\"];\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute(\"role\") || \"\").split(\" \").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element) {\n  return !hasGlobalAriaAttribute(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if ((explicitRole === \"none\" || explicitRole === \"presentation\") && hasPresentationConflictResolution(element))\n    return getImplicitAriaRole(element);\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === \"true\";\n}\nfunction getComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementHiddenForAria(element, cache) {\n  if ([\"STYLE\", \"SCRIPT\", \"NOSCRIPT\", \"TEMPLATE\"].includes(element.tagName))\n    return true;\n  const style = getComputedStyle(element);\n  if (!style || style.visibility === \"hidden\")\n    return true;\n  return belongsToDisplayNoneOrAriaHidden(element, cache);\n}\nfunction belongsToDisplayNoneOrAriaHidden(element, cache) {\n  if (!cache.has(element)) {\n    const style = getComputedStyle(element);\n    let hidden = !style || style.display === \"none\" || getAriaBoolean(element.getAttribute(\"aria-hidden\")) === true;\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = hidden || belongsToDisplayNoneOrAriaHidden(parent, cache);\n    }\n    cache.set(element, hidden);\n  }\n  return cache.get(element);\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(\" \").filter((id) => !!id);\n    const set = /* @__PURE__ */ new Set();\n    for (const id of ids) {\n      const firstElement = root.querySelector(\"#\" + CSS.escape(id));\n      if (firstElement)\n        set.add(firstElement);\n    }\n    return [...set];\n  } catch (e) {\n    return [];\n  }\n}\nfunction normalizeAccessbileName(s) {\n  return s.replace(/\\r\\n/g, \"\\n\").replace(/\\u00A0/g, \" \").replace(/\\s\\s+/g, \" \").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute(\"aria-owns\"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getPseudoContent(pseudoStyle) {\n  if (!pseudoStyle)\n    return \"\";\n  const content = pseudoStyle.getPropertyValue(\"content\");\n  if (content[0] === \"'\" && content[content.length - 1] === \"'\" || content[0] === '\"' && content[content.length - 1] === '\"') {\n    const unquoted = content.substring(1, content.length - 1);\n    const display = pseudoStyle.getPropertyValue(\"display\") || \"inline\";\n    if (display !== \"inline\")\n      return \" \" + unquoted + \" \";\n    return unquoted;\n  }\n  return \"\";\n}\nfunction getElementAccessibleName(element, includeHidden, hiddenCache) {\n  const elementProhibitsNaming = [\"caption\", \"code\", \"definition\", \"deletion\", \"emphasis\", \"generic\", \"insertion\", \"mark\", \"paragraph\", \"presentation\", \"strong\", \"subscript\", \"suggestion\", \"superscript\", \"term\", \"time\"].includes(getAriaRole(element) || \"\");\n  if (elementProhibitsNaming)\n    return \"\";\n  const accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\n    includeHidden,\n    hiddenCache,\n    visitedElements: /* @__PURE__ */ new Set(),\n    embeddedInLabelledBy: \"none\",\n    embeddedInLabel: \"none\",\n    embeddedInTextAlternativeElement: false,\n    embeddedInTargetElement: \"self\"\n  }));\n  return accessibleName;\n}\nfunction getElementAccessibleNameInternal(element, options) {\n  if (options.visitedElements.has(element))\n    return \"\";\n  const childOptions = {\n    ...options,\n    embeddedInLabel: options.embeddedInLabel === \"self\" ? \"descendant\" : options.embeddedInLabel,\n    embeddedInLabelledBy: options.embeddedInLabelledBy === \"self\" ? \"descendant\" : options.embeddedInLabelledBy,\n    embeddedInTargetElement: options.embeddedInTargetElement === \"self\" ? \"descendant\" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden && options.embeddedInLabelledBy !== \"self\" && isElementHiddenForAria(element, options.hiddenCache)) {\n    options.visitedElements.add(element);\n    return \"\";\n  }\n  if (options.embeddedInLabelledBy === \"none\") {\n    const refs = getIdRefs(element, element.getAttribute(\"aria-labelledby\"));\n    const accessibleName = refs.map((ref) => getElementAccessibleNameInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: \"self\",\n      embeddedInTargetElement: \"none\",\n      embeddedInLabel: \"none\",\n      embeddedInTextAlternativeElement: false\n    })).join(\" \");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || \"\";\n  if (options.embeddedInLabel !== \"none\" || options.embeddedInLabelledBy !== \"none\") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = getIdRefs(element, element.getAttribute(\"aria-labelledby\")).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === \"textbox\") {\n        options.visitedElements.add(element);\n        if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\")\n          return element.value;\n        return element.textContent || \"\";\n      }\n      if ([\"combobox\", \"listbox\"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (element.tagName === \"SELECT\") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === \"combobox\" ? queryInAriaOwned(element, \"*\").find((e) => getAriaRole(e) === \"listbox\") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, '[aria-selected=\"true\"]').filter((e) => getAriaRole(e) === \"option\") : [];\n        }\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(\" \");\n      }\n      if ([\"progressbar\", \"scrollbar\", \"slider\", \"spinbutton\", \"meter\"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute(\"aria-valuetext\"))\n          return element.getAttribute(\"aria-valuetext\") || \"\";\n        if (element.hasAttribute(\"aria-valuenow\"))\n          return element.getAttribute(\"aria-valuenow\") || \"\";\n        return element.getAttribute(\"value\") || \"\";\n      }\n      if ([\"menu\"].includes(role)) {\n        options.visitedElements.add(element);\n        return \"\";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute(\"aria-label\") || \"\";\n  if (ariaLabel.trim()) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (![\"presentation\", \"none\"].includes(role)) {\n    if (element.tagName === \"INPUT\" && [\"button\", \"submit\", \"reset\"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || \"\";\n      if (value.trim())\n        return value;\n      if (element.type === \"submit\")\n        return \"Submit\";\n      if (element.type === \"reset\")\n        return \"Reset\";\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (element.tagName === \"INPUT\" && element.type === \"image\") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute(\"alt\") || \"\";\n      if (alt.trim())\n        return alt;\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: \"self\",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: \"none\",\n          embeddedInTargetElement: \"none\"\n        })).filter((accessibleName) => !!accessibleName).join(\" \");\n      }\n      const title = element.getAttribute(\"title\") || \"\";\n      if (title.trim())\n        return title;\n      return \"Submit\";\n    }\n    if (element.tagName === \"TEXTAREA\" || element.tagName === \"SELECT\" || element.tagName === \"INPUT\") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: \"self\",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: \"none\",\n          embeddedInTargetElement: \"none\"\n        })).filter((accessibleName) => !!accessibleName).join(\" \");\n      }\n      const usePlaceholder = element.tagName === \"INPUT\" && [\"text\", \"password\", \"search\", \"tel\", \"email\", \"url\"].includes(element.type) || element.tagName === \"TEXTAREA\";\n      const placeholder = element.getAttribute(\"placeholder\") || \"\";\n      const title = element.getAttribute(\"title\") || \"\";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (element.tagName === \"FIELDSET\") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === \"LEGEND\") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (element.tagName === \"FIGURE\") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === \"FIGCAPTION\") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (element.tagName === \"IMG\") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute(\"alt\") || \"\";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (element.tagName === \"TABLE\") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === \"CAPTION\") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const summary = element.getAttribute(\"summary\") || \"\";\n      if (summary)\n        return summary;\n    }\n    if (element.tagName === \"AREA\") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute(\"alt\") || \"\";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute(\"title\") || \"\";\n      return title;\n    }\n    if (element.tagName === \"SVG\" && element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === \"TITLE\" && element.ownerSVGElement) {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n    }\n  }\n  const allowsNameFromContent = [\"button\", \"cell\", \"checkbox\", \"columnheader\", \"gridcell\", \"heading\", \"link\", \"menuitem\", \"menuitemcheckbox\", \"menuitemradio\", \"option\", \"radio\", \"row\", \"rowheader\", \"switch\", \"tab\", \"tooltip\", \"treeitem\"].includes(role);\n  if (allowsNameFromContent || options.embeddedInLabelledBy !== \"none\" || options.embeddedInLabel !== \"none\" || options.embeddedInTextAlternativeElement || options.embeddedInTargetElement === \"descendant\") {\n    options.visitedElements.add(element);\n    const tokens = [];\n    const visit = (node) => {\n      var _a;\n      if (node.nodeType === 1) {\n        const display = ((_a = getComputedStyle(node)) == null ? void 0 : _a.getPropertyValue(\"display\")) || \"inline\";\n        let token = getElementAccessibleNameInternal(node, childOptions);\n        if (display !== \"inline\" || node.nodeName === \"BR\")\n          token = \" \" + token + \" \";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || \"\");\n      }\n    };\n    tokens.push(getPseudoContent(getComputedStyle(element, \"::before\")));\n    for (let child = element.firstChild; child; child = child.nextSibling)\n      visit(child);\n    if (element.shadowRoot) {\n      for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n        visit(child);\n    }\n    for (const owned of getIdRefs(element, element.getAttribute(\"aria-owns\")))\n      visit(owned);\n    tokens.push(getPseudoContent(getComputedStyle(element, \"::after\")));\n    const accessibleName = tokens.join(\"\");\n    if (accessibleName.trim())\n      return accessibleName;\n  }\n  if (![\"presentation\", \"none\"].includes(role) || element.tagName === \"IFRAME\") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute(\"title\") || \"\";\n    if (title.trim())\n      return title;\n  }\n  options.visitedElements.add(element);\n  return \"\";\n}\nvar kAriaSelectedRoles = [\"gridcell\", \"option\", \"row\", \"tab\", \"rowheader\", \"columnheader\", \"treeitem\"];\nfunction getAriaSelected(element) {\n  if (element.tagName === \"OPTION\")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || \"\"))\n    return getAriaBoolean(element.getAttribute(\"aria-selected\")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = [\"checkbox\", \"menuitemcheckbox\", \"option\", \"radio\", \"switch\", \"menuitemradio\", \"treeitem\"];\nfunction getAriaChecked(element) {\n  if (element.tagName === \"INPUT\" && element.indeterminate)\n    return \"mixed\";\n  if (element.tagName === \"INPUT\" && [\"checkbox\", \"radio\"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || \"\")) {\n    const checked = element.getAttribute(\"aria-checked\");\n    if (checked === \"true\")\n      return true;\n    if (checked === \"mixed\")\n      return \"mixed\";\n  }\n  return false;\n}\nvar kAriaPressedRoles = [\"button\"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || \"\")) {\n    const pressed = element.getAttribute(\"aria-pressed\");\n    if (pressed === \"true\")\n      return true;\n    if (pressed === \"mixed\")\n      return \"mixed\";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = [\"application\", \"button\", \"checkbox\", \"combobox\", \"gridcell\", \"link\", \"listbox\", \"menuitem\", \"row\", \"rowheader\", \"tab\", \"treeitem\", \"columnheader\", \"menuitemcheckbox\", \"menuitemradio\", \"rowheader\", \"switch\"];\nfunction getAriaExpanded(element) {\n  if (element.tagName === \"DETAILS\")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || \"\"))\n    return getAriaBoolean(element.getAttribute(\"aria-expanded\")) === true;\n  return false;\n}\nvar kAriaLevelRoles = [\"heading\", \"listitem\", \"row\", \"treeitem\"];\nfunction getAriaLevel(element) {\n  const native = { \"H1\": 1, \"H2\": 2, \"H3\": 3, \"H4\": 4, \"H5\": 5, \"H6\": 6 }[element.tagName];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || \"\")) {\n    const attr = element.getAttribute(\"aria-level\");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = [\"application\", \"button\", \"composite\", \"gridcell\", \"group\", \"input\", \"link\", \"menuitem\", \"scrollbar\", \"separator\", \"tab\", \"checkbox\", \"columnheader\", \"combobox\", \"grid\", \"listbox\", \"menu\", \"menubar\", \"menuitemcheckbox\", \"menuitemradio\", \"option\", \"radio\", \"radiogroup\", \"row\", \"rowheader\", \"searchbox\", \"select\", \"slider\", \"spinbutton\", \"switch\", \"tablist\", \"textbox\", \"toolbar\", \"tree\", \"treegrid\", \"treeitem\"];\nfunction getAriaDisabled(element) {\n  const isNativeFormControl = [\"BUTTON\", \"INPUT\", \"SELECT\", \"TEXTAREA\", \"OPTION\", \"OPTGROUP\"].includes(element.tagName);\n  if (isNativeFormControl && (element.hasAttribute(\"disabled\") || belongsToDisabledFieldSet(element)))\n    return true;\n  return hasExplicitAriaDisabled(element);\n}\nfunction belongsToDisabledFieldSet(element) {\n  if (!element)\n    return false;\n  if (element.tagName === \"FIELDSET\" && element.hasAttribute(\"disabled\"))\n    return true;\n  return belongsToDisabledFieldSet(element.parentElement);\n}\nfunction hasExplicitAriaDisabled(element) {\n  if (!element)\n    return false;\n  if (kAriaDisabledRoles.includes(getAriaRole(element) || \"\")) {\n    const attribute = (element.getAttribute(\"aria-disabled\") || \"\").toLowerCase();\n    if (attribute === \"true\")\n      return true;\n    if (attribute === \"false\")\n      return false;\n  }\n  return hasExplicitAriaDisabled(parentElementOrShadowHost(element));\n}\n\n// packages/playwright-core/src/server/injected/roleSelectorEngine.ts\nvar kSupportedAttributes = [\"selected\", \"checked\", \"pressed\", \"expanded\", \"level\", \"disabled\", \"name\", \"include-hidden\"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`\"${attr}\" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `\"${role2}\"`).join(\", \")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== \"<truthy>\" && !values.includes(attr.value))\n    throw new Error(`\"${attr.name}\" must be one of ${values.map((v) => JSON.stringify(v)).join(\", \")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`\"${attr.name}\" does not support \"${attr.op}\" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case \"checked\": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, \"mixed\"]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        if (attr.op === \"<truthy>\") {\n          attr.op = \"=\";\n          attr.value = true;\n        }\n        break;\n      }\n      case \"pressed\": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, \"mixed\"]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        if (attr.op === \"<truthy>\") {\n          attr.op = \"=\";\n          attr.value = true;\n        }\n        break;\n      }\n      case \"selected\": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        break;\n      }\n      case \"expanded\": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        break;\n      }\n      case \"level\": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === \"string\")\n          attr.value = +attr.value;\n        if (attr.op !== \"=\" || typeof attr.value !== \"number\" || Number.isNaN(attr.value))\n          throw new Error(`\"level\" attribute must be compared to a number`);\n        break;\n      }\n      case \"disabled\": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        break;\n      }\n      case \"name\": {\n        if (attr.op === \"<truthy>\")\n          throw new Error(`\"name\" attribute must have a value`);\n        if (typeof attr.value !== \"string\" && !(attr.value instanceof RegExp))\n          throw new Error(`\"name\" attribute must be a string or a regular expression`);\n        break;\n      }\n      case \"include-hidden\": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, [\"<truthy>\", \"=\"]);\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute \"${attr.name}\", must be one of ${kSupportedAttributes.map((a) => `\"${a}\"`).join(\", \")}.`);\n      }\n    }\n  }\n}\nvar RoleEngine = {\n  queryAll(scope, selector) {\n    const parsed = parseAttributeSelector(selector, true);\n    const role = parsed.name.toLowerCase();\n    if (!role)\n      throw new Error(`Role must not be empty`);\n    validateAttributes(parsed.attributes, role);\n    const hiddenCache = /* @__PURE__ */ new Map();\n    const result = [];\n    const match = (element) => {\n      if (getAriaRole(element) !== role)\n        return;\n      let includeHidden = false;\n      let nameAttr;\n      for (const attr of parsed.attributes) {\n        if (attr.name === \"include-hidden\") {\n          includeHidden = attr.op === \"<truthy>\" || !!attr.value;\n          continue;\n        }\n        if (attr.name === \"name\") {\n          nameAttr = attr;\n          continue;\n        }\n        let actual;\n        switch (attr.name) {\n          case \"selected\":\n            actual = getAriaSelected(element);\n            break;\n          case \"checked\":\n            actual = getAriaChecked(element);\n            break;\n          case \"pressed\":\n            actual = getAriaPressed(element);\n            break;\n          case \"expanded\":\n            actual = getAriaExpanded(element);\n            break;\n          case \"level\":\n            actual = getAriaLevel(element);\n            break;\n          case \"disabled\":\n            actual = getAriaDisabled(element);\n            break;\n        }\n        if (!matchesAttributePart(actual, attr))\n          return;\n      }\n      if (!includeHidden) {\n        const isHidden = isElementHiddenForAria(element, hiddenCache);\n        if (isHidden)\n          return;\n      }\n      if (nameAttr !== void 0) {\n        const accessibleName = getElementAccessibleName(element, includeHidden, hiddenCache);\n        if (!matchesAttributePart(accessibleName, nameAttr))\n          return;\n      }\n      result.push(element);\n    };\n    const query = (root) => {\n      const shadows = [];\n      if (root.shadowRoot)\n        shadows.push(root.shadowRoot);\n      for (const element of root.querySelectorAll(\"*\")) {\n        match(element);\n        if (element.shadowRoot)\n          shadows.push(element.shadowRoot);\n      }\n      shadows.forEach(query);\n    };\n    query(scope);\n    return result;\n  }\n};\n\n// packages/playwright-core/src/server/injected/layoutSelectorUtils.ts\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nvar kLayoutSelectorNames = [\"left-of\", \"right-of\", \"above\", \"below\", \"near\"];\nfunction layoutSelectorScore(name, element, inner, maxDistance) {\n  const box = element.getBoundingClientRect();\n  const scorer = { \"left-of\": boxLeftOf, \"right-of\": boxRightOf, \"above\": boxAbove, \"below\": boxBelow, \"near\": boxNear }[name];\n  let bestScore;\n  for (const e of inner) {\n    if (e === element)\n      continue;\n    const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n    if (score === void 0)\n      continue;\n    if (bestScore === void 0 || score < bestScore)\n      bestScore = score;\n  }\n  return bestScore;\n}\n\n// packages/playwright-core/src/server/injected/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor(extraEngines) {\n    this._engines = /* @__PURE__ */ new Map();\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\n    this._cacheMatches = /* @__PURE__ */ new Map();\n    this._cacheQuery = /* @__PURE__ */ new Map();\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\n    this._cacheText = /* @__PURE__ */ new Map();\n    this._retainCacheCounter = 0;\n    for (const [name, engine] of extraEngines)\n      this._engines.set(name, engine);\n    this._engines.set(\"not\", notEngine);\n    this._engines.set(\"is\", isEngine);\n    this._engines.set(\"where\", isEngine);\n    this._engines.set(\"has\", hasEngine);\n    this._engines.set(\"scope\", scopeEngine);\n    this._engines.set(\"light\", lightEngine);\n    this._engines.set(\"visible\", visibleEngine);\n    this._engines.set(\"text\", textEngine);\n    this._engines.set(\"text-is\", textIsEngine);\n    this._engines.set(\"text-matches\", textMatchesEngine);\n    this._engines.set(\"has-text\", hasTextEngine);\n    this._engines.set(\"right-of\", createLayoutEngine(\"right-of\"));\n    this._engines.set(\"left-of\", createLayoutEngine(\"left-of\"));\n    this._engines.set(\"above\", createLayoutEngine(\"above\"));\n    this._engines.set(\"below\", createLayoutEngine(\"below\"));\n    this._engines.set(\"near\", createLayoutEngine(\"near\"));\n    this._engines.set(\"nth-match\", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join(\"|\") !== parserNames.join(\"|\"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join(\"|\")} vs ${parserNames.join(\"|\")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === \"object\" && s && (Array.isArray(s) || \"simples\" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector \"${s}\"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = /* @__PURE__ */ new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n      const isPossiblyScopeClause = simple.functions.some((f) => f.name === \"scope\" || f.name === \"is\");\n      if (!isPossiblyScopeClause && element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || \"*\");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n      let css2 = simple.css;\n      const funcs = simple.functions;\n      if (css2 === \"*\" && funcs.length)\n        css2 = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css2 !== void 0) {\n        elements = this._queryCSS(context, css2);\n        const hasScopeClause = funcs.some((f) => f.name === \"scope\");\n        if (hasScopeClause && context.scope.nodeType === 1)\n          elements.unshift(context.scope);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === \">\") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === \"+\") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === \"\") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === \"\")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === \"~\") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === \"~\")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === \">=\") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === \"\")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator \"${combinator}\"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, \"*\").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement \"matches\" or \"query\"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css2) {\n    return element.matches(css2);\n  }\n  _queryCSS(context, css2) {\n    return this._cached(this._cacheQueryCSS, css2, [context.scope, context.pierceShadow], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css2)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll(\"*\")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine \"${name}\"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"is\" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"is\" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"has\" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`\"scope\" engine expects no arguments`);\n    if (context.scope.nodeType === 9)\n      return element === context.scope.documentElement;\n    return element === context.scope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`\"scope\" engine expects no arguments`);\n    if (context.scope.nodeType === 9) {\n      const root = context.scope.documentElement;\n      return root ? [root] : [];\n    }\n    if (context.scope.nodeType === 1)\n      return [context.scope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`\"not\" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`\"visible\" engine expects no arguments`);\n    return isElementVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== \"string\")\n      throw new Error(`\"text\" engine expects a single string`);\n    const matcher = createLaxTextMatcher(args[0]);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \"self\";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== \"string\")\n      throw new Error(`\"text-is\" engine expects a single string`);\n    const matcher = createStrictTextMatcher(args[0]);\n    return elementMatchesText(evaluator._cacheText, element, matcher) !== \"none\";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== \"string\" || args.length > 2 || args.length === 2 && typeof args[1] !== \"string\")\n      throw new Error(`\"text-matches\" engine expects a regexp body and optional regexp flags`);\n    const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : void 0);\n    return elementMatchesText(evaluator._cacheText, element, matcher) === \"self\";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== \"string\")\n      throw new Error(`\"has-text\" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const matcher = createLaxTextMatcher(args[0]);\n    return matcher(elementText(evaluator._cacheText, element));\n  }\n};\nfunction createLayoutEngine(name) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === \"number\" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`\"${name}\" engine expects a selector list and optional maximum distance in pixels`);\n      const inner = evaluator.query(context, queryArgs);\n      const score = layoutSelectorScore(name, element, inner, maxDistance);\n      if (score === void 0)\n        return false;\n      evaluator._markScore(element, score);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`\"nth-match\" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== \"number\" || index < 1)\n      throw new Error(`\"nth-match\" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = /* @__PURE__ */ new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  elements.forEach((e) => append(e).taken = true);\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kNthScore = 1e3;\nfunction generateSelector(injectedScript, targetElement, strict) {\n  injectedScript._evaluator.begin();\n  try {\n    targetElement = targetElement.closest(\"button,select,input,[role=button],[role=checkbox],[role=radio]\") || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, strict);\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement, strict);\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== \"/\");\n}\nfunction generateSelectorFor(injectedScript, targetElement, strict) {\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: \"css\", selector: \"html\", score: 1 }];\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map((token) => [token]) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildCandidates(injectedScript, element).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch, strict);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost2(element); parent; parent = parentElementOrShadowHost2(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch, strict);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n  for (const attribute of [\"data-testid\", \"data-test-id\", \"data-test\"]) {\n    if (element.getAttribute(attribute))\n      candidates.push({ engine: \"css\", selector: `[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: 1 });\n  }\n  if (element.nodeName === \"INPUT\") {\n    const input = element;\n    if (input.placeholder)\n      candidates.push({ engine: \"css\", selector: `[placeholder=${quoteAttributeValue(input.placeholder)}]`, score: 10 });\n  }\n  if (element.getAttribute(\"aria-label\"))\n    candidates.push({ engine: \"css\", selector: `[aria-label=${quoteAttributeValue(element.getAttribute(\"aria-label\"))}]`, score: 10 });\n  if (element.getAttribute(\"alt\") && [\"APPLET\", \"AREA\", \"IMG\", \"INPUT\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[alt=${quoteAttributeValue(element.getAttribute(\"alt\"))}]`, score: 10 });\n  if (element.getAttribute(\"role\"))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[role=${quoteAttributeValue(element.getAttribute(\"role\"))}]`, score: 50 });\n  if (element.getAttribute(\"name\") && [\"BUTTON\", \"FORM\", \"FIELDSET\", \"FRAME\", \"IFRAME\", \"INPUT\", \"KEYGEN\", \"OBJECT\", \"OUTPUT\", \"SELECT\", \"TEXTAREA\", \"MAP\", \"META\", \"PARAM\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute(\"name\"))}]`, score: 50 });\n  if ([\"INPUT\", \"TEXTAREA\"].includes(element.nodeName) && element.getAttribute(\"type\") !== \"hidden\") {\n    if (element.getAttribute(\"type\"))\n      candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute(\"type\"))}]`, score: 50 });\n  }\n  if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: 50 });\n  const idAttr = element.getAttribute(\"id\");\n  if (idAttr && !isGuidLike(idAttr))\n    candidates.push({ engine: \"css\", selector: makeSelectorForId(idAttr), score: 100 });\n  candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: 200 });\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === \"SELECT\")\n    return [];\n  const text = elementText(injectedScript._evaluator._cacheText, element).full.trim().replace(/\\s+/g, \" \").substring(0, 80);\n  if (!text)\n    return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes('\"') || text.includes(\">>\") || text[0] === \"/\")\n    escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({ engine: \"text\", selector: escaped, score: 10 });\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLowerCase();\n    if (element.hasAttribute(\"role\"))\n      prefix += `[role=${quoteAttributeValue(element.getAttribute(\"role\"))}]`;\n    candidates.push({ engine: \"css\", selector: `${prefix}:has-text(\"${text}\")`, score: 30 });\n  }\n  return candidates;\n}\nfunction parentElementOrShadowHost2(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n    return element.parentNode.host;\n  return null;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? \"#\" + id : `[id=\"${cssEscape(id)}\"]`;\n}\nfunction cssFallback(injectedScript, targetElement, strict) {\n  const kFallbackScore = 1e7;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(\" > \");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: \"css\", selector, score: kFallbackScore };\n    if (!strict)\n      return [token];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: \"nth\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost2(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = \"\";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = \".\" + cssEscape(classes.slice(0, i + 1).join(\".\"));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction quoteAttributeValue(text) {\n  return `\"${cssEscape(text).replace(/\\\\ /g, \" \")}\"`;\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = \"\";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== \"css\" || engine !== \"css\" || selector.startsWith(\":nth-match(\")))\n      parts.push(\">>\");\n    lastEngine = engine;\n    if (engine === \"css\")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(\" \");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch, strict) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const isStrictEnough = !strict || result.length === 1;\n    const index = result.indexOf(targetElement);\n    if (index === 0 && isStrictEnough) {\n      return tokens;\n    }\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: \"nth\", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === \"-\" || c === \"_\")\n      continue;\n    if (c >= \"a\" && c <= \"z\")\n      characterType = \"lower\";\n    else if (c >= \"A\" && c <= \"Z\")\n      characterType = \"upper\";\n    else if (c >= \"0\" && c <= \"9\")\n      characterType = \"digit\";\n    else\n      characterType = \"other\";\n    if (characterType === \"lower\" && lastCharacterType === \"upper\") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction cssEscape(s) {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return \"\\uFFFD\";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return \"\\\\\" + c.toString(16) + \" \";\n  if (i === 0 && c === 45 && s.length === 1)\n    return \"\\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return \"\\\\\" + s.charAt(i);\n}\n\n// packages/playwright-core/src/server/injected/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._highlightEntries = [];\n    this._injectedScript = injectedScript;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement(\"x-pw-glass\");\n    this._glassPaneElement.style.position = \"fixed\";\n    this._glassPaneElement.style.top = \"0\";\n    this._glassPaneElement.style.right = \"0\";\n    this._glassPaneElement.style.bottom = \"0\";\n    this._glassPaneElement.style.left = \"0\";\n    this._glassPaneElement.style.zIndex = \"2147483647\";\n    this._glassPaneElement.style.pointerEvents = \"none\";\n    this._glassPaneElement.style.display = \"flex\";\n    this._actionPointElement = document.createElement(\"x-pw-action-point\");\n    this._actionPointElement.setAttribute(\"hidden\", \"true\");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: \"closed\" });\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n    const styleElement = document.createElement(\"style\");\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\n                      'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n    this._glassPaneShadow.appendChild(styleElement);\n  }\n  install() {\n    document.documentElement.appendChild(this._glassPaneElement);\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this.updateHighlight(this._injectedScript.querySelectorAll(selector, document.documentElement), stringifySelector(selector), false);\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  isInstalled() {\n    return this._glassPaneElement.parentElement === document.documentElement && !this._glassPaneElement.nextElementSibling;\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + \"px\";\n    this._actionPointElement.style.left = x + \"px\";\n    this._actionPointElement.hidden = false;\n    if (this._isUnderTest)\n      console.error(\"Action point for test: \" + JSON.stringify({ x, y }));\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._highlightEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._highlightEntries = [];\n  }\n  updateHighlight(elements, selector, isRecording) {\n    let color;\n    if (isRecording)\n      color = \"#dc6f6f7f\";\n    else\n      color = elements.length > 1 ? \"#f6b26b7f\" : \"#6fa8dc7f\";\n    this._innerUpdateHighlight(elements, { color, tooltipText: selector });\n  }\n  maskElements(elements) {\n    this._innerUpdateHighlight(elements, { color: \"#F0F\" });\n  }\n  _innerUpdateHighlight(elements, options) {\n    if (this._highlightIsUpToDate(elements))\n      return;\n    this.clearHighlight();\n    for (let i = 0; i < elements.length; ++i) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (options.tooltipText) {\n        tooltipElement = document.createElement(\"x-pw-tooltip\");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        const suffix = elements.length > 1 ? ` [${i + 1} of ${elements.length}]` : \"\";\n        tooltipElement.textContent = options.tooltipText + suffix;\n        tooltipElement.style.top = \"0\";\n        tooltipElement.style.left = \"0\";\n        tooltipElement.style.display = \"flex\";\n        if (this._isUnderTest)\n          console.error(\"Highlight text for test: \" + JSON.stringify(tooltipElement.textContent));\n      }\n      this._highlightEntries.push({ targetElement: elements[i], tooltipElement, highlightElement });\n    }\n    for (const entry of this._highlightEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const tooltipWidth = entry.tooltipElement.offsetWidth;\n      const tooltipHeight = entry.tooltipElement.offsetHeight;\n      const totalWidth = this._glassPaneElement.offsetWidth;\n      const totalHeight = this._glassPaneElement.offsetHeight;\n      let anchorLeft = entry.box.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\n        anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = entry.box.bottom + 5;\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        if (entry.box.top > tooltipHeight + 5) {\n          anchorTop = entry.box.top - tooltipHeight - 5;\n        } else {\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._highlightEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + \"px\";\n        entry.tooltipElement.style.left = entry.tooltipLeft + \"px\";\n      }\n      const box = entry.box;\n      entry.highlightElement.style.backgroundColor = options.color;\n      entry.highlightElement.style.left = box.x + \"px\";\n      entry.highlightElement.style.top = box.y + \"px\";\n      entry.highlightElement.style.width = box.width + \"px\";\n      entry.highlightElement.style.height = box.height + \"px\";\n      entry.highlightElement.style.display = \"block\";\n      if (this._isUnderTest)\n        console.error(\"Highlight box for test: \" + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n  }\n  _highlightIsUpToDate(elements) {\n    if (elements.length !== this._highlightEntries.length)\n      return false;\n    for (let i = 0; i < this._highlightEntries.length; ++i) {\n      if (elements[i] !== this._highlightEntries[i].targetElement)\n        return false;\n      const oldBox = this._highlightEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box = elements[i].getBoundingClientRect();\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    const highlightElement = document.createElement(\"x-pw-highlight\");\n    highlightElement.style.position = \"absolute\";\n    highlightElement.style.top = \"0\";\n    highlightElement.style.left = \"0\";\n    highlightElement.style.width = \"0\";\n    highlightElement.style.height = \"0\";\n    highlightElement.style.boxSizing = \"border-box\";\n    return highlightElement;\n  }\n};\n\n// packages/playwright-core/src/server/injected/injectedScript.ts\nvar InjectedScript = class {\n  constructor(isUnderTest, stableRafCount, browserName, customEngines) {\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\n    this.isUnderTest = isUnderTest;\n    this._evaluator = new SelectorEvaluatorImpl(/* @__PURE__ */ new Map());\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set(\"xpath\", XPathEngine);\n    this._engines.set(\"xpath:light\", XPathEngine);\n    this._engines.set(\"_react\", ReactEngine);\n    this._engines.set(\"_vue\", VueEngine);\n    this._engines.set(\"role\", RoleEngine);\n    this._engines.set(\"text\", this._createTextEngine(true));\n    this._engines.set(\"text:light\", this._createTextEngine(false));\n    this._engines.set(\"id\", this._createAttributeEngine(\"id\", true));\n    this._engines.set(\"id:light\", this._createAttributeEngine(\"id\", false));\n    this._engines.set(\"data-testid\", this._createAttributeEngine(\"data-testid\", true));\n    this._engines.set(\"data-testid:light\", this._createAttributeEngine(\"data-testid\", false));\n    this._engines.set(\"data-test-id\", this._createAttributeEngine(\"data-test-id\", true));\n    this._engines.set(\"data-test-id:light\", this._createAttributeEngine(\"data-test-id\", false));\n    this._engines.set(\"data-test\", this._createAttributeEngine(\"data-test\", true));\n    this._engines.set(\"data-test:light\", this._createAttributeEngine(\"data-test\", false));\n    this._engines.set(\"css\", this._createCSSEngine());\n    this._engines.set(\"nth\", { queryAll: () => [] });\n    this._engines.set(\"visible\", this._createVisibleEngine());\n    this._engines.set(\"control\", this._createControlEngine());\n    this._engines.set(\"has\", this._createHasEngine());\n    for (const { name, engine } of customEngines)\n      this._engines.set(name, engine);\n    this._stableRafCount = stableRafCount;\n    this._browserName = browserName;\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (isUnderTest)\n      window.__injectedScript = this;\n  }\n  eval(expression) {\n    return globalThis.eval(expression);\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    for (const name of allEngineNames(result)) {\n      if (!this._engines.has(name))\n        throw this.createStacklessError(`Unknown engine \"${name}\" while parsing selector ${selector}`);\n    }\n    return result;\n  }\n  generateSelector(targetElement) {\n    return generateSelector(this, targetElement, true).selector;\n  }\n  querySelector(selector, root, strict) {\n    const result = this.querySelectorAll(selector, root);\n    if (strict && result.length > 1)\n      throw this.strictModeViolationError(selector, result);\n    return result[0];\n  }\n  _queryNth(elements, part) {\n    const list = [...elements];\n    let nth = +part.body;\n    if (nth === -1)\n      nth = list.length - 1;\n    return new Set(list.slice(nth, nth + 1));\n  }\n  _queryLayoutSelector(elements, part, originalRoot) {\n    const name = part.name;\n    const body = part.body;\n    const result = [];\n    const inner = this.querySelectorAll(body.parsed, originalRoot);\n    for (const element of elements) {\n      const score = layoutSelectorScore(name, element, inner, body.distance);\n      if (score !== void 0)\n        result.push({ element, score });\n    }\n    result.sort((a, b) => a.score - b.score);\n    return new Set(result.map((r) => r.element));\n  }\n  querySelectorAll(selector, root) {\n    if (selector.capture !== void 0) {\n      if (selector.parts.some((part) => part.name === \"nth\"))\n        throw this.createStacklessError(`Can't query n-th element in a request with the capture.`);\n      const withHas = { parts: selector.parts.slice(0, selector.capture + 1) };\n      if (selector.capture < selector.parts.length - 1) {\n        const parsed = { parts: selector.parts.slice(selector.capture + 1) };\n        const has = { name: \"has\", body: { parsed }, source: stringifySelector(parsed) };\n        withHas.parts.push(has);\n      }\n      return this.querySelectorAll(withHas, root);\n    }\n    if (!root[\"querySelectorAll\"])\n      throw this.createStacklessError(\"Node is not queryable.\");\n    if (selector.capture !== void 0) {\n      throw this.createStacklessError(\"Internal error: there should not be a capture in the selector.\");\n    }\n    this._evaluator.begin();\n    try {\n      let roots = /* @__PURE__ */ new Set([root]);\n      for (const part of selector.parts) {\n        if (part.name === \"nth\") {\n          roots = this._queryNth(roots, part);\n        } else if (kLayoutSelectorNames.includes(part.name)) {\n          roots = this._queryLayoutSelector(roots, part, root);\n        } else {\n          const next = /* @__PURE__ */ new Set();\n          for (const root2 of roots) {\n            const all = this._queryEngineAll(part, root2);\n            for (const one of all)\n              next.add(one);\n          }\n          roots = next;\n        }\n      }\n      return [...roots];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    const result = this._engines.get(part.name).queryAll(root, part.body);\n    for (const element of result) {\n      if (!(\"nodeName\" in element))\n        throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n    }\n    return result;\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css2 = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css: css2, functions: [] }, combinator: \"\" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    const evaluator = this._evaluator;\n    return {\n      queryAll(root, body) {\n        return evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow) {\n    const queryList = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === \"lax\" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator._cacheText, element, matcher);\n        if (matches === \"none\")\n          lastDidNotMatchSelf = element;\n        if (matches === \"self\" || matches === \"selfAndChildren\" && kind === \"strict\")\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, \"*\");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return {\n      queryAll: (root, selector) => {\n        return queryList(root, selector);\n      }\n    };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === \"enter-frame\")\n          return [];\n        if (body === \"return-empty\")\n          return [];\n        throw new Error(`Internal error, unknown control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body.parsed, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createVisibleEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      return isElementVisible(root) === Boolean(body) ? [root] : [];\n    };\n    return { queryAll };\n  }\n  _createLayoutEngine(name) {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = globalThis.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports;\n    })()`);\n    return new constrFunction(this, params);\n  }\n  isVisible(element) {\n    return isElementVisible(element);\n  }\n  pollRaf(predicate) {\n    return this.poll(predicate, (next) => requestAnimationFrame(next));\n  }\n  pollInterval(pollInterval, predicate) {\n    return this.poll(predicate, (next) => setTimeout(next, pollInterval));\n  }\n  pollLogScale(predicate) {\n    const pollIntervals = [100, 250, 500];\n    let attempts = 0;\n    return this.poll(predicate, (next) => setTimeout(next, pollIntervals[attempts++] || 1e3));\n  }\n  poll(predicate, scheduleNext) {\n    return this._runAbortableTask((progress) => {\n      let fulfill;\n      let reject;\n      const result = new Promise((f, r) => {\n        fulfill = f;\n        reject = r;\n      });\n      const next = () => {\n        if (progress.aborted)\n          return;\n        try {\n          const success = predicate(progress);\n          if (success !== progress.continuePolling)\n            fulfill(success);\n          else\n            scheduleNext(next);\n        } catch (e) {\n          progress.log(\"  \" + e.message);\n          reject(e);\n        }\n      };\n      next();\n      return result;\n    });\n  }\n  _runAbortableTask(task) {\n    let unsentLog = [];\n    let takeNextLogsCallback;\n    let taskFinished = false;\n    const logReady = () => {\n      if (!takeNextLogsCallback)\n        return;\n      takeNextLogsCallback(unsentLog);\n      unsentLog = [];\n      takeNextLogsCallback = void 0;\n    };\n    const takeNextLogs = () => new Promise((fulfill) => {\n      takeNextLogsCallback = fulfill;\n      if (unsentLog.length || taskFinished)\n        logReady();\n    });\n    let lastMessage = \"\";\n    let lastIntermediateResult = void 0;\n    const progress = {\n      injectedScript: this,\n      aborted: false,\n      continuePolling: Symbol(\"continuePolling\"),\n      log: (message) => {\n        lastMessage = message;\n        unsentLog.push({ message });\n        logReady();\n      },\n      logRepeating: (message) => {\n        if (message !== lastMessage)\n          progress.log(message);\n      },\n      setIntermediateResult: (intermediateResult) => {\n        if (lastIntermediateResult === intermediateResult)\n          return;\n        lastIntermediateResult = intermediateResult;\n        unsentLog.push({ intermediateResult });\n        logReady();\n      }\n    };\n    const run = () => {\n      const result = task(progress);\n      result.finally(() => {\n        taskFinished = true;\n        logReady();\n      });\n      return result;\n    };\n    return {\n      takeNextLogs,\n      run,\n      cancel: () => {\n        progress.aborted = true;\n      },\n      takeLastLogs: () => unsentLog\n    };\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || \"\", 10), top: parseInt(style.borderTopWidth || \"\", 10) };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (behavior === \"none\")\n      return element;\n    if (!element.matches(\"input, textarea, select\"))\n      element = element.closest(\"button, [role=button], [role=checkbox], [role=radio]\") || element;\n    if (behavior === \"follow-label\") {\n      if (!element.matches(\"input, textarea, button, select, [role=button], [role=checkbox], [role=radio]\") && !element.isContentEditable) {\n        element = element.closest(\"label\") || element;\n      }\n      if (element.nodeName === \"LABEL\")\n        element = element.control || element;\n    }\n    return element;\n  }\n  waitForElementStatesAndPerformAction(node, states, force, callback) {\n    let lastRect;\n    let counter = 0;\n    let samePositionCounter = 0;\n    let lastTime = 0;\n    return this.pollRaf((progress) => {\n      if (force) {\n        progress.log(`    forcing action`);\n        return callback(node, progress);\n      }\n      for (const state of states) {\n        if (state !== \"stable\") {\n          const result = this.elementState(node, state);\n          if (typeof result !== \"boolean\")\n            return result;\n          if (!result) {\n            progress.logRepeating(`    element is not ${state} - waiting...`);\n            return progress.continuePolling;\n          }\n          continue;\n        }\n        const element = this.retarget(node, \"no-follow-label\");\n        if (!element)\n          return \"error:notconnected\";\n        if (++counter === 1)\n          return progress.continuePolling;\n        const time = performance.now();\n        if (this._stableRafCount > 1 && time - lastTime < 15)\n          return progress.continuePolling;\n        lastTime = time;\n        const clientRect = element.getBoundingClientRect();\n        const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n        const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (samePosition)\n          ++samePositionCounter;\n        else\n          samePositionCounter = 0;\n        const isStable = samePositionCounter >= this._stableRafCount;\n        const isStableForLogs = isStable || !lastRect;\n        lastRect = rect;\n        if (!isStableForLogs)\n          progress.logRepeating(`    element is not stable - waiting...`);\n        if (!isStable)\n          return progress.continuePolling;\n      }\n      return callback(node, progress);\n    });\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, [\"stable\", \"visible\", \"hidden\"].includes(state) ? \"none\" : \"follow-label\");\n    if (!element || !element.isConnected) {\n      if (state === \"hidden\")\n        return true;\n      return \"error:notconnected\";\n    }\n    if (state === \"visible\")\n      return this.isVisible(element);\n    if (state === \"hidden\")\n      return !this.isVisible(element);\n    const disabled = getAriaDisabled(element);\n    if (state === \"disabled\")\n      return disabled;\n    if (state === \"enabled\")\n      return !disabled;\n    const editable = !([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(element.nodeName) && element.hasAttribute(\"readonly\"));\n    if (state === \"editable\")\n      return !disabled && editable;\n    if (state === \"checked\" || state === \"unchecked\") {\n      if ([\"checkbox\", \"radio\"].includes(element.getAttribute(\"role\") || \"\")) {\n        const result2 = element.getAttribute(\"aria-checked\") === \"true\";\n        return state === \"checked\" ? result2 : !result2;\n      }\n      if (element.nodeName !== \"INPUT\")\n        throw this.createStacklessError(\"Not a checkbox or radio button\");\n      if (![\"radio\", \"checkbox\"].includes(element.type.toLowerCase()))\n        throw this.createStacklessError(\"Not a checkbox or radio button\");\n      const result = element.checked;\n      return state === \"checked\" ? result : !result;\n    }\n    throw this.createStacklessError(`Unexpected element state \"${state}\"`);\n  }\n  selectOptions(optionsToSelect, node, progress) {\n    const element = this.retarget(node, \"follow-label\");\n    if (!element)\n      return \"error:notconnected\";\n    if (element.nodeName.toLowerCase() !== \"select\")\n      throw this.createStacklessError(\"Element is not a <select> element\");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length) {\n      progress.logRepeating(\"    did not find some options - waiting... \");\n      return progress.continuePolling;\n    }\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    progress.log(\"    selected specified option(s)\");\n    select.dispatchEvent(new Event(\"input\", { \"bubbles\": true }));\n    select.dispatchEvent(new Event(\"change\", { \"bubbles\": true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(value, node, progress) {\n    const element = this.retarget(node, \"follow-label\");\n    if (!element)\n      return \"error:notconnected\";\n    if (element.nodeName.toLowerCase() === \"input\") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set([\"color\", \"date\", \"time\", \"datetime\", \"datetime-local\", \"month\", \"range\", \"week\"]);\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set([\"\", \"email\", \"number\", \"password\", \"search\", \"tel\", \"text\", \"url\"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type)) {\n        progress.log(`    input of type \"${type}\" cannot be filled`);\n        throw this.createStacklessError(`Input of type \"${type}\" cannot be filled`);\n      }\n      if (type === \"number\") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError(\"Cannot type text into input[type=number]\");\n      }\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError(\"Malformed value\");\n        element.dispatchEvent(new Event(\"input\", { \"bubbles\": true }));\n        element.dispatchEvent(new Event(\"change\", { \"bubbles\": true }));\n        return \"done\";\n      }\n    } else if (element.nodeName.toLowerCase() === \"textarea\") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError(\"Element is not an <input>, <textarea> or [contenteditable] element\");\n    }\n    this.selectText(element);\n    return \"needsinput\";\n  }\n  selectText(node) {\n    const element = this.retarget(node, \"follow-label\");\n    if (!element)\n      return \"error:notconnected\";\n    if (element.nodeName.toLowerCase() === \"input\") {\n      const input = element;\n      input.select();\n      input.focus();\n      return \"done\";\n    }\n    if (element.nodeName.toLowerCase() === \"textarea\") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return \"done\";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return \"done\";\n  }\n  _activelyFocused(node) {\n    const activeElement = node.getRootNode().activeElement;\n    const isFocused = activeElement === node && !!node.ownerDocument && node.ownerDocument.hasFocus();\n    return { activeElement, isFocused };\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return \"error:notconnected\";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError(\"Node is not an element\");\n    const { activeElement, isFocused: wasFocused } = this._activelyFocused(node);\n    if (node.isContentEditable && !wasFocused && activeElement && activeElement.blur) {\n      activeElement.blur();\n    }\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === \"input\") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return \"done\";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return \"Node is not of type HTMLElement\";\n    const element = node;\n    if (element.nodeName !== \"INPUT\")\n      return \"Not an <input> element\";\n    const input = element;\n    const type = (input.getAttribute(\"type\") || \"\").toLowerCase();\n    if (type !== \"file\")\n      return \"Not an input[type=file] element\";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event(\"input\", { \"bubbles\": true }));\n    input.dispatchEvent(new Event(\"change\", { \"bubbles\": true }));\n  }\n  expectHitTargetParent(hitElement, targetElement) {\n    targetElement = targetElement.closest(\"button, [role=button], a, [role=link]\") || targetElement;\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return \"done\";\n    const hitTargetDescription = this.previewNode(hitParents[0] || document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  setupHitTargetInterceptor(node, action, hitPoint, blockAllEvents) {\n    const element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element || !element.isConnected)\n      return \"error:notconnected\";\n    const preliminaryHitElement = this.deepElementFromPoint(document, hitPoint.x, hitPoint.y);\n    const preliminaryResult = this.expectHitTargetParent(preliminaryHitElement, element);\n    if (preliminaryResult !== \"done\")\n      return preliminaryResult.hitTargetDescription;\n    if (action === \"drag\")\n      return { stop: () => \"done\" };\n    const events = {\n      \"hover\": kHoverHitTargetInterceptorEvents,\n      \"tap\": kTapHitTargetInterceptorEvents,\n      \"mouse\": kMouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!window.TouchEvent && event instanceof window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point) {\n        const hitElement = this.deepElementFromPoint(document, point.clientX, point.clientY);\n        result = this.expectHitTargetParent(hitElement, element);\n      }\n      if (blockAllEvents || result !== \"done\" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || \"done\";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInit) {\n    let event;\n    eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInit };\n    switch (eventType.get(type)) {\n      case \"mouse\":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case \"keyboard\":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case \"touch\":\n        event = new TouchEvent(type, eventInit);\n        break;\n      case \"pointer\":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case \"focus\":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case \"drag\":\n        event = new DragEvent(type, eventInit);\n        break;\n      case \"wheel\":\n        event = new WheelEvent(type, eventInit);\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  deepElementFromPoint(document2, x, y) {\n    var _a;\n    let container = document2;\n    let element;\n    while (container) {\n      const elements = container.elementsFromPoint(x, y);\n      const singleElement = container.elementFromPoint(x, y);\n      if (singleElement && elements[0] && parentElementOrShadowHost(singleElement) === elements[0]) {\n        const style = (_a = document2.defaultView) == null ? void 0 : _a.getComputedStyle(singleElement);\n        if ((style == null ? void 0 : style.display) === \"contents\") {\n          elements.unshift(singleElement);\n        }\n      }\n      const innerElement = elements[0];\n      if (!innerElement || element === innerElement)\n        break;\n      element = innerElement;\n      container = element.shadowRoot;\n    }\n    return element;\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || \"\"}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === \"style\" || name.startsWith(\"__playwright\"))\n        continue;\n      if (!value && booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}=\"${value}\"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    let attrText = attrs.join(\"\");\n    if (attrText.length > 50)\n      attrText = attrText.substring(0, 49) + \"\\u2026\";\n    if (autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    let text = onlyText ? element.textContent || \"\" : children.length ? \"\\u2026\" : \"\";\n    if (text.length > 50)\n      text = text.substring(0, 49) + \"\\u2026\";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`);\n  }\n  strictModeViolationError(selector, matches) {\n    const infos = matches.slice(0, 10).map((m) => ({\n      preview: this.previewNode(m),\n      selector: this.generateSelector(m)\n    }));\n    const lines = infos.map((info, i) => `\n    ${i + 1}) ${info.preview} aka playwright.$(\"${info.selector}\")`);\n    if (infos.length < matches.length)\n      lines.push(\"\\n    ...\");\n    return this.createStacklessError(`strict mode violation: \"${stringifySelector(selector)}\" resolved to ${matches.length} elements:${lines.join(\"\")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === \"firefox\") {\n      const error2 = new Error(\"Error: \" + message);\n      error2.stack = \"\";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  maskSelectors(selectors) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, document.documentElement));\n    this._highlight.maskElements(elements.flat());\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this);\n      this._highlight.install();\n    }\n    this._highlight.runHighlightOnRaf(selector);\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = \"__playwright_global_listeners_check__\";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of kAllHitTargetInterceptorEvents)\n        window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  expectSingleElement(progress, element, options) {\n    var _a;\n    const injected = progress.injectedScript;\n    const expression = options.expression;\n    {\n      let elementState;\n      if (expression === \"to.be.checked\") {\n        elementState = progress.injectedScript.elementState(element, \"checked\");\n      } else if (expression === \"to.be.unchecked\") {\n        elementState = progress.injectedScript.elementState(element, \"unchecked\");\n      } else if (expression === \"to.be.disabled\") {\n        elementState = progress.injectedScript.elementState(element, \"disabled\");\n      } else if (expression === \"to.be.editable\") {\n        elementState = progress.injectedScript.elementState(element, \"editable\");\n      } else if (expression === \"to.be.empty\") {\n        if (element.nodeName === \"INPUT\" || element.nodeName === \"TEXTAREA\")\n          elementState = !element.value;\n        else\n          elementState = !((_a = element.textContent) == null ? void 0 : _a.trim());\n      } else if (expression === \"to.be.enabled\") {\n        elementState = progress.injectedScript.elementState(element, \"enabled\");\n      } else if (expression === \"to.be.focused\") {\n        elementState = this._activelyFocused(element).isFocused;\n      } else if (expression === \"to.be.hidden\") {\n        elementState = progress.injectedScript.elementState(element, \"hidden\");\n      } else if (expression === \"to.be.visible\") {\n        elementState = progress.injectedScript.elementState(element, \"visible\");\n      }\n      if (elementState !== void 0) {\n        if (elementState === \"error:notcheckbox\")\n          throw injected.createStacklessError(\"Element is not a checkbox\");\n        if (elementState === \"error:notconnected\")\n          throw injected.createStacklessError(\"Element is not connected\");\n        return { received: elementState, matches: elementState };\n      }\n    }\n    {\n      if (expression === \"to.have.property\") {\n        const received = element[options.expressionArg];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      if (expression === \"to.have.values\") {\n        element = this.retarget(element, \"follow-label\");\n        if (element.nodeName !== \"SELECT\" || !element.multiple)\n          throw this.createStacklessError(\"Not a select element with a multiple attribute\");\n        const received = [...element.selectedOptions].map((o) => o.value);\n        if (received.length !== options.expectedText.length)\n          return { received, matches: false };\n        return { received, matches: received.map((r, i) => new ExpectedTextMatcher(options.expectedText[i]).matches(r)).every(Boolean) };\n      }\n    }\n    {\n      let received;\n      if (expression === \"to.have.attribute\") {\n        received = element.getAttribute(options.expressionArg) || \"\";\n      } else if (expression === \"to.have.class\") {\n        received = element.classList.toString();\n      } else if (expression === \"to.have.css\") {\n        received = window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === \"to.have.id\") {\n        received = element.id;\n      } else if (expression === \"to.have.text\") {\n        received = options.useInnerText ? element.innerText : element.textContent || \"\";\n      } else if (expression === \"to.have.title\") {\n        received = document.title;\n      } else if (expression === \"to.have.url\") {\n        received = document.location.href;\n      } else if (expression === \"to.have.value\") {\n        element = this.retarget(element, \"follow-label\");\n        if (element.nodeName !== \"INPUT\" && element.nodeName !== \"TEXTAREA\" && element.nodeName !== \"SELECT\")\n          throw this.createStacklessError(\"Not an input element\");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError(\"Unknown expect matcher: \" + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === \"to.have.count\") {\n      const received2 = elements.length;\n      const matches = received2 === options.expectedNumber;\n      return { received: received2, matches };\n    }\n    let received;\n    if (expression === \"to.have.text.array\" || expression === \"to.contain.text.array\")\n      received = elements.map((e) => options.useInnerText ? e.innerText : e.textContent || \"\");\n    else if (expression === \"to.have.class.array\")\n      received = elements.map((e) => e.classList.toString());\n    if (received && options.expectedText) {\n      const lengthShouldMatch = expression !== \"to.contain.text.array\";\n      const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n      if (!matchesLength)\n        return { received, matches: false };\n      const matchers = options.expectedText.map((e) => new ExpectedTextMatcher(e));\n      let mIndex = 0, rIndex = 0;\n      while (mIndex < matchers.length && rIndex < received.length) {\n        if (matchers[mIndex].matches(received[rIndex]))\n          ++mIndex;\n        ++rIndex;\n      }\n      return { received, matches: mIndex === matchers.length };\n    }\n    throw this.createStacklessError(\"Unknown expect matcher: \" + expression);\n  }\n  getElementAccessibleName(element, includeHidden) {\n    const hiddenCache = /* @__PURE__ */ new Map();\n    return getElementAccessibleName(element, !!includeHidden, hiddenCache);\n  }\n  getAriaRole(element) {\n    return getAriaRole(element);\n  }\n};\nvar autoClosingTags = /* @__PURE__ */ new Set([\"AREA\", \"BASE\", \"BR\", \"COL\", \"COMMAND\", \"EMBED\", \"HR\", \"IMG\", \"INPUT\", \"KEYGEN\", \"LINK\", \"MENUITEM\", \"META\", \"PARAM\", \"SOURCE\", \"TRACK\", \"WBR\"]);\nvar booleanAttributes = /* @__PURE__ */ new Set([\"checked\", \"selected\", \"disabled\", \"readonly\", \"multiple\"]);\nfunction oneLine(s) {\n  return s.replace(/\\n/g, \"\\u21B5\").replace(/\\t/g, \"\\u21C6\");\n}\nvar eventType = /* @__PURE__ */ new Map([\n  [\"auxclick\", \"mouse\"],\n  [\"click\", \"mouse\"],\n  [\"dblclick\", \"mouse\"],\n  [\"mousedown\", \"mouse\"],\n  [\"mouseeenter\", \"mouse\"],\n  [\"mouseleave\", \"mouse\"],\n  [\"mousemove\", \"mouse\"],\n  [\"mouseout\", \"mouse\"],\n  [\"mouseover\", \"mouse\"],\n  [\"mouseup\", \"mouse\"],\n  [\"mouseleave\", \"mouse\"],\n  [\"mousewheel\", \"mouse\"],\n  [\"keydown\", \"keyboard\"],\n  [\"keyup\", \"keyboard\"],\n  [\"keypress\", \"keyboard\"],\n  [\"textInput\", \"keyboard\"],\n  [\"touchstart\", \"touch\"],\n  [\"touchmove\", \"touch\"],\n  [\"touchend\", \"touch\"],\n  [\"touchcancel\", \"touch\"],\n  [\"pointerover\", \"pointer\"],\n  [\"pointerout\", \"pointer\"],\n  [\"pointerenter\", \"pointer\"],\n  [\"pointerleave\", \"pointer\"],\n  [\"pointerdown\", \"pointer\"],\n  [\"pointerup\", \"pointer\"],\n  [\"pointermove\", \"pointer\"],\n  [\"pointercancel\", \"pointer\"],\n  [\"gotpointercapture\", \"pointer\"],\n  [\"lostpointercapture\", \"pointer\"],\n  [\"focus\", \"focus\"],\n  [\"blur\", \"focus\"],\n  [\"drag\", \"drag\"],\n  [\"dragstart\", \"drag\"],\n  [\"dragend\", \"drag\"],\n  [\"dragover\", \"drag\"],\n  [\"dragenter\", \"drag\"],\n  [\"dragleave\", \"drag\"],\n  [\"dragexit\", \"drag\"],\n  [\"drop\", \"drag\"],\n  [\"wheel\", \"wheel\"]\n]);\nvar kHoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\"mousemove\"]);\nvar kTapHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\"pointerdown\", \"pointerup\", \"touchstart\", \"touchend\", \"touchcancel\"]);\nvar kMouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set([\"mousedown\", \"mouseup\", \"pointerdown\", \"pointerup\", \"click\", \"auxclick\", \"dblclick\", \"contextmenu\"]);\nvar kAllHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...kHoverHitTargetInterceptorEvents, ...kTapHitTargetInterceptorEvents, ...kMouseHitTargetInterceptorEvents]);\nfunction unescape(s) {\n  if (!s.includes(\"\\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === \"\\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join(\"\");\n}\nfunction createTextMatcher(selector) {\n  if (selector[0] === \"/\" && selector.lastIndexOf(\"/\") > 0) {\n    const lastSlash = selector.lastIndexOf(\"/\");\n    const matcher2 = createRegexTextMatcher(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: matcher2, kind: \"regex\" };\n  }\n  let strict = false;\n  if (selector.length > 1 && selector[0] === '\"' && selector[selector.length - 1] === '\"') {\n    selector = unescape(selector.substring(1, selector.length - 1));\n    strict = true;\n  }\n  if (selector.length > 1 && selector[0] === \"'\" && selector[selector.length - 1] === \"'\") {\n    selector = unescape(selector.substring(1, selector.length - 1));\n    strict = true;\n  }\n  const matcher = strict ? createStrictTextMatcher(selector) : createLaxTextMatcher(selector);\n  return { matcher, kind: strict ? \"strict\" : \"lax\" };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._ignoreCase = expected.ignoreCase;\n    this._string = expected.matchSubstring ? void 0 : this.normalize(expected.string);\n    this._substring = expected.matchSubstring ? this.normalize(expected.string) : void 0;\n    if (expected.regexSource) {\n      const flags = new Set((expected.regexFlags || \"\").split(\"\"));\n      if (expected.ignoreCase === false)\n        flags.delete(\"i\");\n      if (expected.ignoreCase === true)\n        flags.add(\"i\");\n      this._regex = new RegExp(expected.regexSource, [...flags].join(\"\"));\n    }\n  }\n  matches(text) {\n    if (!this._regex)\n      text = this.normalize(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  normalize(s) {\n    if (!s)\n      return s;\n    if (this._normalizeWhiteSpace)\n      s = s.trim().replace(/\\u200b/g, \"\").replace(/\\s+/g, \" \");\n    if (this._ignoreCase)\n      s = s.toLocaleLowerCase();\n    return s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === \"object\" && typeof b === \"object\") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === \"number\" && typeof b === \"number\")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\nmodule.exports = InjectedScript;\n";
exports.source = source;

/***/ }),

/***/ 6048:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.source = void 0;
const source = "\"use strict\";\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target, mod));\n\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.js\nvar require_cssTokenizer = __commonJS({\n  \"packages/playwright-core/src/server/isomorphic/cssTokenizer.js\"(exports2) {\n    \"use strict\";\n    var between = function(num, first, last) {\n      return num >= first && num <= last;\n    };\n    function digit(code) {\n      return between(code, 48, 57);\n    }\n    function hexdigit(code) {\n      return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n    }\n    function uppercaseletter(code) {\n      return between(code, 65, 90);\n    }\n    function lowercaseletter(code) {\n      return between(code, 97, 122);\n    }\n    function letter(code) {\n      return uppercaseletter(code) || lowercaseletter(code);\n    }\n    function nonascii(code) {\n      return code >= 128;\n    }\n    function namestartchar(code) {\n      return letter(code) || nonascii(code) || code == 95;\n    }\n    function namechar(code) {\n      return namestartchar(code) || digit(code) || code == 45;\n    }\n    function nonprintable(code) {\n      return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;\n    }\n    function newline(code) {\n      return code == 10;\n    }\n    function whitespace(code) {\n      return newline(code) || code == 9 || code == 32;\n    }\n    var maximumallowedcodepoint = 1114111;\n    var InvalidCharacterError = function(message) {\n      this.message = message;\n    };\n    InvalidCharacterError.prototype = new Error();\n    InvalidCharacterError.prototype.name = \"InvalidCharacterError\";\n    function preprocess(str) {\n      var codepoints = [];\n      for (var i = 0; i < str.length; i++) {\n        var code = str.charCodeAt(i);\n        if (code == 13 && str.charCodeAt(i + 1) == 10) {\n          code = 10;\n          i++;\n        }\n        if (code == 13 || code == 12)\n          code = 10;\n        if (code == 0)\n          code = 65533;\n        if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n          var lead = code - 55296;\n          var trail = str.charCodeAt(i + 1) - 56320;\n          code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n          i++;\n        }\n        codepoints.push(code);\n      }\n      return codepoints;\n    }\n    function stringFromCode(code) {\n      if (code <= 65535)\n        return String.fromCharCode(code);\n      code -= Math.pow(2, 16);\n      var lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n      var trail = code % Math.pow(2, 10) + 56320;\n      return String.fromCharCode(lead) + String.fromCharCode(trail);\n    }\n    function tokenize2(str) {\n      str = preprocess(str);\n      var i = -1;\n      var tokens = [];\n      var code;\n      var line = 0;\n      var column = 0;\n      var lastLineLength = 0;\n      var incrLineno = function() {\n        line += 1;\n        lastLineLength = column;\n        column = 0;\n      };\n      var locStart = { line, column };\n      var codepoint = function(i2) {\n        if (i2 >= str.length) {\n          return -1;\n        }\n        return str[i2];\n      };\n      var next = function(num) {\n        if (num === void 0)\n          num = 1;\n        if (num > 3)\n          throw \"Spec Error: no more than three codepoints of lookahead.\";\n        return codepoint(i + num);\n      };\n      var consume = function(num) {\n        if (num === void 0)\n          num = 1;\n        i += num;\n        code = codepoint(i);\n        if (newline(code))\n          incrLineno();\n        else\n          column += num;\n        return true;\n      };\n      var reconsume = function() {\n        i -= 1;\n        if (newline(code)) {\n          line -= 1;\n          column = lastLineLength;\n        } else {\n          column -= 1;\n        }\n        locStart.line = line;\n        locStart.column = column;\n        return true;\n      };\n      var eof = function(codepoint2) {\n        if (codepoint2 === void 0)\n          codepoint2 = code;\n        return codepoint2 == -1;\n      };\n      var donothing = function() {\n      };\n      var parseerror = function() {\n        console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");\n        return true;\n      };\n      var consumeAToken = function() {\n        consumeComments();\n        consume();\n        if (whitespace(code)) {\n          while (whitespace(next()))\n            consume();\n          return new WhitespaceToken2();\n        } else if (code == 34)\n          return consumeAStringToken();\n        else if (code == 35) {\n          if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n            var token = new HashToken2();\n            if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n              token.type = \"id\";\n            token.value = consumeAName();\n            return token;\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 36) {\n          if (next() == 61) {\n            consume();\n            return new SuffixMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 39)\n          return consumeAStringToken();\n        else if (code == 40)\n          return new OpenParenToken();\n        else if (code == 41)\n          return new CloseParenToken2();\n        else if (code == 42) {\n          if (next() == 61) {\n            consume();\n            return new SubstringMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 43) {\n          if (startsWithANumber()) {\n            reconsume();\n            return consumeANumericToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 44)\n          return new CommaToken2();\n        else if (code == 45) {\n          if (startsWithANumber()) {\n            reconsume();\n            return consumeANumericToken();\n          } else if (next(1) == 45 && next(2) == 62) {\n            consume(2);\n            return new CDCToken2();\n          } else if (startsWithAnIdentifier()) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 46) {\n          if (startsWithANumber()) {\n            reconsume();\n            return consumeANumericToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 58)\n          return new ColonToken2();\n        else if (code == 59)\n          return new SemicolonToken2();\n        else if (code == 60) {\n          if (next(1) == 33 && next(2) == 45 && next(3) == 45) {\n            consume(3);\n            return new CDOToken2();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 64) {\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n            return new AtKeywordToken2(consumeAName());\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 91)\n          return new OpenSquareToken2();\n        else if (code == 92) {\n          if (startsWithAValidEscape()) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else {\n            parseerror();\n            return new DelimToken2(code);\n          }\n        } else if (code == 93)\n          return new CloseSquareToken2();\n        else if (code == 94) {\n          if (next() == 61) {\n            consume();\n            return new PrefixMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 123)\n          return new OpenCurlyToken2();\n        else if (code == 124) {\n          if (next() == 61) {\n            consume();\n            return new DashMatchToken();\n          } else if (next() == 124) {\n            consume();\n            return new ColumnToken2();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (code == 125)\n          return new CloseCurlyToken2();\n        else if (code == 126) {\n          if (next() == 61) {\n            consume();\n            return new IncludeMatchToken();\n          } else {\n            return new DelimToken2(code);\n          }\n        } else if (digit(code)) {\n          reconsume();\n          return consumeANumericToken();\n        } else if (namestartchar(code)) {\n          reconsume();\n          return consumeAnIdentlikeToken();\n        } else if (eof())\n          return new EOFToken2();\n        else\n          return new DelimToken2(code);\n      };\n      var consumeComments = function() {\n        while (next(1) == 47 && next(2) == 42) {\n          consume(2);\n          while (true) {\n            consume();\n            if (code == 42 && next() == 47) {\n              consume();\n              break;\n            } else if (eof()) {\n              parseerror();\n              return;\n            }\n          }\n        }\n      };\n      var consumeANumericToken = function() {\n        var num = consumeANumber();\n        if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n          var token = new DimensionToken();\n          token.value = num.value;\n          token.repr = num.repr;\n          token.type = num.type;\n          token.unit = consumeAName();\n          return token;\n        } else if (next() == 37) {\n          consume();\n          var token = new PercentageToken2();\n          token.value = num.value;\n          token.repr = num.repr;\n          return token;\n        } else {\n          var token = new NumberToken2();\n          token.value = num.value;\n          token.repr = num.repr;\n          token.type = num.type;\n          return token;\n        }\n      };\n      var consumeAnIdentlikeToken = function() {\n        var str2 = consumeAName();\n        if (str2.toLowerCase() == \"url\" && next() == 40) {\n          consume();\n          while (whitespace(next(1)) && whitespace(next(2)))\n            consume();\n          if (next() == 34 || next() == 39) {\n            return new FunctionToken2(str2);\n          } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {\n            return new FunctionToken2(str2);\n          } else {\n            return consumeAURLToken();\n          }\n        } else if (next() == 40) {\n          consume();\n          return new FunctionToken2(str2);\n        } else {\n          return new IdentToken2(str2);\n        }\n      };\n      var consumeAStringToken = function(endingCodePoint) {\n        if (endingCodePoint === void 0)\n          endingCodePoint = code;\n        var string = \"\";\n        while (consume()) {\n          if (code == endingCodePoint || eof()) {\n            return new StringToken2(string);\n          } else if (newline(code)) {\n            parseerror();\n            reconsume();\n            return new BadStringToken2();\n          } else if (code == 92) {\n            if (eof(next())) {\n              donothing();\n            } else if (newline(next())) {\n              consume();\n            } else {\n              string += stringFromCode(consumeEscape());\n            }\n          } else {\n            string += stringFromCode(code);\n          }\n        }\n      };\n      var consumeAURLToken = function() {\n        var token = new URLToken2(\"\");\n        while (whitespace(next()))\n          consume();\n        if (eof(next()))\n          return token;\n        while (consume()) {\n          if (code == 41 || eof()) {\n            return token;\n          } else if (whitespace(code)) {\n            while (whitespace(next()))\n              consume();\n            if (next() == 41 || eof(next())) {\n              consume();\n              return token;\n            } else {\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            }\n          } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {\n            parseerror();\n            consumeTheRemnantsOfABadURL();\n            return new BadURLToken2();\n          } else if (code == 92) {\n            if (startsWithAValidEscape()) {\n              token.value += stringFromCode(consumeEscape());\n            } else {\n              parseerror();\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            }\n          } else {\n            token.value += stringFromCode(code);\n          }\n        }\n      };\n      var consumeEscape = function() {\n        consume();\n        if (hexdigit(code)) {\n          var digits = [code];\n          for (var total = 0; total < 5; total++) {\n            if (hexdigit(next())) {\n              consume();\n              digits.push(code);\n            } else {\n              break;\n            }\n          }\n          if (whitespace(next()))\n            consume();\n          var value = parseInt(digits.map(function(x) {\n            return String.fromCharCode(x);\n          }).join(\"\"), 16);\n          if (value > maximumallowedcodepoint)\n            value = 65533;\n          return value;\n        } else if (eof()) {\n          return 65533;\n        } else {\n          return code;\n        }\n      };\n      var areAValidEscape = function(c1, c2) {\n        if (c1 != 92)\n          return false;\n        if (newline(c2))\n          return false;\n        return true;\n      };\n      var startsWithAValidEscape = function() {\n        return areAValidEscape(code, next());\n      };\n      var wouldStartAnIdentifier = function(c1, c2, c3) {\n        if (c1 == 45) {\n          return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);\n        } else if (namestartchar(c1)) {\n          return true;\n        } else if (c1 == 92) {\n          return areAValidEscape(c1, c2);\n        } else {\n          return false;\n        }\n      };\n      var startsWithAnIdentifier = function() {\n        return wouldStartAnIdentifier(code, next(1), next(2));\n      };\n      var wouldStartANumber = function(c1, c2, c3) {\n        if (c1 == 43 || c1 == 45) {\n          if (digit(c2))\n            return true;\n          if (c2 == 46 && digit(c3))\n            return true;\n          return false;\n        } else if (c1 == 46) {\n          if (digit(c2))\n            return true;\n          return false;\n        } else if (digit(c1)) {\n          return true;\n        } else {\n          return false;\n        }\n      };\n      var startsWithANumber = function() {\n        return wouldStartANumber(code, next(1), next(2));\n      };\n      var consumeAName = function() {\n        var result = \"\";\n        while (consume()) {\n          if (namechar(code)) {\n            result += stringFromCode(code);\n          } else if (startsWithAValidEscape()) {\n            result += stringFromCode(consumeEscape());\n          } else {\n            reconsume();\n            return result;\n          }\n        }\n      };\n      var consumeANumber = function() {\n        var repr = [];\n        var type = \"integer\";\n        if (next() == 43 || next() == 45) {\n          consume();\n          repr += stringFromCode(code);\n        }\n        while (digit(next())) {\n          consume();\n          repr += stringFromCode(code);\n        }\n        if (next(1) == 46 && digit(next(2))) {\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          type = \"number\";\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n        }\n        var c1 = next(1), c2 = next(2), c3 = next(3);\n        if ((c1 == 69 || c1 == 101) && digit(c2)) {\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          type = \"number\";\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n        } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          consume();\n          repr += stringFromCode(code);\n          type = \"number\";\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n        }\n        var value = convertAStringToANumber(repr);\n        return { type, value, repr };\n      };\n      var convertAStringToANumber = function(string) {\n        return +string;\n      };\n      var consumeTheRemnantsOfABadURL = function() {\n        while (consume()) {\n          if (code == 41 || eof()) {\n            return;\n          } else if (startsWithAValidEscape()) {\n            consumeEscape();\n            donothing();\n          } else {\n            donothing();\n          }\n        }\n      };\n      var iterationCount = 0;\n      while (!eof(next())) {\n        tokens.push(consumeAToken());\n        iterationCount++;\n        if (iterationCount > str.length * 2)\n          return \"I'm infinite-looping!\";\n      }\n      return tokens;\n    }\n    function CSSParserToken() {\n      throw \"Abstract Base Class\";\n    }\n    CSSParserToken.prototype.toJSON = function() {\n      return { token: this.tokenType };\n    };\n    CSSParserToken.prototype.toString = function() {\n      return this.tokenType;\n    };\n    CSSParserToken.prototype.toSource = function() {\n      return \"\" + this;\n    };\n    function BadStringToken2() {\n      return this;\n    }\n    BadStringToken2.prototype = Object.create(CSSParserToken.prototype);\n    BadStringToken2.prototype.tokenType = \"BADSTRING\";\n    function BadURLToken2() {\n      return this;\n    }\n    BadURLToken2.prototype = Object.create(CSSParserToken.prototype);\n    BadURLToken2.prototype.tokenType = \"BADURL\";\n    function WhitespaceToken2() {\n      return this;\n    }\n    WhitespaceToken2.prototype = Object.create(CSSParserToken.prototype);\n    WhitespaceToken2.prototype.tokenType = \"WHITESPACE\";\n    WhitespaceToken2.prototype.toString = function() {\n      return \"WS\";\n    };\n    WhitespaceToken2.prototype.toSource = function() {\n      return \" \";\n    };\n    function CDOToken2() {\n      return this;\n    }\n    CDOToken2.prototype = Object.create(CSSParserToken.prototype);\n    CDOToken2.prototype.tokenType = \"CDO\";\n    CDOToken2.prototype.toSource = function() {\n      return \"<!--\";\n    };\n    function CDCToken2() {\n      return this;\n    }\n    CDCToken2.prototype = Object.create(CSSParserToken.prototype);\n    CDCToken2.prototype.tokenType = \"CDC\";\n    CDCToken2.prototype.toSource = function() {\n      return \"-->\";\n    };\n    function ColonToken2() {\n      return this;\n    }\n    ColonToken2.prototype = Object.create(CSSParserToken.prototype);\n    ColonToken2.prototype.tokenType = \":\";\n    function SemicolonToken2() {\n      return this;\n    }\n    SemicolonToken2.prototype = Object.create(CSSParserToken.prototype);\n    SemicolonToken2.prototype.tokenType = \";\";\n    function CommaToken2() {\n      return this;\n    }\n    CommaToken2.prototype = Object.create(CSSParserToken.prototype);\n    CommaToken2.prototype.tokenType = \",\";\n    function GroupingToken() {\n      throw \"Abstract Base Class\";\n    }\n    GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n    function OpenCurlyToken2() {\n      this.value = \"{\";\n      this.mirror = \"}\";\n      return this;\n    }\n    OpenCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n    OpenCurlyToken2.prototype.tokenType = \"{\";\n    function CloseCurlyToken2() {\n      this.value = \"}\";\n      this.mirror = \"{\";\n      return this;\n    }\n    CloseCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n    CloseCurlyToken2.prototype.tokenType = \"}\";\n    function OpenSquareToken2() {\n      this.value = \"[\";\n      this.mirror = \"]\";\n      return this;\n    }\n    OpenSquareToken2.prototype = Object.create(GroupingToken.prototype);\n    OpenSquareToken2.prototype.tokenType = \"[\";\n    function CloseSquareToken2() {\n      this.value = \"]\";\n      this.mirror = \"[\";\n      return this;\n    }\n    CloseSquareToken2.prototype = Object.create(GroupingToken.prototype);\n    CloseSquareToken2.prototype.tokenType = \"]\";\n    function OpenParenToken() {\n      this.value = \"(\";\n      this.mirror = \")\";\n      return this;\n    }\n    OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n    OpenParenToken.prototype.tokenType = \"(\";\n    function CloseParenToken2() {\n      this.value = \")\";\n      this.mirror = \"(\";\n      return this;\n    }\n    CloseParenToken2.prototype = Object.create(GroupingToken.prototype);\n    CloseParenToken2.prototype.tokenType = \")\";\n    function IncludeMatchToken() {\n      return this;\n    }\n    IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    IncludeMatchToken.prototype.tokenType = \"~=\";\n    function DashMatchToken() {\n      return this;\n    }\n    DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    DashMatchToken.prototype.tokenType = \"|=\";\n    function PrefixMatchToken() {\n      return this;\n    }\n    PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    PrefixMatchToken.prototype.tokenType = \"^=\";\n    function SuffixMatchToken() {\n      return this;\n    }\n    SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SuffixMatchToken.prototype.tokenType = \"$=\";\n    function SubstringMatchToken() {\n      return this;\n    }\n    SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n    SubstringMatchToken.prototype.tokenType = \"*=\";\n    function ColumnToken2() {\n      return this;\n    }\n    ColumnToken2.prototype = Object.create(CSSParserToken.prototype);\n    ColumnToken2.prototype.tokenType = \"||\";\n    function EOFToken2() {\n      return this;\n    }\n    EOFToken2.prototype = Object.create(CSSParserToken.prototype);\n    EOFToken2.prototype.tokenType = \"EOF\";\n    EOFToken2.prototype.toSource = function() {\n      return \"\";\n    };\n    function DelimToken2(code) {\n      this.value = stringFromCode(code);\n      return this;\n    }\n    DelimToken2.prototype = Object.create(CSSParserToken.prototype);\n    DelimToken2.prototype.tokenType = \"DELIM\";\n    DelimToken2.prototype.toString = function() {\n      return \"DELIM(\" + this.value + \")\";\n    };\n    DelimToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      return json;\n    };\n    DelimToken2.prototype.toSource = function() {\n      if (this.value == \"\\\\\")\n        return \"\\\\\\n\";\n      else\n        return this.value;\n    };\n    function StringValuedToken() {\n      throw \"Abstract Base Class\";\n    }\n    StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n    StringValuedToken.prototype.ASCIIMatch = function(str) {\n      return this.value.toLowerCase() == str.toLowerCase();\n    };\n    StringValuedToken.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      return json;\n    };\n    function IdentToken2(val) {\n      this.value = val;\n    }\n    IdentToken2.prototype = Object.create(StringValuedToken.prototype);\n    IdentToken2.prototype.tokenType = \"IDENT\";\n    IdentToken2.prototype.toString = function() {\n      return \"IDENT(\" + this.value + \")\";\n    };\n    IdentToken2.prototype.toSource = function() {\n      return escapeIdent(this.value);\n    };\n    function FunctionToken2(val) {\n      this.value = val;\n      this.mirror = \")\";\n    }\n    FunctionToken2.prototype = Object.create(StringValuedToken.prototype);\n    FunctionToken2.prototype.tokenType = \"FUNCTION\";\n    FunctionToken2.prototype.toString = function() {\n      return \"FUNCTION(\" + this.value + \")\";\n    };\n    FunctionToken2.prototype.toSource = function() {\n      return escapeIdent(this.value) + \"(\";\n    };\n    function AtKeywordToken2(val) {\n      this.value = val;\n    }\n    AtKeywordToken2.prototype = Object.create(StringValuedToken.prototype);\n    AtKeywordToken2.prototype.tokenType = \"AT-KEYWORD\";\n    AtKeywordToken2.prototype.toString = function() {\n      return \"AT(\" + this.value + \")\";\n    };\n    AtKeywordToken2.prototype.toSource = function() {\n      return \"@\" + escapeIdent(this.value);\n    };\n    function HashToken2(val) {\n      this.value = val;\n      this.type = \"unrestricted\";\n    }\n    HashToken2.prototype = Object.create(StringValuedToken.prototype);\n    HashToken2.prototype.tokenType = \"HASH\";\n    HashToken2.prototype.toString = function() {\n      return \"HASH(\" + this.value + \")\";\n    };\n    HashToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      return json;\n    };\n    HashToken2.prototype.toSource = function() {\n      if (this.type == \"id\") {\n        return \"#\" + escapeIdent(this.value);\n      } else {\n        return \"#\" + escapeHash(this.value);\n      }\n    };\n    function StringToken2(val) {\n      this.value = val;\n    }\n    StringToken2.prototype = Object.create(StringValuedToken.prototype);\n    StringToken2.prototype.tokenType = \"STRING\";\n    StringToken2.prototype.toString = function() {\n      return '\"' + escapeString(this.value) + '\"';\n    };\n    function URLToken2(val) {\n      this.value = val;\n    }\n    URLToken2.prototype = Object.create(StringValuedToken.prototype);\n    URLToken2.prototype.tokenType = \"URL\";\n    URLToken2.prototype.toString = function() {\n      return \"URL(\" + this.value + \")\";\n    };\n    URLToken2.prototype.toSource = function() {\n      return 'url(\"' + escapeString(this.value) + '\")';\n    };\n    function NumberToken2() {\n      this.value = null;\n      this.type = \"integer\";\n      this.repr = \"\";\n    }\n    NumberToken2.prototype = Object.create(CSSParserToken.prototype);\n    NumberToken2.prototype.tokenType = \"NUMBER\";\n    NumberToken2.prototype.toString = function() {\n      if (this.type == \"integer\")\n        return \"INT(\" + this.value + \")\";\n      return \"NUMBER(\" + this.value + \")\";\n    };\n    NumberToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      json.repr = this.repr;\n      return json;\n    };\n    NumberToken2.prototype.toSource = function() {\n      return this.repr;\n    };\n    function PercentageToken2() {\n      this.value = null;\n      this.repr = \"\";\n    }\n    PercentageToken2.prototype = Object.create(CSSParserToken.prototype);\n    PercentageToken2.prototype.tokenType = \"PERCENTAGE\";\n    PercentageToken2.prototype.toString = function() {\n      return \"PERCENTAGE(\" + this.value + \")\";\n    };\n    PercentageToken2.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.repr = this.repr;\n      return json;\n    };\n    PercentageToken2.prototype.toSource = function() {\n      return this.repr + \"%\";\n    };\n    function DimensionToken() {\n      this.value = null;\n      this.type = \"integer\";\n      this.repr = \"\";\n      this.unit = \"\";\n    }\n    DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n    DimensionToken.prototype.tokenType = \"DIMENSION\";\n    DimensionToken.prototype.toString = function() {\n      return \"DIM(\" + this.value + \",\" + this.unit + \")\";\n    };\n    DimensionToken.prototype.toJSON = function() {\n      var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n      json.value = this.value;\n      json.type = this.type;\n      json.repr = this.repr;\n      json.unit = this.unit;\n      return json;\n    };\n    DimensionToken.prototype.toSource = function() {\n      var source = this.repr;\n      var unit = escapeIdent(this.unit);\n      if (unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 48, 57))) {\n        unit = \"\\\\65 \" + unit.slice(1, unit.length);\n      }\n      return source + unit;\n    };\n    function escapeIdent(string) {\n      string = \"\" + string;\n      var result = \"\";\n      var firstcode = string.charCodeAt(0);\n      for (var i = 0; i < string.length; i++) {\n        var code = string.charCodeAt(i);\n        if (code == 0) {\n          throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n        }\n        if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {\n          result += \"\\\\\" + code.toString(16) + \" \";\n        } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n          result += string[i];\n        } else {\n          result += \"\\\\\" + string[i];\n        }\n      }\n      return result;\n    }\n    function escapeHash(string) {\n      string = \"\" + string;\n      var result = \"\";\n      var firstcode = string.charCodeAt(0);\n      for (var i = 0; i < string.length; i++) {\n        var code = string.charCodeAt(i);\n        if (code == 0) {\n          throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n        }\n        if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n          result += string[i];\n        } else {\n          result += \"\\\\\" + code.toString(16) + \" \";\n        }\n      }\n      return result;\n    }\n    function escapeString(string) {\n      string = \"\" + string;\n      var result = \"\";\n      for (var i = 0; i < string.length; i++) {\n        var code = string.charCodeAt(i);\n        if (code == 0) {\n          throw new InvalidCharacterError(\"Invalid character: the input contains U+0000.\");\n        }\n        if (between(code, 1, 31) || code == 127) {\n          result += \"\\\\\" + code.toString(16) + \" \";\n        } else if (code == 34 || code == 92) {\n          result += \"\\\\\" + string[i];\n        } else {\n          result += string[i];\n        }\n      }\n      return result;\n    }\n    exports2.tokenize = tokenize2;\n    exports2.IdentToken = IdentToken2;\n    exports2.FunctionToken = FunctionToken2;\n    exports2.AtKeywordToken = AtKeywordToken2;\n    exports2.HashToken = HashToken2;\n    exports2.StringToken = StringToken2;\n    exports2.BadStringToken = BadStringToken2;\n    exports2.URLToken = URLToken2;\n    exports2.BadURLToken = BadURLToken2;\n    exports2.DelimToken = DelimToken2;\n    exports2.NumberToken = NumberToken2;\n    exports2.PercentageToken = PercentageToken2;\n    exports2.DimensionToken = DimensionToken;\n    exports2.IncludeMatchToken = IncludeMatchToken;\n    exports2.DashMatchToken = DashMatchToken;\n    exports2.PrefixMatchToken = PrefixMatchToken;\n    exports2.SuffixMatchToken = SuffixMatchToken;\n    exports2.SubstringMatchToken = SubstringMatchToken;\n    exports2.ColumnToken = ColumnToken2;\n    exports2.WhitespaceToken = WhitespaceToken2;\n    exports2.CDOToken = CDOToken2;\n    exports2.CDCToken = CDCToken2;\n    exports2.ColonToken = ColonToken2;\n    exports2.SemicolonToken = SemicolonToken2;\n    exports2.CommaToken = CommaToken2;\n    exports2.OpenParenToken = OpenParenToken;\n    exports2.CloseParenToken = CloseParenToken2;\n    exports2.OpenSquareToken = OpenSquareToken2;\n    exports2.CloseSquareToken = CloseSquareToken2;\n    exports2.OpenCurlyToken = OpenCurlyToken2;\n    exports2.CloseCurlyToken = CloseCurlyToken2;\n    exports2.EOFToken = EOFToken2;\n    exports2.CSSParserToken = CSSParserToken;\n    exports2.GroupingToken = GroupingToken;\n  }\n});\n\n// packages/playwright-core/src/server/injected/selectorUtils.ts\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === \"SCRIPT\" || element.nodeName === \"NOSCRIPT\" || element.nodeName === \"STYLE\" || document.head && document.head.contains(element);\n}\nfunction elementText(cache, root) {\n  let value = cache.get(root);\n  if (value === void 0) {\n    value = { full: \"\", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = \"\";\n      if (root instanceof HTMLInputElement && (root.type === \"submit\" || root.type === \"button\")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || \"\";\n            currentImmediate += child.nodeValue || \"\";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = \"\";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(cache, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(cache, root.shadowRoot).full;\n      }\n    }\n    cache.set(root, value);\n  }\n  return value;\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kNthScore = 1e3;\nfunction querySelector(injectedScript, selector, ownerDocument) {\n  try {\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n    };\n  } catch (e) {\n    return {\n      selector,\n      elements: []\n    };\n  }\n}\nfunction generateSelector(injectedScript, targetElement, strict) {\n  injectedScript._evaluator.begin();\n  try {\n    targetElement = targetElement.closest(\"button,select,input,[role=button],[role=checkbox],[role=radio]\") || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, strict);\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement, strict);\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== \"/\");\n}\nfunction generateSelectorFor(injectedScript, targetElement, strict) {\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: \"css\", selector: \"html\", score: 1 }];\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map((token) => [token]) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildCandidates(injectedScript, element).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch, strict);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch, strict);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n  for (const attribute of [\"data-testid\", \"data-test-id\", \"data-test\"]) {\n    if (element.getAttribute(attribute))\n      candidates.push({ engine: \"css\", selector: `[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: 1 });\n  }\n  if (element.nodeName === \"INPUT\") {\n    const input = element;\n    if (input.placeholder)\n      candidates.push({ engine: \"css\", selector: `[placeholder=${quoteAttributeValue(input.placeholder)}]`, score: 10 });\n  }\n  if (element.getAttribute(\"aria-label\"))\n    candidates.push({ engine: \"css\", selector: `[aria-label=${quoteAttributeValue(element.getAttribute(\"aria-label\"))}]`, score: 10 });\n  if (element.getAttribute(\"alt\") && [\"APPLET\", \"AREA\", \"IMG\", \"INPUT\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[alt=${quoteAttributeValue(element.getAttribute(\"alt\"))}]`, score: 10 });\n  if (element.getAttribute(\"role\"))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[role=${quoteAttributeValue(element.getAttribute(\"role\"))}]`, score: 50 });\n  if (element.getAttribute(\"name\") && [\"BUTTON\", \"FORM\", \"FIELDSET\", \"FRAME\", \"IFRAME\", \"INPUT\", \"KEYGEN\", \"OBJECT\", \"OUTPUT\", \"SELECT\", \"TEXTAREA\", \"MAP\", \"META\", \"PARAM\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute(\"name\"))}]`, score: 50 });\n  if ([\"INPUT\", \"TEXTAREA\"].includes(element.nodeName) && element.getAttribute(\"type\") !== \"hidden\") {\n    if (element.getAttribute(\"type\"))\n      candidates.push({ engine: \"css\", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute(\"type\"))}]`, score: 50 });\n  }\n  if ([\"INPUT\", \"TEXTAREA\", \"SELECT\"].includes(element.nodeName))\n    candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: 50 });\n  const idAttr = element.getAttribute(\"id\");\n  if (idAttr && !isGuidLike(idAttr))\n    candidates.push({ engine: \"css\", selector: makeSelectorForId(idAttr), score: 100 });\n  candidates.push({ engine: \"css\", selector: cssEscape(element.nodeName.toLowerCase()), score: 200 });\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === \"SELECT\")\n    return [];\n  const text = elementText(injectedScript._evaluator._cacheText, element).full.trim().replace(/\\s+/g, \" \").substring(0, 80);\n  if (!text)\n    return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes('\"') || text.includes(\">>\") || text[0] === \"/\")\n    escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({ engine: \"text\", selector: escaped, score: 10 });\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLowerCase();\n    if (element.hasAttribute(\"role\"))\n      prefix += `[role=${quoteAttributeValue(element.getAttribute(\"role\"))}]`;\n    candidates.push({ engine: \"css\", selector: `${prefix}:has-text(\"${text}\")`, score: 30 });\n  }\n  return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n    return element.parentNode.host;\n  return null;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? \"#\" + id : `[id=\"${cssEscape(id)}\"]`;\n}\nfunction cssFallback(injectedScript, targetElement, strict) {\n  const kFallbackScore = 1e7;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(\" > \");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: \"css\", selector, score: kFallbackScore };\n    if (!strict)\n      return [token];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: \"nth\", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = \"\";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = \".\" + cssEscape(classes.slice(0, i + 1).join(\".\"));\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction quoteAttributeValue(text) {\n  return `\"${cssEscape(text).replace(/\\\\ /g, \" \")}\"`;\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = \"\";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== \"css\" || engine !== \"css\" || selector.startsWith(\":nth-match(\")))\n      parts.push(\">>\");\n    lastEngine = engine;\n    if (engine === \"css\")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(\" \");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch, strict) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const isStrictEnough = !strict || result.length === 1;\n    const index = result.indexOf(targetElement);\n    if (index === 0 && isStrictEnough) {\n      return tokens;\n    }\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: \"nth\", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === \"-\" || c === \"_\")\n      continue;\n    if (c >= \"a\" && c <= \"z\")\n      characterType = \"lower\";\n    else if (c >= \"A\" && c <= \"Z\")\n      characterType = \"upper\";\n    else if (c >= \"0\" && c <= \"9\")\n      characterType = \"digit\";\n    else\n      characterType = \"other\";\n    if (characterType === \"lower\" && lastCharacterType === \"upper\") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction cssEscape(s) {\n  let result = \"\";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return \"\\uFFFD\";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return \"\\\\\" + c.toString(16) + \" \";\n  if (i === 0 && c === 45 && s.length === 1)\n    return \"\\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return \"\\\\\" + s.charAt(i);\n}\n\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\nvar css = __toESM(require_cssTokenizer());\n\n// packages/playwright-core/src/server/isomorphic/selectorParser.ts\nfunction stringifySelector(selector) {\n  if (typeof selector === \"string\")\n    return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === \"css\" ? \"\" : p.name + \"=\";\n    return `${i === selector.capture ? \"*\" : \"\"}${prefix}${p.source}`;\n  }).join(\" >> \");\n}\n\n// packages/playwright-core/src/server/injected/highlight.ts\nvar Highlight = class {\n  constructor(injectedScript) {\n    this._highlightEntries = [];\n    this._injectedScript = injectedScript;\n    this._isUnderTest = injectedScript.isUnderTest;\n    this._glassPaneElement = document.createElement(\"x-pw-glass\");\n    this._glassPaneElement.style.position = \"fixed\";\n    this._glassPaneElement.style.top = \"0\";\n    this._glassPaneElement.style.right = \"0\";\n    this._glassPaneElement.style.bottom = \"0\";\n    this._glassPaneElement.style.left = \"0\";\n    this._glassPaneElement.style.zIndex = \"2147483647\";\n    this._glassPaneElement.style.pointerEvents = \"none\";\n    this._glassPaneElement.style.display = \"flex\";\n    this._actionPointElement = document.createElement(\"x-pw-action-point\");\n    this._actionPointElement.setAttribute(\"hidden\", \"true\");\n    this._glassPaneShadow = this._glassPaneElement.attachShadow({ mode: \"closed\" });\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n    const styleElement = document.createElement(\"style\");\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: 'Dank Mono', 'Operator Mono', Inconsolata, 'Fira Mono',\n                      'SF Mono', Monaco, 'Droid Sans Mono', 'Source Code Pro', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n    this._glassPaneShadow.appendChild(styleElement);\n  }\n  install() {\n    document.documentElement.appendChild(this._glassPaneElement);\n  }\n  runHighlightOnRaf(selector) {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this.updateHighlight(this._injectedScript.querySelectorAll(selector, document.documentElement), stringifySelector(selector), false);\n    this._rafRequest = requestAnimationFrame(() => this.runHighlightOnRaf(selector));\n  }\n  uninstall() {\n    if (this._rafRequest)\n      cancelAnimationFrame(this._rafRequest);\n    this._glassPaneElement.remove();\n  }\n  isInstalled() {\n    return this._glassPaneElement.parentElement === document.documentElement && !this._glassPaneElement.nextElementSibling;\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + \"px\";\n    this._actionPointElement.style.left = x + \"px\";\n    this._actionPointElement.hidden = false;\n    if (this._isUnderTest)\n      console.error(\"Action point for test: \" + JSON.stringify({ x, y }));\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  clearHighlight() {\n    var _a, _b;\n    for (const entry of this._highlightEntries) {\n      (_a = entry.highlightElement) == null ? void 0 : _a.remove();\n      (_b = entry.tooltipElement) == null ? void 0 : _b.remove();\n    }\n    this._highlightEntries = [];\n  }\n  updateHighlight(elements, selector, isRecording) {\n    let color;\n    if (isRecording)\n      color = \"#dc6f6f7f\";\n    else\n      color = elements.length > 1 ? \"#f6b26b7f\" : \"#6fa8dc7f\";\n    this._innerUpdateHighlight(elements, { color, tooltipText: selector });\n  }\n  maskElements(elements) {\n    this._innerUpdateHighlight(elements, { color: \"#F0F\" });\n  }\n  _innerUpdateHighlight(elements, options) {\n    if (this._highlightIsUpToDate(elements))\n      return;\n    this.clearHighlight();\n    for (let i = 0; i < elements.length; ++i) {\n      const highlightElement = this._createHighlightElement();\n      this._glassPaneShadow.appendChild(highlightElement);\n      let tooltipElement;\n      if (options.tooltipText) {\n        tooltipElement = document.createElement(\"x-pw-tooltip\");\n        this._glassPaneShadow.appendChild(tooltipElement);\n        const suffix = elements.length > 1 ? ` [${i + 1} of ${elements.length}]` : \"\";\n        tooltipElement.textContent = options.tooltipText + suffix;\n        tooltipElement.style.top = \"0\";\n        tooltipElement.style.left = \"0\";\n        tooltipElement.style.display = \"flex\";\n        if (this._isUnderTest)\n          console.error(\"Highlight text for test: \" + JSON.stringify(tooltipElement.textContent));\n      }\n      this._highlightEntries.push({ targetElement: elements[i], tooltipElement, highlightElement });\n    }\n    for (const entry of this._highlightEntries) {\n      entry.box = entry.targetElement.getBoundingClientRect();\n      if (!entry.tooltipElement)\n        continue;\n      const tooltipWidth = entry.tooltipElement.offsetWidth;\n      const tooltipHeight = entry.tooltipElement.offsetHeight;\n      const totalWidth = this._glassPaneElement.offsetWidth;\n      const totalHeight = this._glassPaneElement.offsetHeight;\n      let anchorLeft = entry.box.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\n        anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = entry.box.bottom + 5;\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        if (entry.box.top > tooltipHeight + 5) {\n          anchorTop = entry.box.top - tooltipHeight - 5;\n        } else {\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n      entry.tooltipTop = anchorTop;\n      entry.tooltipLeft = anchorLeft;\n    }\n    for (const entry of this._highlightEntries) {\n      if (entry.tooltipElement) {\n        entry.tooltipElement.style.top = entry.tooltipTop + \"px\";\n        entry.tooltipElement.style.left = entry.tooltipLeft + \"px\";\n      }\n      const box = entry.box;\n      entry.highlightElement.style.backgroundColor = options.color;\n      entry.highlightElement.style.left = box.x + \"px\";\n      entry.highlightElement.style.top = box.y + \"px\";\n      entry.highlightElement.style.width = box.width + \"px\";\n      entry.highlightElement.style.height = box.height + \"px\";\n      entry.highlightElement.style.display = \"block\";\n      if (this._isUnderTest)\n        console.error(\"Highlight box for test: \" + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n  }\n  _highlightIsUpToDate(elements) {\n    if (elements.length !== this._highlightEntries.length)\n      return false;\n    for (let i = 0; i < this._highlightEntries.length; ++i) {\n      if (elements[i] !== this._highlightEntries[i].targetElement)\n        return false;\n      const oldBox = this._highlightEntries[i].box;\n      if (!oldBox)\n        return false;\n      const box = elements[i].getBoundingClientRect();\n      if (box.top !== oldBox.top || box.right !== oldBox.right || box.bottom !== oldBox.bottom || box.left !== oldBox.left)\n        return false;\n    }\n    return true;\n  }\n  _createHighlightElement() {\n    const highlightElement = document.createElement(\"x-pw-highlight\");\n    highlightElement.style.position = \"absolute\";\n    highlightElement.style.top = \"0\";\n    highlightElement.style.left = \"0\";\n    highlightElement.style.width = \"0\";\n    highlightElement.style.height = \"0\";\n    highlightElement.style.boxSizing = \"border-box\";\n    return highlightElement;\n  }\n};\n\n// packages/playwright-core/src/server/injected/recorder.ts\nvar Recorder = class {\n  constructor(injectedScript) {\n    this._performingAction = false;\n    this._listeners = [];\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n    this._mode = \"none\";\n    this._injectedScript = injectedScript;\n    this._highlight = new Highlight(injectedScript);\n    this._refreshListenersIfNeeded();\n    injectedScript.onGlobalListenersRemoved.add(() => this._refreshListenersIfNeeded());\n    globalThis.__pw_refreshOverlay = () => {\n      this._pollRecorderMode().catch((e) => console.log(e));\n    };\n    globalThis.__pw_refreshOverlay();\n    if (injectedScript.isUnderTest)\n      console.error(\"Recorder script ready for test\");\n  }\n  _refreshListenersIfNeeded() {\n    if (this._highlight.isInstalled())\n      return;\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(document, \"click\", (event) => this._onClick(event), true),\n      addEventListener(document, \"auxclick\", (event) => this._onClick(event), true),\n      addEventListener(document, \"input\", (event) => this._onInput(event), true),\n      addEventListener(document, \"keydown\", (event) => this._onKeyDown(event), true),\n      addEventListener(document, \"keyup\", (event) => this._onKeyUp(event), true),\n      addEventListener(document, \"mousedown\", (event) => this._onMouseDown(event), true),\n      addEventListener(document, \"mouseup\", (event) => this._onMouseUp(event), true),\n      addEventListener(document, \"mousemove\", (event) => this._onMouseMove(event), true),\n      addEventListener(document, \"mouseleave\", (event) => this._onMouseLeave(event), true),\n      addEventListener(document, \"focus\", () => this._onFocus(), true),\n      addEventListener(document, \"scroll\", () => {\n        this._hoveredModel = null;\n        this._highlight.hideActionPoint();\n        this._updateHighlight();\n      }, true)\n    ];\n    this._highlight.install();\n  }\n  async _pollRecorderMode() {\n    var _a;\n    const pollPeriod = 1e3;\n    if (this._pollRecorderModeTimer)\n      clearTimeout(this._pollRecorderModeTimer);\n    const state = await globalThis.__pw_recorderState().catch((e) => null);\n    if (!state) {\n      this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n      return;\n    }\n    const { mode, actionPoint, actionSelector } = state;\n    if (mode !== this._mode) {\n      this._mode = mode;\n      this._clearHighlight();\n    }\n    if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {\n    } else if (!actionPoint && !this._actionPoint) {\n    } else {\n      if (actionPoint)\n        this._highlight.showActionPoint(actionPoint.x, actionPoint.y);\n      else\n        this._highlight.hideActionPoint();\n      this._actionPoint = actionPoint;\n    }\n    if (this._actionSelector && !((_a = this._hoveredModel) == null ? void 0 : _a.elements.length))\n      this._actionSelector = void 0;\n    if (actionSelector !== this._actionSelector) {\n      this._hoveredModel = actionSelector ? querySelector(this._injectedScript, actionSelector, document) : null;\n      this._updateHighlight();\n      this._actionSelector = actionSelector;\n    }\n    this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n  }\n  _clearHighlight() {\n    this._hoveredModel = null;\n    this._activeModel = null;\n    this._updateHighlight();\n  }\n  _actionInProgress(event) {\n    if (this._performingAction)\n      return true;\n    consumeEvent(event);\n    return false;\n  }\n  _consumedDueToNoModel(event, model) {\n    if (model)\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _consumedDueWrongTarget(event) {\n    if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _onClick(event) {\n    if (this._mode === \"inspecting\")\n      globalThis.__pw_recorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : \"\");\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    const checkbox = asCheckbox(this._deepEventTarget(event));\n    if (checkbox) {\n      this._performAction({\n        name: checkbox.checked ? \"check\" : \"uncheck\",\n        selector: this._hoveredModel.selector,\n        signals: []\n      });\n      return;\n    }\n    this._performAction({\n      name: \"click\",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._deepEventTarget(event);\n    if (this._mode === \"none\")\n      return true;\n    if (this._mode === \"inspecting\") {\n      consumeEvent(event);\n      return true;\n    }\n    const nodeName = target.nodeName;\n    if (nodeName === \"SELECT\")\n      return true;\n    if (nodeName === \"INPUT\" && [\"date\"].includes(target.type))\n      return true;\n    return false;\n  }\n  _onMouseDown(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingAction)\n      consumeEvent(event);\n    this._activeModel = this._hoveredModel;\n  }\n  _onMouseUp(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingAction)\n      consumeEvent(event);\n  }\n  _onMouseMove(event) {\n    if (this._mode === \"none\")\n      return;\n    const target = this._deepEventTarget(event);\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    this._updateModelForHoveredElement();\n  }\n  _onMouseLeave(event) {\n    if (this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n      this._hoveredElement = null;\n      this._updateModelForHoveredElement();\n    }\n  }\n  _onFocus() {\n    const activeElement = this._deepActiveElement(document);\n    const result = activeElement ? generateSelector(this._injectedScript, activeElement, true) : null;\n    this._activeModel = result && result.selector ? result : null;\n    if (this._injectedScript.isUnderTest)\n      console.error(\"Highlight updated for test: \" + (result ? result.selector : null));\n  }\n  _updateModelForHoveredElement() {\n    if (!this._hoveredElement) {\n      this._hoveredModel = null;\n      this._updateHighlight();\n      return;\n    }\n    const hoveredElement = this._hoveredElement;\n    const { selector, elements } = generateSelector(this._injectedScript, hoveredElement, true);\n    if (this._hoveredModel && this._hoveredModel.selector === selector || this._hoveredElement !== hoveredElement)\n      return;\n    this._hoveredModel = selector ? { selector, elements } : null;\n    this._updateHighlight();\n    if (this._injectedScript.isUnderTest)\n      console.error(\"Highlight updated for test: \" + selector);\n  }\n  _updateHighlight() {\n    const elements = this._hoveredModel ? this._hoveredModel.elements : [];\n    const selector = this._hoveredModel ? this._hoveredModel.selector : \"\";\n    this._highlight.updateHighlight(elements, selector, this._mode === \"recording\");\n  }\n  _onInput(event) {\n    if (this._mode !== \"recording\")\n      return true;\n    const target = this._deepEventTarget(event);\n    if ([\"INPUT\", \"TEXTAREA\"].includes(target.nodeName)) {\n      const inputElement = target;\n      const elementType = (inputElement.type || \"\").toLowerCase();\n      if ([\"checkbox\", \"radio\"].includes(elementType)) {\n        return;\n      }\n      if (elementType === \"file\") {\n        globalThis.__pw_recorderRecordAction({\n          name: \"setInputFiles\",\n          selector: this._activeModel.selector,\n          signals: [],\n          files: [...inputElement.files || []].map((file) => file.name)\n        });\n        return;\n      }\n      if (this._consumedDueWrongTarget(event))\n        return;\n      globalThis.__pw_recorderRecordAction({\n        name: \"fill\",\n        selector: this._activeModel.selector,\n        signals: [],\n        text: inputElement.value\n      });\n    }\n    if (target.nodeName === \"SELECT\") {\n      const selectElement = target;\n      if (this._actionInProgress(event))\n        return;\n      this._performAction({\n        name: \"select\",\n        selector: this._hoveredModel.selector,\n        options: [...selectElement.selectedOptions].map((option) => option.value),\n        signals: []\n      });\n    }\n  }\n  _shouldGenerateKeyPressFor(event) {\n    if ([\"Backspace\", \"Delete\", \"AltGraph\"].includes(event.key))\n      return false;\n    if (event.key === \"@\" && event.code === \"KeyL\")\n      return false;\n    if (navigator.platform.includes(\"Mac\")) {\n      if (event.key === \"v\" && event.metaKey)\n        return false;\n    } else {\n      if (event.key === \"v\" && event.ctrlKey)\n        return false;\n      if (event.key === \"Insert\" && event.shiftKey)\n        return false;\n    }\n    if ([\"Shift\", \"Control\", \"Meta\", \"Alt\", \"Process\"].includes(event.key))\n      return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier)\n      return !!asCheckbox(this._deepEventTarget(event));\n    return true;\n  }\n  _onKeyDown(event) {\n    if (this._mode === \"inspecting\") {\n      consumeEvent(event);\n      return;\n    }\n    if (this._mode !== \"recording\")\n      return;\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (this._actionInProgress(event)) {\n      this._expectProgrammaticKeyUp = true;\n      return;\n    }\n    if (this._consumedDueWrongTarget(event))\n      return;\n    if (event.key === \" \") {\n      const checkbox = asCheckbox(this._deepEventTarget(event));\n      if (checkbox) {\n        this._performAction({\n          name: checkbox.checked ? \"uncheck\" : \"check\",\n          selector: this._activeModel.selector,\n          signals: []\n        });\n        return;\n      }\n    }\n    this._performAction({\n      name: \"press\",\n      selector: this._activeModel.selector,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n  _onKeyUp(event) {\n    if (this._mode === \"none\")\n      return;\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (!this._expectProgrammaticKeyUp) {\n      consumeEvent(event);\n      return;\n    }\n    this._expectProgrammaticKeyUp = false;\n  }\n  async _performAction(action) {\n    this._clearHighlight();\n    this._performingAction = true;\n    await globalThis.__pw_recorderPerformAction(action).catch(() => {\n    });\n    this._performingAction = false;\n    this._updateModelForHoveredElement();\n    this._onFocus();\n    if (this._injectedScript.isUnderTest) {\n      console.error(\"Action performed for test: \" + JSON.stringify({\n        hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n        active: this._activeModel ? this._activeModel.selector : null\n      }));\n    }\n  }\n  _deepEventTarget(event) {\n    return event.composedPath()[0];\n  }\n  _deepActiveElement(document2) {\n    let activeElement = document2.activeElement;\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      activeElement = activeElement.shadowRoot.activeElement;\n    return activeElement;\n  }\n};\nfunction modifiersForEvent(event) {\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n  switch (event.which) {\n    case 1:\n      return \"left\";\n    case 2:\n      return \"middle\";\n    case 3:\n      return \"right\";\n  }\n  return \"left\";\n}\nfunction positionForEvent(event) {\n  const targetElement = event.target;\n  if (targetElement.nodeName !== \"CANVAS\")\n    return;\n  return {\n    x: event.offsetX,\n    y: event.offsetY\n  };\n}\nfunction consumeEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n  if (!node || node.nodeName !== \"INPUT\")\n    return null;\n  const inputElement = node;\n  return [\"checkbox\", \"radio\"].includes(inputElement.type) ? inputElement : null;\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n  target.addEventListener(eventName, listener, useCapture);\n  const remove = () => {\n    target.removeEventListener(eventName, listener, useCapture);\n  };\n  return remove;\n}\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners)\n    listener();\n  listeners.splice(0, listeners.length);\n}\nmodule.exports = Recorder;\n";
exports.source = source;

/***/ }),

/***/ 7186:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.source = void 0;
const source = "\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// packages/playwright-core/src/server/injected/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/server/isomorphic/utilityScriptSerializers.ts\nfunction source() {\n  function isRegExp(obj) {\n    return obj instanceof RegExp || Object.prototype.toString.call(obj) === \"[object RegExp]\";\n  }\n  function isDate(obj) {\n    return obj instanceof Date || Object.prototype.toString.call(obj) === \"[object Date]\";\n  }\n  function isURL(obj) {\n    return obj instanceof URL || Object.prototype.toString.call(obj) === \"[object URL]\";\n  }\n  function isError(obj) {\n    try {\n      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === \"Error\";\n    } catch (error) {\n      return false;\n    }\n  }\n  function parseEvaluationResultValue2(value, handles = [], refs = /* @__PURE__ */ new Map()) {\n    if (Object.is(value, void 0))\n      return void 0;\n    if (typeof value === \"object\" && value) {\n      if (\"ref\" in value)\n        return refs.get(value.ref);\n      if (\"v\" in value) {\n        if (value.v === \"undefined\")\n          return void 0;\n        if (value.v === \"null\")\n          return null;\n        if (value.v === \"NaN\")\n          return NaN;\n        if (value.v === \"Infinity\")\n          return Infinity;\n        if (value.v === \"-Infinity\")\n          return -Infinity;\n        if (value.v === \"-0\")\n          return -0;\n        return void 0;\n      }\n      if (\"d\" in value)\n        return new Date(value.d);\n      if (\"u\" in value)\n        return new URL(value.u);\n      if (\"r\" in value)\n        return new RegExp(value.r.p, value.r.f);\n      if (\"a\" in value) {\n        const result2 = [];\n        refs.set(value.id, result2);\n        for (const a of value.a)\n          result2.push(parseEvaluationResultValue2(a, handles, refs));\n        return result2;\n      }\n      if (\"o\" in value) {\n        const result2 = {};\n        refs.set(value.id, result2);\n        for (const { k, v } of value.o)\n          result2[k] = parseEvaluationResultValue2(v, handles, refs);\n        return result2;\n      }\n      if (\"h\" in value)\n        return handles[value.h];\n    }\n    return value;\n  }\n  function serializeAsCallArgument2(value, handleSerializer) {\n    return serialize(value, handleSerializer, { visited: /* @__PURE__ */ new Map(), lastId: 0 });\n  }\n  function serialize(value, handleSerializer, visitorInfo) {\n    if (value && typeof value === \"object\") {\n      if (globalThis.Window && value instanceof globalThis.Window)\n        return \"ref: <Window>\";\n      if (globalThis.Document && value instanceof globalThis.Document)\n        return \"ref: <Document>\";\n      if (globalThis.Node && value instanceof globalThis.Node)\n        return \"ref: <Node>\";\n    }\n    return innerSerialize(value, handleSerializer, visitorInfo);\n  }\n  function innerSerialize(value, handleSerializer, visitorInfo) {\n    const result2 = handleSerializer(value);\n    if (\"fallThrough\" in result2)\n      value = result2.fallThrough;\n    else\n      return result2;\n    if (typeof value === \"symbol\")\n      return { v: \"undefined\" };\n    if (Object.is(value, void 0))\n      return { v: \"undefined\" };\n    if (Object.is(value, null))\n      return { v: \"null\" };\n    if (Object.is(value, NaN))\n      return { v: \"NaN\" };\n    if (Object.is(value, Infinity))\n      return { v: \"Infinity\" };\n    if (Object.is(value, -Infinity))\n      return { v: \"-Infinity\" };\n    if (Object.is(value, -0))\n      return { v: \"-0\" };\n    if (typeof value === \"boolean\")\n      return value;\n    if (typeof value === \"number\")\n      return value;\n    if (typeof value === \"string\")\n      return value;\n    if (isError(value)) {\n      const error = value;\n      if (\"captureStackTrace\" in globalThis.Error) {\n        return error.stack || \"\";\n      }\n      return `${error.name}: ${error.message}\n${error.stack}`;\n    }\n    if (isDate(value))\n      return { d: value.toJSON() };\n    if (isURL(value))\n      return { u: value.toJSON() };\n    if (isRegExp(value))\n      return { r: { p: value.source, f: value.flags } };\n    const id = visitorInfo.visited.get(value);\n    if (id)\n      return { ref: id };\n    if (Array.isArray(value)) {\n      const a = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (let i = 0; i < value.length; ++i)\n        a.push(serialize(value[i], handleSerializer, visitorInfo));\n      return { a, id: id2 };\n    }\n    if (typeof value === \"object\") {\n      const o = [];\n      const id2 = ++visitorInfo.lastId;\n      visitorInfo.visited.set(value, id2);\n      for (const name of Object.keys(value)) {\n        let item;\n        try {\n          item = value[name];\n        } catch (e) {\n          continue;\n        }\n        if (name === \"toJSON\" && typeof item === \"function\")\n          o.push({ k: name, v: { o: [], id: 0 } });\n        else\n          o.push({ k: name, v: serialize(item, handleSerializer, visitorInfo) });\n      }\n      if (o.length === 0 && value.toJSON && typeof value.toJSON === \"function\")\n        return innerSerialize(value.toJSON(), handleSerializer, visitorInfo);\n      return { o, id: id2 };\n    }\n  }\n  return { parseEvaluationResultValue: parseEvaluationResultValue2, serializeAsCallArgument: serializeAsCallArgument2 };\n}\nvar result = source();\nvar parseEvaluationResultValue = result.parseEvaluationResultValue;\nvar serializeAsCallArgument = result.serializeAsCallArgument;\n\n// packages/playwright-core/src/server/injected/utilityScript.ts\nvar UtilityScript = class {\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = args.map((a) => parseEvaluationResultValue(a, handles));\n    let result2 = globalThis.eval(expression);\n    if (isFunction === true) {\n      result2 = result2(...parameters);\n    } else if (isFunction === false) {\n      result2 = result2;\n    } else {\n      if (typeof result2 === \"function\")\n        result2 = result2(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result2) : result2;\n  }\n  jsonValue(returnByValue, value) {\n    if (Object.is(value, void 0))\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === \"object\" && typeof value.then === \"function\") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\nmodule.exports = UtilityScript;\n";
exports.source = source;

/***/ }),

/***/ 9781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createInProcessPlaywright = createInProcessPlaywright;

var _server = __nccwpck_require__(4540);

var _connection = __nccwpck_require__(1776);

var _browserServerImpl = __nccwpck_require__(5309);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function createInProcessPlaywright() {
  const playwright = (0, _server.createPlaywright)('javascript');
  const clientConnection = new _connection.Connection();
  const dispatcherConnection = new _server.DispatcherConnection(true
  /* local */
  ); // Dispatch synchronously at first.

  dispatcherConnection.onmessage = message => clientConnection.dispatch(message);

  clientConnection.onmessage = message => dispatcherConnection.dispatch(message);

  const rootScope = new _server.Root(dispatcherConnection); // Initialize Playwright channel.

  new _server.PlaywrightDispatcher(rootScope, playwright);
  const playwrightAPI = clientConnection.getObjectWithKnownName('Playwright');
  playwrightAPI.chromium._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl('chromium');
  playwrightAPI.firefox._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl('firefox');
  playwrightAPI.webkit._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl('webkit'); // Switch to async dispatch after we got Playwright object.

  dispatcherConnection.onmessage = message => setImmediate(() => clientConnection.dispatch(message));

  clientConnection.onmessage = message => setImmediate(() => dispatcherConnection.dispatch(message));

  clientConnection.toImpl = x => x ? dispatcherConnection._dispatchers.get(x._guid)._object : dispatcherConnection._dispatchers.get('');

  playwrightAPI._toImpl = clientConnection.toImpl;
  return playwrightAPI;
}

/***/ }),

/***/ 2698:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";


var _inProcessFactory = __nccwpck_require__(9781);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
module.exports = (0, _inProcessFactory.createInProcessPlaywright)();

/***/ }),

/***/ 6272:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.pausesBeforeInputActions = exports.commandsWithTracingSnapshots = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This file is generated by generate_channels.js, do not edit manually.
// ----------- Initializer Traits -----------
// ----------- Event Traits -----------
// ----------- EventTarget Traits -----------
// ----------- APIRequestContext -----------
// ----------- LocalUtils -----------
// ----------- Root -----------
// ----------- Playwright -----------
// ----------- SocksSupport -----------
// ----------- Selectors -----------
// ----------- BrowserType -----------
// ----------- Browser -----------
// ----------- EventTarget -----------
// ----------- BrowserContext -----------
// ----------- Page -----------
// ----------- Frame -----------
// ----------- Worker -----------
// ----------- JSHandle -----------
// ----------- ElementHandle -----------
// ----------- Request -----------
// ----------- Route -----------
// ----------- Response -----------
// ----------- WebSocket -----------
// ----------- ConsoleMessage -----------
// ----------- BindingCall -----------
// ----------- Dialog -----------
// ----------- Tracing -----------
// ----------- Artifact -----------
// ----------- Stream -----------
// ----------- WritableStream -----------
// ----------- CDPSession -----------
// ----------- Electron -----------
// ----------- ElectronApplication -----------
// ----------- Android -----------
// ----------- AndroidSocket -----------
// ----------- AndroidDevice -----------
// ----------- JsonPipe -----------
const commandsWithTracingSnapshots = new Set(['EventTarget.waitForEventInfo', 'BrowserContext.waitForEventInfo', 'Page.waitForEventInfo', 'WebSocket.waitForEventInfo', 'ElectronApplication.waitForEventInfo', 'AndroidDevice.waitForEventInfo', 'Page.goBack', 'Page.goForward', 'Page.reload', 'Page.expectScreenshot', 'Page.screenshot', 'Page.setViewportSize', 'Page.keyboardDown', 'Page.keyboardUp', 'Page.keyboardInsertText', 'Page.keyboardType', 'Page.keyboardPress', 'Page.mouseMove', 'Page.mouseDown', 'Page.mouseUp', 'Page.mouseClick', 'Page.mouseWheel', 'Page.touchscreenTap', 'Frame.evalOnSelector', 'Frame.evalOnSelectorAll', 'Frame.addScriptTag', 'Frame.addStyleTag', 'Frame.check', 'Frame.click', 'Frame.dragAndDrop', 'Frame.dblclick', 'Frame.dispatchEvent', 'Frame.evaluateExpression', 'Frame.evaluateExpressionHandle', 'Frame.fill', 'Frame.focus', 'Frame.getAttribute', 'Frame.goto', 'Frame.hover', 'Frame.innerHTML', 'Frame.innerText', 'Frame.inputValue', 'Frame.isChecked', 'Frame.isDisabled', 'Frame.isEnabled', 'Frame.isHidden', 'Frame.isVisible', 'Frame.isEditable', 'Frame.press', 'Frame.selectOption', 'Frame.setContent', 'Frame.setInputFiles', 'Frame.setInputFilePaths', 'Frame.tap', 'Frame.textContent', 'Frame.type', 'Frame.uncheck', 'Frame.waitForTimeout', 'Frame.waitForFunction', 'Frame.waitForSelector', 'Frame.expect', 'JSHandle.evaluateExpression', 'ElementHandle.evaluateExpression', 'JSHandle.evaluateExpressionHandle', 'ElementHandle.evaluateExpressionHandle', 'ElementHandle.evalOnSelector', 'ElementHandle.evalOnSelectorAll', 'ElementHandle.check', 'ElementHandle.click', 'ElementHandle.dblclick', 'ElementHandle.dispatchEvent', 'ElementHandle.fill', 'ElementHandle.hover', 'ElementHandle.innerHTML', 'ElementHandle.innerText', 'ElementHandle.inputValue', 'ElementHandle.isChecked', 'ElementHandle.isDisabled', 'ElementHandle.isEditable', 'ElementHandle.isEnabled', 'ElementHandle.isHidden', 'ElementHandle.isVisible', 'ElementHandle.press', 'ElementHandle.screenshot', 'ElementHandle.scrollIntoViewIfNeeded', 'ElementHandle.selectOption', 'ElementHandle.selectText', 'ElementHandle.setInputFiles', 'ElementHandle.setInputFilePaths', 'ElementHandle.tap', 'ElementHandle.textContent', 'ElementHandle.type', 'ElementHandle.uncheck', 'ElementHandle.waitForElementState', 'ElementHandle.waitForSelector']);
exports.commandsWithTracingSnapshots = commandsWithTracingSnapshots;
const pausesBeforeInputActions = new Set(['Frame.check', 'Frame.click', 'Frame.dragAndDrop', 'Frame.dblclick', 'Frame.fill', 'Frame.hover', 'Frame.press', 'Frame.selectOption', 'Frame.setInputFiles', 'Frame.setInputFilePaths', 'Frame.tap', 'Frame.type', 'Frame.uncheck', 'ElementHandle.check', 'ElementHandle.click', 'ElementHandle.dblclick', 'ElementHandle.fill', 'ElementHandle.hover', 'ElementHandle.press', 'ElementHandle.selectOption', 'ElementHandle.setInputFiles', 'ElementHandle.setInputFilePaths', 'ElementHandle.tap', 'ElementHandle.type', 'ElementHandle.uncheck']);
exports.pausesBeforeInputActions = pausesBeforeInputActions;

/***/ }),

/***/ 5644:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.parseError = parseError;
exports.parseSerializedValue = parseSerializedValue;
exports.serializeError = serializeError;
exports.serializeValue = serializeValue;

var _errors = __nccwpck_require__(542);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function serializeError(e) {
  if (isError(e)) return {
    error: {
      message: e.message,
      stack: e.stack,
      name: e.name
    }
  };
  return {
    value: serializeValue(e, value => ({
      fallThrough: value
    }))
  };
}

function parseError(error) {
  if (!error.error) {
    if (error.value === undefined) throw new Error('Serialized error must have either an error or a value');
    return parseSerializedValue(error.value, undefined);
  }

  if (error.error.name === 'TimeoutError') {
    const e = new _errors.TimeoutError(error.error.message);
    e.stack = error.error.stack || '';
    return e;
  }

  const e = new Error(error.error.message);
  e.stack = error.error.stack || '';
  e.name = error.error.name;
  return e;
}

function parseSerializedValue(value, handles) {
  return innerParseSerializedValue(value, handles, new Map());
}

function innerParseSerializedValue(value, handles, refs) {
  if (value.ref !== undefined) return refs.get(value.ref);
  if (value.n !== undefined) return value.n;
  if (value.s !== undefined) return value.s;
  if (value.b !== undefined) return value.b;

  if (value.v !== undefined) {
    if (value.v === 'undefined') return undefined;
    if (value.v === 'null') return null;
    if (value.v === 'NaN') return NaN;
    if (value.v === 'Infinity') return Infinity;
    if (value.v === '-Infinity') return -Infinity;
    if (value.v === '-0') return -0;
  }

  if (value.d !== undefined) return new Date(value.d);
  if (value.u !== undefined) return new URL(value.u);
  if (value.r !== undefined) return new RegExp(value.r.p, value.r.f);

  if (value.a !== undefined) {
    const result = [];
    refs.set(value.id, result);

    for (const v of value.a) result.push(innerParseSerializedValue(v, handles, refs));

    return result;
  }

  if (value.o !== undefined) {
    const result = {};
    refs.set(value.id, result);

    for (const {
      k,
      v
    } of value.o) result[k] = innerParseSerializedValue(v, handles, refs);

    return result;
  }

  if (value.h !== undefined) {
    if (handles === undefined) throw new Error('Unexpected handle');
    return handles[value.h];
  }

  throw new Error('Unexpected value');
}

function serializeValue(value, handleSerializer) {
  return innerSerializeValue(value, handleSerializer, {
    lastId: 0,
    visited: new Map()
  });
}

function innerSerializeValue(value, handleSerializer, visitorInfo) {
  const handle = handleSerializer(value);
  if ('fallThrough' in handle) value = handle.fallThrough;else return handle;
  if (typeof value === 'symbol') return {
    v: 'undefined'
  };
  if (Object.is(value, undefined)) return {
    v: 'undefined'
  };
  if (Object.is(value, null)) return {
    v: 'null'
  };
  if (Object.is(value, NaN)) return {
    v: 'NaN'
  };
  if (Object.is(value, Infinity)) return {
    v: 'Infinity'
  };
  if (Object.is(value, -Infinity)) return {
    v: '-Infinity'
  };
  if (Object.is(value, -0)) return {
    v: '-0'
  };
  if (typeof value === 'boolean') return {
    b: value
  };
  if (typeof value === 'number') return {
    n: value
  };
  if (typeof value === 'string') return {
    s: value
  };

  if (isError(value)) {
    const error = value;

    if ('captureStackTrace' in globalThis.Error) {
      // v8
      return {
        s: error.stack || ''
      };
    }

    return {
      s: `${error.name}: ${error.message}\n${error.stack}`
    };
  }

  if (isDate(value)) return {
    d: value.toJSON()
  };
  if (isURL(value)) return {
    u: value.toJSON()
  };
  if (isRegExp(value)) return {
    r: {
      p: value.source,
      f: value.flags
    }
  };
  const id = visitorInfo.visited.get(value);
  if (id) return {
    ref: id
  };

  if (Array.isArray(value)) {
    const a = [];
    const id = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id);

    for (let i = 0; i < value.length; ++i) a.push(innerSerializeValue(value[i], handleSerializer, visitorInfo));

    return {
      a,
      id
    };
  }

  if (typeof value === 'object') {
    const o = [];
    const id = ++visitorInfo.lastId;
    visitorInfo.visited.set(value, id);

    for (const name of Object.keys(value)) o.push({
      k: name,
      v: innerSerializeValue(value[name], handleSerializer, visitorInfo)
    });

    return {
      o,
      id
    };
  }

  throw new Error('Unexpected value');
}

function isRegExp(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
}

function isDate(obj) {
  return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
}

function isURL(obj) {
  return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';
}

function isError(obj) {
  var _obj$__proto__;

  return obj instanceof Error || (obj === null || obj === void 0 ? void 0 : (_obj$__proto__ = obj.__proto__) === null || _obj$__proto__ === void 0 ? void 0 : _obj$__proto__.name) === 'Error' || (obj === null || obj === void 0 ? void 0 : obj.__proto__) && isError(obj.__proto__);
}

/***/ }),

/***/ 3086:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PipeTransport = exports.IpcTransport = void 0;

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PipeTransport {
  constructor(pipeWrite, pipeRead, closeable, endian = 'le') {
    this._pipeWrite = void 0;
    this._data = Buffer.from([]);
    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
    this._closed = false;
    this._bytesLeft = 0;
    this.onmessage = void 0;
    this.onclose = void 0;
    this._endian = void 0;
    this._closeableStream = void 0;
    this._pipeWrite = pipeWrite;
    this._endian = endian;
    this._closeableStream = closeable;
    pipeRead.on('data', buffer => this._dispatch(buffer));
    pipeRead.on('close', () => {
      this._closed = true;
      if (this.onclose) this.onclose();
    });
    this.onmessage = undefined;
    this.onclose = undefined;
  }

  send(message) {
    if (this._closed) throw new Error('Pipe has been closed');
    const data = Buffer.from(message, 'utf-8');
    const dataLength = Buffer.alloc(4);
    if (this._endian === 'be') dataLength.writeUInt32BE(data.length, 0);else dataLength.writeUInt32LE(data.length, 0);

    this._pipeWrite.write(dataLength);

    this._pipeWrite.write(data);
  }

  close() {
    // Let it throw.
    this._closeableStream.close();
  }

  _dispatch(buffer) {
    this._data = Buffer.concat([this._data, buffer]);

    while (true) {
      if (!this._bytesLeft && this._data.length < 4) {
        // Need more data.
        break;
      }

      if (!this._bytesLeft) {
        this._bytesLeft = this._endian === 'be' ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
        this._data = this._data.slice(4);
      }

      if (!this._bytesLeft || this._data.length < this._bytesLeft) {
        // Need more data.
        break;
      }

      const message = this._data.slice(0, this._bytesLeft);

      this._data = this._data.slice(this._bytesLeft);
      this._bytesLeft = 0;

      this._waitForNextTask(() => {
        if (this.onmessage) this.onmessage(message.toString('utf-8'));
      });
    }
  }

}

exports.PipeTransport = PipeTransport;

class IpcTransport {
  constructor(process) {
    this._process = void 0;
    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
    this.onmessage = void 0;
    this.onclose = void 0;
    this._process = process;

    this._process.on('message', message => this._waitForNextTask(() => {
      var _this$onclose, _this$onmessage;

      if (message === '<eof>') (_this$onclose = this.onclose) === null || _this$onclose === void 0 ? void 0 : _this$onclose.call(this);else (_this$onmessage = this.onmessage) === null || _this$onmessage === void 0 ? void 0 : _this$onmessage.call(this, message);
    }));
  }

  send(message) {
    this._process.send(message);
  }

  close() {
    this._process.send('<eof>');
  }

}

exports.IpcTransport = IpcTransport;

/***/ }),

/***/ 7989:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "ValidationError", ({
  enumerable: true,
  get: function () {
    return _validatorPrimitives.ValidationError;
  }
}));
Object.defineProperty(exports, "createMetadataValidator", ({
  enumerable: true,
  get: function () {
    return _validatorPrimitives.createMetadataValidator;
  }
}));
Object.defineProperty(exports, "findValidator", ({
  enumerable: true,
  get: function () {
    return _validatorPrimitives.findValidator;
  }
}));
Object.defineProperty(exports, "maybeFindValidator", ({
  enumerable: true,
  get: function () {
    return _validatorPrimitives.maybeFindValidator;
  }
}));

var _validatorPrimitives = __nccwpck_require__(2209);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// This file is generated by generate_channels.js, do not edit manually.
_validatorPrimitives.scheme.StackFrame = (0, _validatorPrimitives.tObject)({
  file: _validatorPrimitives.tString,
  line: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  column: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  function: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.Metadata = (0, _validatorPrimitives.tObject)({
  stack: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('StackFrame'))),
  apiName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  internal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.Point = (0, _validatorPrimitives.tObject)({
  x: _validatorPrimitives.tNumber,
  y: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.Rect = (0, _validatorPrimitives.tObject)({
  x: _validatorPrimitives.tNumber,
  y: _validatorPrimitives.tNumber,
  width: _validatorPrimitives.tNumber,
  height: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.SerializedValue = (0, _validatorPrimitives.tObject)({
  n: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  b: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  s: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  v: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['null', 'undefined', 'NaN', 'Infinity', '-Infinity', '-0'])),
  d: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  u: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  r: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    p: _validatorPrimitives.tString,
    f: _validatorPrimitives.tString
  })),
  a: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SerializedValue'))),
  o: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    k: _validatorPrimitives.tString,
    v: (0, _validatorPrimitives.tType)('SerializedValue')
  }))),
  h: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  id: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  ref: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.SerializedArgument = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue'),
  handles: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)('*'))
});
_validatorPrimitives.scheme.ExpectedTextValue = (0, _validatorPrimitives.tObject)({
  string: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  matchSubstring: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  ignoreCase: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  normalizeWhiteSpace: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.AXNode = (0, _validatorPrimitives.tObject)({
  role: _validatorPrimitives.tString,
  name: _validatorPrimitives.tString,
  valueString: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  valueNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  description: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  keyshortcuts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  roledescription: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  valuetext: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  disabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  expanded: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  multiline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  multiselectable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  readonly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  required: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  checked: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['checked', 'unchecked', 'mixed'])),
  pressed: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['pressed', 'released', 'mixed'])),
  level: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  valuemin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  valuemax: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  autocomplete: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  haspopup: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  invalid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  orientation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('AXNode')))
});
_validatorPrimitives.scheme.SetNetworkCookie = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  value: _validatorPrimitives.tString,
  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  domain: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  expires: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  httpOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  secure: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  sameSite: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['Strict', 'Lax', 'None']))
});
_validatorPrimitives.scheme.NetworkCookie = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  value: _validatorPrimitives.tString,
  domain: _validatorPrimitives.tString,
  path: _validatorPrimitives.tString,
  expires: _validatorPrimitives.tNumber,
  httpOnly: _validatorPrimitives.tBoolean,
  secure: _validatorPrimitives.tBoolean,
  sameSite: (0, _validatorPrimitives.tEnum)(['Strict', 'Lax', 'None'])
});
_validatorPrimitives.scheme.NameValue = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.OriginStorage = (0, _validatorPrimitives.tObject)({
  origin: _validatorPrimitives.tString,
  localStorage: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.SerializedError = (0, _validatorPrimitives.tObject)({
  error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    message: _validatorPrimitives.tString,
    name: _validatorPrimitives.tString,
    stack: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })),
  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedValue'))
});
_validatorPrimitives.scheme.RecordHarOptions = (0, _validatorPrimitives.tObject)({
  path: _validatorPrimitives.tString,
  content: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['embed', 'attach', 'omit'])),
  mode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['full', 'minimal'])),
  urlGlob: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  urlRegexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  urlRegexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FormField = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  file: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    name: _validatorPrimitives.tString,
    mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    buffer: _validatorPrimitives.tBinary
  }))
});
_validatorPrimitives.scheme.APIRequestContextInitializer = (0, _validatorPrimitives.tObject)({
  tracing: (0, _validatorPrimitives.tChannel)(['Tracing'])
});
_validatorPrimitives.scheme.APIRequestContextFetchParams = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString,
  params: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  jsonData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
  formData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  multipartData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('FormField'))),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  failOnStatusCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.APIRequestContextFetchResult = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tType)('APIResponse')
});
_validatorPrimitives.scheme.APIRequestContextFetchResponseBodyParams = (0, _validatorPrimitives.tObject)({
  fetchUid: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.APIRequestContextFetchResponseBodyResult = (0, _validatorPrimitives.tObject)({
  binary: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
});
_validatorPrimitives.scheme.APIRequestContextFetchLogParams = (0, _validatorPrimitives.tObject)({
  fetchUid: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.APIRequestContextFetchLogResult = (0, _validatorPrimitives.tObject)({
  log: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.APIRequestContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.APIRequestContextStorageStateResult = (0, _validatorPrimitives.tObject)({
  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie')),
  origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage'))
});
_validatorPrimitives.scheme.APIRequestContextDisposeAPIResponseParams = (0, _validatorPrimitives.tObject)({
  fetchUid: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.APIRequestContextDisposeAPIResponseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.APIRequestContextDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.APIRequestContextDisposeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.APIResponse = (0, _validatorPrimitives.tObject)({
  fetchUid: _validatorPrimitives.tString,
  url: _validatorPrimitives.tString,
  status: _validatorPrimitives.tNumber,
  statusText: _validatorPrimitives.tString,
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.LifecycleEvent = (0, _validatorPrimitives.tEnum)(['load', 'domcontentloaded', 'networkidle', 'commit']);
_validatorPrimitives.scheme.LocalUtilsInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.LocalUtilsZipParams = (0, _validatorPrimitives.tObject)({
  zipFile: _validatorPrimitives.tString,
  entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.LocalUtilsZipResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.LocalUtilsHarOpenParams = (0, _validatorPrimitives.tObject)({
  file: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.LocalUtilsHarOpenResult = (0, _validatorPrimitives.tObject)({
  harId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.LocalUtilsHarLookupParams = (0, _validatorPrimitives.tObject)({
  harId: _validatorPrimitives.tString,
  url: _validatorPrimitives.tString,
  method: _validatorPrimitives.tString,
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')),
  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  isNavigationRequest: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.LocalUtilsHarLookupResult = (0, _validatorPrimitives.tObject)({
  action: (0, _validatorPrimitives.tEnum)(['error', 'redirect', 'fulfill', 'noentry']),
  message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  redirectURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
});
_validatorPrimitives.scheme.LocalUtilsHarCloseParams = (0, _validatorPrimitives.tObject)({
  harId: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.LocalUtilsHarCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.LocalUtilsHarUnzipParams = (0, _validatorPrimitives.tObject)({
  zipFile: _validatorPrimitives.tString,
  harFile: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.LocalUtilsHarUnzipResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RootInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RootInitializeParams = (0, _validatorPrimitives.tObject)({
  sdkLanguage: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.RootInitializeResult = (0, _validatorPrimitives.tObject)({
  playwright: (0, _validatorPrimitives.tChannel)(['Playwright'])
});
_validatorPrimitives.scheme.PlaywrightInitializer = (0, _validatorPrimitives.tObject)({
  chromium: (0, _validatorPrimitives.tChannel)(['BrowserType']),
  firefox: (0, _validatorPrimitives.tChannel)(['BrowserType']),
  webkit: (0, _validatorPrimitives.tChannel)(['BrowserType']),
  android: (0, _validatorPrimitives.tChannel)(['Android']),
  electron: (0, _validatorPrimitives.tChannel)(['Electron']),
  utils: (0, _validatorPrimitives.tChannel)(['LocalUtils']),
  deviceDescriptors: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    name: _validatorPrimitives.tString,
    descriptor: (0, _validatorPrimitives.tObject)({
      userAgent: _validatorPrimitives.tString,
      viewport: (0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      }),
      screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      })),
      deviceScaleFactor: _validatorPrimitives.tNumber,
      isMobile: _validatorPrimitives.tBoolean,
      hasTouch: _validatorPrimitives.tBoolean,
      defaultBrowserType: (0, _validatorPrimitives.tEnum)(['chromium', 'firefox', 'webkit'])
    })
  })),
  selectors: (0, _validatorPrimitives.tChannel)(['Selectors']),
  preLaunchedBrowser: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Browser'])),
  socksSupport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['SocksSupport']))
});
_validatorPrimitives.scheme.PlaywrightNewRequestParams = (0, _validatorPrimitives.tObject)({
  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  })),
  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    server: _validatorPrimitives.tString,
    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie')),
    origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage'))
  })),
  tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.PlaywrightNewRequestResult = (0, _validatorPrimitives.tObject)({
  request: (0, _validatorPrimitives.tChannel)(['APIRequestContext'])
});
_validatorPrimitives.scheme.PlaywrightHideHighlightParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PlaywrightHideHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SocksSupportInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SocksSupportSocksRequestedEvent = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString,
  host: _validatorPrimitives.tString,
  port: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.SocksSupportSocksDataEvent = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString,
  data: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.SocksSupportSocksClosedEvent = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.SocksSupportSocksConnectedParams = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString,
  host: _validatorPrimitives.tString,
  port: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.SocksSupportSocksConnectedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SocksSupportSocksFailedParams = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString,
  errorCode: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.SocksSupportSocksFailedResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SocksSupportSocksDataParams = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString,
  data: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.SocksSupportSocksDataResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SocksSupportSocksErrorParams = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString,
  error: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.SocksSupportSocksErrorResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SocksSupportSocksEndParams = (0, _validatorPrimitives.tObject)({
  uid: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.SocksSupportSocksEndResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SelectorsInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.SelectorsRegisterParams = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  source: _validatorPrimitives.tString,
  contentScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.SelectorsRegisterResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserTypeInitializer = (0, _validatorPrimitives.tObject)({
  executablePath: _validatorPrimitives.tString,
  name: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.BrowserTypeConnectParams = (0, _validatorPrimitives.tObject)({
  wsEndpoint: _validatorPrimitives.tString,
  headers: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  socksProxyRedirectPortForTest: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.BrowserTypeConnectResult = (0, _validatorPrimitives.tObject)({
  pipe: (0, _validatorPrimitives.tChannel)(['JsonPipe'])
});
_validatorPrimitives.scheme.BrowserTypeLaunchParams = (0, _validatorPrimitives.tObject)({
  channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    server: _validatorPrimitives.tString,
    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })),
  downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  firefoxUserPrefs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.BrowserTypeLaunchResult = (0, _validatorPrimitives.tObject)({
  browser: (0, _validatorPrimitives.tChannel)(['Browser'])
});
_validatorPrimitives.scheme.BrowserTypeLaunchPersistentContextParams = (0, _validatorPrimitives.tObject)({
  channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    server: _validatorPrimitives.tString,
    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })),
  downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    longitude: _validatorPrimitives.tNumber,
    latitude: _validatorPrimitives.tNumber,
    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  })),
  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference'])),
  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference'])),
  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none'])),
  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    dir: _validatorPrimitives.tString,
    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
      width: _validatorPrimitives.tNumber,
      height: _validatorPrimitives.tNumber
    }))
  })),
  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),
  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),
  userDataDir: _validatorPrimitives.tString,
  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.BrowserTypeLaunchPersistentContextResult = (0, _validatorPrimitives.tObject)({
  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])
});
_validatorPrimitives.scheme.BrowserTypeConnectOverCDPParams = (0, _validatorPrimitives.tObject)({
  endpointURL: _validatorPrimitives.tString,
  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.BrowserTypeConnectOverCDPResult = (0, _validatorPrimitives.tObject)({
  browser: (0, _validatorPrimitives.tChannel)(['Browser']),
  defaultContext: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['BrowserContext']))
});
_validatorPrimitives.scheme.BrowserInitializer = (0, _validatorPrimitives.tObject)({
  version: _validatorPrimitives.tString,
  name: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.BrowserCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserKillForTestsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserKillForTestsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserNewContextParams = (0, _validatorPrimitives.tObject)({
  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    longitude: _validatorPrimitives.tNumber,
    latitude: _validatorPrimitives.tNumber,
    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  })),
  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference'])),
  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference'])),
  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none'])),
  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    dir: _validatorPrimitives.tString,
    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
      width: _validatorPrimitives.tNumber,
      height: _validatorPrimitives.tNumber
    }))
  })),
  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),
  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),
  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    server: _validatorPrimitives.tString,
    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })),
  storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SetNetworkCookie'))),
    origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage')))
  }))
});
_validatorPrimitives.scheme.BrowserNewContextResult = (0, _validatorPrimitives.tObject)({
  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])
});
_validatorPrimitives.scheme.BrowserNewContextForReuseParams = (0, _validatorPrimitives.tObject)({
  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    longitude: _validatorPrimitives.tNumber,
    latitude: _validatorPrimitives.tNumber,
    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  })),
  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference'])),
  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference'])),
  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none'])),
  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    dir: _validatorPrimitives.tString,
    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
      width: _validatorPrimitives.tNumber,
      height: _validatorPrimitives.tNumber
    }))
  })),
  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),
  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),
  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    server: _validatorPrimitives.tString,
    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })),
  storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SetNetworkCookie'))),
    origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage')))
  }))
});
_validatorPrimitives.scheme.BrowserNewContextForReuseResult = (0, _validatorPrimitives.tObject)({
  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])
});
_validatorPrimitives.scheme.BrowserNewBrowserCDPSessionParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserNewBrowserCDPSessionResult = (0, _validatorPrimitives.tObject)({
  session: (0, _validatorPrimitives.tChannel)(['CDPSession'])
});
_validatorPrimitives.scheme.BrowserStartTracingParams = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page'])),
  path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  categories: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
});
_validatorPrimitives.scheme.BrowserStartTracingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserStopTracingParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserStopTracingResult = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.EventTargetInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.EventTargetWaitForEventInfoParams = (0, _validatorPrimitives.tObject)({
  info: (0, _validatorPrimitives.tObject)({
    waitId: _validatorPrimitives.tString,
    phase: (0, _validatorPrimitives.tEnum)(['before', 'after', 'log']),
    event: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  })
});
_validatorPrimitives.scheme.BrowserContextWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');
_validatorPrimitives.scheme.PageWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');
_validatorPrimitives.scheme.WebSocketWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');
_validatorPrimitives.scheme.ElectronApplicationWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');
_validatorPrimitives.scheme.AndroidDeviceWaitForEventInfoParams = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoParams');
_validatorPrimitives.scheme.EventTargetWaitForEventInfoResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');
_validatorPrimitives.scheme.PageWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');
_validatorPrimitives.scheme.WebSocketWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');
_validatorPrimitives.scheme.ElectronApplicationWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');
_validatorPrimitives.scheme.AndroidDeviceWaitForEventInfoResult = (0, _validatorPrimitives.tType)('EventTargetWaitForEventInfoResult');
_validatorPrimitives.scheme.BrowserContextInitializer = (0, _validatorPrimitives.tObject)({
  isChromium: _validatorPrimitives.tBoolean,
  requestContext: (0, _validatorPrimitives.tChannel)(['APIRequestContext']),
  tracing: (0, _validatorPrimitives.tChannel)(['Tracing'])
});
_validatorPrimitives.scheme.BrowserContextBindingCallEvent = (0, _validatorPrimitives.tObject)({
  binding: (0, _validatorPrimitives.tChannel)(['BindingCall'])
});
_validatorPrimitives.scheme.BrowserContextCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextPageEvent = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tChannel)(['Page'])
});
_validatorPrimitives.scheme.BrowserContextRouteEvent = (0, _validatorPrimitives.tObject)({
  route: (0, _validatorPrimitives.tChannel)(['Route']),
  request: (0, _validatorPrimitives.tChannel)(['Request'])
});
_validatorPrimitives.scheme.BrowserContextVideoEvent = (0, _validatorPrimitives.tObject)({
  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])
});
_validatorPrimitives.scheme.BrowserContextBackgroundPageEvent = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tChannel)(['Page'])
});
_validatorPrimitives.scheme.BrowserContextServiceWorkerEvent = (0, _validatorPrimitives.tObject)({
  worker: (0, _validatorPrimitives.tChannel)(['Worker'])
});
_validatorPrimitives.scheme.BrowserContextRequestEvent = (0, _validatorPrimitives.tObject)({
  request: (0, _validatorPrimitives.tChannel)(['Request']),
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))
});
_validatorPrimitives.scheme.BrowserContextRequestFailedEvent = (0, _validatorPrimitives.tObject)({
  request: (0, _validatorPrimitives.tChannel)(['Request']),
  failureText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  responseEndTiming: _validatorPrimitives.tNumber,
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))
});
_validatorPrimitives.scheme.BrowserContextRequestFinishedEvent = (0, _validatorPrimitives.tObject)({
  request: (0, _validatorPrimitives.tChannel)(['Request']),
  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response'])),
  responseEndTiming: _validatorPrimitives.tNumber,
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))
});
_validatorPrimitives.scheme.BrowserContextResponseEvent = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tChannel)(['Response']),
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))
});
_validatorPrimitives.scheme.BrowserContextAddCookiesParams = (0, _validatorPrimitives.tObject)({
  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SetNetworkCookie'))
});
_validatorPrimitives.scheme.BrowserContextAddCookiesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextAddInitScriptParams = (0, _validatorPrimitives.tObject)({
  source: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.BrowserContextAddInitScriptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextClearCookiesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextClearCookiesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextClearPermissionsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextClearPermissionsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextCookiesParams = (0, _validatorPrimitives.tObject)({
  urls: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.BrowserContextCookiesResult = (0, _validatorPrimitives.tObject)({
  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie'))
});
_validatorPrimitives.scheme.BrowserContextExposeBindingParams = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.BrowserContextExposeBindingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextGrantPermissionsParams = (0, _validatorPrimitives.tObject)({
  permissions: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString),
  origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.BrowserContextGrantPermissionsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextNewPageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextNewPageResult = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tChannel)(['Page'])
});
_validatorPrimitives.scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.BrowserContextSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.BrowserContextSetExtraHTTPHeadersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextSetGeolocationParams = (0, _validatorPrimitives.tObject)({
  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    longitude: _validatorPrimitives.tNumber,
    latitude: _validatorPrimitives.tNumber,
    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  }))
});
_validatorPrimitives.scheme.BrowserContextSetGeolocationResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextSetHTTPCredentialsParams = (0, _validatorPrimitives.tObject)({
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  }))
});
_validatorPrimitives.scheme.BrowserContextSetHTTPCredentialsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
  enabled: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.BrowserContextSetNetworkInterceptionEnabledResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextSetOfflineParams = (0, _validatorPrimitives.tObject)({
  offline: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.BrowserContextSetOfflineResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextStorageStateResult = (0, _validatorPrimitives.tObject)({
  cookies: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NetworkCookie')),
  origins: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('OriginStorage'))
});
_validatorPrimitives.scheme.BrowserContextPauseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextPauseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextRecorderSupplementEnableParams = (0, _validatorPrimitives.tObject)({
  language: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  mode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['inspecting', 'recording'])),
  pauseOnNextStatement: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  launchOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
  contextOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
  device: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  saveStorage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  outputFile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  omitCallTracking: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.BrowserContextRecorderSupplementEnableResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BrowserContextNewCDPSessionParams = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page'])),
  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame']))
});
_validatorPrimitives.scheme.BrowserContextNewCDPSessionResult = (0, _validatorPrimitives.tObject)({
  session: (0, _validatorPrimitives.tChannel)(['CDPSession'])
});
_validatorPrimitives.scheme.BrowserContextHarStartParams = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page'])),
  options: (0, _validatorPrimitives.tType)('RecordHarOptions')
});
_validatorPrimitives.scheme.BrowserContextHarStartResult = (0, _validatorPrimitives.tObject)({
  harId: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.BrowserContextHarExportParams = (0, _validatorPrimitives.tObject)({
  harId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.BrowserContextHarExportResult = (0, _validatorPrimitives.tObject)({
  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])
});
_validatorPrimitives.scheme.BrowserContextCreateTempFileParams = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.BrowserContextCreateTempFileResult = (0, _validatorPrimitives.tObject)({
  writableStream: (0, _validatorPrimitives.tChannel)(['WritableStream'])
});
_validatorPrimitives.scheme.PageInitializer = (0, _validatorPrimitives.tObject)({
  mainFrame: (0, _validatorPrimitives.tChannel)(['Frame']),
  viewportSize: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  isClosed: _validatorPrimitives.tBoolean,
  opener: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Page']))
});
_validatorPrimitives.scheme.PageBindingCallEvent = (0, _validatorPrimitives.tObject)({
  binding: (0, _validatorPrimitives.tChannel)(['BindingCall'])
});
_validatorPrimitives.scheme.PageCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageConsoleEvent = (0, _validatorPrimitives.tObject)({
  message: (0, _validatorPrimitives.tChannel)(['ConsoleMessage'])
});
_validatorPrimitives.scheme.PageCrashEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageDialogEvent = (0, _validatorPrimitives.tObject)({
  dialog: (0, _validatorPrimitives.tChannel)(['Dialog'])
});
_validatorPrimitives.scheme.PageDownloadEvent = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString,
  suggestedFilename: _validatorPrimitives.tString,
  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])
});
_validatorPrimitives.scheme.PageFileChooserEvent = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tChannel)(['ElementHandle']),
  isMultiple: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.PageFrameAttachedEvent = (0, _validatorPrimitives.tObject)({
  frame: (0, _validatorPrimitives.tChannel)(['Frame'])
});
_validatorPrimitives.scheme.PageFrameDetachedEvent = (0, _validatorPrimitives.tObject)({
  frame: (0, _validatorPrimitives.tChannel)(['Frame'])
});
_validatorPrimitives.scheme.PagePageErrorEvent = (0, _validatorPrimitives.tObject)({
  error: (0, _validatorPrimitives.tType)('SerializedError')
});
_validatorPrimitives.scheme.PageRouteEvent = (0, _validatorPrimitives.tObject)({
  route: (0, _validatorPrimitives.tChannel)(['Route']),
  request: (0, _validatorPrimitives.tChannel)(['Request'])
});
_validatorPrimitives.scheme.PageVideoEvent = (0, _validatorPrimitives.tObject)({
  artifact: (0, _validatorPrimitives.tChannel)(['Artifact'])
});
_validatorPrimitives.scheme.PageWebSocketEvent = (0, _validatorPrimitives.tObject)({
  webSocket: (0, _validatorPrimitives.tChannel)(['WebSocket'])
});
_validatorPrimitives.scheme.PageWorkerEvent = (0, _validatorPrimitives.tObject)({
  worker: (0, _validatorPrimitives.tChannel)(['Worker'])
});
_validatorPrimitives.scheme.PageSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageSetDefaultNavigationTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageSetFileChooserInterceptedNoReplyParams = (0, _validatorPrimitives.tObject)({
  intercepted: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.PageSetFileChooserInterceptedNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageAddInitScriptParams = (0, _validatorPrimitives.tObject)({
  source: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.PageAddInitScriptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageCloseParams = (0, _validatorPrimitives.tObject)({
  runBeforeUnload: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.PageCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageEmulateMediaParams = (0, _validatorPrimitives.tObject)({
  media: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['screen', 'print', 'null'])),
  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference', 'null'])),
  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference', 'null'])),
  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none', 'null']))
});
_validatorPrimitives.scheme.PageEmulateMediaResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageExposeBindingParams = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString,
  needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.PageExposeBindingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageGoBackParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))
});
_validatorPrimitives.scheme.PageGoBackResult = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))
});
_validatorPrimitives.scheme.PageGoForwardParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))
});
_validatorPrimitives.scheme.PageGoForwardResult = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))
});
_validatorPrimitives.scheme.PageReloadParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))
});
_validatorPrimitives.scheme.PageReloadResult = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))
});
_validatorPrimitives.scheme.PageExpectScreenshotParams = (0, _validatorPrimitives.tObject)({
  expected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  isNot: _validatorPrimitives.tBoolean,
  locator: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    frame: (0, _validatorPrimitives.tChannel)(['Frame']),
    selector: _validatorPrimitives.tString
  })),
  comparatorOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    maxDiffPixels: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
    maxDiffPixelRatio: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
    threshold: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  screenshotOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
    clip: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Rect')),
    omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
    caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['hide', 'initial'])),
    animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['disabled', 'allow'])),
    scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['css', 'device'])),
    mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
      frame: (0, _validatorPrimitives.tChannel)(['Frame']),
      selector: _validatorPrimitives.tString
    })))
  }))
});
_validatorPrimitives.scheme.PageExpectScreenshotResult = (0, _validatorPrimitives.tObject)({
  diff: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  errorMessage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  actual: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  previous: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  log: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
});
_validatorPrimitives.scheme.PageScreenshotParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['png', 'jpeg'])),
  quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  clip: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Rect')),
  omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['hide', 'initial'])),
  animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['disabled', 'allow'])),
  scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['css', 'device'])),
  mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    frame: (0, _validatorPrimitives.tChannel)(['Frame']),
    selector: _validatorPrimitives.tString
  })))
});
_validatorPrimitives.scheme.PageScreenshotResult = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.PageSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.PageSetExtraHTTPHeadersResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
  enabled: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.PageSetNetworkInterceptionEnabledResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageSetViewportSizeParams = (0, _validatorPrimitives.tObject)({
  viewportSize: (0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })
});
_validatorPrimitives.scheme.PageSetViewportSizeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageKeyboardDownParams = (0, _validatorPrimitives.tObject)({
  key: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.PageKeyboardDownResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageKeyboardUpParams = (0, _validatorPrimitives.tObject)({
  key: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.PageKeyboardUpResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageKeyboardInsertTextParams = (0, _validatorPrimitives.tObject)({
  text: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.PageKeyboardInsertTextResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageKeyboardTypeParams = (0, _validatorPrimitives.tObject)({
  text: _validatorPrimitives.tString,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageKeyboardTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageKeyboardPressParams = (0, _validatorPrimitives.tObject)({
  key: _validatorPrimitives.tString,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageKeyboardPressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageMouseMoveParams = (0, _validatorPrimitives.tObject)({
  x: _validatorPrimitives.tNumber,
  y: _validatorPrimitives.tNumber,
  steps: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageMouseMoveResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageMouseDownParams = (0, _validatorPrimitives.tObject)({
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageMouseDownResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageMouseUpParams = (0, _validatorPrimitives.tObject)({
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageMouseUpResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageMouseClickParams = (0, _validatorPrimitives.tObject)({
  x: _validatorPrimitives.tNumber,
  y: _validatorPrimitives.tNumber,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.PageMouseClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageMouseWheelParams = (0, _validatorPrimitives.tObject)({
  deltaX: _validatorPrimitives.tNumber,
  deltaY: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.PageMouseWheelResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageTouchscreenTapParams = (0, _validatorPrimitives.tObject)({
  x: _validatorPrimitives.tNumber,
  y: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.PageTouchscreenTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageAccessibilitySnapshotParams = (0, _validatorPrimitives.tObject)({
  interestingOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  root: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.PageAccessibilitySnapshotResult = (0, _validatorPrimitives.tObject)({
  rootAXNode: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('AXNode'))
});
_validatorPrimitives.scheme.PagePdfParams = (0, _validatorPrimitives.tObject)({
  scale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  displayHeaderFooter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  headerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  footerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  printBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  landscape: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  pageRanges: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  format: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  width: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  height: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  preferCSSPageSize: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  margin: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    top: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    bottom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    left: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    right: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  }))
});
_validatorPrimitives.scheme.PagePdfResult = (0, _validatorPrimitives.tObject)({
  pdf: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.PageStartJSCoverageParams = (0, _validatorPrimitives.tObject)({
  resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  reportAnonymousScripts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.PageStartJSCoverageResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageStopJSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageStopJSCoverageResult = (0, _validatorPrimitives.tObject)({
  entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    url: _validatorPrimitives.tString,
    scriptId: _validatorPrimitives.tString,
    source: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    functions: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
      functionName: _validatorPrimitives.tString,
      isBlockCoverage: _validatorPrimitives.tBoolean,
      ranges: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
        startOffset: _validatorPrimitives.tNumber,
        endOffset: _validatorPrimitives.tNumber,
        count: _validatorPrimitives.tNumber
      }))
    }))
  }))
});
_validatorPrimitives.scheme.PageStartCSSCoverageParams = (0, _validatorPrimitives.tObject)({
  resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.PageStartCSSCoverageResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageStopCSSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageStopCSSCoverageResult = (0, _validatorPrimitives.tObject)({
  entries: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    url: _validatorPrimitives.tString,
    text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    ranges: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
      start: _validatorPrimitives.tNumber,
      end: _validatorPrimitives.tNumber
    }))
  }))
});
_validatorPrimitives.scheme.PageBringToFrontParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.PageBringToFrontResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameInitializer = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString,
  name: _validatorPrimitives.tString,
  parentFrame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame'])),
  loadStates: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('LifecycleEvent'))
});
_validatorPrimitives.scheme.FrameLoadstateEvent = (0, _validatorPrimitives.tObject)({
  add: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent')),
  remove: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))
});
_validatorPrimitives.scheme.FrameNavigatedEvent = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString,
  name: _validatorPrimitives.tString,
  newDocument: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    request: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Request']))
  })),
  error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.FrameEvalOnSelectorResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.FrameEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.FrameEvalOnSelectorAllResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.FrameAddScriptTagParams = (0, _validatorPrimitives.tObject)({
  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  type: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameAddScriptTagResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tChannel)(['ElementHandle'])
});
_validatorPrimitives.scheme.FrameAddStyleTagParams = (0, _validatorPrimitives.tObject)({
  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameAddStyleTagResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tChannel)(['ElementHandle'])
});
_validatorPrimitives.scheme.FrameCheckParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameCheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameClickParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameContentResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameDragAndDropParams = (0, _validatorPrimitives.tObject)({
  source: _validatorPrimitives.tString,
  target: _validatorPrimitives.tString,
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  sourcePosition: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  targetPosition: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameDragAndDropResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameDblclickParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameDblclickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameDispatchEventParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  type: _validatorPrimitives.tString,
  eventInit: (0, _validatorPrimitives.tType)('SerializedArgument'),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameDispatchEventResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.FrameEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.FrameEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.FrameEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.FrameFillParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  value: _validatorPrimitives.tString,
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameFocusParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameFocusResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameFrameElementParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameFrameElementResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tChannel)(['ElementHandle'])
});
_validatorPrimitives.scheme.FrameHighlightParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameHighlightResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameGetAttributeParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  name: _validatorPrimitives.tString,
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameGetAttributeResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameGotoParams = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString,
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent')),
  referer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameGotoResult = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))
});
_validatorPrimitives.scheme.FrameHoverParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameHoverResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameInnerHTMLParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameInnerHTMLResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameInnerTextParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameInnerTextResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameInputValueParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameInputValueResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameIsCheckedParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameIsCheckedResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.FrameIsDisabledParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameIsDisabledResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.FrameIsEnabledParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameIsEnabledResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.FrameIsHiddenParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameIsHiddenResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.FrameIsVisibleParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameIsVisibleResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.FrameIsEditableParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameIsEditableResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.FramePressParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  key: _validatorPrimitives.tString,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FramePressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameQuerySelectorParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameQuerySelectorResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.FrameQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameQuerySelectorAllResult = (0, _validatorPrimitives.tObject)({
  elements: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.FrameQueryCountParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameQueryCountResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.FrameSelectOptionParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))),
  options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  }))),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameSelectOptionResult = (0, _validatorPrimitives.tObject)({
  values: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameSetContentParams = (0, _validatorPrimitives.tObject)({
  html: _validatorPrimitives.tString,
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  waitUntil: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('LifecycleEvent'))
});
_validatorPrimitives.scheme.FrameSetContentResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameSetInputFilesParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    name: _validatorPrimitives.tString,
    mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    buffer: _validatorPrimitives.tBinary
  })),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameSetInputFilesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['WritableStream']))),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameSetInputFilePathsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameTapParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameTextContentParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameTextContentResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.FrameTitleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameTitleResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.FrameTypeParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  text: _validatorPrimitives.tString,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameUncheckParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameUncheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameWaitForTimeoutParams = (0, _validatorPrimitives.tObject)({
  timeout: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.FrameWaitForTimeoutResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.FrameWaitForFunctionParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument'),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  pollingInterval: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameWaitForFunctionResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.FrameWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['attached', 'detached', 'visible', 'hidden'])),
  omitReturnValue: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.FrameWaitForSelectorResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.FrameExpectParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  expression: _validatorPrimitives.tString,
  expressionArg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
  expectedText: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('ExpectedTextValue'))),
  expectedNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  expectedValue: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedArgument')),
  useInnerText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  isNot: _validatorPrimitives.tBoolean,
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.FrameExpectResult = (0, _validatorPrimitives.tObject)({
  matches: _validatorPrimitives.tBoolean,
  received: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedValue')),
  log: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
});
_validatorPrimitives.scheme.WorkerInitializer = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.WorkerCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.WorkerEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.WorkerEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.WorkerEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.WorkerEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.JSHandleInitializer = (0, _validatorPrimitives.tObject)({
  preview: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.JSHandlePreviewUpdatedEvent = (0, _validatorPrimitives.tObject)({
  preview: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandlePreviewUpdatedEvent = (0, _validatorPrimitives.tType)('JSHandlePreviewUpdatedEvent');
_validatorPrimitives.scheme.JSHandleDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleDisposeParams = (0, _validatorPrimitives.tType)('JSHandleDisposeParams');
_validatorPrimitives.scheme.JSHandleDisposeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleDisposeResult = (0, _validatorPrimitives.tType)('JSHandleDisposeResult');
_validatorPrimitives.scheme.JSHandleEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElementHandleEvaluateExpressionParams = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionParams');
_validatorPrimitives.scheme.JSHandleEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.ElementHandleEvaluateExpressionResult = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionResult');
_validatorPrimitives.scheme.JSHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElementHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionHandleParams');
_validatorPrimitives.scheme.JSHandleEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.ElementHandleEvaluateExpressionHandleResult = (0, _validatorPrimitives.tType)('JSHandleEvaluateExpressionHandleResult');
_validatorPrimitives.scheme.JSHandleGetPropertyListParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleGetPropertyListParams = (0, _validatorPrimitives.tType)('JSHandleGetPropertyListParams');
_validatorPrimitives.scheme.JSHandleGetPropertyListResult = (0, _validatorPrimitives.tObject)({
  properties: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    name: _validatorPrimitives.tString,
    value: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
  }))
});
_validatorPrimitives.scheme.ElementHandleGetPropertyListResult = (0, _validatorPrimitives.tType)('JSHandleGetPropertyListResult');
_validatorPrimitives.scheme.JSHandleGetPropertyParams = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleGetPropertyParams = (0, _validatorPrimitives.tType)('JSHandleGetPropertyParams');
_validatorPrimitives.scheme.JSHandleGetPropertyResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.ElementHandleGetPropertyResult = (0, _validatorPrimitives.tType)('JSHandleGetPropertyResult');
_validatorPrimitives.scheme.JSHandleJsonValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleJsonValueParams = (0, _validatorPrimitives.tType)('JSHandleJsonValueParams');
_validatorPrimitives.scheme.JSHandleJsonValueResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.ElementHandleJsonValueResult = (0, _validatorPrimitives.tType)('JSHandleJsonValueResult');
_validatorPrimitives.scheme.ElementHandleInitializer = (0, _validatorPrimitives.tObject)({
  preview: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElementHandleEvalOnSelectorResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.ElementHandleEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElementHandleEvalOnSelectorAllResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.ElementHandleBoundingBoxParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleBoundingBoxResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Rect'))
});
_validatorPrimitives.scheme.ElementHandleCheckParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleCheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleClickParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleClickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleContentFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleContentFrameResult = (0, _validatorPrimitives.tObject)({
  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame']))
});
_validatorPrimitives.scheme.ElementHandleDblclickParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['left', 'right', 'middle'])),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleDblclickResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleDispatchEventParams = (0, _validatorPrimitives.tObject)({
  type: _validatorPrimitives.tString,
  eventInit: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElementHandleDispatchEventResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleFillParams = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString,
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleFocusParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleFocusResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleGetAttributeParams = (0, _validatorPrimitives.tObject)({
  name: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleGetAttributeResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.ElementHandleHoverParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleHoverResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleInnerHTMLParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleInnerHTMLResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleInnerTextParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleInnerTextResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleInputValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleInputValueResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleIsCheckedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleIsCheckedResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ElementHandleIsDisabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleIsDisabledResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ElementHandleIsEditableParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleIsEditableResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ElementHandleIsEnabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleIsEnabledResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ElementHandleIsHiddenParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleIsHiddenResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ElementHandleIsVisibleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleIsVisibleResult = (0, _validatorPrimitives.tObject)({
  value: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ElementHandleOwnerFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleOwnerFrameResult = (0, _validatorPrimitives.tObject)({
  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame']))
});
_validatorPrimitives.scheme.ElementHandlePressParams = (0, _validatorPrimitives.tObject)({
  key: _validatorPrimitives.tString,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandlePressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleQuerySelectorParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleQuerySelectorResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.ElementHandleQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ElementHandleQuerySelectorAllResult = (0, _validatorPrimitives.tObject)({
  elements: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.ElementHandleScreenshotParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['png', 'jpeg'])),
  quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['hide', 'initial'])),
  animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['disabled', 'allow'])),
  scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['css', 'device'])),
  mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    frame: (0, _validatorPrimitives.tChannel)(['Frame']),
    selector: _validatorPrimitives.tString
  })))
});
_validatorPrimitives.scheme.ElementHandleScreenshotResult = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.ElementHandleScrollIntoViewIfNeededParams = (0, _validatorPrimitives.tObject)({
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.ElementHandleScrollIntoViewIfNeededResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleSelectOptionParams = (0, _validatorPrimitives.tObject)({
  elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle']))),
  options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  }))),
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleSelectOptionResult = (0, _validatorPrimitives.tObject)({
  values: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.ElementHandleSelectTextParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.ElementHandleSelectTextResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleSetInputFilesParams = (0, _validatorPrimitives.tObject)({
  files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
    name: _validatorPrimitives.tString,
    mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    buffer: _validatorPrimitives.tBinary
  })),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleSetInputFilesResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({
  localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['WritableStream']))),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleSetInputFilePathsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleTapParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(['Alt', 'Control', 'Meta', 'Shift']))),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleTextContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleTextContentResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.ElementHandleTypeParams = (0, _validatorPrimitives.tObject)({
  text: _validatorPrimitives.tString,
  delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.ElementHandleTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleUncheckParams = (0, _validatorPrimitives.tObject)({
  force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  position: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('Point')),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.ElementHandleUncheckResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleWaitForElementStateParams = (0, _validatorPrimitives.tObject)({
  state: (0, _validatorPrimitives.tEnum)(['visible', 'hidden', 'stable', 'enabled', 'disabled', 'editable']),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.ElementHandleWaitForElementStateResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElementHandleWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
  selector: _validatorPrimitives.tString,
  strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['attached', 'detached', 'visible', 'hidden']))
});
_validatorPrimitives.scheme.ElementHandleWaitForSelectorResult = (0, _validatorPrimitives.tObject)({
  element: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle']))
});
_validatorPrimitives.scheme.RequestInitializer = (0, _validatorPrimitives.tObject)({
  frame: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Frame'])),
  serviceWorker: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Worker'])),
  url: _validatorPrimitives.tString,
  resourceType: _validatorPrimitives.tString,
  method: _validatorPrimitives.tString,
  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')),
  isNavigationRequest: _validatorPrimitives.tBoolean,
  redirectedFrom: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Request']))
});
_validatorPrimitives.scheme.RequestResponseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RequestResponseResult = (0, _validatorPrimitives.tObject)({
  response: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Response']))
});
_validatorPrimitives.scheme.RequestRawRequestHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RequestRawRequestHeadersResult = (0, _validatorPrimitives.tObject)({
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.RouteInitializer = (0, _validatorPrimitives.tObject)({
  request: (0, _validatorPrimitives.tChannel)(['Request'])
});
_validatorPrimitives.scheme.RouteRedirectNavigationRequestParams = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.RouteRedirectNavigationRequestResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RouteAbortParams = (0, _validatorPrimitives.tObject)({
  errorCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.RouteAbortResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RouteContinueParams = (0, _validatorPrimitives.tObject)({
  url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
});
_validatorPrimitives.scheme.RouteContinueResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.RouteFulfillParams = (0, _validatorPrimitives.tObject)({
  status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  isBase64: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  fetchResponseUid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.RouteFulfillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ResourceTiming = (0, _validatorPrimitives.tObject)({
  startTime: _validatorPrimitives.tNumber,
  domainLookupStart: _validatorPrimitives.tNumber,
  domainLookupEnd: _validatorPrimitives.tNumber,
  connectStart: _validatorPrimitives.tNumber,
  secureConnectionStart: _validatorPrimitives.tNumber,
  connectEnd: _validatorPrimitives.tNumber,
  requestStart: _validatorPrimitives.tNumber,
  responseStart: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.ResponseInitializer = (0, _validatorPrimitives.tObject)({
  request: (0, _validatorPrimitives.tChannel)(['Request']),
  url: _validatorPrimitives.tString,
  status: _validatorPrimitives.tNumber,
  statusText: _validatorPrimitives.tString,
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')),
  timing: (0, _validatorPrimitives.tType)('ResourceTiming'),
  fromServiceWorker: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.ResponseBodyParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ResponseBodyResult = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.ResponseSecurityDetailsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ResponseSecurityDetailsResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SecurityDetails'))
});
_validatorPrimitives.scheme.ResponseServerAddrParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ResponseServerAddrResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RemoteAddr'))
});
_validatorPrimitives.scheme.ResponseRawResponseHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ResponseRawResponseHeadersResult = (0, _validatorPrimitives.tObject)({
  headers: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))
});
_validatorPrimitives.scheme.ResponseSizesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ResponseSizesResult = (0, _validatorPrimitives.tObject)({
  sizes: (0, _validatorPrimitives.tType)('RequestSizes')
});
_validatorPrimitives.scheme.SecurityDetails = (0, _validatorPrimitives.tObject)({
  issuer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  protocol: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  subjectName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  validFrom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  validTo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.RequestSizes = (0, _validatorPrimitives.tObject)({
  requestBodySize: _validatorPrimitives.tNumber,
  requestHeadersSize: _validatorPrimitives.tNumber,
  responseBodySize: _validatorPrimitives.tNumber,
  responseHeadersSize: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.RemoteAddr = (0, _validatorPrimitives.tObject)({
  ipAddress: _validatorPrimitives.tString,
  port: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.WebSocketInitializer = (0, _validatorPrimitives.tObject)({
  url: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.WebSocketOpenEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.WebSocketFrameSentEvent = (0, _validatorPrimitives.tObject)({
  opcode: _validatorPrimitives.tNumber,
  data: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.WebSocketFrameReceivedEvent = (0, _validatorPrimitives.tObject)({
  opcode: _validatorPrimitives.tNumber,
  data: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.WebSocketSocketErrorEvent = (0, _validatorPrimitives.tObject)({
  error: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.WebSocketCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ConsoleMessageInitializer = (0, _validatorPrimitives.tObject)({
  type: _validatorPrimitives.tString,
  text: _validatorPrimitives.tString,
  args: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])),
  location: (0, _validatorPrimitives.tObject)({
    url: _validatorPrimitives.tString,
    lineNumber: _validatorPrimitives.tNumber,
    columnNumber: _validatorPrimitives.tNumber
  })
});
_validatorPrimitives.scheme.BindingCallInitializer = (0, _validatorPrimitives.tObject)({
  frame: (0, _validatorPrimitives.tChannel)(['Frame']),
  name: _validatorPrimitives.tString,
  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('SerializedValue'))),
  handle: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle']))
});
_validatorPrimitives.scheme.BindingCallRejectParams = (0, _validatorPrimitives.tObject)({
  error: (0, _validatorPrimitives.tType)('SerializedError')
});
_validatorPrimitives.scheme.BindingCallRejectResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.BindingCallResolveParams = (0, _validatorPrimitives.tObject)({
  result: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.BindingCallResolveResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.DialogInitializer = (0, _validatorPrimitives.tObject)({
  type: _validatorPrimitives.tString,
  message: _validatorPrimitives.tString,
  defaultValue: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.DialogAcceptParams = (0, _validatorPrimitives.tObject)({
  promptText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.DialogAcceptResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.DialogDismissParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.DialogDismissResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.TracingInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.TracingTracingStartParams = (0, _validatorPrimitives.tObject)({
  name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  snapshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  sources: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.TracingTracingStartResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.TracingTracingStartChunkParams = (0, _validatorPrimitives.tObject)({
  title: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.TracingTracingStartChunkResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.TracingTracingStopChunkParams = (0, _validatorPrimitives.tObject)({
  mode: (0, _validatorPrimitives.tEnum)(['doNotSave', 'compressTrace', 'compressTraceAndSources'])
});
_validatorPrimitives.scheme.TracingTracingStopChunkResult = (0, _validatorPrimitives.tObject)({
  artifact: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Artifact'])),
  sourceEntries: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue')))
});
_validatorPrimitives.scheme.TracingTracingStopParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.TracingTracingStopResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactInitializer = (0, _validatorPrimitives.tObject)({
  absolutePath: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ArtifactPathAfterFinishedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactPathAfterFinishedResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.ArtifactSaveAsParams = (0, _validatorPrimitives.tObject)({
  path: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.ArtifactSaveAsResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactSaveAsStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactSaveAsStreamResult = (0, _validatorPrimitives.tObject)({
  stream: (0, _validatorPrimitives.tChannel)(['Stream'])
});
_validatorPrimitives.scheme.ArtifactFailureParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactFailureResult = (0, _validatorPrimitives.tObject)({
  error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.ArtifactStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactStreamResult = (0, _validatorPrimitives.tObject)({
  stream: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tChannel)(['Stream']))
});
_validatorPrimitives.scheme.ArtifactCancelParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactCancelResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactDeleteParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ArtifactDeleteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.StreamInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.StreamReadParams = (0, _validatorPrimitives.tObject)({
  size: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.StreamReadResult = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.StreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.StreamCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.WritableStreamInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.WritableStreamWriteParams = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.WritableStreamWriteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.WritableStreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.WritableStreamCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.CDPSessionInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.CDPSessionEventEvent = (0, _validatorPrimitives.tObject)({
  method: _validatorPrimitives.tString,
  params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
});
_validatorPrimitives.scheme.CDPSessionSendParams = (0, _validatorPrimitives.tObject)({
  method: _validatorPrimitives.tString,
  params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
});
_validatorPrimitives.scheme.CDPSessionSendResult = (0, _validatorPrimitives.tObject)({
  result: _validatorPrimitives.tAny
});
_validatorPrimitives.scheme.CDPSessionDetachParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.CDPSessionDetachResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElectronInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElectronLaunchParams = (0, _validatorPrimitives.tObject)({
  executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  cwd: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference'])),
  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    longitude: _validatorPrimitives.tNumber,
    latitude: _validatorPrimitives.tNumber,
    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  })),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),
  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    dir: _validatorPrimitives.tString,
    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
      width: _validatorPrimitives.tNumber,
      height: _validatorPrimitives.tNumber
    }))
  })),
  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.ElectronLaunchResult = (0, _validatorPrimitives.tObject)({
  electronApplication: (0, _validatorPrimitives.tChannel)(['ElectronApplication'])
});
_validatorPrimitives.scheme.ElectronApplicationInitializer = (0, _validatorPrimitives.tObject)({
  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])
});
_validatorPrimitives.scheme.ElectronApplicationCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElectronApplicationBrowserWindowParams = (0, _validatorPrimitives.tObject)({
  page: (0, _validatorPrimitives.tChannel)(['Page'])
});
_validatorPrimitives.scheme.ElectronApplicationBrowserWindowResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionResult = (0, _validatorPrimitives.tObject)({
  value: (0, _validatorPrimitives.tType)('SerializedValue')
});
_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
  expression: _validatorPrimitives.tString,
  isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  arg: (0, _validatorPrimitives.tType)('SerializedArgument')
});
_validatorPrimitives.scheme.ElectronApplicationEvaluateExpressionHandleResult = (0, _validatorPrimitives.tObject)({
  handle: (0, _validatorPrimitives.tChannel)(['ElementHandle', 'JSHandle'])
});
_validatorPrimitives.scheme.ElectronApplicationCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.ElectronApplicationCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDevicesParams = (0, _validatorPrimitives.tObject)({
  host: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  port: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  omitDriverInstall: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
});
_validatorPrimitives.scheme.AndroidDevicesResult = (0, _validatorPrimitives.tObject)({
  devices: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tChannel)(['AndroidDevice']))
});
_validatorPrimitives.scheme.AndroidSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
  timeout: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.AndroidSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidSocketInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidSocketDataEvent = (0, _validatorPrimitives.tObject)({
  data: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.AndroidSocketCloseEvent = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidSocketWriteParams = (0, _validatorPrimitives.tObject)({
  data: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.AndroidSocketWriteResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidSocketCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidSocketCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceInitializer = (0, _validatorPrimitives.tObject)({
  model: _validatorPrimitives.tString,
  serial: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceWebViewAddedEvent = (0, _validatorPrimitives.tObject)({
  webView: (0, _validatorPrimitives.tType)('AndroidWebView')
});
_validatorPrimitives.scheme.AndroidDeviceWebViewRemovedEvent = (0, _validatorPrimitives.tObject)({
  socketName: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceWaitParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['gone'])),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceWaitResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceFillParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  text: _validatorPrimitives.tString,
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceFillResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceTapParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  duration: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceDragParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  dest: (0, _validatorPrimitives.tType)('Point'),
  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceDragResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceFlingParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  direction: (0, _validatorPrimitives.tEnum)(['up', 'down', 'left', 'right']),
  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceFlingResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceLongTapParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceLongTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDevicePinchCloseParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  percent: _validatorPrimitives.tNumber,
  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDevicePinchCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDevicePinchOpenParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  percent: _validatorPrimitives.tNumber,
  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDevicePinchOpenResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceScrollParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  direction: (0, _validatorPrimitives.tEnum)(['up', 'down', 'left', 'right']),
  percent: _validatorPrimitives.tNumber,
  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceScrollResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceSwipeParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
  direction: (0, _validatorPrimitives.tEnum)(['up', 'down', 'left', 'right']),
  percent: _validatorPrimitives.tNumber,
  speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDeviceSwipeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceInfoParams = (0, _validatorPrimitives.tObject)({
  selector: (0, _validatorPrimitives.tType)('AndroidSelector')
});
_validatorPrimitives.scheme.AndroidDeviceInfoResult = (0, _validatorPrimitives.tObject)({
  info: (0, _validatorPrimitives.tType)('AndroidElementInfo')
});
_validatorPrimitives.scheme.AndroidDeviceScreenshotParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceScreenshotResult = (0, _validatorPrimitives.tObject)({
  binary: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.AndroidDeviceInputTypeParams = (0, _validatorPrimitives.tObject)({
  text: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceInputTypeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceInputPressParams = (0, _validatorPrimitives.tObject)({
  key: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceInputPressResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceInputTapParams = (0, _validatorPrimitives.tObject)({
  point: (0, _validatorPrimitives.tType)('Point')
});
_validatorPrimitives.scheme.AndroidDeviceInputTapResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceInputSwipeParams = (0, _validatorPrimitives.tObject)({
  segments: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('Point')),
  steps: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.AndroidDeviceInputSwipeResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceInputDragParams = (0, _validatorPrimitives.tObject)({
  from: (0, _validatorPrimitives.tType)('Point'),
  to: (0, _validatorPrimitives.tType)('Point'),
  steps: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.AndroidDeviceInputDragResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceLaunchBrowserParams = (0, _validatorPrimitives.tObject)({
  noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    width: _validatorPrimitives.tNumber,
    height: _validatorPrimitives.tNumber
  })),
  ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    longitude: _validatorPrimitives.tNumber,
    latitude: _validatorPrimitives.tNumber,
    accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
  extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('NameValue'))),
  offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    username: _validatorPrimitives.tString,
    password: _validatorPrimitives.tString
  })),
  deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['dark', 'light', 'no-preference'])),
  reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['reduce', 'no-preference'])),
  forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['active', 'none'])),
  acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    dir: _validatorPrimitives.tString,
    size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
      width: _validatorPrimitives.tNumber,
      height: _validatorPrimitives.tNumber
    }))
  })),
  recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('RecordHarOptions')),
  strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  serviceWorkers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(['allow', 'block'])),
  pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    server: _validatorPrimitives.tString,
    bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
    password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
  }))
});
_validatorPrimitives.scheme.AndroidDeviceLaunchBrowserResult = (0, _validatorPrimitives.tObject)({
  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])
});
_validatorPrimitives.scheme.AndroidDeviceOpenParams = (0, _validatorPrimitives.tObject)({
  command: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceOpenResult = (0, _validatorPrimitives.tObject)({
  socket: (0, _validatorPrimitives.tChannel)(['AndroidSocket'])
});
_validatorPrimitives.scheme.AndroidDeviceShellParams = (0, _validatorPrimitives.tObject)({
  command: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceShellResult = (0, _validatorPrimitives.tObject)({
  result: _validatorPrimitives.tBinary
});
_validatorPrimitives.scheme.AndroidDeviceInstallApkParams = (0, _validatorPrimitives.tObject)({
  file: _validatorPrimitives.tBinary,
  args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
});
_validatorPrimitives.scheme.AndroidDeviceInstallApkResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDevicePushParams = (0, _validatorPrimitives.tObject)({
  file: _validatorPrimitives.tBinary,
  path: _validatorPrimitives.tString,
  mode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
});
_validatorPrimitives.scheme.AndroidDevicePushResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
  timeout: _validatorPrimitives.tNumber
});
_validatorPrimitives.scheme.AndroidDeviceSetDefaultTimeoutNoReplyResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceConnectToWebViewParams = (0, _validatorPrimitives.tObject)({
  socketName: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidDeviceConnectToWebViewResult = (0, _validatorPrimitives.tObject)({
  context: (0, _validatorPrimitives.tChannel)(['BrowserContext'])
});
_validatorPrimitives.scheme.AndroidDeviceCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidDeviceCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.AndroidWebView = (0, _validatorPrimitives.tObject)({
  pid: _validatorPrimitives.tNumber,
  pkg: _validatorPrimitives.tString,
  socketName: _validatorPrimitives.tString
});
_validatorPrimitives.scheme.AndroidSelector = (0, _validatorPrimitives.tObject)({
  checkable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  checked: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  clazz: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  clickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  depth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
  desc: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  enabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  focusable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  hasChild: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    selector: (0, _validatorPrimitives.tType)('AndroidSelector')
  })),
  hasDescendant: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
    selector: (0, _validatorPrimitives.tType)('AndroidSelector'),
    maxDepth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
  })),
  longClickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  res: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
  scrollable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
  text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
});
_validatorPrimitives.scheme.AndroidElementInfo = (0, _validatorPrimitives.tObject)({
  children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tType)('AndroidElementInfo'))),
  clazz: _validatorPrimitives.tString,
  desc: _validatorPrimitives.tString,
  res: _validatorPrimitives.tString,
  pkg: _validatorPrimitives.tString,
  text: _validatorPrimitives.tString,
  bounds: (0, _validatorPrimitives.tType)('Rect'),
  checkable: _validatorPrimitives.tBoolean,
  checked: _validatorPrimitives.tBoolean,
  clickable: _validatorPrimitives.tBoolean,
  enabled: _validatorPrimitives.tBoolean,
  focusable: _validatorPrimitives.tBoolean,
  focused: _validatorPrimitives.tBoolean,
  longClickable: _validatorPrimitives.tBoolean,
  scrollable: _validatorPrimitives.tBoolean,
  selected: _validatorPrimitives.tBoolean
});
_validatorPrimitives.scheme.JsonPipeInitializer = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.JsonPipeMessageEvent = (0, _validatorPrimitives.tObject)({
  message: _validatorPrimitives.tAny
});
_validatorPrimitives.scheme.JsonPipeClosedEvent = (0, _validatorPrimitives.tObject)({
  error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tType)('SerializedError'))
});
_validatorPrimitives.scheme.JsonPipeSendParams = (0, _validatorPrimitives.tObject)({
  message: _validatorPrimitives.tAny
});
_validatorPrimitives.scheme.JsonPipeSendResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.JsonPipeCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
_validatorPrimitives.scheme.JsonPipeCloseResult = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));

/***/ }),

/***/ 2209:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ValidationError = void 0;
exports.createMetadataValidator = createMetadataValidator;
exports.findValidator = findValidator;
exports.maybeFindValidator = maybeFindValidator;
exports.tUndefined = exports.tType = exports.tString = exports.tOptional = exports.tObject = exports.tNumber = exports.tEnum = exports.tChannel = exports.tBoolean = exports.tBinary = exports.tArray = exports.tAny = exports.scheme = void 0;

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidationError extends Error {}

exports.ValidationError = ValidationError;
const scheme = {};
exports.scheme = scheme;

function findValidator(type, method, kind) {
  const validator = maybeFindValidator(type, method, kind);
  if (!validator) throw new ValidationError(`Unknown scheme for ${kind}: ${type}.${method}`);
  return validator;
}

function maybeFindValidator(type, method, kind) {
  const schemeName = type + (kind === 'Initializer' ? '' : method[0].toUpperCase() + method.substring(1)) + kind;
  return scheme[schemeName];
}

function createMetadataValidator() {
  return tOptional(scheme['Metadata']);
}

const tNumber = (arg, path, context) => {
  if (arg instanceof Number) return arg.valueOf();
  if (typeof arg === 'number') return arg;
  throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
};

exports.tNumber = tNumber;

const tBoolean = (arg, path, context) => {
  if (arg instanceof Boolean) return arg.valueOf();
  if (typeof arg === 'boolean') return arg;
  throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
};

exports.tBoolean = tBoolean;

const tString = (arg, path, context) => {
  if (arg instanceof String) return arg.valueOf();
  if (typeof arg === 'string') return arg;
  throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
};

exports.tString = tString;

const tBinary = (arg, path, context) => {
  if (context.binary === 'fromBase64') {
    if (arg instanceof String) return Buffer.from(arg.valueOf(), 'base64');
    if (typeof arg === 'string') return Buffer.from(arg, 'base64');
    throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
  }

  if (context.binary === 'toBase64') {
    if (!(arg instanceof Buffer)) throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);
    return arg.toString('base64');
  }

  if (context.binary === 'buffer') {
    if (!(arg instanceof Buffer)) throw new ValidationError(`${path}: expected Buffer, got ${typeof arg}`);
    return arg;
  }

  throw new ValidationError(`Unsupported binary behavior "${context.binary}"`);
};

exports.tBinary = tBinary;

const tUndefined = (arg, path, context) => {
  if (Object.is(arg, undefined)) return arg;
  throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
};

exports.tUndefined = tUndefined;

const tAny = (arg, path, context) => {
  return arg;
};

exports.tAny = tAny;

const tOptional = v => {
  return (arg, path, context) => {
    if (Object.is(arg, undefined)) return arg;
    return v(arg, path, context);
  };
};

exports.tOptional = tOptional;

const tArray = v => {
  return (arg, path, context) => {
    if (!Array.isArray(arg)) throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
    return arg.map((x, index) => v(x, path + '[' + index + ']', context));
  };
};

exports.tArray = tArray;

const tObject = s => {
  return (arg, path, context) => {
    if (Object.is(arg, null)) throw new ValidationError(`${path}: expected object, got null`);
    if (typeof arg !== 'object') throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
    const result = {};

    for (const [key, v] of Object.entries(s)) {
      const value = v(arg[key], path ? path + '.' + key : key, context);
      if (!Object.is(value, undefined)) result[key] = value;
    }

    if ((0, _utils.isUnderTest)()) {
      for (const [key, value] of Object.entries(arg)) {
        if (key.startsWith('__testHook')) result[key] = value;
      }
    }

    return result;
  };
};

exports.tObject = tObject;

const tEnum = e => {
  return (arg, path, context) => {
    if (!e.includes(arg)) throw new ValidationError(`${path}: expected one of (${e.join('|')})`);
    return arg;
  };
};

exports.tEnum = tEnum;

const tChannel = names => {
  return (arg, path, context) => {
    return context.tChannelImpl(names, arg, path, context);
  };
};

exports.tChannel = tChannel;

const tType = name => {
  return (arg, path, context) => {
    const v = scheme[name];
    if (!v) throw new ValidationError(path + ': unknown type "' + name + '"');
    return v(arg, path, context);
  };
};

exports.tType = tType;

/***/ }),

/***/ 4533:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PlaywrightConnection = void 0;

var _server = __nccwpck_require__(4540);

var _browser = __nccwpck_require__(6705);

var _instrumentation = __nccwpck_require__(6686);

var _processLauncher = __nccwpck_require__(1441);

var _socksProxy = __nccwpck_require__(1570);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlaywrightConnection {
  constructor(lock, mode, ws, options, preLaunched, log, onClose) {
    this._ws = void 0;
    this._onClose = void 0;
    this._dispatcherConnection = void 0;
    this._cleanups = [];
    this._debugLog = void 0;
    this._disconnected = false;
    this._preLaunched = void 0;
    this._options = void 0;
    this._root = void 0;
    this._ws = ws;
    this._preLaunched = preLaunched;
    this._options = options;
    if (mode === 'reuse-browser' || mode === 'use-pre-launched-browser') (0, _utils.assert)(preLaunched.playwright);
    if (mode === 'use-pre-launched-browser') (0, _utils.assert)(preLaunched.browser);
    this._onClose = onClose;
    this._debugLog = log;
    this._dispatcherConnection = new _server.DispatcherConnection();

    this._dispatcherConnection.onmessage = async message => {
      await lock;
      if (ws.readyState !== ws.CLOSING) ws.send(JSON.stringify(message));
    };

    ws.on('message', async message => {
      await lock;

      this._dispatcherConnection.dispatch(JSON.parse(Buffer.from(message).toString()));
    });
    ws.on('close', () => this._onDisconnect());
    ws.on('error', error => this._onDisconnect(error));
    this._root = new _server.Root(this._dispatcherConnection, async scope => {
      if (mode === 'reuse-browser') return await this._initReuseBrowsersMode(scope);
      if (mode === 'use-pre-launched-browser') return await this._initPreLaunchedBrowserMode(scope);
      if (!options.browserName) return await this._initPlaywrightConnectMode(scope);
      return await this._initLaunchBrowserMode(scope);
    });
  }

  async _initPlaywrightConnectMode(scope) {
    this._debugLog(`engaged playwright.connect mode`);

    const playwright = (0, _server.createPlaywright)('javascript'); // Close all launched browsers on disconnect.

    this._cleanups.push(() => (0, _processLauncher.gracefullyCloseAll)());

    const socksProxy = this._options.enableSocksProxy ? await this._enableSocksProxy(playwright) : undefined;
    return new _server.PlaywrightDispatcher(scope, playwright, socksProxy);
  }

  async _initLaunchBrowserMode(scope) {
    this._debugLog(`engaged launch mode for "${this._options.browserName}"`);

    const playwright = (0, _server.createPlaywright)('javascript');
    const socksProxy = this._options.enableSocksProxy ? await this._enableSocksProxy(playwright) : undefined;
    const browser = await playwright[this._options.browserName].launch((0, _instrumentation.serverSideCallMetadata)(), this._options.launchOptions);

    this._cleanups.push(async () => {
      for (const browser of playwright.allBrowsers()) await browser.close();
    });

    browser.on(_browser.Browser.Events.Disconnected, () => {
      // Underlying browser did close for some reason - force disconnect the client.
      this.close({
        code: 1001,
        reason: 'Browser closed'
      });
    });
    return new _server.PlaywrightDispatcher(scope, playwright, socksProxy, browser);
  }

  async _initPreLaunchedBrowserMode(scope) {
    this._debugLog(`engaged pre-launched mode`);

    const playwright = this._preLaunched.playwright;
    const browser = this._preLaunched.browser;
    browser.on(_browser.Browser.Events.Disconnected, () => {
      // Underlying browser did close for some reason - force disconnect the client.
      this.close({
        code: 1001,
        reason: 'Browser closed'
      });
    });
    const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, undefined, browser); // In pre-launched mode, keep only the pre-launched browser.

    for (const b of playwright.allBrowsers()) {
      if (b !== browser) await b.close();
    }

    this._cleanups.push(() => playwrightDispatcher.cleanup());

    return playwrightDispatcher;
  }

  async _initReuseBrowsersMode(scope) {
    this._debugLog(`engaged reuse browsers mode for ${this._options.browserName}`);

    const playwright = this._preLaunched.playwright;
    const requestedOptions = launchOptionsHash(this._options.launchOptions);
    let browser = playwright.allBrowsers().find(b => {
      if (b.options.name !== this._options.browserName) return false;
      const existingOptions = launchOptionsHash(b.options.originalLaunchOptions);
      return existingOptions === requestedOptions;
    }); // Close remaining browsers of this type+channel. Keep different browser types for the speed.

    for (const b of playwright.allBrowsers()) {
      if (b === browser) continue;
      if (b.options.name === this._options.browserName && b.options.channel === this._options.launchOptions.channel) await b.close();
    }

    if (!browser) {
      browser = await playwright[this._options.browserName].launch((0, _instrumentation.serverSideCallMetadata)(), { ...this._options.launchOptions,
        headless: false
      });
      browser.on(_browser.Browser.Events.Disconnected, () => {
        // Underlying browser did close for some reason - force disconnect the client.
        this.close({
          code: 1001,
          reason: 'Browser closed'
        });
      });
    }

    this._cleanups.push(async () => {
      // Don't close the pages so that user could debug them,
      // but close all the empty browsers and contexts to clean up.
      for (const browser of playwright.allBrowsers()) {
        for (const context of browser.contexts()) {
          if (!context.pages().length) await context.close((0, _instrumentation.serverSideCallMetadata)());
        }

        if (!browser.contexts()) await browser.close();
      }
    });

    const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, undefined, browser);
    return playwrightDispatcher;
  }

  async _enableSocksProxy(playwright) {
    const socksProxy = new _socksProxy.SocksProxy();
    playwright.options.socksProxyPort = await socksProxy.listen(0);

    this._debugLog(`started socks proxy on port ${playwright.options.socksProxyPort}`);

    this._cleanups.push(() => socksProxy.close());

    return socksProxy;
  }

  async _onDisconnect(error) {
    this._disconnected = true;

    this._debugLog(`disconnected. error: ${error}`);

    this._root._dispose();

    this._debugLog(`starting cleanup`);

    for (const cleanup of this._cleanups) await cleanup().catch(() => {});

    this._onClose();

    this._debugLog(`finished cleanup`);
  }

  async close(reason) {
    if (this._disconnected) return;

    this._debugLog(`force closing connection: ${(reason === null || reason === void 0 ? void 0 : reason.reason) || ''} (${(reason === null || reason === void 0 ? void 0 : reason.code) || 0})`);

    try {
      this._ws.close(reason === null || reason === void 0 ? void 0 : reason.code, reason === null || reason === void 0 ? void 0 : reason.reason);
    } catch (e) {}
  }

}

exports.PlaywrightConnection = PlaywrightConnection;

function launchOptionsHash(options) {
  const copy = { ...options
  };

  for (const k of Object.keys(copy)) {
    const key = k;
    if (copy[key] === defaultLaunchOptions[key]) delete copy[key];
  }

  for (const key of optionsThatAllowBrowserReuse) delete copy[key];

  return JSON.stringify(copy);
}

const defaultLaunchOptions = {
  ignoreAllDefaultArgs: false,
  handleSIGINT: false,
  handleSIGTERM: false,
  handleSIGHUP: false,
  headless: true,
  devtools: false
};
const optionsThatAllowBrowserReuse = ['headless'];

/***/ }),

/***/ 7358:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Semaphore = exports.PlaywrightServer = void 0;

var _utilsBundle = __nccwpck_require__(1319);

var _http = _interopRequireDefault(__nccwpck_require__(3685));

var _playwright = __nccwpck_require__(4506);

var _playwrightConnection = __nccwpck_require__(4533);

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const debugLog = (0, _utilsBundle.debug)('pw:server');
let lastConnectionId = 0;
const kConnectionSymbol = Symbol('kConnection');

function newLogger() {
  const id = ++lastConnectionId;
  return message => debugLog(`[id=${id}] ${message}`);
}

class PlaywrightServer {
  constructor(mode, options) {
    this._preLaunchedPlaywright = null;
    this._wsServer = void 0;
    this._mode = void 0;
    this._options = void 0;
    this._mode = mode;
    this._options = options;

    if (mode === 'use-pre-launched-browser') {
      (0, _utils.assert)(options.preLaunchedBrowser);
      this._preLaunchedPlaywright = options.preLaunchedBrowser.options.rootSdkObject;
    }

    if (mode === 'reuse-browser') this._preLaunchedPlaywright = (0, _playwright.createPlaywright)('javascript');
  }

  preLaunchedPlaywright() {
    return this._preLaunchedPlaywright;
  }

  async listen(port = 0) {
    const server = _http.default.createServer((request, response) => {
      response.end('Running');
    });

    server.on('error', error => debugLog(error));
    const wsEndpoint = await new Promise((resolve, reject) => {
      server.listen(port, () => {
        const address = server.address();

        if (!address) {
          reject(new Error('Could not bind server socket'));
          return;
        }

        const wsEndpoint = typeof address === 'string' ? `${address}${this._options.path}` : `ws://127.0.0.1:${address.port}${this._options.path}`;
        resolve(wsEndpoint);
      }).on('error', reject);
    });
    debugLog('Listening at ' + wsEndpoint);
    this._wsServer = new _utilsBundle.wsServer({
      server,
      path: this._options.path
    });
    const semaphore = new Semaphore(this._options.maxConcurrentConnections);

    this._wsServer.on('connection', (ws, request) => {
      if (semaphore.requested() >= this._options.maxIncomingConnections) {
        ws.close(1013, 'Playwright Server is busy');
        return;
      }

      const url = new URL('http://localhost' + (request.url || ''));
      const browserHeader = request.headers['x-playwright-browser'];
      const browserName = url.searchParams.get('browser') || (Array.isArray(browserHeader) ? browserHeader[0] : browserHeader) || null;
      const proxyHeader = request.headers['x-playwright-proxy'];
      const proxyValue = url.searchParams.get('proxy') || (Array.isArray(proxyHeader) ? proxyHeader[0] : proxyHeader);
      const enableSocksProxy = this._options.enableSocksProxy && proxyValue === '*';
      const launchOptionsHeader = request.headers['x-playwright-launch-options'] || '';
      let launchOptions = {};

      try {
        launchOptions = JSON.parse(Array.isArray(launchOptionsHeader) ? launchOptionsHeader[0] : launchOptionsHeader);
      } catch (e) {}

      const log = newLogger();
      log(`serving connection: ${request.url}`);
      const connection = new _playwrightConnection.PlaywrightConnection(semaphore.aquire(), this._mode, ws, {
        enableSocksProxy,
        browserName,
        launchOptions
      }, {
        playwright: this._preLaunchedPlaywright,
        browser: this._options.preLaunchedBrowser || null
      }, log, () => semaphore.release());
      ws[kConnectionSymbol] = connection;
    });

    return wsEndpoint;
  }

  async close() {
    const server = this._wsServer;
    if (!server) return;
    debugLog('closing websocket server');
    const waitForClose = new Promise(f => server.close(f)); // First disconnect all remaining clients.

    await Promise.all(Array.from(server.clients).map(async ws => {
      const connection = ws[kConnectionSymbol];
      if (connection) await connection.close();

      try {
        ws.terminate();
      } catch (e) {}
    }));
    await waitForClose;
    debugLog('closing http server');
    await new Promise(f => server.options.server.close(f));
    this._wsServer = undefined;
    debugLog('closed server');
  }

}

exports.PlaywrightServer = PlaywrightServer;

class Semaphore {
  constructor(max) {
    this._max = void 0;
    this._aquired = 0;
    this._queue = [];
    this._max = max;
  }

  aquire() {
    const lock = new _manualPromise.ManualPromise();

    this._queue.push(lock);

    this._flush();

    return lock;
  }

  requested() {
    return this._aquired + this._queue.length;
  }

  release() {
    --this._aquired;

    this._flush();
  }

  _flush() {
    while (this._aquired < this._max && this._queue.length) {
      ++this._aquired;

      this._queue.shift().resolve();
    }
  }

}

exports.Semaphore = Semaphore;

/***/ }),

/***/ 5900:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Accessibility = void 0;

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Accessibility {
  constructor(getAXTree) {
    this._getAXTree = void 0;
    this._getAXTree = getAXTree;
  }

  async snapshot(options = {}) {
    const {
      interestingOnly = true,
      root = null
    } = options;
    const {
      tree,
      needle
    } = await this._getAXTree(root || undefined);

    if (!interestingOnly) {
      if (root) return needle && serializeTree(needle)[0];
      return serializeTree(tree)[0];
    }

    const interestingNodes = new Set();
    collectInterestingNodes(interestingNodes, tree, false);
    if (root && (!needle || !interestingNodes.has(needle))) return null;
    return serializeTree(needle || tree, interestingNodes)[0];
  }

}

exports.Accessibility = Accessibility;

function collectInterestingNodes(collection, node, insideControl) {
  if (node.isInteresting(insideControl)) collection.add(node);
  if (node.isLeafNode()) return;
  insideControl = insideControl || node.isControl();

  for (const child of node.children()) collectInterestingNodes(collection, child, insideControl);
}

function serializeTree(node, whitelistedNodes) {
  const children = [];

  for (const child of node.children()) children.push(...serializeTree(child, whitelistedNodes));

  if (whitelistedNodes && !whitelistedNodes.has(node)) return children;
  const serializedNode = node.serialize();
  if (children.length) serializedNode.children = children;
  return [serializedNode];
}

/***/ }),

/***/ 6781:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AndroidDevice = exports.Android = void 0;

var _utilsBundle = __nccwpck_require__(1319);

var _events = __nccwpck_require__(2361);

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _browserContext = __nccwpck_require__(5985);

var _progress = __nccwpck_require__(2836);

var _crBrowser = __nccwpck_require__(2731);

var _helper = __nccwpck_require__(9175);

var _transport = __nccwpck_require__(3086);

var _debugLogger = __nccwpck_require__(2003);

var _processLauncher = __nccwpck_require__(1441);

var _timeoutSettings = __nccwpck_require__(9053);

var _instrumentation = __nccwpck_require__(6686);

var _chromium = __nccwpck_require__(2302);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), 'playwright-artifacts-');

class Android extends _instrumentation.SdkObject {
  constructor(backend, playwrightOptions) {
    super(playwrightOptions.rootSdkObject, 'android');
    this._backend = void 0;
    this._devices = new Map();
    this._timeoutSettings = void 0;
    this._playwrightOptions = void 0;
    this._backend = backend;
    this._playwrightOptions = playwrightOptions;
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }

  async devices(options) {
    const devices = (await this._backend.devices(options)).filter(d => d.status === 'device');
    const newSerials = new Set();

    for (const d of devices) {
      newSerials.add(d.serial);
      if (this._devices.has(d.serial)) continue;
      const device = await AndroidDevice.create(this, d, options);

      this._devices.set(d.serial, device);
    }

    for (const d of this._devices.keys()) {
      if (!newSerials.has(d)) this._devices.delete(d);
    }

    return [...this._devices.values()];
  }

  _deviceClosed(device) {
    this._devices.delete(device.serial);
  }

}

exports.Android = Android;

class AndroidDevice extends _instrumentation.SdkObject {
  constructor(android, backend, model, options) {
    super(android, 'android-device');
    this._backend = void 0;
    this.model = void 0;
    this.serial = void 0;
    this._options = void 0;
    this._driverPromise = void 0;
    this._lastId = 0;
    this._callbacks = new Map();
    this._pollingWebViews = void 0;
    this._timeoutSettings = void 0;
    this._webViews = new Map();
    this._browserConnections = new Set();
    this._android = void 0;
    this._isClosed = false;
    this._android = android;
    this._backend = backend;
    this.model = model;
    this.serial = backend.serial;
    this._options = options;
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(android._timeoutSettings);
  }

  static async create(android, backend, options) {
    await backend.init();
    const model = await backend.runCommand('shell:getprop ro.product.model');
    const device = new AndroidDevice(android, backend, model.toString().trim(), options);
    await device._init();
    return device;
  }

  async _init() {
    await this._refreshWebViews();

    const poll = () => {
      this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {}), 500);
    };

    poll();
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }

  async shell(command) {
    const result = await this._backend.runCommand(`shell:${command}`);
    await this._refreshWebViews();
    return result;
  }

  async open(command) {
    return await this._backend.open(`${command}`);
  }

  async screenshot() {
    return await this._backend.runCommand(`shell:screencap -p`);
  }

  async _driver() {
    if (!this._driverPromise) this._driverPromise = this._installDriver();
    return this._driverPromise;
  }

  async _installDriver() {
    (0, _utilsBundle.debug)('pw:android')('Stopping the old driver');
    await this.shell(`am force-stop com.microsoft.playwright.androiddriver`); // uninstall and install driver on every excution

    if (!this._options.omitDriverInstall) {
      (0, _utilsBundle.debug)('pw:android')('Uninstalling the old driver');
      await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
      await this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
      (0, _utilsBundle.debug)('pw:android')('Installing the new driver');

      for (const file of ['android-driver.apk', 'android-driver-target.apk']) await this.installApk(await _fs.default.promises.readFile(require.resolve(`../../../bin/${file}`)));
    } else {
      (0, _utilsBundle.debug)('pw:android')('Skipping the driver installation');
    }

    (0, _utilsBundle.debug)('pw:android')('Starting the new driver');
    this.shell('am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner').catch(e => (0, _utilsBundle.debug)('pw:android')(e));
    const socket = await this._waitForLocalAbstract('playwright_android_driver_socket');
    const transport = new _transport.PipeTransport(socket, socket, socket, 'be');

    transport.onmessage = message => {
      const response = JSON.parse(message);
      const {
        id,
        result,
        error
      } = response;

      const callback = this._callbacks.get(id);

      if (!callback) return;
      if (error) callback.reject(new Error(error));else callback.fulfill(result);

      this._callbacks.delete(id);
    };

    return transport;
  }

  async _waitForLocalAbstract(socketName) {
    let socket;
    (0, _utilsBundle.debug)('pw:android')(`Polling the socket localabstract:${socketName}`);

    while (!socket) {
      try {
        socket = await this._backend.open(`localabstract:${socketName}`);
      } catch (e) {
        await new Promise(f => setTimeout(f, 250));
      }
    }

    (0, _utilsBundle.debug)('pw:android')(`Connected to localabstract:${socketName}`);
    return socket;
  }

  async send(method, params = {}) {
    // Patch the timeout in!
    params.timeout = this._timeoutSettings.timeout(params);
    const driver = await this._driver();
    const id = ++this._lastId;
    const result = new Promise((fulfill, reject) => this._callbacks.set(id, {
      fulfill,
      reject
    }));
    driver.send(JSON.stringify({
      id,
      method,
      params
    }));
    return result;
  }

  async close() {
    this._isClosed = true;
    if (this._pollingWebViews) clearTimeout(this._pollingWebViews);

    for (const connection of this._browserConnections) await connection.close();

    if (this._driverPromise) {
      const driver = await this._driver();
      driver.close();
    }

    await this._backend.close();

    this._android._deviceClosed(this);

    this.emit(AndroidDevice.Events.Closed);
  }

  async launchBrowser(pkg = 'com.android.chrome', options) {
    (0, _utilsBundle.debug)('pw:android')('Force-stopping', pkg);
    await this._backend.runCommand(`shell:am force-stop ${pkg}`);
    const socketName = (0, _utils.isUnderTest)() ? 'webview_devtools_remote_playwright_test' : 'playwright-' + (0, _utils.createGuid)();
    const commandLine = ['_', '--disable-fre', '--no-default-browser-check', `--remote-debugging-socket-name=${socketName}`, ..._chromium.DEFAULT_ARGS].join(' ');
    (0, _utilsBundle.debug)('pw:android')('Starting', pkg, commandLine);
    await this._backend.runCommand(`shell:echo "${commandLine}" > /data/local/tmp/chrome-command-line`);
    await this._backend.runCommand(`shell:am start -a android.intent.action.VIEW -d about:blank ${pkg}`);
    return await this._connectToBrowser(socketName, options);
  }

  async connectToWebView(socketName) {
    const webView = this._webViews.get(socketName);

    if (!webView) throw new Error('WebView has been closed');
    return await this._connectToBrowser(socketName);
  }

  async _connectToBrowser(socketName, options = {}) {
    const socket = await this._waitForLocalAbstract(socketName);
    const androidBrowser = new AndroidBrowser(this, socket);
    await androidBrowser._init();

    this._browserConnections.add(androidBrowser);

    const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);

    const cleanupArtifactsDir = async () => {
      const errors = await (0, _fileUtils.removeFolders)([artifactsDir]);

      for (let i = 0; i < (errors || []).length; ++i) (0, _utilsBundle.debug)('pw:android')(`exception while removing ${artifactsDir}: ${errors[i]}`);
    };

    _processLauncher.gracefullyCloseSet.add(cleanupArtifactsDir);

    socket.on('close', async () => {
      _processLauncher.gracefullyCloseSet.delete(cleanupArtifactsDir);

      cleanupArtifactsDir().catch(e => (0, _utilsBundle.debug)('pw:android')(`could not cleanup artifacts dir: ${e}`));
    });
    const browserOptions = { ...this._android._playwrightOptions,
      name: 'clank',
      isChromium: true,
      slowMo: 0,
      persistent: { ...options,
        noDefaultViewport: true
      },
      artifactsDir,
      downloadsPath: artifactsDir,
      tracesDir: artifactsDir,
      browserProcess: new ClankBrowserProcess(androidBrowser),
      proxy: options.proxy,
      protocolLogger: _helper.helper.debugProtocolLogger(),
      browserLogsCollector: new _debugLogger.RecentLogsCollector(),
      originalLaunchOptions: {}
    };
    (0, _browserContext.validateBrowserContextOptions)(options, browserOptions);
    const browser = await _crBrowser.CRBrowser.connect(androidBrowser, browserOptions);
    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
    const defaultContext = browser._defaultContext;
    await controller.run(async progress => {
      await defaultContext._loadDefaultContextAsIs(progress);
    });
    return defaultContext;
  }

  webViews() {
    return [...this._webViews.values()];
  }

  async installApk(content, options) {
    const args = options && options.args ? options.args : ['-r', '-t', '-S'];
    (0, _utilsBundle.debug)('pw:android')('Opening install socket');
    const installSocket = await this._backend.open(`shell:cmd package install ${args.join(' ')} ${content.length}`);
    (0, _utilsBundle.debug)('pw:android')('Writing driver bytes: ' + content.length);
    await installSocket.write(content);
    const success = await new Promise(f => installSocket.on('data', f));
    (0, _utilsBundle.debug)('pw:android')('Written driver bytes: ' + success);
    installSocket.close();
  }

  async push(content, path, mode = 0o644) {
    const socket = await this._backend.open(`sync:`);

    const sendHeader = async (command, length) => {
      const buffer = Buffer.alloc(command.length + 4);
      buffer.write(command, 0);
      buffer.writeUInt32LE(length, command.length);
      await socket.write(buffer);
    };

    const send = async (command, data) => {
      await sendHeader(command, data.length);
      await socket.write(data);
    };

    await send('SEND', Buffer.from(`${path},${mode}`));
    const maxChunk = 65535;

    for (let i = 0; i < content.length; i += maxChunk) await send('DATA', content.slice(i, i + maxChunk));

    await sendHeader('DONE', Date.now() / 1000 | 0);
    const result = await new Promise(f => socket.once('data', f));
    const code = result.slice(0, 4).toString();
    if (code !== 'OKAY') throw new Error('Could not push: ' + code);
    socket.close();
  }

  async _refreshWebViews() {
    // possible socketName, eg: webview_devtools_remote_32327, webview_devtools_remote_32327_zeus, webview_devtools_remote_zeus
    const sockets = (await this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split('\n');
    if (this._isClosed) return;
    const socketNames = new Set();

    for (const line of sockets) {
      const matchSocketName = line.match(/[^@]+@(.*?webview_devtools_remote_?.*)/);
      if (!matchSocketName) continue;
      const socketName = matchSocketName[1];
      socketNames.add(socketName);
      if (this._webViews.has(socketName)) continue; // possible line: 0000000000000000: 00000002 00000000 00010000 0001 01 5841881 @webview_devtools_remote_zeus
      // the result: match[1] = ''

      const match = line.match(/[^@]+@.*?webview_devtools_remote_?(\d*)/);
      let pid = -1;
      if (match && match[1]) pid = +match[1];
      const pkg = await this._extractPkg(pid);
      if (this._isClosed) return;
      const webView = {
        pid,
        pkg,
        socketName
      };

      this._webViews.set(socketName, webView);

      this.emit(AndroidDevice.Events.WebViewAdded, webView);
    }

    for (const p of this._webViews.keys()) {
      if (!socketNames.has(p)) {
        this._webViews.delete(p);

        this.emit(AndroidDevice.Events.WebViewRemoved, p);
      }
    }
  }

  async _extractPkg(pid) {
    let pkg = '';
    if (pid === -1) return pkg;
    const procs = (await this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split('\n');

    for (const proc of procs) {
      const match = proc.match(/[^\s]+\s+(\d+).*$/);
      if (!match) continue;
      pkg = proc.substring(proc.lastIndexOf(' ') + 1);
    }

    return pkg;
  }

}

exports.AndroidDevice = AndroidDevice;
AndroidDevice.Events = {
  WebViewAdded: 'webViewAdded',
  WebViewRemoved: 'webViewRemoved',
  Closed: 'closed'
};

class AndroidBrowser extends _events.EventEmitter {
  constructor(device, socket) {
    super();
    this.device = void 0;
    this._socket = void 0;
    this._receiver = void 0;
    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
    this.onmessage = void 0;
    this.onclose = void 0;
    this.setMaxListeners(0);
    this.device = device;
    this._socket = socket;

    this._socket.on('close', () => {
      this._waitForNextTask(() => {
        if (this.onclose) this.onclose();
      });
    });

    this._receiver = new _utilsBundle.wsReceiver();

    this._receiver.on('message', message => {
      this._waitForNextTask(() => {
        if (this.onmessage) this.onmessage(JSON.parse(message));
      });
    });
  }

  async _init() {
    await this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`)); // HTTP Upgrade response.

    await new Promise(f => this._socket.once('data', f)); // Start sending web frame to receiver.

    this._socket.on('data', data => this._receiver._write(data, 'binary', () => {}));
  }

  async send(s) {
    await this._socket.write(encodeWebFrame(JSON.stringify(s)));
  }

  async close() {
    this._socket.close();
  }

}

function encodeWebFrame(data) {
  return _utilsBundle.wsSender.frame(Buffer.from(data), {
    opcode: 1,
    mask: true,
    fin: true,
    readOnly: true
  })[0];
}

class ClankBrowserProcess {
  constructor(browser) {
    this._browser = void 0;
    this.onclose = void 0;
    this._browser = browser;
  }

  async kill() {}

  async close() {
    await this._browser.close();
  }

}

/***/ }),

/***/ 389:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AdbBackend = void 0;

var _utilsBundle = __nccwpck_require__(1319);

var net = _interopRequireWildcard(__nccwpck_require__(1808));

var _events = __nccwpck_require__(2361);

var _utils = __nccwpck_require__(3557);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AdbBackend {
  async devices(options = {}) {
    const result = await runCommand('host:devices', options.host, options.port);
    const lines = result.toString().trim().split('\n');
    return lines.map(line => {
      const [serial, status] = line.trim().split('\t');
      return new AdbDevice(serial, status, options.host, options.port);
    });
  }

}

exports.AdbBackend = AdbBackend;

class AdbDevice {
  constructor(serial, status, host, port) {
    this.serial = void 0;
    this.status = void 0;
    this.host = void 0;
    this.port = void 0;
    this.serial = serial;
    this.status = status;
    this.host = host;
    this.port = port;
  }

  async init() {}

  async close() {}

  runCommand(command) {
    return runCommand(command, this.host, this.port, this.serial);
  }

  async open(command) {
    const result = await open(command, this.host, this.port, this.serial);
    result.becomeSocket();
    return result;
  }

}

async function runCommand(command, host = '127.0.0.1', port = 5037, serial) {
  (0, _utilsBundle.debug)('pw:adb:runCommand')(command, serial);
  const socket = new BufferedSocketWrapper(command, net.createConnection({
    host,
    port
  }));

  if (serial) {
    await socket.write(encodeMessage(`host:transport:${serial}`));
    const status = await socket.read(4);
    (0, _utils.assert)(status.toString() === 'OKAY', status.toString());
  }

  await socket.write(encodeMessage(command));
  const status = await socket.read(4);
  (0, _utils.assert)(status.toString() === 'OKAY', status.toString());
  let commandOutput;

  if (!command.startsWith('shell:')) {
    const remainingLength = parseInt((await socket.read(4)).toString(), 16);
    commandOutput = await socket.read(remainingLength);
  } else {
    commandOutput = await socket.readAll();
  }

  socket.close();
  return commandOutput;
}

async function open(command, host = '127.0.0.1', port = 5037, serial) {
  const socket = new BufferedSocketWrapper(command, net.createConnection({
    host,
    port
  }));

  if (serial) {
    await socket.write(encodeMessage(`host:transport:${serial}`));
    const status = await socket.read(4);
    (0, _utils.assert)(status.toString() === 'OKAY', status.toString());
  }

  await socket.write(encodeMessage(command));
  const status = await socket.read(4);
  (0, _utils.assert)(status.toString() === 'OKAY', status.toString());
  return socket;
}

function encodeMessage(message) {
  let lenHex = message.length.toString(16);
  lenHex = '0'.repeat(4 - lenHex.length) + lenHex;
  return Buffer.from(lenHex + message);
}

class BufferedSocketWrapper extends _events.EventEmitter {
  constructor(command, socket) {
    super();
    this.guid = (0, _utils.createGuid)();
    this._socket = void 0;
    this._buffer = Buffer.from([]);
    this._isSocket = false;
    this._notifyReader = void 0;
    this._connectPromise = void 0;
    this._isClosed = false;
    this._command = void 0;
    this._command = command;
    this._socket = socket;
    this._connectPromise = new Promise(f => this._socket.on('connect', f));

    this._socket.on('data', data => {
      (0, _utilsBundle.debug)('pw:adb:data')(data.toString());

      if (this._isSocket) {
        this.emit('data', data);
        return;
      }

      this._buffer = Buffer.concat([this._buffer, data]);
      if (this._notifyReader) this._notifyReader();
    });

    this._socket.on('close', () => {
      this._isClosed = true;
      if (this._notifyReader) this._notifyReader();
      this.close();
      this.emit('close');
    });

    this._socket.on('error', error => this.emit('error', error));
  }

  async write(data) {
    (0, _utilsBundle.debug)('pw:adb:send')(data.toString().substring(0, 100) + '...');
    await this._connectPromise;
    await new Promise(f => this._socket.write(data, f));
  }

  close() {
    if (this._isClosed) return;
    (0, _utilsBundle.debug)('pw:adb')('Close ' + this._command);

    this._socket.destroy();
  }

  async read(length) {
    await this._connectPromise;
    (0, _utils.assert)(!this._isSocket, 'Can not read by length in socket mode');

    while (this._buffer.length < length) await new Promise(f => this._notifyReader = f);

    const result = this._buffer.slice(0, length);

    this._buffer = this._buffer.slice(length);
    (0, _utilsBundle.debug)('pw:adb:recv')(result.toString().substring(0, 100) + '...');
    return result;
  }

  async readAll() {
    while (!this._isClosed) await new Promise(f => this._notifyReader = f);

    return this._buffer;
  }

  becomeSocket() {
    (0, _utils.assert)(!this._buffer.length);
    this._isSocket = true;
  }

}

/***/ }),

/***/ 1796:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Artifact = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

var _instrumentation = __nccwpck_require__(6686);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Artifact extends _instrumentation.SdkObject {
  constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
    super(parent, 'artifact');
    this._localPath = void 0;
    this._unaccessibleErrorMessage = void 0;
    this._cancelCallback = void 0;
    this._finishedPromise = new _manualPromise.ManualPromise();
    this._saveCallbacks = [];
    this._finished = false;
    this._deleted = false;
    this._failureError = null;
    this._localPath = localPath;
    this._unaccessibleErrorMessage = unaccessibleErrorMessage;
    this._cancelCallback = cancelCallback;
  }

  finishedPromise() {
    return this._finishedPromise;
  }

  localPath() {
    return this._localPath;
  }

  async localPathAfterFinished() {
    if (this._unaccessibleErrorMessage) throw new Error(this._unaccessibleErrorMessage);
    await this._finishedPromise;
    if (this._failureError) return null;
    return this._localPath;
  }

  saveAs(saveCallback) {
    if (this._unaccessibleErrorMessage) throw new Error(this._unaccessibleErrorMessage);
    if (this._deleted) throw new Error(`File already deleted. Save before deleting.`);
    if (this._failureError) throw new Error(`File not found on disk. Check download.failure() for details.`);

    if (this._finished) {
      saveCallback(this._localPath).catch(e => {});
      return;
    }

    this._saveCallbacks.push(saveCallback);
  }

  async failureError() {
    if (this._unaccessibleErrorMessage) return this._unaccessibleErrorMessage;
    await this._finishedPromise;
    return this._failureError;
  }

  async cancel() {
    (0, _utils.assert)(this._cancelCallback !== undefined);
    return this._cancelCallback();
  }

  async delete() {
    if (this._unaccessibleErrorMessage) return;
    const fileName = await this.localPathAfterFinished();
    if (this._deleted) return;
    this._deleted = true;
    if (fileName) await _fs.default.promises.unlink(fileName).catch(e => {});
  }

  async deleteOnContextClose() {
    // Compared to "delete", this method does not wait for the artifact to finish.
    // We use it when closing the context to avoid stalling.
    if (this._deleted) return;
    this._deleted = true;
    if (!this._unaccessibleErrorMessage) await _fs.default.promises.unlink(this._localPath).catch(e => {});
    await this.reportFinished('File deleted upon browser context closure.');
  }

  async reportFinished(error) {
    if (this._finished) return;
    this._finished = true;
    this._failureError = error || null;

    if (error) {
      for (const callback of this._saveCallbacks) await callback('', error);
    } else {
      for (const callback of this._saveCallbacks) await callback(this._localPath);
    }

    this._saveCallbacks = [];

    this._finishedPromise.resolve();
  }

}

exports.Artifact = Artifact;

/***/ }),

/***/ 6705:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Browser = void 0;

var _browserContext = __nccwpck_require__(5985);

var _page = __nccwpck_require__(3555);

var _download = __nccwpck_require__(3404);

var _instrumentation = __nccwpck_require__(6686);

var _artifact = __nccwpck_require__(1796);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Browser extends _instrumentation.SdkObject {
  constructor(options) {
    super(options.rootSdkObject, 'browser');
    this.options = void 0;
    this._downloads = new Map();
    this._defaultContext = null;
    this._startedClosing = false;
    this._idToVideo = new Map();
    this._contextForReuse = void 0;
    this.attribution.browser = this;
    this.options = options;
    this.instrumentation.onBrowserOpen(this);
  }

  async newContext(metadata, options) {
    (0, _browserContext.validateBrowserContextOptions)(options, this.options);
    const context = await this.doCreateNewContext(options);
    if (options.storageState) await context.setStorageState(metadata, options.storageState);
    return context;
  }

  async newContextForReuse(params, metadata) {
    const hash = _browserContext.BrowserContext.reusableContextHash(params);

    for (const context of this.contexts()) {
      var _this$_contextForReus;

      if (context !== ((_this$_contextForReus = this._contextForReuse) === null || _this$_contextForReus === void 0 ? void 0 : _this$_contextForReus.context)) await context.close(metadata);
    }

    if (!this._contextForReuse || hash !== this._contextForReuse.hash || !this._contextForReuse.context.canResetForReuse()) {
      if (this._contextForReuse) await this._contextForReuse.context.close(metadata);
      this._contextForReuse = {
        context: await this.newContext(metadata, params),
        hash
      };
      return {
        context: this._contextForReuse.context,
        needsReset: false
      };
    }

    return {
      context: this._contextForReuse.context,
      needsReset: true
    };
  }

  _downloadCreated(page, uuid, url, suggestedFilename) {
    const download = new _download.Download(page, this.options.downloadsPath || '', uuid, url, suggestedFilename);

    this._downloads.set(uuid, download);
  }

  _downloadFilenameSuggested(uuid, suggestedFilename) {
    const download = this._downloads.get(uuid);

    if (!download) return;

    download._filenameSuggested(suggestedFilename);
  }

  _downloadFinished(uuid, error) {
    const download = this._downloads.get(uuid);

    if (!download) return;
    download.artifact.reportFinished(error);

    this._downloads.delete(uuid);
  }

  _videoStarted(context, videoId, path, pageOrError) {
    const artifact = new _artifact.Artifact(context, path);

    this._idToVideo.set(videoId, {
      context,
      artifact
    });

    pageOrError.then(page => {
      if (page instanceof _page.Page) {
        page._video = artifact;
        page.emitOnContext(_browserContext.BrowserContext.Events.VideoStarted, artifact);
        page.emit(_page.Page.Events.Video, artifact);
      }
    });
  }

  _takeVideo(videoId) {
    const video = this._idToVideo.get(videoId);

    this._idToVideo.delete(videoId);

    return video === null || video === void 0 ? void 0 : video.artifact;
  }

  _didClose() {
    for (const context of this.contexts()) context._browserClosed();

    if (this._defaultContext) this._defaultContext._browserClosed();
    this.emit(Browser.Events.Disconnected);
    this.instrumentation.onBrowserClose(this);
  }

  async close() {
    if (!this._startedClosing) {
      this._startedClosing = true;
      await this.options.browserProcess.close();
    }

    if (this.isConnected()) await new Promise(x => this.once(Browser.Events.Disconnected, x));
  }

  async killForTests() {
    await this.options.browserProcess.kill();
  }

}

exports.Browser = Browser;
Browser.Events = {
  Disconnected: 'disconnected'
};

/***/ }),

/***/ 5985:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BrowserContext = void 0;
exports.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
exports.normalizeProxySettings = normalizeProxySettings;
exports.validateBrowserContextOptions = validateBrowserContextOptions;
exports.verifyGeolocation = verifyGeolocation;

var os = _interopRequireWildcard(__nccwpck_require__(2037));

var _timeoutSettings = __nccwpck_require__(9053);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _helper = __nccwpck_require__(9175);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _page4 = __nccwpck_require__(3555);

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _instrumentation = __nccwpck_require__(6686);

var _debugger = __nccwpck_require__(7370);

var _tracing = __nccwpck_require__(865);

var _harRecorder = __nccwpck_require__(746);

var _recorder = __nccwpck_require__(8584);

var consoleApiSource = _interopRequireWildcard(__nccwpck_require__(4989));

var _fetch = __nccwpck_require__(2857);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserContext extends _instrumentation.SdkObject {
  constructor(browser, options, browserContextId) {
    super(browser, 'browser-context');
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
    this._pageBindings = new Map();
    this._options = void 0;
    this._requestInterceptor = void 0;
    this._isPersistentContext = void 0;
    this._closedStatus = 'open';
    this._closePromise = void 0;
    this._closePromiseFulfill = void 0;
    this._permissions = new Map();
    this._downloads = new Set();
    this._browser = void 0;
    this._browserContextId = void 0;
    this._selectors = void 0;
    this._origins = new Set();
    this._harRecorders = new Map();
    this.tracing = void 0;
    this.fetchRequest = void 0;
    this._customCloseHandler = void 0;
    this._tempDirs = [];
    this._settingStorageState = false;
    this.initScripts = [];
    this._routesInFlight = new Set();
    this.attribution.context = this;
    this._browser = browser;
    this._options = options;
    this._browserContextId = browserContextId;
    this._isPersistentContext = !browserContextId;
    this._closePromise = new Promise(fulfill => this._closePromiseFulfill = fulfill);
    this.fetchRequest = new _fetch.BrowserContextAPIRequestContext(this);
    if (this._options.recordHar) this._harRecorders.set('', new _harRecorder.HarRecorder(this, null, this._options.recordHar));
    this.tracing = new _tracing.Tracing(this, browser.options.tracesDir);
  }

  isPersistentContext() {
    return this._isPersistentContext;
  }

  setSelectors(selectors) {
    this._selectors = selectors;

    for (const page of this.pages()) page.selectors = selectors;
  }

  selectors() {
    return this._selectors || this._browser.options.selectors;
  }

  async _initialize() {
    if (this.attribution.isInternalPlaywright) return; // Debugger will pause execution upon page.pause in headed mode.

    const contextDebugger = new _debugger.Debugger(this); // When PWDEBUG=1, show inspector for each context.

    if ((0, _utils.debugMode)() === 'inspector') await _recorder.Recorder.show(this, {
      pauseOnNextStatement: true
    }); // When paused, show inspector.

    if (contextDebugger.isPaused()) _recorder.Recorder.showInspector(this);
    contextDebugger.on(_debugger.Debugger.Events.PausedStateChanged, () => {
      _recorder.Recorder.showInspector(this);
    });
    if ((0, _utils.debugMode)() === 'console') await this.extendInjectedScript(consoleApiSource.source);
    if (this._options.serviceWorkers === 'block') await this.addInitScript(`\nnavigator.serviceWorker.register = () => { console.warn('Service Worker registration blocked by Playwright'); };\n`);
    if (this._options.permissions) await this.grantPermissions(this._options.permissions);
  }

  async _ensureVideosPath() {
    if (this._options.recordVideo) await (0, _fileUtils.mkdirIfNeeded)(_path.default.join(this._options.recordVideo.dir, 'dummy'));
  }

  canResetForReuse() {
    if (this._closedStatus !== 'open') return false;
    return true;
  }

  static reusableContextHash(params) {
    const paramsCopy = { ...params
    };

    for (const k of Object.keys(paramsCopy)) {
      const key = k;
      if (paramsCopy[key] === defaultNewContextParamValues[key]) delete paramsCopy[key];
    }

    for (const key of paramsThatAllowContextReuse) delete paramsCopy[key];

    return JSON.stringify(paramsCopy);
  }

  async resetForReuse(metadata, params) {
    var _page, _page2, _page3;

    this.setDefaultNavigationTimeout(undefined);
    this.setDefaultTimeout(undefined);

    if (params) {
      for (const key of paramsThatAllowContextReuse) this._options[key] = params[key];
    }

    await this._cancelAllRoutesInFlight(); // Close extra pages early.

    let page = this.pages()[0];
    const [, ...otherPages] = this.pages();

    for (const p of otherPages) await p.close(metadata);

    if (page && page._crashedPromise.isDone()) {
      await page.close(metadata);
      page = undefined;
    } // Unless I do this early, setting extra http headers below does not respond.


    await ((_page = page) === null || _page === void 0 ? void 0 : _page._frameManager.closeOpenDialogs()); // Navigate to about:blank first to ensure no page scripts are running after this point.

    await ((_page2 = page) === null || _page2 === void 0 ? void 0 : _page2.mainFrame().goto(metadata, 'about:blank', {
      timeout: 0
    }));
    await this._clearStorage();
    await this._removeExposedBindings();
    await this._removeInitScripts(); // TODO: following can be optimized to not perform noops.

    if (this._options.permissions) await this.grantPermissions(this._options.permissions);else await this.clearPermissions();
    await this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []);
    await this.setGeolocation(this._options.geolocation);
    await this.setOffline(!!this._options.offline);
    await this.setUserAgent(this._options.userAgent);
    await this.clearCookies();
    await ((_page3 = page) === null || _page3 === void 0 ? void 0 : _page3.resetForReuse(metadata));
  }

  _browserClosed() {
    for (const page of this.pages()) page._didClose();

    this._didCloseInternal();
  }

  _didCloseInternal() {
    if (this._closedStatus === 'closed') {
      // We can come here twice if we close browser context and browser
      // at the same time.
      return;
    }

    this._closedStatus = 'closed';

    this._deleteAllDownloads();

    this._downloads.clear();

    this.tracing.dispose();
    if (this._isPersistentContext) this.onClosePersistent();

    this._closePromiseFulfill(new Error('Context closed'));

    this.emit(BrowserContext.Events.Close);
  } // BrowserContext methods.


  async cookies(urls = []) {
    if (urls && !Array.isArray(urls)) urls = [urls];
    return await this.doGetCookies(urls);
  }

  setHTTPCredentials(httpCredentials) {
    return this.doSetHTTPCredentials(httpCredentials);
  }

  async exposeBinding(name, needsHandle, playwrightBinding) {
    if (this._pageBindings.has(name)) throw new Error(`Function "${name}" has been already registered`);

    for (const page of this.pages()) {
      if (page.getBinding(name)) throw new Error(`Function "${name}" has been already registered in one of the pages`);
    }

    const binding = new _page4.PageBinding(name, playwrightBinding, needsHandle);

    this._pageBindings.set(name, binding);

    await this.doExposeBinding(binding);
  }

  async _removeExposedBindings() {
    for (const key of this._pageBindings.keys()) {
      if (!key.startsWith('__pw')) this._pageBindings.delete(key);
    }

    await this.doRemoveExposedBindings();
  }

  async grantPermissions(permissions, origin) {
    let resolvedOrigin = '*';

    if (origin) {
      const url = new URL(origin);
      resolvedOrigin = url.origin;
    }

    const existing = new Set(this._permissions.get(resolvedOrigin) || []);
    permissions.forEach(p => existing.add(p));
    const list = [...existing.values()];

    this._permissions.set(resolvedOrigin, list);

    await this.doGrantPermissions(resolvedOrigin, list);
  }

  async clearPermissions() {
    this._permissions.clear();

    await this.doClearPermissions();
  }

  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }

  async _loadDefaultContextAsIs(progress) {
    if (!this.pages().length) {
      const waitForEvent = _helper.helper.waitForEvent(progress, this, BrowserContext.Events.Page);

      progress.cleanupWhenAborted(() => waitForEvent.dispose);
      const page = await waitForEvent.promise;
      if (page._pageIsError) throw page._pageIsError;
    }

    const pages = this.pages();
    if (pages[0]._pageIsError) throw pages[0]._pageIsError;
    await pages[0].mainFrame()._waitForLoadState(progress, 'load');
    return pages;
  }

  async _loadDefaultContext(progress) {
    const pages = await this._loadDefaultContextAsIs(progress);
    const browserName = this._browser.options.name;

    if (this._options.isMobile && browserName === 'chromium' || this._options.locale && browserName === 'webkit') {
      // Workaround for:
      // - chromium fails to change isMobile for existing page;
      // - webkit fails to change locale for existing page.
      const oldPage = pages[0];
      await this.newPage(progress.metadata);
      await oldPage.close(progress.metadata);
    }
  }

  _authenticateProxyViaHeader() {
    const proxy = this._options.proxy || this._browser.options.proxy || {
      username: undefined,
      password: undefined
    };
    const {
      username,
      password
    } = proxy;

    if (username) {
      this._options.httpCredentials = {
        username,
        password: password
      };
      const token = Buffer.from(`${username}:${password}`).toString('base64');
      this._options.extraHTTPHeaders = network.mergeHeaders([this._options.extraHTTPHeaders, network.singleHeader('Proxy-Authorization', `Basic ${token}`)]);
    }
  }

  _authenticateProxyViaCredentials() {
    const proxy = this._options.proxy || this._browser.options.proxy;
    if (!proxy) return;
    const {
      username,
      password
    } = proxy;
    if (username) this._options.httpCredentials = {
      username,
      password: password || ''
    };
  }

  async addInitScript(script) {
    this.initScripts.push(script);
    await this.doAddInitScript(script);
  }

  async _removeInitScripts() {
    this.initScripts.splice(0, this.initScripts.length);
    await this.doRemoveInitScripts();
  }

  async setRequestInterceptor(handler) {
    this._requestInterceptor = handler;
    await this.doUpdateRequestInterception();
  }

  isClosingOrClosed() {
    return this._closedStatus !== 'open';
  }

  async _deleteAllDownloads() {
    await Promise.all(Array.from(this._downloads).map(download => download.artifact.deleteOnContextClose()));
  }

  async _deleteAllTempDirs() {
    await Promise.all(this._tempDirs.map(async dir => await _fs.default.promises.unlink(dir).catch(e => {})));
  }

  setCustomCloseHandler(handler) {
    this._customCloseHandler = handler;
  }

  async close(metadata) {
    if (this._closedStatus === 'open') {
      this.emit(BrowserContext.Events.BeforeClose);
      this._closedStatus = 'closing';

      for (const harRecorder of this._harRecorders.values()) await harRecorder.flush();

      await this.tracing.flush(); // Cleanup.

      const promises = [];

      for (const {
        context,
        artifact
      } of this._browser._idToVideo.values()) {
        // Wait for the videos to finish.
        if (context === this) promises.push(artifact.finishedPromise());
      }

      if (this._customCloseHandler) {
        await this._customCloseHandler();
      } else if (this._isPersistentContext) {
        // Close all the pages instead of the context,
        // because we cannot close the default context.
        await Promise.all(this.pages().map(page => page.close(metadata)));
      } else {
        // Close the context.
        await this.doClose();
      } // We delete downloads after context closure
      // so that browser does not write to the download file anymore.


      promises.push(this._deleteAllDownloads());
      promises.push(this._deleteAllTempDirs());
      await Promise.all(promises); // Custom handler should trigger didCloseInternal itself.

      if (this._customCloseHandler) return; // Persistent context should also close the browser.

      if (this._isPersistentContext) await this._browser.close(); // Bookkeeping.

      this._didCloseInternal();
    }

    await this._closePromise;
  }

  async newPage(metadata) {
    const pageDelegate = await this.newPageDelegate();
    if (metadata.isServerSide) pageDelegate.potentiallyUninitializedPage().markAsServerSideOnly();
    const pageOrError = await pageDelegate.pageOrError();

    if (pageOrError instanceof _page4.Page) {
      if (pageOrError.isClosed()) throw new Error('Page has been closed.');
      return pageOrError;
    }

    throw pageOrError;
  }

  addVisitedOrigin(origin) {
    this._origins.add(origin);
  }

  async storageState() {
    const result = {
      cookies: await this.cookies(),
      origins: []
    };

    if (this._origins.size) {
      const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
      const page = await this.newPage(internalMetadata);
      await page._setServerRequestInterceptor(handler => {
        handler.fulfill({
          body: '<html></html>'
        }).catch(() => {});
      });

      for (const origin of this._origins) {
        const originStorage = {
          origin,
          localStorage: []
        };
        const frame = page.mainFrame();
        await frame.goto(internalMetadata, origin);
        const storage = await frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, false, undefined, 'utility');
        originStorage.localStorage = storage.localStorage;
        if (storage.localStorage.length) result.origins.push(originStorage);
      }

      await page.close(internalMetadata);
    }

    return result;
  }

  async _clearStorage() {
    if (!this._origins.size) return;
    let page = this.pages()[0];
    const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
    page = page || (await this.newPage(internalMetadata));
    await page._setServerRequestInterceptor(handler => {
      handler.fulfill({
        body: '<html></html>'
      }).catch(() => {});
    });

    for (const origin of this._origins) {
      const frame = page.mainFrame();
      await frame.goto(internalMetadata, origin);
      await frame.clearStorageForCurrentOriginBestEffort();
    }

    await page._setServerRequestInterceptor(undefined); // It is safe to not restore the URL to about:blank since we are doing it in Page::resetForReuse.
  }

  isSettingStorageState() {
    return this._settingStorageState;
  }

  async setStorageState(metadata, state) {
    this._settingStorageState = true;

    try {
      if (state.cookies) await this.addCookies(state.cookies);

      if (state.origins && state.origins.length) {
        const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
        const page = await this.newPage(internalMetadata);
        await page._setServerRequestInterceptor(handler => {
          handler.fulfill({
            body: '<html></html>'
          }).catch(() => {});
        });

        for (const originState of state.origins) {
          const frame = page.mainFrame();
          await frame.goto(metadata, originState.origin);
          await frame.evaluateExpression(`
            originState => {
              for (const { name, value } of (originState.localStorage || []))
                localStorage.setItem(name, value);
            }`, true, originState, 'utility');
        }

        await page.close(internalMetadata);
      }
    } finally {
      this._settingStorageState = false;
    }
  }

  async extendInjectedScript(source, arg) {
    const installInFrame = frame => frame.extendInjectedScript(source, arg).catch(() => {});

    const installInPage = page => {
      page.on(_page4.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
      return Promise.all(page.frames().map(installInFrame));
    };

    this.on(BrowserContext.Events.Page, installInPage);
    return Promise.all(this.pages().map(installInPage));
  }

  async _harStart(page, options) {
    const harId = (0, _utils.createGuid)();

    this._harRecorders.set(harId, new _harRecorder.HarRecorder(this, page, options));

    return harId;
  }

  async _harExport(harId) {
    const recorder = this._harRecorders.get(harId || '');

    return recorder.export();
  }

  addRouteInFlight(route) {
    this._routesInFlight.add(route);
  }

  removeRouteInFlight(route) {
    this._routesInFlight.delete(route);
  }

  async _cancelAllRoutesInFlight() {
    await Promise.all([...this._routesInFlight].map(r => r.abort())).catch(() => {});

    this._routesInFlight.clear();
  }

}

exports.BrowserContext = BrowserContext;
BrowserContext.Events = {
  Close: 'close',
  Page: 'page',
  Request: 'request',
  Response: 'response',
  RequestFailed: 'requestfailed',
  RequestFinished: 'requestfinished',
  BeforeClose: 'beforeclose',
  VideoStarted: 'videostarted'
};

function assertBrowserContextIsNotOwned(context) {
  for (const page of context.pages()) {
    if (page._ownedContext) throw new Error('Please use browser.newContext() for multi-page scripts that share the context.');
  }
}

function validateBrowserContextOptions(options, browserOptions) {
  if (options.noDefaultViewport && options.deviceScaleFactor !== undefined) throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
  if (options.noDefaultViewport && options.isMobile !== undefined) throw new Error(`"isMobile" option is not supported with null "viewport"`);
  if (options.acceptDownloads === undefined) options.acceptDownloads = true;
  if (!options.viewport && !options.noDefaultViewport) options.viewport = {
    width: 1280,
    height: 720
  };

  if (options.recordVideo) {
    if (!options.recordVideo.size) {
      if (options.noDefaultViewport) {
        options.recordVideo.size = {
          width: 800,
          height: 600
        };
      } else {
        const size = options.viewport;
        const scale = Math.min(1, 800 / Math.max(size.width, size.height));
        options.recordVideo.size = {
          width: Math.floor(size.width * scale),
          height: Math.floor(size.height * scale)
        };
      }
    } // Make sure both dimensions are odd, this is required for vp8


    options.recordVideo.size.width &= ~1;
    options.recordVideo.size.height &= ~1;
  }

  if (options.proxy) {
    if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === 'win32') throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
    options.proxy = normalizeProxySettings(options.proxy);
  }

  if ((0, _utils.debugMode)() === 'inspector') options.bypassCSP = true;
  verifyGeolocation(options.geolocation);
}

function verifyGeolocation(geolocation) {
  if (!geolocation) return;
  geolocation.accuracy = geolocation.accuracy || 0;
  const {
    longitude,
    latitude,
    accuracy
  } = geolocation;
  if (longitude < -180 || longitude > 180) throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
  if (latitude < -90 || latitude > 90) throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
  if (accuracy < 0) throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
}

function normalizeProxySettings(proxy) {
  let {
    server,
    bypass
  } = proxy;
  let url;

  try {
    // new URL('127.0.0.1:8080') throws
    // new URL('localhost:8080') fails to parse host or protocol
    // In both of these cases, we need to try re-parse URL with `http://` prefix.
    url = new URL(server);
    if (!url.host || !url.protocol) url = new URL('http://' + server);
  } catch (e) {
    url = new URL('http://' + server);
  }

  if (url.protocol === 'socks4:' && (proxy.username || proxy.password)) throw new Error(`Socks4 proxy protocol does not support authentication`);
  if (url.protocol === 'socks5:' && (proxy.username || proxy.password)) throw new Error(`Browser does not support socks5 proxy authentication`);
  server = url.protocol + '//' + url.host;
  if (bypass) bypass = bypass.split(',').map(t => t.trim()).join(',');
  return { ...proxy,
    server,
    bypass
  };
}

const paramsThatAllowContextReuse = ['colorScheme', 'forcedColors', 'reducedMotion', 'screen', 'userAgent', 'viewport'];
const defaultNewContextParamValues = {
  noDefaultViewport: false,
  ignoreHTTPSErrors: false,
  javaScriptEnabled: true,
  bypassCSP: false,
  offline: false,
  isMobile: false,
  hasTouch: false,
  acceptDownloads: true,
  strictSelectors: false,
  serviceWorkers: 'allow'
};

/***/ }),

/***/ 1192:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.kNoXServerRunningError = exports.BrowserType = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var os = _interopRequireWildcard(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _browserContext = __nccwpck_require__(5985);

var _registry = __nccwpck_require__(9048);

var _transport = __nccwpck_require__(1232);

var _processLauncher = __nccwpck_require__(1441);

var _pipeTransport = __nccwpck_require__(5241);

var _progress = __nccwpck_require__(2836);

var _timeoutSettings = __nccwpck_require__(9053);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _helper = __nccwpck_require__(9175);

var _debugLogger = __nccwpck_require__(2003);

var _instrumentation = __nccwpck_require__(6686);

var _manualPromise = __nccwpck_require__(6729);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kNoXServerRunningError = 'Looks like you launched a headed browser without having a XServer running.\n' + 'Set either \'headless: true\' or use \'xvfb-run <your-playwright-app>\' before running Playwright.\n\n<3 Playwright Team';
exports.kNoXServerRunningError = kNoXServerRunningError;

class BrowserType extends _instrumentation.SdkObject {
  constructor(browserName, playwrightOptions) {
    super(playwrightOptions.rootSdkObject, 'browser-type');
    this._name = void 0;
    this._playwrightOptions = void 0;
    this.attribution.browserType = this;
    this._playwrightOptions = playwrightOptions;
    this._name = browserName;
  }

  executablePath() {
    return _registry.registry.findExecutable(this._name).executablePath(this._playwrightOptions.sdkLanguage) || '';
  }

  name() {
    return this._name;
  }

  async launch(metadata, options, protocolLogger) {
    options = this._validateLaunchOptions(options);
    const controller = new _progress.ProgressController(metadata, this);
    controller.setLogName('browser');
    const browser = await controller.run(progress => {
      const seleniumHubUrl = options.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
      if (seleniumHubUrl) return this._launchWithSeleniumHub(progress, seleniumHubUrl, options);
      return this._innerLaunchWithRetries(progress, options, undefined, _helper.helper.debugProtocolLogger(protocolLogger)).catch(e => {
        throw this._rewriteStartupError(e);
      });
    }, _timeoutSettings.TimeoutSettings.launchTimeout(options));
    return browser;
  }

  async launchPersistentContext(metadata, userDataDir, options) {
    options = this._validateLaunchOptions(options);
    const controller = new _progress.ProgressController(metadata, this);
    const persistent = options;
    controller.setLogName('browser');
    const browser = await controller.run(progress => {
      return this._innerLaunchWithRetries(progress, options, persistent, _helper.helper.debugProtocolLogger(), userDataDir).catch(e => {
        throw this._rewriteStartupError(e);
      });
    }, _timeoutSettings.TimeoutSettings.launchTimeout(options));
    return browser._defaultContext;
  }

  async _innerLaunchWithRetries(progress, options, persistent, protocolLogger, userDataDir) {
    try {
      return await this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
    } catch (error) {
      // @see https://github.com/microsoft/playwright/issues/5214
      const errorMessage = typeof error === 'object' && typeof error.message === 'string' ? error.message : '';

      if (errorMessage.includes('Inconsistency detected by ld.so')) {
        progress.log(`<restarting browser due to hitting race condition in glibc>`);
        return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
      }

      throw error;
    }
  }

  async _innerLaunch(progress, options, persistent, protocolLogger, maybeUserDataDir) {
    options.proxy = options.proxy ? (0, _browserContext.normalizeProxySettings)(options.proxy) : undefined;
    const browserLogsCollector = new _debugLogger.RecentLogsCollector();
    const {
      browserProcess,
      userDataDir,
      artifactsDir,
      transport
    } = await this._launchProcess(progress, options, !!persistent, browserLogsCollector, maybeUserDataDir);
    if (options.__testHookBeforeCreateBrowser) await options.__testHookBeforeCreateBrowser();
    const browserOptions = { ...this._playwrightOptions,
      name: this._name,
      isChromium: this._name === 'chromium',
      channel: options.channel,
      slowMo: options.slowMo,
      persistent,
      headful: !options.headless,
      artifactsDir,
      downloadsPath: options.downloadsPath || artifactsDir,
      tracesDir: options.tracesDir || artifactsDir,
      browserProcess,
      customExecutablePath: options.executablePath,
      proxy: options.proxy,
      protocolLogger,
      browserLogsCollector,
      wsEndpoint: options.useWebSocket ? transport.wsEndpoint : undefined,
      originalLaunchOptions: options
    };
    if (persistent) (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
    copyTestHooks(options, browserOptions);
    const browser = await this._connectToTransport(transport, browserOptions);
    browser._userDataDirForTest = userDataDir; // We assume no control when using custom arguments, and do not prepare the default context in that case.

    if (persistent && !options.ignoreAllDefaultArgs) await browser._defaultContext._loadDefaultContext(progress);
    return browser;
  }

  async _launchProcess(progress, options, isPersistent, browserLogsCollector, userDataDir) {
    var _options$args;

    const {
      ignoreDefaultArgs,
      ignoreAllDefaultArgs,
      args = [],
      executablePath = null,
      handleSIGINT = true,
      handleSIGTERM = true,
      handleSIGHUP = true
    } = options;
    const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
    const tempDirectories = [];
    if (options.downloadsPath) await _fs.default.promises.mkdir(options.downloadsPath, {
      recursive: true
    });
    if (options.tracesDir) await _fs.default.promises.mkdir(options.tracesDir, {
      recursive: true
    });
    const artifactsDir = await _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), 'playwright-artifacts-'));
    tempDirectories.push(artifactsDir);

    if (userDataDir) {
      // Firefox bails if the profile directory does not exist, Chrome creates it. We ensure consistent behavior here.
      if (!(await (0, _fileUtils.existsAsync)(userDataDir))) await _fs.default.promises.mkdir(userDataDir, {
        recursive: true,
        mode: 0o700
      });
    } else {
      userDataDir = await _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
      tempDirectories.push(userDataDir);
    }

    const browserArguments = [];
    if (ignoreAllDefaultArgs) browserArguments.push(...args);else if (ignoreDefaultArgs) browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter(arg => ignoreDefaultArgs.indexOf(arg) === -1));else browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));
    let executable;

    if (executablePath) {
      if (!(await (0, _fileUtils.existsAsync)(executablePath))) throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
      executable = executablePath;
    } else {
      const registryExecutable = _registry.registry.findExecutable(options.channel || this._name);

      if (!registryExecutable || registryExecutable.browserName !== this._name) throw new Error(`Unsupported ${this._name} channel "${options.channel}"`);
      executable = registryExecutable.executablePathOrDie(this._playwrightOptions.sdkLanguage);
      await registryExecutable.validateHostRequirements(this._playwrightOptions.sdkLanguage);
    }

    const waitForWSEndpoint = options.useWebSocket || (_options$args = options.args) !== null && _options$args !== void 0 && _options$args.some(a => a.startsWith('--remote-debugging-port')) ? new _manualPromise.ManualPromise() : undefined;
    const waitForJuggler = this._name === 'firefox' ? new _manualPromise.ManualPromise() : undefined; // Note: it is important to define these variables before launchProcess, so that we don't get
    // "Cannot access 'browserServer' before initialization" if something went wrong.

    let transport = undefined;
    let browserProcess = undefined;
    const {
      launchedProcess,
      gracefullyClose,
      kill
    } = await (0, _processLauncher.launchProcess)({
      command: executable,
      args: browserArguments,
      env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
      handleSIGINT,
      handleSIGTERM,
      handleSIGHUP,
      log: message => {
        if (waitForWSEndpoint) {
          const match = message.match(/DevTools listening on (.*)/);
          if (match) waitForWSEndpoint.resolve(match[1]);
        }

        if (waitForJuggler && message.includes('Juggler listening to the pipe')) waitForJuggler.resolve();
        progress.log(message);
        browserLogsCollector.log(message);
      },
      stdio: 'pipe',
      tempDirectories,
      attemptToGracefullyClose: async () => {
        if (options.__testHookGracefullyClose) await options.__testHookGracefullyClose(); // We try to gracefully close to prevent crash reporting and core dumps.
        // Note that it's fine to reuse the pipe transport, since
        // our connection ignores kBrowserCloseMessageId.

        this._attemptToGracefullyCloseBrowser(transport);
      },
      onExit: (exitCode, signal) => {
        // Unblock launch when browser prematurely exits.
        waitForJuggler === null || waitForJuggler === void 0 ? void 0 : waitForJuggler.resolve();
        if (browserProcess && browserProcess.onclose) browserProcess.onclose(exitCode, signal);
      }
    });

    async function closeOrKill(timeout) {
      let timer;

      try {
        await Promise.race([gracefullyClose(), new Promise((resolve, reject) => timer = setTimeout(reject, timeout))]);
      } catch (ignored) {
        await kill().catch(ignored => {}); // Make sure to await actual process exit.
      } finally {
        clearTimeout(timer);
      }
    }

    browserProcess = {
      onclose: undefined,
      process: launchedProcess,
      close: () => closeOrKill(options.__testHookBrowserCloseTimeout || _timeoutSettings.DEFAULT_TIMEOUT),
      kill
    };
    progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));
    const wsEndpoint = await waitForWSEndpoint;
    await waitForJuggler;

    if (options.useWebSocket) {
      transport = await _transport.WebSocketTransport.connect(progress, wsEndpoint);
    } else {
      const stdio = launchedProcess.stdio;
      transport = new _pipeTransport.PipeTransport(stdio[3], stdio[4]);
    }

    return {
      browserProcess,
      artifactsDir,
      userDataDir,
      transport
    };
  }

  async connectOverCDP(metadata, endpointURL, options, timeout) {
    throw new Error('CDP connections are only supported by Chromium');
  }

  async _launchWithSeleniumHub(progress, hubUrl, options) {
    throw new Error('Connecting to SELENIUM_REMOTE_URL is only supported by Chromium');
  }

  _validateLaunchOptions(options) {
    const {
      devtools = false
    } = options;
    let {
      headless = !devtools,
      downloadsPath,
      proxy
    } = options;
    if ((0, _utils.debugMode)()) headless = false;
    if (downloadsPath && !_path.default.isAbsolute(downloadsPath)) downloadsPath = _path.default.join(process.cwd(), downloadsPath);
    if (this._playwrightOptions.socksProxyPort) proxy = {
      server: `socks5://127.0.0.1:${this._playwrightOptions.socksProxyPort}`
    };
    return { ...options,
      devtools,
      headless,
      downloadsPath,
      proxy
    };
  }

}

exports.BrowserType = BrowserType;

function copyTestHooks(from, to) {
  for (const [key, value] of Object.entries(from)) {
    if (key.startsWith('__testHook')) to[key] = value;
  }
}

/***/ }),

/***/ 2302:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DEFAULT_ARGS = exports.Chromium = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _crBrowser = __nccwpck_require__(2731);

var _processLauncher = __nccwpck_require__(1441);

var _crConnection = __nccwpck_require__(5460);

var _stackTrace = __nccwpck_require__(9030);

var _browserType = __nccwpck_require__(1192);

var _transport = __nccwpck_require__(1232);

var _crDevTools = __nccwpck_require__(7898);

var _browser = __nccwpck_require__(6705);

var _netUtils = __nccwpck_require__(989);

var _userAgent = __nccwpck_require__(5110);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _debugLogger = __nccwpck_require__(2003);

var _progress = __nccwpck_require__(2836);

var _timeoutSettings = __nccwpck_require__(9053);

var _helper = __nccwpck_require__(9175);

var _http = _interopRequireDefault(__nccwpck_require__(3685));

var _https = _interopRequireDefault(__nccwpck_require__(5687));

var _registry = __nccwpck_require__(9048);

var _manualPromise = __nccwpck_require__(6729);

var _browserContext = __nccwpck_require__(5985);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), 'playwright-artifacts-');

class Chromium extends _browserType.BrowserType {
  constructor(playwrightOptions) {
    super('chromium', playwrightOptions);
    this._devtools = void 0;
    if ((0, _utils.debugMode)()) this._devtools = this._createDevTools();
  }

  async connectOverCDP(metadata, endpointURL, options, timeout) {
    const controller = new _progress.ProgressController(metadata, this);
    controller.setLogName('browser');
    return controller.run(async progress => {
      return await this._connectOverCDPInternal(progress, endpointURL, options);
    }, _timeoutSettings.TimeoutSettings.timeout({
      timeout
    }));
  }

  async _connectOverCDPInternal(progress, endpointURL, options, onClose) {
    let headersMap;
    if (options.headers) headersMap = (0, _utils.headersArrayToObject)(options.headers, false);
    if (!headersMap) headersMap = {
      'User-Agent': (0, _userAgent.getUserAgent)()
    };else if (headersMap && !Object.keys(headersMap).some(key => key.toLowerCase() === 'user-agent')) headersMap['User-Agent'] = (0, _userAgent.getUserAgent)();
    const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
    const wsEndpoint = await urlToWSEndpoint(progress, endpointURL);
    progress.throwIfAborted();
    const chromeTransport = await _transport.WebSocketTransport.connect(progress, wsEndpoint, headersMap);
    const cleanedUp = new _manualPromise.ManualPromise();

    const doCleanup = async () => {
      await (0, _fileUtils.removeFolders)([artifactsDir]);
      await (onClose === null || onClose === void 0 ? void 0 : onClose());
      cleanedUp.resolve();
    };

    const doClose = async () => {
      await chromeTransport.closeAndWait();
      await cleanedUp;
    };

    const browserProcess = {
      close: doClose,
      kill: doClose
    };
    const persistent = {
      noDefaultViewport: true
    };
    const browserOptions = { ...this._playwrightOptions,
      slowMo: options.slowMo,
      name: 'chromium',
      isChromium: true,
      persistent,
      browserProcess,
      protocolLogger: _helper.helper.debugProtocolLogger(),
      browserLogsCollector: new _debugLogger.RecentLogsCollector(),
      artifactsDir,
      downloadsPath: artifactsDir,
      tracesDir: artifactsDir,
      // On Windows context level proxies only work, if there isn't a global proxy
      // set. This is currently a bug in the CR/Windows networking stack. By
      // passing an arbitrary value we disable the check in PW land which warns
      // users in normal (launch/launchServer) mode since otherwise connectOverCDP
      // does not work at all with proxies on Windows.
      proxy: {
        server: 'per-context'
      },
      originalLaunchOptions: {}
    };
    (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
    progress.throwIfAborted();
    const browser = await _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
    browser.on(_browser.Browser.Events.Disconnected, doCleanup);
    return browser;
  }

  _createDevTools() {
    // TODO: this is totally wrong when using channels.
    const directory = _registry.registry.findExecutable('chromium').directory;

    return directory ? new _crDevTools.CRDevTools(_path.default.join(directory, 'devtools-preferences.json')) : undefined;
  }

  async _connectToTransport(transport, options) {
    let devtools = this._devtools;

    if (options.__testHookForDevTools) {
      devtools = this._createDevTools();
      await options.__testHookForDevTools(devtools);
    }

    return _crBrowser.CRBrowser.connect(transport, options, devtools);
  }

  _rewriteStartupError(error) {
    if (error.message.includes('Missing X server')) return (0, _stackTrace.rewriteErrorMessage)(error, '\n' + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1)); // These error messages are taken from Chromium source code as of July, 2020:
    // https://github.com/chromium/chromium/blob/70565f67e79f79e17663ad1337dc6e63ee207ce9/content/browser/zygote_host/zygote_host_impl_linux.cc

    if (!error.message.includes('crbug.com/357670') && !error.message.includes('No usable sandbox!') && !error.message.includes('crbug.com/638180')) return error;
    return (0, _stackTrace.rewriteErrorMessage)(error, [`Chromium sandboxing failed!`, `================================`, `To workaround sandboxing issues, do either of the following:`, `  - (preferred): Configure environment to support sandboxing: https://playwright.dev/docs/troubleshooting`, `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`, `================================`, ``].join('\n'));
  }

  _amendEnvironment(env, userDataDir, executable, browserArguments) {
    return env;
  }

  _attemptToGracefullyCloseBrowser(transport) {
    const message = {
      method: 'Browser.close',
      id: _crConnection.kBrowserCloseMessageId,
      params: {}
    };
    transport.send(message);
  }

  async _launchWithSeleniumHub(progress, hubUrl, options) {
    if (!hubUrl.endsWith('/')) hubUrl = hubUrl + '/';

    const args = this._innerDefaultArgs(options);

    args.push('--remote-debugging-port=0');
    const isEdge = options.channel && options.channel.startsWith('msedge');
    let desiredCapabilities = {
      'browserName': isEdge ? 'MicrosoftEdge' : 'chrome',
      [isEdge ? 'ms:edgeOptions' : 'goog:chromeOptions']: {
        args
      }
    };

    try {
      if (process.env.SELENIUM_REMOTE_CAPABILITIES) {
        const parsed = JSON.parse(process.env.SELENIUM_REMOTE_CAPABILITIES);
        desiredCapabilities = { ...desiredCapabilities,
          ...parsed
        };
        progress.log(`<selenium> using additional capabilities "${process.env.SELENIUM_REMOTE_CAPABILITIES}"`);
      }
    } catch (e) {
      progress.log(`<selenium> ignoring additional capabilities "${process.env.SELENIUM_REMOTE_CAPABILITIES}": ${e}`);
    }

    progress.log(`<selenium> connecting to ${hubUrl}`);
    const response = await (0, _netUtils.fetchData)({
      url: hubUrl + 'session',
      method: 'POST',
      data: JSON.stringify({
        desiredCapabilities,
        capabilities: {
          alwaysMatch: desiredCapabilities
        }
      }),
      timeout: progress.timeUntilDeadline()
    }, seleniumErrorHandler);
    const value = JSON.parse(response).value;
    const sessionId = value.sessionId;
    progress.log(`<selenium> connected to sessionId=${sessionId}`);

    const disconnectFromSelenium = async () => {
      progress.log(`<selenium> disconnecting from sessionId=${sessionId}`);
      await (0, _netUtils.fetchData)({
        url: hubUrl + 'session/' + sessionId,
        method: 'DELETE'
      }).catch(error => progress.log(`<error disconnecting from selenium>: ${error}`));
      progress.log(`<selenium> disconnected from sessionId=${sessionId}`);

      _processLauncher.gracefullyCloseSet.delete(disconnectFromSelenium);
    };

    _processLauncher.gracefullyCloseSet.add(disconnectFromSelenium);

    try {
      const capabilities = value.capabilities;
      let endpointURL;

      if (capabilities['se:cdp']) {
        // Selenium 4 - use built-in CDP websocket proxy.
        progress.log(`<selenium> using selenium v4`);
        const endpointURLString = addProtocol(capabilities['se:cdp']);
        endpointURL = new URL(endpointURLString);
        if (endpointURL.hostname === 'localhost' || endpointURL.hostname === '127.0.0.1') endpointURL.hostname = new URL(hubUrl).hostname;
        progress.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
      } else {
        // Selenium 3 - resolve target node IP to use instead of localhost ws url.
        progress.log(`<selenium> using selenium v3`);
        const maybeChromeOptions = capabilities['goog:chromeOptions'];
        const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === 'object' ? maybeChromeOptions : undefined;
        const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === 'string' ? chromeOptions.debuggerAddress : undefined;
        const chromeOptionsURL = typeof maybeChromeOptions === 'string' ? maybeChromeOptions : undefined; // TODO(dgozman): figure out if we can make ChromeDriver to return 127.0.0.1 instead of localhost.

        const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL).replace('localhost', '127.0.0.1');
        progress.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);
        endpointURL = new URL(endpointURLString);

        if (endpointURL.hostname === 'localhost' || endpointURL.hostname === '127.0.0.1') {
          const sessionInfoUrl = new URL(hubUrl).origin + '/grid/api/testsession?session=' + sessionId;

          try {
            const sessionResponse = await (0, _netUtils.fetchData)({
              url: sessionInfoUrl,
              method: 'GET',
              timeout: progress.timeUntilDeadline()
            }, seleniumErrorHandler);
            const proxyId = JSON.parse(sessionResponse).proxyId;
            endpointURL.hostname = new URL(proxyId).hostname;
            progress.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
          } catch (e) {
            progress.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
          }
        }
      }

      return await this._connectOverCDPInternal(progress, endpointURL.toString(), {
        slowMo: options.slowMo
      }, disconnectFromSelenium);
    } catch (e) {
      await disconnectFromSelenium();
      throw e;
    }
  }

  _defaultArgs(options, isPersistent, userDataDir) {
    const chromeArguments = this._innerDefaultArgs(options);

    chromeArguments.push(`--user-data-dir=${userDataDir}`);
    if (options.useWebSocket) chromeArguments.push('--remote-debugging-port=0');else chromeArguments.push('--remote-debugging-pipe');
    if (isPersistent) chromeArguments.push('about:blank');else chromeArguments.push('--no-startup-window');
    return chromeArguments;
  }

  _innerDefaultArgs(options) {
    const {
      args = [],
      proxy
    } = options;
    const userDataDirArg = args.find(arg => arg.startsWith('--user-data-dir'));
    if (userDataDirArg) throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument');
    if (args.find(arg => arg.startsWith('--remote-debugging-pipe'))) throw new Error('Playwright manages remote debugging connection itself.');
    if (args.find(arg => !arg.startsWith('-'))) throw new Error('Arguments can not specify page to be opened');
    const chromeArguments = [...DEFAULT_ARGS]; // See https://github.com/microsoft/playwright/issues/7362

    if (_os.default.platform() === 'darwin') chromeArguments.push('--enable-use-zoom-for-dsf=false');
    if (options.devtools) chromeArguments.push('--auto-open-devtools-for-tabs');

    if (options.headless) {
      chromeArguments.push('--headless', '--hide-scrollbars', '--mute-audio', '--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4');
    }

    if (options.chromiumSandbox !== true) chromeArguments.push('--no-sandbox');

    if (proxy) {
      const proxyURL = new URL(proxy.server);
      const isSocks = proxyURL.protocol === 'socks5:'; // https://www.chromium.org/developers/design-documents/network-settings

      if (isSocks && !this._playwrightOptions.socksProxyPort) {
        // https://www.chromium.org/developers/design-documents/network-stack/socks-proxy
        chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
      }

      chromeArguments.push(`--proxy-server=${proxy.server}`);
      const proxyBypassRules = []; // https://source.chromium.org/chromium/chromium/src/+/master:net/docs/proxy.md;l=548;drc=71698e610121078e0d1a811054dcf9fd89b49578

      if (this._playwrightOptions.socksProxyPort) proxyBypassRules.push('<-loopback>');
      if (proxy.bypass) proxyBypassRules.push(...proxy.bypass.split(',').map(t => t.trim()).map(t => t.startsWith('.') ? '*' + t : t));
      if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes('<-loopback>')) proxyBypassRules.push('<-loopback>');
      if (proxyBypassRules.length > 0) chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(';')}`);
    }

    chromeArguments.push(...args);
    return chromeArguments;
  }

}

exports.Chromium = Chromium;
const DEFAULT_ARGS = ['--disable-field-trial-config', // https://source.chromium.org/chromium/chromium/src/+/main:testing/variations/README.md
'--disable-background-networking', '--enable-features=NetworkService,NetworkServiceInProcess', '--disable-background-timer-throttling', '--disable-backgrounding-occluded-windows', '--disable-back-forward-cache', // Avoids surprises like main request not being intercepted during page.goBack().
'--disable-breakpad', '--disable-client-side-phishing-detection', '--disable-component-extensions-with-background-pages', '--disable-default-apps', '--disable-dev-shm-usage', '--disable-extensions', // AvoidUnnecessaryBeforeUnloadCheckSync - https://github.com/microsoft/playwright/issues/14047
// Translate - https://github.com/microsoft/playwright/issues/16126
'--disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,DialMediaRouteProvider,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater,AvoidUnnecessaryBeforeUnloadCheckSync,Translate', '--allow-pre-commit-input', '--disable-hang-monitor', '--disable-ipc-flooding-protection', '--disable-popup-blocking', '--disable-prompt-on-repost', '--disable-renderer-backgrounding', '--disable-sync', '--force-color-profile=srgb', '--metrics-recording-only', '--no-first-run', '--enable-automation', '--password-store=basic', '--use-mock-keychain', // See https://chromium-review.googlesource.com/c/chromium/src/+/2436773
'--no-service-autorun', '--export-tagged-pdf'];
exports.DEFAULT_ARGS = DEFAULT_ARGS;

async function urlToWSEndpoint(progress, endpointURL) {
  if (endpointURL.startsWith('ws')) return endpointURL;
  progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
  const httpURL = endpointURL.endsWith('/') ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
  const request = endpointURL.startsWith('https') ? _https.default : _http.default;
  const json = await new Promise((resolve, reject) => {
    request.get(httpURL, resp => {
      if (resp.statusCode < 200 || resp.statusCode >= 400) {
        reject(new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.\n` + `This does not look like a DevTools server, try connecting via ws://.`));
      }

      let data = '';
      resp.on('data', chunk => data += chunk);
      resp.on('end', () => resolve(data));
    }).on('error', reject);
  });
  return JSON.parse(json).webSocketDebuggerUrl;
}

async function seleniumErrorHandler(params, response) {
  const body = await (0, _utils.streamToString)(response);
  let message = body;

  try {
    const json = JSON.parse(body);
    message = json.value.localizedMessage || json.value.message;
  } catch (e) {}

  return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
}

function addProtocol(url) {
  if (!['ws://', 'wss://', 'http://', 'https://'].some(protocol => url.startsWith(protocol))) return 'http://' + url;
  return url;
}

/***/ }),

/***/ 5246:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getAccessibilityTree = getAccessibilityTree;

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getAccessibilityTree(client, needle) {
  const {
    nodes
  } = await client.send('Accessibility.getFullAXTree');
  const tree = CRAXNode.createTree(client, nodes);
  return {
    tree,
    needle: needle ? await tree._findElement(needle) : null
  };
}

class CRAXNode {
  constructor(client, payload) {
    this._payload = void 0;
    this._children = [];
    this._richlyEditable = false;
    this._editable = false;
    this._focusable = false;
    this._expanded = false;
    this._hidden = false;
    this._name = void 0;
    this._role = void 0;
    this._cachedHasFocusableChild = void 0;
    this._client = void 0;
    this._client = client;
    this._payload = payload;
    this._name = this._payload.name ? this._payload.name.value : '';
    this._role = this._payload.role ? this._payload.role.value : 'Unknown';

    for (const property of this._payload.properties || []) {
      if (property.name === 'editable') {
        this._richlyEditable = property.value.value === 'richtext';
        this._editable = true;
      }

      if (property.name === 'focusable') this._focusable = property.value.value;
      if (property.name === 'expanded') this._expanded = property.value.value;
      if (property.name === 'hidden') this._hidden = property.value.value;
    }
  }

  _isPlainTextField() {
    if (this._richlyEditable) return false;
    if (this._editable) return true;
    return this._role === 'textbox' || this._role === 'ComboBox' || this._role === 'searchbox';
  }

  _isTextOnlyObject() {
    const role = this._role;
    return role === 'LineBreak' || role === 'text' || role === 'InlineTextBox' || role === 'StaticText';
  }

  _hasFocusableChild() {
    if (this._cachedHasFocusableChild === undefined) {
      this._cachedHasFocusableChild = false;

      for (const child of this._children) {
        if (child._focusable || child._hasFocusableChild()) {
          this._cachedHasFocusableChild = true;
          break;
        }
      }
    }

    return this._cachedHasFocusableChild;
  }

  children() {
    return this._children;
  }

  async _findElement(element) {
    const objectId = element._objectId;
    const {
      node: {
        backendNodeId
      }
    } = await this._client.send('DOM.describeNode', {
      objectId
    });
    const needle = this.find(node => node._payload.backendDOMNodeId === backendNodeId);
    return needle || null;
  }

  find(predicate) {
    if (predicate(this)) return this;

    for (const child of this._children) {
      const result = child.find(predicate);
      if (result) return result;
    }

    return null;
  }

  isLeafNode() {
    if (!this._children.length) return true; // These types of objects may have children that we use as internal
    // implementation details, but we want to expose them as leaves to platform
    // accessibility APIs because screen readers might be confused if they find
    // any children.

    if (this._isPlainTextField() || this._isTextOnlyObject()) return true; // Roles whose children are only presentational according to the ARIA and
    // HTML5 Specs should be hidden from screen readers.
    // (Note that whilst ARIA buttons can have only presentational children, HTML5
    // buttons are allowed to have content.)

    switch (this._role) {
      case 'doc-cover':
      case 'graphics-symbol':
      case 'img':
      case 'Meter':
      case 'scrollbar':
      case 'slider':
      case 'separator':
      case 'progressbar':
        return true;

      default:
        break;
    } // Here and below: Android heuristics


    if (this._hasFocusableChild()) return false;
    if (this._focusable && this._role !== 'WebArea' && this._role !== 'RootWebArea' && this._name) return true;
    if (this._role === 'heading' && this._name) return true;
    return false;
  }

  isControl() {
    switch (this._role) {
      case 'button':
      case 'checkbox':
      case 'ColorWell':
      case 'combobox':
      case 'DisclosureTriangle':
      case 'listbox':
      case 'menu':
      case 'menubar':
      case 'menuitem':
      case 'menuitemcheckbox':
      case 'menuitemradio':
      case 'radio':
      case 'scrollbar':
      case 'searchbox':
      case 'slider':
      case 'spinbutton':
      case 'switch':
      case 'tab':
      case 'textbox':
      case 'tree':
        return true;

      default:
        return false;
    }
  }

  isInteresting(insideControl) {
    const role = this._role;
    if (role === 'Ignored' || this._hidden) return false;
    if (this._focusable || this._richlyEditable) return true; // If it's not focusable but has a control role, then it's interesting.

    if (this.isControl()) return true; // A non focusable child of a control is not interesting

    if (insideControl) return false;
    return this.isLeafNode() && !!this._name;
  }

  normalizedRole() {
    switch (this._role) {
      case 'RootWebArea':
        return 'WebArea';

      case 'StaticText':
        return 'text';

      default:
        return this._role;
    }
  }

  serialize() {
    const properties = new Map();

    for (const property of this._payload.properties || []) properties.set(property.name.toLowerCase(), property.value.value);

    if (this._payload.description) properties.set('description', this._payload.description.value);
    const node = {
      role: this.normalizedRole(),
      name: this._payload.name ? this._payload.name.value || '' : ''
    };
    const userStringProperties = ['description', 'keyshortcuts', 'roledescription', 'valuetext'];

    for (const userStringProperty of userStringProperties) {
      if (!properties.has(userStringProperty)) continue;
      node[userStringProperty] = properties.get(userStringProperty);
    }

    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];

    for (const booleanProperty of booleanProperties) {
      // WebArea's treat focus differently than other nodes. They report whether their frame  has focus,
      // not whether focus is specifically on the root node.
      if (booleanProperty === 'focused' && (this._role === 'WebArea' || this._role === 'RootWebArea')) continue;
      const value = properties.get(booleanProperty);
      if (!value) continue;
      node[booleanProperty] = value;
    }

    const numericalProperties = ['level', 'valuemax', 'valuemin'];

    for (const numericalProperty of numericalProperties) {
      if (!properties.has(numericalProperty)) continue;
      node[numericalProperty] = properties.get(numericalProperty);
    }

    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];

    for (const tokenProperty of tokenProperties) {
      const value = properties.get(tokenProperty);
      if (!value || value === 'false') continue;
      node[tokenProperty] = value;
    }

    const axNode = node;

    if (this._payload.value) {
      if (typeof this._payload.value.value === 'string') axNode.valueString = this._payload.value.value;
      if (typeof this._payload.value.value === 'number') axNode.valueNumber = this._payload.value.value;
    }

    if (properties.has('checked')) axNode.checked = properties.get('checked') === 'true' ? 'checked' : properties.get('checked') === 'false' ? 'unchecked' : 'mixed';
    if (properties.has('pressed')) axNode.pressed = properties.get('pressed') === 'true' ? 'pressed' : properties.get('pressed') === 'false' ? 'released' : 'mixed';
    return axNode;
  }

  static createTree(client, payloads) {
    const nodeById = new Map();

    for (const payload of payloads) nodeById.set(payload.nodeId, new CRAXNode(client, payload));

    for (const node of nodeById.values()) {
      for (const childId of node._payload.childIds || []) node._children.push(nodeById.get(childId));
    }

    return nodeById.values().next().value;
  }

}

/***/ }),

/***/ 3025:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.installAppIcon = installAppIcon;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function installAppIcon(page) {
  const icon = await _fs.default.promises.readFile(__nccwpck_require__.ab + "appIcon.png");
  const crPage = page._delegate;
  await crPage._mainFrameSession._client.send('Browser.setDockTile', {
    image: icon.toString('base64')
  });
}

/***/ }),

/***/ 2731:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRBrowserContext = exports.CRBrowser = void 0;

var _browser = __nccwpck_require__(6705);

var _browserContext = __nccwpck_require__(5985);

var _utils = __nccwpck_require__(3557);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _page = __nccwpck_require__(3555);

var _frames = __nccwpck_require__(8895);

var _crConnection = __nccwpck_require__(5460);

var _crPage = __nccwpck_require__(2382);

var _crProtocolHelper = __nccwpck_require__(911);

var _crServiceWorker = __nccwpck_require__(2594);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CRBrowser extends _browser.Browser {
  static async connect(transport, options, devtools) {
    // Make a copy in case we need to update `headful` property below.
    options = { ...options
    };
    const connection = new _crConnection.CRConnection(transport, options.protocolLogger, options.browserLogsCollector);
    const browser = new CRBrowser(connection, options);
    browser._devtools = devtools;
    const session = connection.rootSession;
    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();
    const version = await session.send('Browser.getVersion');
    browser._version = version.product.substring(version.product.indexOf('/') + 1);
    browser._userAgent = version.userAgent; // We don't trust the option as it may lie in case of connectOverCDP where remote browser
    // may have been launched with different options.

    browser.options.headful = !version.userAgent.includes('Headless');

    if (!options.persistent) {
      await session.send('Target.setAutoAttach', {
        autoAttach: true,
        waitForDebuggerOnStart: true,
        flatten: true
      });
      return browser;
    }

    browser._defaultContext = new CRBrowserContext(browser, undefined, options.persistent);
    await Promise.all([session.send('Target.setAutoAttach', {
      autoAttach: true,
      waitForDebuggerOnStart: true,
      flatten: true
    }).then(async () => {
      // Target.setAutoAttach has a bug where it does not wait for new Targets being attached.
      // However making a dummy call afterwards fixes this.
      // This can be removed after https://chromium-review.googlesource.com/c/chromium/src/+/2885888 lands in stable.
      await session.send('Target.getTargetInfo');
    }), browser._defaultContext._initialize()]);
    await browser._waitForAllPagesToBeInitialized();
    return browser;
  }

  constructor(connection, options) {
    super(options);
    this._connection = void 0;
    this._session = void 0;
    this._clientRootSessionPromise = null;
    this._contexts = new Map();
    this._crPages = new Map();
    this._backgroundPages = new Map();
    this._serviceWorkers = new Map();
    this._devtools = void 0;
    this._version = '';
    this._tracingRecording = false;
    this._tracingPath = '';
    this._tracingClient = void 0;
    this._userAgent = '';
    this._connection = connection;
    this._session = this._connection.rootSession;

    this._connection.on(_crConnection.ConnectionEvents.Disconnected, () => this._didClose());

    this._session.on('Target.attachedToTarget', this._onAttachedToTarget.bind(this));

    this._session.on('Target.detachedFromTarget', this._onDetachedFromTarget.bind(this));

    this._session.on('Browser.downloadWillBegin', this._onDownloadWillBegin.bind(this));

    this._session.on('Browser.downloadProgress', this._onDownloadProgress.bind(this));
  }

  async doCreateNewContext(options) {
    let proxyBypassList = undefined;

    if (options.proxy) {
      if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK) proxyBypassList = options.proxy.bypass;else proxyBypassList = '<-loopback>' + (options.proxy.bypass ? `,${options.proxy.bypass}` : '');
    }

    const {
      browserContextId
    } = await this._session.send('Target.createBrowserContext', {
      disposeOnDetach: true,
      proxyServer: options.proxy ? options.proxy.server : undefined,
      proxyBypassList
    });
    const context = new CRBrowserContext(this, browserContextId, options);
    await context._initialize();

    this._contexts.set(browserContextId, context);

    return context;
  }

  contexts() {
    return Array.from(this._contexts.values());
  }

  version() {
    return this._version;
  }

  userAgent() {
    return this._userAgent;
  }

  _platform() {
    if (this._userAgent.includes('Windows')) return 'win';
    if (this._userAgent.includes('Macintosh')) return 'mac';
    return 'linux';
  }

  isClank() {
    return this.options.name === 'clank';
  }

  async _waitForAllPagesToBeInitialized() {
    await Promise.all([...this._crPages.values()].map(page => page.pageOrError()));
  }

  _onAttachedToTarget({
    targetInfo,
    sessionId,
    waitingForDebugger
  }) {
    if (targetInfo.type === 'browser') return;

    const session = this._connection.session(sessionId);

    (0, _utils.assert)(targetInfo.browserContextId, 'targetInfo: ' + JSON.stringify(targetInfo, null, 2));
    let context = this._contexts.get(targetInfo.browserContextId) || null;

    if (!context) {
      // TODO: auto attach only to pages from our contexts.
      // assert(this._defaultContext);
      context = this._defaultContext;
    }

    if (targetInfo.type === 'other' && targetInfo.url.startsWith('devtools://devtools') && this._devtools) {
      this._devtools.install(session);

      return;
    }

    const treatOtherAsPage = targetInfo.type === 'other' && process.env.PW_CHROMIUM_ATTACH_TO_OTHER;

    if (!context || targetInfo.type === 'other' && !treatOtherAsPage) {
      if (waitingForDebugger) {
        // Ideally, detaching should resume any target, but there is a bug in the backend.
        session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {
          this._session._sendMayFail('Target.detachFromTarget', {
            sessionId
          });
        });
      }

      return;
    }

    (0, _utils.assert)(!this._crPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
    (0, _utils.assert)(!this._backgroundPages.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);
    (0, _utils.assert)(!this._serviceWorkers.has(targetInfo.targetId), 'Duplicate target ' + targetInfo.targetId);

    if (targetInfo.type === 'background_page') {
      const backgroundPage = new _crPage.CRPage(session, targetInfo.targetId, context, null, {
        hasUIWindow: false,
        isBackgroundPage: true
      });

      this._backgroundPages.set(targetInfo.targetId, backgroundPage);

      return;
    }

    if (targetInfo.type === 'page' || treatOtherAsPage) {
      const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
      const crPage = new _crPage.CRPage(session, targetInfo.targetId, context, opener, {
        hasUIWindow: targetInfo.type === 'page',
        isBackgroundPage: false
      });

      this._crPages.set(targetInfo.targetId, crPage);

      return;
    }

    if (targetInfo.type === 'service_worker') {
      const serviceWorker = new _crServiceWorker.CRServiceWorker(context, session, targetInfo.url);

      this._serviceWorkers.set(targetInfo.targetId, serviceWorker);

      context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
      return;
    }
  }

  _onDetachedFromTarget(payload) {
    const targetId = payload.targetId;

    const crPage = this._crPages.get(targetId);

    if (crPage) {
      this._crPages.delete(targetId);

      crPage.didClose();
      return;
    }

    const backgroundPage = this._backgroundPages.get(targetId);

    if (backgroundPage) {
      this._backgroundPages.delete(targetId);

      backgroundPage.didClose();
      return;
    }

    const serviceWorker = this._serviceWorkers.get(targetId);

    if (serviceWorker) {
      this._serviceWorkers.delete(targetId);

      serviceWorker.didClose();
      return;
    }
  }

  _findOwningPage(frameId) {
    for (const crPage of this._crPages.values()) {
      const frame = crPage._page._frameManager.frame(frameId);

      if (frame) return crPage;
    }

    return null;
  }

  _onDownloadWillBegin(payload) {
    const page = this._findOwningPage(payload.frameId);

    (0, _utils.assert)(page, 'Download started in unknown page: ' + JSON.stringify(payload));
    page.willBeginDownload();
    let originPage = page._initializedPage; // If it's a new window download, report it on the opener page.

    if (!originPage && page._opener) originPage = page._opener._initializedPage;
    if (!originPage) return;

    this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
  }

  _onDownloadProgress(payload) {
    if (payload.state === 'completed') this._downloadFinished(payload.guid, '');
    if (payload.state === 'canceled') this._downloadFinished(payload.guid, 'canceled');
  }

  async _closePage(crPage) {
    await this._session.send('Target.closeTarget', {
      targetId: crPage._targetId
    });
  }

  async newBrowserCDPSession() {
    return await this._connection.createBrowserSession();
  }

  async startTracing(page, options = {}) {
    (0, _utils.assert)(!this._tracingRecording, 'Cannot start recording trace while already recording trace.');
    this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
    const defaultCategories = ['-*', 'devtools.timeline', 'v8.execute', 'disabled-by-default-devtools.timeline', 'disabled-by-default-devtools.timeline.frame', 'toplevel', 'blink.console', 'blink.user_timing', 'latencyInfo', 'disabled-by-default-devtools.timeline.stack', 'disabled-by-default-v8.cpu_profiler', 'disabled-by-default-v8.cpu_profiler.hires'];
    const {
      path = null,
      screenshots = false,
      categories = defaultCategories
    } = options;
    if (screenshots) categories.push('disabled-by-default-devtools.screenshot');
    this._tracingPath = path;
    this._tracingRecording = true;
    await this._tracingClient.send('Tracing.start', {
      transferMode: 'ReturnAsStream',
      categories: categories.join(',')
    });
  }

  async stopTracing() {
    (0, _utils.assert)(this._tracingClient, 'Tracing was not started.');
    const [event] = await Promise.all([new Promise(f => this._tracingClient.once('Tracing.tracingComplete', f)), this._tracingClient.send('Tracing.end')]);
    const result = await (0, _crProtocolHelper.readProtocolStream)(this._tracingClient, event.stream, this._tracingPath);
    this._tracingRecording = false;
    return result;
  }

  isConnected() {
    return !this._connection._closed;
  }

  async _clientRootSession() {
    if (!this._clientRootSessionPromise) this._clientRootSessionPromise = this._connection.createBrowserSession();
    return this._clientRootSessionPromise;
  }

}

exports.CRBrowser = CRBrowser;

class CRBrowserContext extends _browserContext.BrowserContext {
  constructor(browser, browserContextId, options) {
    super(browser, options, browserContextId);

    this._authenticateProxyViaCredentials();
  }

  async _initialize() {
    (0, _utils.assert)(!Array.from(this._browser._crPages.values()).some(page => page._browserContext === this));
    const promises = [super._initialize()];

    if (this._browser.options.name !== 'electron' && this._browser.options.name !== 'clank') {
      promises.push(this._browser._session.send('Browser.setDownloadBehavior', {
        behavior: this._options.acceptDownloads ? 'allowAndName' : 'deny',
        browserContextId: this._browserContextId,
        downloadPath: this._browser.options.downloadsPath,
        eventsEnabled: true
      }));
    }

    await Promise.all(promises);
  }

  pages() {
    const result = [];

    for (const crPage of this._browser._crPages.values()) {
      if (crPage._browserContext === this && crPage._initializedPage) result.push(crPage._initializedPage);
    }

    return result;
  }

  async newPageDelegate() {
    (0, _browserContext.assertBrowserContextIsNotOwned)(this);
    const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : undefined;
    let {
      targetId
    } = await this._browser._session.send('Target.createTarget', {
      url: 'about:blank',
      browserContextId: this._browserContextId
    });

    if (oldKeys) {
      // Chrome for Android returns tab ids (1, 2, 3, 4, 5) instead of content target ids here, work around it via the
      // heuristic assuming that there is only one page created at a time.
      const newKeys = new Set(this._browser._crPages.keys()); // Remove old keys.

      for (const key of oldKeys) newKeys.delete(key); // Remove potential concurrent popups.


      for (const key of newKeys) {
        const page = this._browser._crPages.get(key);

        if (page._opener) newKeys.delete(key);
      }

      (0, _utils.assert)(newKeys.size === 1);
      [targetId] = [...newKeys];
    }

    return this._browser._crPages.get(targetId);
  }

  async doGetCookies(urls) {
    const {
      cookies
    } = await this._browser._session.send('Storage.getCookies', {
      browserContextId: this._browserContextId
    });
    return network.filterCookies(cookies.map(c => {
      const copy = {
        sameSite: 'Lax',
        ...c
      };
      delete copy.size;
      delete copy.priority;
      delete copy.session;
      delete copy.sameParty;
      delete copy.sourceScheme;
      delete copy.sourcePort;
      return copy;
    }), urls);
  }

  async addCookies(cookies) {
    await this._browser._session.send('Storage.setCookies', {
      cookies: network.rewriteCookies(cookies),
      browserContextId: this._browserContextId
    });
  }

  async clearCookies() {
    await this._browser._session.send('Storage.clearCookies', {
      browserContextId: this._browserContextId
    });
  }

  async doGrantPermissions(origin, permissions) {
    const webPermissionToProtocol = new Map([['geolocation', 'geolocation'], ['midi', 'midi'], ['notifications', 'notifications'], ['camera', 'videoCapture'], ['microphone', 'audioCapture'], ['background-sync', 'backgroundSync'], ['ambient-light-sensor', 'sensors'], ['accelerometer', 'sensors'], ['gyroscope', 'sensors'], ['magnetometer', 'sensors'], ['accessibility-events', 'accessibilityEvents'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-write', 'clipboardSanitizedWrite'], ['payment-handler', 'paymentHandler'], // chrome-specific permissions we have.
    ['midi-sysex', 'midiSysex']]);
    const filtered = permissions.map(permission => {
      const protocolPermission = webPermissionToProtocol.get(permission);
      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);
      return protocolPermission;
    });
    await this._browser._session.send('Browser.grantPermissions', {
      origin: origin === '*' ? undefined : origin,
      browserContextId: this._browserContextId,
      permissions: filtered
    });
  }

  async doClearPermissions() {
    await this._browser._session.send('Browser.resetPermissions', {
      browserContextId: this._browserContextId
    });
  }

  async setGeolocation(geolocation) {
    (0, _browserContext.verifyGeolocation)(geolocation);
    this._options.geolocation = geolocation;

    for (const page of this.pages()) await page._delegate.updateGeolocation();
  }

  async setExtraHTTPHeaders(headers) {
    this._options.extraHTTPHeaders = headers;

    for (const page of this.pages()) await page._delegate.updateExtraHTTPHeaders();

    for (const sw of this.serviceWorkers()) await sw.updateExtraHTTPHeaders(false);
  }

  async setUserAgent(userAgent) {
    this._options.userAgent = userAgent;

    for (const page of this.pages()) await page._delegate.updateUserAgent(); // TODO: service workers don't have Emulation domain?

  }

  async setOffline(offline) {
    this._options.offline = offline;

    for (const page of this.pages()) await page._delegate.updateOffline();

    for (const sw of this.serviceWorkers()) await sw.updateOffline(false);
  }

  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;

    for (const page of this.pages()) await page._delegate.updateHttpCredentials();

    for (const sw of this.serviceWorkers()) await sw.updateHttpCredentials(false);
  }

  async doAddInitScript(source) {
    for (const page of this.pages()) await page._delegate.addInitScript(source);
  }

  async doRemoveInitScripts() {
    for (const page of this.pages()) await page._delegate.removeInitScripts();
  }

  async doExposeBinding(binding) {
    for (const page of this.pages()) await page._delegate.exposeBinding(binding);
  }

  async doRemoveExposedBindings() {
    for (const page of this.pages()) await page._delegate.removeExposedBindings();
  }

  async doUpdateRequestInterception() {
    for (const page of this.pages()) await page._delegate.updateRequestInterception();

    for (const sw of this.serviceWorkers()) await sw.updateRequestInterception();
  }

  async doClose() {
    (0, _utils.assert)(this._browserContextId); // Headful chrome cannot dispose browser context with opened 'beforeunload'
    // dialogs, so we should close all that are currently opened.
    // We also won't get new ones since `Target.disposeBrowserContext` does not trigger
    // beforeunload.

    const openedBeforeUnloadDialogs = [];

    for (const crPage of this._browser._crPages.values()) {
      if (crPage._browserContext !== this) continue;
      const dialogs = [...crPage._page._frameManager._openedDialogs].filter(dialog => dialog.type() === 'beforeunload');
      openedBeforeUnloadDialogs.push(...dialogs);
    }

    await Promise.all(openedBeforeUnloadDialogs.map(dialog => dialog.dismiss()));
    await this._browser._session.send('Target.disposeBrowserContext', {
      browserContextId: this._browserContextId
    });

    this._browser._contexts.delete(this._browserContextId);

    for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
      if (serviceWorker._browserContext !== this) continue; // When closing a browser context, service workers are shutdown
      // asynchronously and we get detached from them later.
      // To avoid the wrong order of notifications, we manually fire
      // "close" event here and forget about the serivce worker.

      serviceWorker.didClose();

      this._browser._serviceWorkers.delete(targetId);
    }
  }

  onClosePersistent() {
    // When persistent context is closed, we do not necessary get Target.detachedFromTarget
    // for all the background pages.
    for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
      if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {
        backgroundPage.didClose();

        this._browser._backgroundPages.delete(targetId);
      }
    }
  }

  async cancelDownload(guid) {
    // The upstream CDP method is implemented in a way that no explicit error would be given
    // regarding the requested `guid`, even if the download is in a state not suitable for
    // cancellation (finished, cancelled, etc.) or the guid is invalid at all.
    await this._browser._session.send('Browser.cancelDownload', {
      guid: guid,
      browserContextId: this._browserContextId
    });
  }

  backgroundPages() {
    const result = [];

    for (const backgroundPage of this._browser._backgroundPages.values()) {
      if (backgroundPage._browserContext === this && backgroundPage._initializedPage) result.push(backgroundPage._initializedPage);
    }

    return result;
  }

  serviceWorkers() {
    return Array.from(this._browser._serviceWorkers.values()).filter(serviceWorker => serviceWorker._browserContext === this);
  }

  async newCDPSession(page) {
    let targetId = null;

    if (page instanceof _page.Page) {
      targetId = page._delegate._targetId;
    } else if (page instanceof _frames.Frame) {
      const session = page._page._delegate._sessions.get(page._id);

      if (!session) throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
      targetId = session._targetId;
    } else {
      throw new Error('page: expected Page or Frame');
    }

    const rootSession = await this._browser._clientRootSession();
    const {
      sessionId
    } = await rootSession.send('Target.attachToTarget', {
      targetId,
      flatten: true
    });
    return this._browser._connection.session(sessionId);
  }

}

exports.CRBrowserContext = CRBrowserContext;
CRBrowserContext.CREvents = {
  BackgroundPage: 'backgroundpage',
  ServiceWorker: 'serviceworker'
};

/***/ }),

/***/ 5460:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.kBrowserCloseMessageId = exports.ConnectionEvents = exports.CRSessionEvents = exports.CRSession = exports.CRConnection = void 0;

var _utils = __nccwpck_require__(3557);

var _events = __nccwpck_require__(2361);

var _stackTrace = __nccwpck_require__(9030);

var _debugLogger = __nccwpck_require__(2003);

var _helper = __nccwpck_require__(9175);

var _protocolError = __nccwpck_require__(7314);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ConnectionEvents = {
  Disconnected: Symbol('ConnectionEvents.Disconnected')
}; // CRPlaywright uses this special id to issue Browser.close command which we
// should ignore.

exports.ConnectionEvents = ConnectionEvents;
const kBrowserCloseMessageId = -9999;
exports.kBrowserCloseMessageId = kBrowserCloseMessageId;

class CRConnection extends _events.EventEmitter {
  constructor(transport, protocolLogger, browserLogsCollector) {
    super();
    this._lastId = 0;
    this._transport = void 0;
    this._sessions = new Map();
    this._protocolLogger = void 0;
    this._browserLogsCollector = void 0;
    this.rootSession = void 0;
    this._closed = false;
    this.setMaxListeners(0);
    this._transport = transport;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.rootSession = new CRSession(this, '', 'browser', '');

    this._sessions.set('', this.rootSession);

    this._transport.onmessage = this._onMessage.bind(this); // onclose should be set last, since it can be immediately called.

    this._transport.onclose = this._onClose.bind(this);
  }

  static fromSession(session) {
    return session._connection;
  }

  session(sessionId) {
    return this._sessions.get(sessionId) || null;
  }

  _rawSend(sessionId, method, params) {
    const id = ++this._lastId;
    const message = {
      id,
      method,
      params
    };
    if (sessionId) message.sessionId = sessionId;

    this._protocolLogger('send', message);

    this._transport.send(message);

    return id;
  }

  async _onMessage(message) {
    this._protocolLogger('receive', message);

    if (message.id === kBrowserCloseMessageId) return;

    if (message.method === 'Target.attachedToTarget') {
      const sessionId = message.params.sessionId;
      const rootSessionId = message.sessionId || '';
      const session = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);

      this._sessions.set(sessionId, session);
    } else if (message.method === 'Target.detachedFromTarget') {
      const session = this._sessions.get(message.params.sessionId);

      if (session) {
        session._onClosed(undefined);

        this._sessions.delete(message.params.sessionId);
      }
    }

    const session = this._sessions.get(message.sessionId || '');

    if (session) session._onMessage(message);
  }

  _onClose() {
    this._closed = true;
    this._transport.onmessage = undefined;
    this._transport.onclose = undefined;

    const browserDisconnectedLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());

    for (const session of this._sessions.values()) session._onClosed(browserDisconnectedLogs);

    this._sessions.clear();

    Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
  }

  close() {
    if (!this._closed) this._transport.close();
  }

  async createSession(targetInfo) {
    const {
      sessionId
    } = await this.rootSession.send('Target.attachToTarget', {
      targetId: targetInfo.targetId,
      flatten: true
    });
    return this._sessions.get(sessionId);
  }

  async createBrowserSession() {
    const {
      sessionId
    } = await this.rootSession.send('Target.attachToBrowserTarget');
    return this._sessions.get(sessionId);
  }

}

exports.CRConnection = CRConnection;
const CRSessionEvents = {
  Disconnected: Symbol('Events.CDPSession.Disconnected')
};
exports.CRSessionEvents = CRSessionEvents;

class CRSession extends _events.EventEmitter {
  constructor(connection, rootSessionId, targetType, sessionId) {
    super();
    this._connection = void 0;
    this._eventListener = void 0;
    this._callbacks = new Map();
    this._targetType = void 0;
    this._sessionId = void 0;
    this._rootSessionId = void 0;
    this._crashed = false;
    this._browserDisconnectedLogs = void 0;
    this.on = void 0;
    this.addListener = void 0;
    this.off = void 0;
    this.removeListener = void 0;
    this.once = void 0;
    this.guid = void 0;
    this.guid = `cdp-session@${sessionId}`;
    this.setMaxListeners(0);
    this._connection = connection;
    this._rootSessionId = rootSessionId;
    this._targetType = targetType;
    this._sessionId = sessionId;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }

  _markAsCrashed() {
    this._crashed = true;
  }

  async send(method, params) {
    if (this._crashed) throw new _protocolError.ProtocolError(true, 'Target crashed');
    if (this._browserDisconnectedLogs !== undefined) throw new _protocolError.ProtocolError(true, `Browser closed.` + this._browserDisconnectedLogs);
    if (!this._connection) throw new _protocolError.ProtocolError(true, `Target closed`);

    const id = this._connection._rawSend(this._sessionId, method, params);

    return new Promise((resolve, reject) => {
      this._callbacks.set(id, {
        resolve,
        reject,
        error: new _protocolError.ProtocolError(false),
        method
      });
    });
  }

  _sendMayFail(method, params) {
    return this.send(method, params).catch(error => _debugLogger.debugLogger.log('error', error));
  }

  _onMessage(object) {
    var _object$error;

    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);

      this._callbacks.delete(object.id);

      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object.error));else callback.resolve(object.result);
    } else if (object.id && ((_object$error = object.error) === null || _object$error === void 0 ? void 0 : _object$error.code) === -32001) {// Message to a closed session, just ignore it.
    } else {
      var _object$error2;

      (0, _utils.assert)(!object.id, (object === null || object === void 0 ? void 0 : (_object$error2 = object.error) === null || _object$error2 === void 0 ? void 0 : _object$error2.message) || undefined);
      Promise.resolve().then(() => {
        if (this._eventListener) this._eventListener(object.method, object.params);
        this.emit(object.method, object.params);
      });
    }
  }

  async detach() {
    if (!this._connection) throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);

    const rootSession = this._connection.session(this._rootSessionId);

    if (!rootSession) throw new Error('Root session has been closed');
    await rootSession.send('Target.detachFromTarget', {
      sessionId: this._sessionId
    });
  }

  _onClosed(browserDisconnectedLogs) {
    this._browserDisconnectedLogs = browserDisconnectedLogs;
    const errorMessage = browserDisconnectedLogs !== undefined ? 'Browser closed.' + browserDisconnectedLogs : 'Target closed';

    for (const callback of this._callbacks.values()) {
      callback.error.sessionClosed = true;
      callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, errorMessage));
    }

    this._callbacks.clear();

    this._connection = null;
    Promise.resolve().then(() => this.emit(CRSessionEvents.Disconnected));
  }

}

exports.CRSession = CRSession;

function createProtocolError(error, method, protocolError) {
  let message = `Protocol error (${method}): ${protocolError.message}`;
  if ('data' in protocolError) message += ` ${protocolError.data}`;
  return (0, _stackTrace.rewriteErrorMessage)(error, message);
}

/***/ }),

/***/ 9956:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRCoverage = void 0;

var _eventsHelper = __nccwpck_require__(3841);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CRCoverage {
  constructor(client) {
    this._jsCoverage = void 0;
    this._cssCoverage = void 0;
    this._jsCoverage = new JSCoverage(client);
    this._cssCoverage = new CSSCoverage(client);
  }

  async startJSCoverage(options) {
    return await this._jsCoverage.start(options);
  }

  async stopJSCoverage() {
    return await this._jsCoverage.stop();
  }

  async startCSSCoverage(options) {
    return await this._cssCoverage.start(options);
  }

  async stopCSSCoverage() {
    return await this._cssCoverage.stop();
  }

}

exports.CRCoverage = CRCoverage;

class JSCoverage {
  constructor(client) {
    this._client = void 0;
    this._enabled = void 0;
    this._scriptIds = void 0;
    this._scriptSources = void 0;
    this._eventListeners = void 0;
    this._resetOnNavigation = void 0;
    this._reportAnonymousScripts = false;
    this._client = client;
    this._enabled = false;
    this._scriptIds = new Set();
    this._scriptSources = new Map();
    this._eventListeners = [];
    this._resetOnNavigation = false;
  }

  async start(options) {
    (0, _utils.assert)(!this._enabled, 'JSCoverage is already enabled');
    const {
      resetOnNavigation = true,
      reportAnonymousScripts = false
    } = options;
    this._resetOnNavigation = resetOnNavigation;
    this._reportAnonymousScripts = reportAnonymousScripts;
    this._enabled = true;

    this._scriptIds.clear();

    this._scriptSources.clear();

    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, 'Debugger.scriptParsed', this._onScriptParsed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Debugger.paused', this._onDebuggerPaused.bind(this))];
    await Promise.all([this._client.send('Profiler.enable'), this._client.send('Profiler.startPreciseCoverage', {
      callCount: true,
      detailed: true
    }), this._client.send('Debugger.enable'), this._client.send('Debugger.setSkipAllPauses', {
      skip: true
    })]);
  }

  _onDebuggerPaused() {
    this._client.send('Debugger.resume');
  }

  _onExecutionContextsCleared() {
    if (!this._resetOnNavigation) return;

    this._scriptIds.clear();

    this._scriptSources.clear();
  }

  async _onScriptParsed(event) {
    this._scriptIds.add(event.scriptId); // Ignore other anonymous scripts unless the reportAnonymousScripts option is true.


    if (!event.url && !this._reportAnonymousScripts) return; // This might fail if the page has already navigated away.

    const response = await this._client._sendMayFail('Debugger.getScriptSource', {
      scriptId: event.scriptId
    });
    if (response) this._scriptSources.set(event.scriptId, response.scriptSource);
  }

  async stop() {
    (0, _utils.assert)(this._enabled, 'JSCoverage is not enabled');
    this._enabled = false;
    const [profileResponse] = await Promise.all([this._client.send('Profiler.takePreciseCoverage'), this._client.send('Profiler.stopPreciseCoverage'), this._client.send('Profiler.disable'), this._client.send('Debugger.disable')]);

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);

    const coverage = {
      entries: []
    };

    for (const entry of profileResponse.result) {
      if (!this._scriptIds.has(entry.scriptId)) continue;
      if (!entry.url && !this._reportAnonymousScripts) continue;

      const source = this._scriptSources.get(entry.scriptId);

      if (source) coverage.entries.push({ ...entry,
        source
      });else coverage.entries.push(entry);
    }

    return coverage;
  }

}

class CSSCoverage {
  constructor(client) {
    this._client = void 0;
    this._enabled = void 0;
    this._stylesheetURLs = void 0;
    this._stylesheetSources = void 0;
    this._eventListeners = void 0;
    this._resetOnNavigation = void 0;
    this._client = client;
    this._enabled = false;
    this._stylesheetURLs = new Map();
    this._stylesheetSources = new Map();
    this._eventListeners = [];
    this._resetOnNavigation = false;
  }

  async start(options) {
    (0, _utils.assert)(!this._enabled, 'CSSCoverage is already enabled');
    const {
      resetOnNavigation = true
    } = options;
    this._resetOnNavigation = resetOnNavigation;
    this._enabled = true;

    this._stylesheetURLs.clear();

    this._stylesheetSources.clear();

    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, 'CSS.styleSheetAdded', this._onStyleSheet.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', this._onExecutionContextsCleared.bind(this))];
    await Promise.all([this._client.send('DOM.enable'), this._client.send('CSS.enable'), this._client.send('CSS.startRuleUsageTracking')]);
  }

  _onExecutionContextsCleared() {
    if (!this._resetOnNavigation) return;

    this._stylesheetURLs.clear();

    this._stylesheetSources.clear();
  }

  async _onStyleSheet(event) {
    const header = event.header; // Ignore anonymous scripts

    if (!header.sourceURL) return; // This might fail if the page has already navigated away.

    const response = await this._client._sendMayFail('CSS.getStyleSheetText', {
      styleSheetId: header.styleSheetId
    });

    if (response) {
      this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);

      this._stylesheetSources.set(header.styleSheetId, response.text);
    }
  }

  async stop() {
    (0, _utils.assert)(this._enabled, 'CSSCoverage is not enabled');
    this._enabled = false;
    const ruleTrackingResponse = await this._client.send('CSS.stopRuleUsageTracking');
    await Promise.all([this._client.send('CSS.disable'), this._client.send('DOM.disable')]);

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners); // aggregate by styleSheetId


    const styleSheetIdToCoverage = new Map();

    for (const entry of ruleTrackingResponse.ruleUsage) {
      let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);

      if (!ranges) {
        ranges = [];
        styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
      }

      ranges.push({
        startOffset: entry.startOffset,
        endOffset: entry.endOffset,
        count: entry.used ? 1 : 0
      });
    }

    const coverage = {
      entries: []
    };

    for (const styleSheetId of this._stylesheetURLs.keys()) {
      const url = this._stylesheetURLs.get(styleSheetId);

      const text = this._stylesheetSources.get(styleSheetId);

      const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
      coverage.entries.push({
        url,
        ranges,
        text
      });
    }

    return coverage;
  }

}

function convertToDisjointRanges(nestedRanges) {
  const points = [];

  for (const range of nestedRanges) {
    points.push({
      offset: range.startOffset,
      type: 0,
      range
    });
    points.push({
      offset: range.endOffset,
      type: 1,
      range
    });
  } // Sort points to form a valid parenthesis sequence.


  points.sort((a, b) => {
    // Sort with increasing offsets.
    if (a.offset !== b.offset) return a.offset - b.offset; // All "end" points should go before "start" points.

    if (a.type !== b.type) return b.type - a.type;
    const aLength = a.range.endOffset - a.range.startOffset;
    const bLength = b.range.endOffset - b.range.startOffset; // For two "start" points, the one with longer range goes first.

    if (a.type === 0) return bLength - aLength; // For two "end" points, the one with shorter range goes first.

    return aLength - bLength;
  });
  const hitCountStack = [];
  const results = [];
  let lastOffset = 0; // Run scanning line to intersect all ranges.

  for (const point of points) {
    if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
      const lastResult = results.length ? results[results.length - 1] : null;
      if (lastResult && lastResult.end === lastOffset) lastResult.end = point.offset;else results.push({
        start: lastOffset,
        end: point.offset
      });
    }

    lastOffset = point.offset;
    if (point.type === 0) hitCountStack.push(point.range.count);else hitCountStack.pop();
  } // Filter out empty ranges.


  return results.filter(range => range.end - range.start > 1);
}

/***/ }),

/***/ 7898:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRDevTools = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kBindingName = '__pw_devtools__'; // This class intercepts preferences-related DevTools embedder methods
// and stores preferences as a json file in the browser installation directory.

class CRDevTools {
  constructor(preferencesPath) {
    this._preferencesPath = void 0;
    this._prefs = void 0;
    this._savePromise = void 0;
    this.__testHookOnBinding = void 0;
    this._preferencesPath = preferencesPath;
    this._savePromise = Promise.resolve();
  }

  install(session) {
    session.on('Runtime.bindingCalled', async event => {
      if (event.name !== kBindingName) return;
      const parsed = JSON.parse(event.payload);
      let result = undefined;
      if (this.__testHookOnBinding) this.__testHookOnBinding(parsed);

      if (parsed.method === 'getPreferences') {
        if (this._prefs === undefined) {
          try {
            const json = await _fs.default.promises.readFile(this._preferencesPath, 'utf8');
            this._prefs = JSON.parse(json);
          } catch (e) {
            this._prefs = {};
          }
        }

        result = this._prefs;
      } else if (parsed.method === 'setPreference') {
        this._prefs[parsed.params[0]] = parsed.params[1];

        this._save();
      } else if (parsed.method === 'removePreference') {
        delete this._prefs[parsed.params[0]];

        this._save();
      } else if (parsed.method === 'clearPreferences') {
        this._prefs = {};

        this._save();
      }

      session.send('Runtime.evaluate', {
        expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
        contextId: event.executionContextId
      }).catch(e => null);
    });
    Promise.all([session.send('Runtime.enable'), session.send('Runtime.addBinding', {
      name: kBindingName
    }), session.send('Page.enable'), session.send('Page.addScriptToEvaluateOnNewDocument', {
      source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      `
    }), session.send('Runtime.runIfWaitingForDebugger')]).catch(e => null);
  }

  _save() {
    // Serialize saves to avoid corruption.
    this._savePromise = this._savePromise.then(async () => {
      await _fs.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch(e => null);
    });
  }

}

exports.CRDevTools = CRDevTools;

/***/ }),

/***/ 6027:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DragManager = void 0;

var _utils = __nccwpck_require__(3557);

var _crProtocolHelper = __nccwpck_require__(911);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
class DragManager {
  constructor(page) {
    this._crPage = void 0;
    this._dragState = null;
    this._lastPosition = {
      x: 0,
      y: 0
    };
    this._crPage = page;
  }

  async cancelDrag() {
    if (!this._dragState) return false;
    await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
      type: 'dragCancel',
      x: this._lastPosition.x,
      y: this._lastPosition.y,
      data: {
        items: [],
        dragOperationsMask: 0xFFFF
      }
    });
    this._dragState = null;
    return true;
  }

  async interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
    this._lastPosition = {
      x,
      y
    };

    if (this._dragState) {
      await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
        type: 'dragOver',
        x,
        y,
        data: this._dragState,
        modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
      });
      return;
    }

    if (button !== 'left') return moveCallback();
    const client = this._crPage._mainFrameSession._client;
    let onDragIntercepted;
    const dragInterceptedPromise = new Promise(x => onDragIntercepted = x);
    await Promise.all(this._crPage._page.frames().map(async frame => {
      await frame.nonStallingEvaluateInExistingContext(function () {
        let didStartDrag = Promise.resolve(false);
        let dragEvent = null;

        const dragListener = event => dragEvent = event;

        const mouseListener = () => {
          didStartDrag = new Promise(callback => {
            window.addEventListener('dragstart', dragListener, {
              once: true,
              capture: true
            });
            setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
          });
        };

        window.addEventListener('mousemove', mouseListener, {
          once: true,
          capture: true
        });

        window.__cleanupDrag = async () => {
          const val = await didStartDrag;
          window.removeEventListener('mousemove', mouseListener, {
            capture: true
          });
          window.removeEventListener('dragstart', dragListener, {
            capture: true
          });
          delete window.__cleanupDrag;
          return val;
        };
      }.toString(), true, 'utility').catch(() => {});
    }));
    client.on('Input.dragIntercepted', onDragIntercepted);

    try {
      await client.send('Input.setInterceptDrags', {
        enabled: true
      });
    } catch {
      // If Input.setInterceptDrags is not supported, just do a regular move.
      // This can be removed once we stop supporting old Electron.
      client.off('Input.dragIntercepted', onDragIntercepted);
      return moveCallback();
    }

    await moveCallback();
    const expectingDrag = (await Promise.all(this._crPage._page.frames().map(async frame => {
      return frame.nonStallingEvaluateInExistingContext('window.__cleanupDrag && window.__cleanupDrag()', false, 'utility').catch(() => false);
    }))).some(x => x);
    this._dragState = expectingDrag ? (await dragInterceptedPromise).data : null;
    client.off('Input.dragIntercepted', onDragIntercepted);
    await client.send('Input.setInterceptDrags', {
      enabled: false
    });

    if (this._dragState) {
      await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
        type: 'dragEnter',
        x,
        y,
        data: this._dragState,
        modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
      });
    }
  }

  isDragging() {
    return !!this._dragState;
  }

  async drop(x, y, modifiers) {
    (0, _utils.assert)(this._dragState, 'missing drag state');
    await this._crPage._mainFrameSession._client.send('Input.dispatchDragEvent', {
      type: 'drop',
      x,
      y,
      data: this._dragState,
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
    });
    this._dragState = null;
  }

}

exports.DragManager = DragManager;

/***/ }),

/***/ 4244:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRExecutionContext = void 0;

var _crProtocolHelper = __nccwpck_require__(911);

var js = _interopRequireWildcard(__nccwpck_require__(804));

var _stackTrace = __nccwpck_require__(9030);

var _utilityScriptSerializers = __nccwpck_require__(9012);

var _protocolError = __nccwpck_require__(7314);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CRExecutionContext {
  constructor(client, contextPayload) {
    this._client = void 0;
    this._contextId = void 0;
    this._client = client;
    this._contextId = contextPayload.id;
  }

  async rawEvaluateJSON(expression) {
    const {
      exceptionDetails,
      result: remoteObject
    } = await this._client.send('Runtime.evaluate', {
      expression,
      contextId: this._contextId,
      returnByValue: true
    }).catch(rewriteError);
    if (exceptionDetails) throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
    return remoteObject.value;
  }

  async rawEvaluateHandle(expression) {
    const {
      exceptionDetails,
      result: remoteObject
    } = await this._client.send('Runtime.evaluate', {
      expression,
      contextId: this._contextId
    }).catch(rewriteError);
    if (exceptionDetails) throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
    return remoteObject.objectId;
  }

  rawCallFunctionNoReply(func, ...args) {
    this._client.send('Runtime.callFunctionOn', {
      functionDeclaration: func.toString(),
      arguments: args.map(a => a instanceof js.JSHandle ? {
        objectId: a._objectId
      } : {
        value: a
      }),
      returnByValue: true,
      executionContextId: this._contextId,
      userGesture: true
    }).catch(() => {});
  }

  async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
    const {
      exceptionDetails,
      result: remoteObject
    } = await this._client.send('Runtime.callFunctionOn', {
      functionDeclaration: expression,
      objectId: utilityScript._objectId,
      arguments: [{
        objectId: utilityScript._objectId
      }, ...values.map(value => ({
        value
      })), ...objectIds.map(objectId => ({
        objectId
      }))],
      returnByValue,
      awaitPromise: true,
      userGesture: true
    }).catch(rewriteError);
    if (exceptionDetails) throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
    return returnByValue ? (0, _utilityScriptSerializers.parseEvaluationResultValue)(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
  }

  async getProperties(context, objectId) {
    const response = await this._client.send('Runtime.getProperties', {
      objectId,
      ownProperties: true
    });
    const result = new Map();

    for (const property of response.result) {
      if (!property.enumerable || !property.value) continue;
      result.set(property.name, context.createHandle(property.value));
    }

    return result;
  }

  createHandle(context, remoteObject) {
    return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
  }

  async releaseHandle(objectId) {
    await (0, _crProtocolHelper.releaseObject)(this._client, objectId);
  }

}

exports.CRExecutionContext = CRExecutionContext;

function rewriteError(error) {
  if (error.message.includes('Object reference chain is too long')) return {
    result: {
      type: 'undefined'
    }
  };
  if (error.message.includes('Object couldn\'t be returned by value')) return {
    result: {
      type: 'undefined'
    }
  };
  if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) (0, _stackTrace.rewriteErrorMessage)(error, error.message + ' Are you passing a nested JSHandle?');
  if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error)) throw new Error('Execution context was destroyed, most likely because of a navigation.');
  throw error;
}

function potentiallyUnserializableValue(remoteObject) {
  const value = remoteObject.value;
  const unserializableValue = remoteObject.unserializableValue;
  return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
}

function renderPreview(object) {
  if (object.type === 'undefined') return 'undefined';
  if ('value' in object) return String(object.value);
  if (object.unserializableValue) return String(object.unserializableValue);

  if (object.description === 'Object' && object.preview) {
    const tokens = [];

    for (const {
      name,
      value
    } of object.preview.properties) tokens.push(`${name}: ${value}`);

    return `{${tokens.join(', ')}}`;
  }

  if (object.subtype === 'array' && object.preview) {
    const result = [];

    for (const {
      name,
      value
    } of object.preview.properties) result[+name] = value;

    return '[' + String(result) + ']';
  }

  return object.description;
}

/***/ }),

/***/ 921:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;

var input = _interopRequireWildcard(__nccwpck_require__(2654));

var _macEditingCommands = __nccwpck_require__(2310);

var _utils = __nccwpck_require__(3557);

var _crProtocolHelper = __nccwpck_require__(911);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RawKeyboardImpl {
  constructor(_client, _isMac, _dragManger) {
    this._client = _client;
    this._isMac = _isMac;
    this._dragManger = _dragManger;
  }

  _commandsForCode(code, modifiers) {
    if (!this._isMac) return [];
    const parts = [];

    for (const modifier of ['Shift', 'Control', 'Alt', 'Meta']) {
      if (modifiers.has(modifier)) parts.push(modifier);
    }

    parts.push(code);
    const shortcut = parts.join('+');
    let commands = _macEditingCommands.macEditingCommands[shortcut] || [];
    if ((0, _utils.isString)(commands)) commands = [commands]; // Commands that insert text are not supported

    commands = commands.filter(x => !x.startsWith('insert')); // remove the trailing : to match the Chromium command names.

    return commands.map(c => c.substring(0, c.length - 1));
  }

  async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
    if (code === 'Escape' && (await this._dragManger.cancelDrag())) return;

    const commands = this._commandsForCode(code, modifiers);

    await this._client.send('Input.dispatchKeyEvent', {
      type: text ? 'keyDown' : 'rawKeyDown',
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      windowsVirtualKeyCode: keyCodeWithoutLocation,
      code,
      commands,
      key,
      text,
      unmodifiedText: text,
      autoRepeat,
      location,
      isKeypad: location === input.keypadLocation
    });
  }

  async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
    await this._client.send('Input.dispatchKeyEvent', {
      type: 'keyUp',
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      key,
      windowsVirtualKeyCode: keyCodeWithoutLocation,
      code,
      location
    });
  }

  async sendText(text) {
    await this._client.send('Input.insertText', {
      text
    });
  }

}

exports.RawKeyboardImpl = RawKeyboardImpl;

class RawMouseImpl {
  constructor(page, client, dragManager) {
    this._client = void 0;
    this._page = void 0;
    this._dragManager = void 0;
    this._page = page;
    this._client = client;
    this._dragManager = dragManager;
  }

  async move(x, y, button, buttons, modifiers, forClick) {
    const actualMove = async () => {
      await this._client.send('Input.dispatchMouseEvent', {
        type: 'mouseMoved',
        button,
        buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
        x,
        y,
        modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
      });
    };

    if (forClick) {
      // Avoid extra protocol calls related to drag and drop, because click relies on
      // move-down-up protocol commands being sent synchronously.
      return actualMove();
    }

    await this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, actualMove);
  }

  async down(x, y, button, buttons, modifiers, clickCount) {
    if (this._dragManager.isDragging()) return;
    await this._client.send('Input.dispatchMouseEvent', {
      type: 'mousePressed',
      button,
      buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
      x,
      y,
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      clickCount
    });
  }

  async up(x, y, button, buttons, modifiers, clickCount) {
    if (this._dragManager.isDragging()) {
      await this._dragManager.drop(x, y, modifiers);
      return;
    }

    await this._client.send('Input.dispatchMouseEvent', {
      type: 'mouseReleased',
      button,
      buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
      x,
      y,
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      clickCount
    });
  }

  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    await this._client.send('Input.dispatchMouseEvent', {
      type: 'mouseWheel',
      x,
      y,
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      deltaX,
      deltaY
    });
  }

}

exports.RawMouseImpl = RawMouseImpl;

class RawTouchscreenImpl {
  constructor(client) {
    this._client = void 0;
    this._client = client;
  }

  async tap(x, y, modifiers) {
    await Promise.all([this._client.send('Input.dispatchTouchEvent', {
      type: 'touchStart',
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      touchPoints: [{
        x,
        y
      }]
    }), this._client.send('Input.dispatchTouchEvent', {
      type: 'touchEnd',
      modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
      touchPoints: []
    })]);
  }

}

exports.RawTouchscreenImpl = RawTouchscreenImpl;

/***/ }),

/***/ 2969:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRNetworkManager = void 0;

var _helper = __nccwpck_require__(9175);

var _eventsHelper = __nccwpck_require__(3841);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _utils = __nccwpck_require__(3557);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CRNetworkManager {
  constructor(client, page, serviceWorker, parentManager) {
    this._client = void 0;
    this._page = void 0;
    this._serviceWorker = void 0;
    this._parentManager = void 0;
    this._requestIdToRequest = new Map();
    this._requestIdToRequestWillBeSentEvent = new Map();
    this._credentials = null;
    this._attemptedAuthentications = new Set();
    this._userRequestInterceptionEnabled = false;
    this._protocolRequestInterceptionEnabled = false;
    this._requestIdToRequestPausedEvent = new Map();
    this._eventListeners = void 0;
    this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
    this._client = client;
    this._page = page;
    this._serviceWorker = serviceWorker;
    this._parentManager = parentManager;
    this._eventListeners = this.instrumentNetworkEvents(client);
  }

  instrumentNetworkEvents(session, workerFrame) {
    const listeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Fetch.requestPaused', this._onRequestPaused.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, 'Fetch.authRequired', this._onAuthRequired.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSentExtraInfo', this._onRequestWillBeSentExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestServedFromCache', this._onRequestServedFromCache.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceivedExtraInfo', this._onResponseReceivedExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFinished', this._onLoadingFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFailed', this._onLoadingFailed.bind(this, workerFrame))];

    if (this._page) {
      listeners.push(...[_eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketCreated', e => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketWillSendHandshakeRequest', e => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketHandshakeResponseReceived', e => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketClosed', e => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.webSocketFrameError', e => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))]);
    }

    return listeners;
  }

  async initialize() {
    await this._client.send('Network.enable');
  }

  dispose() {
    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
  }

  async authenticate(credentials) {
    this._credentials = credentials;
    await this._updateProtocolRequestInterception();
  }

  async setOffline(offline) {
    await this._client.send('Network.emulateNetworkConditions', {
      offline,
      // values of 0 remove any active throttling. crbug.com/456324#c9
      latency: 0,
      downloadThroughput: -1,
      uploadThroughput: -1
    });
  }

  async setRequestInterception(value) {
    this._userRequestInterceptionEnabled = value;
    await this._updateProtocolRequestInterception();
  }

  async _updateProtocolRequestInterception() {
    const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
    if (enabled === this._protocolRequestInterceptionEnabled) return;
    this._protocolRequestInterceptionEnabled = enabled;

    if (enabled) {
      await Promise.all([this._client.send('Network.setCacheDisabled', {
        cacheDisabled: true
      }), this._client.send('Fetch.enable', {
        handleAuthRequests: true,
        patterns: [{
          urlPattern: '*',
          requestStage: 'Request'
        }]
      })]);
    } else {
      await Promise.all([this._client.send('Network.setCacheDisabled', {
        cacheDisabled: false
      }), this._client.send('Fetch.disable')]);
    }
  }

  _onRequestWillBeSent(workerFrame, event) {
    // Request interception doesn't happen for data URLs with Network Service.
    if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith('data:')) {
      const requestId = event.requestId;

      const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);

      if (requestPausedEvent) {
        this._onRequest(workerFrame, event, requestPausedEvent);

        this._requestIdToRequestPausedEvent.delete(requestId);
      } else {
        this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
      }
    } else {
      this._onRequest(workerFrame, event, null);
    }
  }

  _onRequestServedFromCache(event) {
    this._responseExtraInfoTracker.requestServedFromCache(event);
  }

  _onRequestWillBeSentExtraInfo(event) {
    this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
  }

  _onAuthRequired(event) {
    let response = 'Default';

    if (this._attemptedAuthentications.has(event.requestId)) {
      response = 'CancelAuth';
    } else if (this._credentials) {
      response = 'ProvideCredentials';

      this._attemptedAuthentications.add(event.requestId);
    }

    const {
      username,
      password
    } = this._credentials || {
      username: undefined,
      password: undefined
    };

    this._client._sendMayFail('Fetch.continueWithAuth', {
      requestId: event.requestId,
      authChallengeResponse: {
        response,
        username,
        password
      }
    });
  }

  _onRequestPaused(workerFrame, event) {
    if (!event.networkId) {
      // Fetch without networkId means that request was not recongnized by inspector, and
      // it will never receive Network.requestWillBeSent. Most likely, this is an internal request
      // that we can safely fail.
      this._client._sendMayFail('Fetch.failRequest', {
        requestId: event.requestId,
        errorReason: 'Aborted'
      });

      return;
    }

    if (event.request.url.startsWith('data:')) return;
    const requestId = event.networkId;

    const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);

    if (requestWillBeSentEvent) {
      this._onRequest(workerFrame, requestWillBeSentEvent, event);

      this._requestIdToRequestWillBeSentEvent.delete(requestId);
    } else {
      this._requestIdToRequestPausedEvent.set(requestId, event);
    }
  }

  _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {
    var _this$_page, _this$_page2, _this$_page3;

    if (requestWillBeSentEvent.request.url.startsWith('data:')) return;
    let redirectedFrom = null;

    if (requestWillBeSentEvent.redirectResponse) {
      const request = this._requestIdToRequest.get(requestWillBeSentEvent.requestId); // If we connect late to the target, we could have missed the requestWillBeSent event.


      if (request) {
        this._handleRequestRedirect(request, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp, requestWillBeSentEvent.redirectHasExtraInfo);

        redirectedFrom = request;
      }
    }

    let frame = requestWillBeSentEvent.frameId ? (_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame; // Requests from workers lack frameId, because we receive Network.requestWillBeSent
    // on the worker target. However, we receive Fetch.requestPaused on the page target,
    // and lack workerFrame there. Luckily, Fetch.requestPaused provides a frameId.

    if (!frame && this._page && requestPausedEvent && requestPausedEvent.frameId) frame = this._page._frameManager.frame(requestPausedEvent.frameId); // Check if it's main resource request interception (targetId === main frame id).

    if (!frame && this._page && requestWillBeSentEvent.frameId === ((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2._delegate)._targetId) {
      // Main resource request for the page is being intercepted so the Frame is not created
      // yet. Precreate it here for the purposes of request interception. It will be updated
      // later as soon as the request continues and we receive frame tree from the page.
      frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
    } // CORS options request is generated by the network stack. If interception is enabled,
    // we accept all CORS options, assuming that this was intended when setting route.
    //
    // Note: it would be better to match the URL against interception patterns, but
    // that information is only available to the client. Perhaps we can just route to the client?


    if (requestPausedEvent && requestPausedEvent.request.method === 'OPTIONS' && (this._page || this._serviceWorker).needsRequestInterception()) {
      const requestHeaders = requestPausedEvent.request.headers;
      const responseHeaders = [{
        name: 'Access-Control-Allow-Origin',
        value: requestHeaders['Origin'] || '*'
      }, {
        name: 'Access-Control-Allow-Methods',
        value: requestHeaders['Access-Control-Request-Method'] || 'GET, POST, OPTIONS, DELETE'
      }, {
        name: 'Access-Control-Allow-Credentials',
        value: 'true'
      }];
      if (requestHeaders['Access-Control-Request-Headers']) responseHeaders.push({
        name: 'Access-Control-Allow-Headers',
        value: requestHeaders['Access-Control-Request-Headers']
      });

      this._client._sendMayFail('Fetch.fulfillRequest', {
        requestId: requestPausedEvent.requestId,
        responseCode: 204,
        responsePhrase: network.STATUS_TEXTS['204'],
        responseHeaders,
        body: ''
      });

      return;
    } // Non-service-worker requests MUST have a frame—if they don't, we pretend there was no request


    if (!frame && !this._serviceWorker) {
      if (requestPausedEvent) this._client._sendMayFail('Fetch.continueRequest', {
        requestId: requestPausedEvent.requestId
      });
      return;
    }

    let route = null;

    if (requestPausedEvent) {
      // We do not support intercepting redirects.
      if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) this._client._sendMayFail('Fetch.continueRequest', {
        requestId: requestPausedEvent.requestId
      });else route = new RouteImpl(this._client, requestPausedEvent.requestId);
    }

    const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === 'Document';
    const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : undefined;
    const request = new InterceptableRequest({
      context: (this._page || this._serviceWorker)._browserContext,
      frame: frame || null,
      serviceWorker: this._serviceWorker || null,
      documentId,
      route,
      requestWillBeSentEvent,
      requestPausedEvent,
      redirectedFrom
    });

    this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);

    if (requestPausedEvent && !requestPausedEvent.responseStatusCode && !requestPausedEvent.responseErrorReason) {
      // We will not receive extra info when intercepting the request.
      // Use the headers from the Fetch.requestPausedPayload and release the allHeaders()
      // right away, so that client can call it from the route handler.
      request.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(requestPausedEvent.request.headers, '\n'));
    }

    (((_this$_page3 = this._page) === null || _this$_page3 === void 0 ? void 0 : _this$_page3._frameManager) || this._serviceWorker).requestStarted(request.request, route || undefined);
  }

  _createResponse(request, responsePayload, hasExtraInfo) {
    var _responsePayload$secu, _responsePayload$secu2, _responsePayload$secu3, _responsePayload$secu4, _responsePayload$secu5;

    const getResponseBody = async () => {
      const contentLengthHeader = Object.entries(responsePayload.headers).find(header => header[0].toLowerCase() === 'content-length');
      const expectedLength = contentLengthHeader ? +contentLengthHeader[1] : undefined;
      const response = await this._client.send('Network.getResponseBody', {
        requestId: request._requestId
      });
      if (response.body || !expectedLength) return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8'); // For <link prefetch we are going to receive empty body with non-emtpy content-length expectation. Reach out for the actual content.

      const resource = await this._client.send('Network.loadNetworkResource', {
        url: request.request.url(),
        frameId: this._serviceWorker ? undefined : request.request.frame()._id,
        options: {
          disableCache: false,
          includeCredentials: true
        }
      });
      const chunks = [];

      while (resource.resource.stream) {
        const chunk = await this._client.send('IO.read', {
          handle: resource.resource.stream
        });
        chunks.push(Buffer.from(chunk.data, chunk.base64Encoded ? 'base64' : 'utf-8'));

        if (chunk.eof) {
          await this._client.send('IO.close', {
            handle: resource.resource.stream
          });
          break;
        }
      }

      return Buffer.concat(chunks);
    };

    const timingPayload = responsePayload.timing;
    let timing;

    if (timingPayload) {
      timing = {
        startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1000,
        domainLookupStart: timingPayload.dnsStart,
        domainLookupEnd: timingPayload.dnsEnd,
        connectStart: timingPayload.connectStart,
        secureConnectionStart: timingPayload.sslStart,
        connectEnd: timingPayload.connectEnd,
        requestStart: timingPayload.sendStart,
        responseStart: timingPayload.receiveHeadersEnd
      };
    } else {
      timing = {
        startTime: request._wallTime * 1000,
        domainLookupStart: -1,
        domainLookupEnd: -1,
        connectStart: -1,
        secureConnectionStart: -1,
        connectEnd: -1,
        requestStart: -1,
        responseStart: -1
      };
    }

    const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers), timing, getResponseBody, !!responsePayload.fromServiceWorker, responsePayload.protocol);

    if (responsePayload !== null && responsePayload !== void 0 && responsePayload.remoteIPAddress && typeof (responsePayload === null || responsePayload === void 0 ? void 0 : responsePayload.remotePort) === 'number') {
      response._serverAddrFinished({
        ipAddress: responsePayload.remoteIPAddress,
        port: responsePayload.remotePort
      });
    } else {
      response._serverAddrFinished();
    }

    response._securityDetailsFinished({
      protocol: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu = responsePayload.securityDetails) === null || _responsePayload$secu === void 0 ? void 0 : _responsePayload$secu.protocol,
      subjectName: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu2 = responsePayload.securityDetails) === null || _responsePayload$secu2 === void 0 ? void 0 : _responsePayload$secu2.subjectName,
      issuer: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu3 = responsePayload.securityDetails) === null || _responsePayload$secu3 === void 0 ? void 0 : _responsePayload$secu3.issuer,
      validFrom: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu4 = responsePayload.securityDetails) === null || _responsePayload$secu4 === void 0 ? void 0 : _responsePayload$secu4.validFrom,
      validTo: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu5 = responsePayload.securityDetails) === null || _responsePayload$secu5 === void 0 ? void 0 : _responsePayload$secu5.validTo
    });

    this._responseExtraInfoTracker.processResponse(request._requestId, response, hasExtraInfo);

    return response;
  }

  _handleRequestRedirect(request, responsePayload, timestamp, hasExtraInfo) {
    var _this$_page4, _this$_page5;

    const response = this._createResponse(request, responsePayload, hasExtraInfo);

    response.setTransferSize(null);
    response.setEncodedBodySize(null);

    response._requestFinished((timestamp - request._timestamp) * 1000);

    this._requestIdToRequest.delete(request._requestId);

    if (request._interceptionId) this._attemptedAuthentications.delete(request._interceptionId);

    (((_this$_page4 = this._page) === null || _this$_page4 === void 0 ? void 0 : _this$_page4._frameManager) || this._serviceWorker).requestReceivedResponse(response);

    (((_this$_page5 = this._page) === null || _this$_page5 === void 0 ? void 0 : _this$_page5._frameManager) || this._serviceWorker).reportRequestFinished(request.request, response);
  }

  _onResponseReceivedExtraInfo(event) {
    this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
  }

  _onResponseReceived(event) {
    var _this$_page7;

    let request = this._requestIdToRequest.get(event.requestId); // For frame-level Requests that are handled by a Service Worker's fetch handler, we'll never get a requestPaused event, so we need to
    // manually create the request. In an ideal world, crNetworkManager would be able to know this on Network.requestWillBeSent, but there
    // is not enough metadata there.
    //
    // PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS we guard with, since this would fix an old bug where, when using routing,
    // request would not be emitted to the user for requests made by a page with a SW (and fetch handler) registered


    if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS && !request && event.response.fromServiceWorker) {
      var _this$_page6;

      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);

      const frame = requestWillBeSentEvent !== null && requestWillBeSentEvent !== void 0 && requestWillBeSentEvent.frameId ? (_this$_page6 = this._page) === null || _this$_page6 === void 0 ? void 0 : _this$_page6._frameManager.frame(requestWillBeSentEvent.frameId) : null;

      if (requestWillBeSentEvent && frame) {
        this._onRequest(frame, requestWillBeSentEvent, null
        /* requestPausedPayload */
        );

        request = this._requestIdToRequest.get(event.requestId);

        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
      }
    } // FileUpload sends a response without a matching request.


    if (!request) return;

    const response = this._createResponse(request, event.response, event.hasExtraInfo);

    (((_this$_page7 = this._page) === null || _this$_page7 === void 0 ? void 0 : _this$_page7._frameManager) || this._serviceWorker).requestReceivedResponse(response);
  }

  _onLoadingFinished(event) {
    var _this$_page8;

    this._responseExtraInfoTracker.loadingFinished(event);

    let request = this._requestIdToRequest.get(event.requestId);

    if (!request) request = this._maybeAdoptMainRequest(event.requestId); // For certain requestIds we never receive requestWillBeSent event.
    // @see https://crbug.com/750469

    if (!request) return; // Under certain conditions we never get the Network.responseReceived
    // event from protocol. @see https://crbug.com/883475

    const response = request.request._existingResponse();

    if (response) {
      response.setTransferSize(event.encodedDataLength);
      response.responseHeadersSize().then(size => response.setEncodedBodySize(event.encodedDataLength - size));

      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
    }

    this._requestIdToRequest.delete(request._requestId);

    if (request._interceptionId) this._attemptedAuthentications.delete(request._interceptionId);

    (((_this$_page8 = this._page) === null || _this$_page8 === void 0 ? void 0 : _this$_page8._frameManager) || this._serviceWorker).reportRequestFinished(request.request, response);
  }

  _onLoadingFailed(workerFrame, event) {
    var _this$_page9;

    this._responseExtraInfoTracker.loadingFailed(event);

    let request = this._requestIdToRequest.get(event.requestId);

    if (!request) request = this._maybeAdoptMainRequest(event.requestId);

    if (!request) {
      const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);

      if (requestWillBeSentEvent) {
        // This is a case where request has failed before we had a chance to intercept it.
        // We stop waiting for Fetch.requestPaused (it might never come), and dispatch request event
        // right away, followed by requestfailed event.
        this._requestIdToRequestWillBeSentEvent.delete(event.requestId);

        this._onRequest(workerFrame, requestWillBeSentEvent, null);

        request = this._requestIdToRequest.get(event.requestId);
      }
    } // For certain requestIds we never receive requestWillBeSent event.
    // @see https://crbug.com/750469


    if (!request) return;

    const response = request.request._existingResponse();

    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);

      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
    }

    this._requestIdToRequest.delete(request._requestId);

    if (request._interceptionId) this._attemptedAuthentications.delete(request._interceptionId);

    request.request._setFailureText(event.errorText);

    (((_this$_page9 = this._page) === null || _this$_page9 === void 0 ? void 0 : _this$_page9._frameManager) || this._serviceWorker).requestFailed(request.request, !!event.canceled);
  }

  _maybeAdoptMainRequest(requestId) {
    // OOPIF has a main request that starts in the parent session but finishes in the child session.
    if (!this._parentManager) return;

    const request = this._parentManager._requestIdToRequest.get(requestId); // Main requests have matching loaderId and requestId.


    if (!request || request._documentId !== requestId) return;

    this._requestIdToRequest.set(requestId, request);

    this._parentManager._requestIdToRequest.delete(requestId);

    if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
      this._parentManager._attemptedAuthentications.delete(request._interceptionId);

      this._attemptedAuthentications.add(request._interceptionId);
    }

    return request;
  }

}

exports.CRNetworkManager = CRNetworkManager;

class InterceptableRequest {
  constructor(options) {
    this.request = void 0;
    this._requestId = void 0;
    this._interceptionId = void 0;
    this._documentId = void 0;
    this._timestamp = void 0;
    this._wallTime = void 0;
    this._route = void 0;
    this._redirectedFrom = void 0;
    const {
      context,
      frame,
      documentId,
      route,
      requestWillBeSentEvent,
      requestPausedEvent,
      redirectedFrom,
      serviceWorker
    } = options;
    this._timestamp = requestWillBeSentEvent.timestamp;
    this._wallTime = requestWillBeSentEvent.wallTime;
    this._requestId = requestWillBeSentEvent.requestId;
    this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
    this._documentId = documentId;
    this._route = route;
    this._redirectedFrom = redirectedFrom;
    const {
      headers,
      method,
      url,
      postDataEntries = null
    } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
    const type = (requestWillBeSentEvent.type || '').toLowerCase();
    let postDataBuffer = null;
    if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes) postDataBuffer = Buffer.from(postDataEntries[0].bytes, 'base64');
    this.request = new network.Request(context, frame, serviceWorker, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, url, type, method, postDataBuffer, (0, _utils.headersObjectToArray)(headers));
  }

  _routeForRedirectChain() {
    let request = this;

    while (request._redirectedFrom) request = request._redirectedFrom;

    return request._route;
  }

}

class RouteImpl {
  constructor(client, interceptionId) {
    this._client = void 0;
    this._interceptionId = void 0;
    this._client = client;
    this._interceptionId = interceptionId;
  }

  async continue(request, overrides) {
    // In certain cases, protocol will return error if the request was already canceled
    // or the page was closed. We should tolerate these errors.
    await this._client._sendMayFail('Fetch.continueRequest', {
      requestId: this._interceptionId,
      url: overrides.url,
      headers: overrides.headers,
      method: overrides.method,
      postData: overrides.postData ? overrides.postData.toString('base64') : undefined
    });
  }

  async fulfill(response) {
    const body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
    const responseHeaders = splitSetCookieHeader(response.headers); // In certain cases, protocol will return error if the request was already canceled
    // or the page was closed. We should tolerate these errors.

    await this._client._sendMayFail('Fetch.fulfillRequest', {
      requestId: this._interceptionId,
      responseCode: response.status,
      responsePhrase: network.STATUS_TEXTS[String(response.status)],
      responseHeaders,
      body
    });
  }

  async abort(errorCode = 'failed') {
    const errorReason = errorReasons[errorCode];
    (0, _utils.assert)(errorReason, 'Unknown error code: ' + errorCode); // In certain cases, protocol will return error if the request was already canceled
    // or the page was closed. We should tolerate these errors.

    await this._client._sendMayFail('Fetch.failRequest', {
      requestId: this._interceptionId,
      errorReason
    });
  }

}

function splitSetCookieHeader(headers) {
  const index = headers.findIndex(({
    name
  }) => name.toLowerCase() === 'set-cookie');
  if (index === -1) return headers;
  const header = headers[index];
  const values = header.value.split('\n');
  if (values.length === 1) return headers;
  const result = headers.slice();
  result.splice(index, 1, ...values.map(value => ({
    name: header.name,
    value
  })));
  return result;
}

const errorReasons = {
  'aborted': 'Aborted',
  'accessdenied': 'AccessDenied',
  'addressunreachable': 'AddressUnreachable',
  'blockedbyclient': 'BlockedByClient',
  'blockedbyresponse': 'BlockedByResponse',
  'connectionaborted': 'ConnectionAborted',
  'connectionclosed': 'ConnectionClosed',
  'connectionfailed': 'ConnectionFailed',
  'connectionrefused': 'ConnectionRefused',
  'connectionreset': 'ConnectionReset',
  'internetdisconnected': 'InternetDisconnected',
  'namenotresolved': 'NameNotResolved',
  'timedout': 'TimedOut',
  'failed': 'Failed'
};

// This class aligns responses with response headers from extra info:
//   - Network.requestWillBeSent, Network.responseReceived, Network.loadingFinished/loadingFailed are
//     dispatched using one channel.
//   - Network.requestWillBeSentExtraInfo and Network.responseReceivedExtraInfo are dispatched on
//     another channel. Those channels are not associated, so events come in random order.
//
// This class will associate responses with the new headers. These extra info headers will become
// available to client reliably upon requestfinished event only. It consumes CDP
// signals on one end and processResponse(network.Response) signals on the other hands. It then makes
// sure that responses have all the extra headers in place by the time request finishes.
//
// The shape of the instrumentation API is deliberately following the CDP, so that it
// is clear what is called when and what this means to the tracker without extra
// documentation.
class ResponseExtraInfoTracker {
  constructor() {
    this._requests = new Map();
  }

  requestWillBeSentExtraInfo(event) {
    const info = this._getOrCreateEntry(event.requestId);

    info.requestWillBeSentExtraInfo.push(event);

    this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);

    this._checkFinished(info);
  }

  requestServedFromCache(event) {
    const info = this._getOrCreateEntry(event.requestId);

    info.servedFromCache = true;
  }

  responseReceivedExtraInfo(event) {
    const info = this._getOrCreateEntry(event.requestId);

    info.responseReceivedExtraInfo.push(event);

    this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);

    this._checkFinished(info);
  }

  processResponse(requestId, response, hasExtraInfo) {
    var _info;

    let info = this._requests.get(requestId); // Cached responses have erroneous "hasExtraInfo" flag.
    // https://bugs.chromium.org/p/chromium/issues/detail?id=1340398


    if (!hasExtraInfo || (_info = info) !== null && _info !== void 0 && _info.servedFromCache) {
      // Use "provisional" headers as "raw" ones.
      response.request().setRawRequestHeaders(null);
      response.setResponseHeadersSize(null);
      response.setRawResponseHeaders(null);
      return;
    }

    info = this._getOrCreateEntry(requestId);
    info.responses.push(response);

    this._patchHeaders(info, info.responses.length - 1);
  }

  loadingFinished(event) {
    const info = this._requests.get(event.requestId);

    if (!info) return;
    info.loadingFinished = event;

    this._checkFinished(info);
  }

  loadingFailed(event) {
    const info = this._requests.get(event.requestId);

    if (!info) return;
    info.loadingFailed = event;

    this._checkFinished(info);
  }

  _getOrCreateEntry(requestId) {
    let info = this._requests.get(requestId);

    if (!info) {
      info = {
        requestId: requestId,
        requestWillBeSentExtraInfo: [],
        responseReceivedExtraInfo: [],
        responses: []
      };

      this._requests.set(requestId, info);
    }

    return info;
  }

  _patchHeaders(info, index) {
    const response = info.responses[index];
    const requestExtraInfo = info.requestWillBeSentExtraInfo[index];

    if (response && requestExtraInfo) {
      response.request().setRawRequestHeaders((0, _utils.headersObjectToArray)(requestExtraInfo.headers, '\n'));
      info.requestWillBeSentExtraInfo[index] = undefined;
    }

    const responseExtraInfo = info.responseReceivedExtraInfo[index];

    if (response && responseExtraInfo) {
      var _responseExtraInfo$he;

      response.setResponseHeadersSize(((_responseExtraInfo$he = responseExtraInfo.headersText) === null || _responseExtraInfo$he === void 0 ? void 0 : _responseExtraInfo$he.length) || 0);
      response.setRawResponseHeaders((0, _utils.headersObjectToArray)(responseExtraInfo.headers, '\n'));
      info.responseReceivedExtraInfo[index] = undefined;
    }
  }

  _checkFinished(info) {
    if (!info.loadingFinished && !info.loadingFailed) return;

    if (info.responses.length <= info.responseReceivedExtraInfo.length) {
      // We have extra info for each response.
      this._stopTracking(info.requestId);

      return;
    } // We are not done yet.

  }

  _stopTracking(requestId) {
    this._requests.delete(requestId);
  }

}

/***/ }),

/***/ 2382:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRPage = void 0;

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _eventsHelper = __nccwpck_require__(3841);

var _registry = __nccwpck_require__(9048);

var _stackTrace = __nccwpck_require__(9030);

var _utils = __nccwpck_require__(3557);

var dialog = _interopRequireWildcard(__nccwpck_require__(1645));

var dom = _interopRequireWildcard(__nccwpck_require__(8139));

var frames = _interopRequireWildcard(__nccwpck_require__(8895));

var _helper = __nccwpck_require__(9175);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _page = __nccwpck_require__(3555);

var _crAccessibility = __nccwpck_require__(5246);

var _crBrowser = __nccwpck_require__(2731);

var _crConnection = __nccwpck_require__(5460);

var _crCoverage = __nccwpck_require__(9956);

var _crDragDrop = __nccwpck_require__(6027);

var _crExecutionContext = __nccwpck_require__(4244);

var _crInput = __nccwpck_require__(921);

var _crNetworkManager = __nccwpck_require__(2969);

var _crPdf = __nccwpck_require__(2206);

var _crProtocolHelper = __nccwpck_require__(911);

var _defaultFontFamilies = __nccwpck_require__(5948);

var _videoRecorder = __nccwpck_require__(3202);

var _browserContext = __nccwpck_require__(5985);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const UTILITY_WORLD_NAME = '__playwright_utility_world__';

class CRPage {
  // Holds window features for the next popup being opened via window.open,
  // until the popup target arrives. This could be racy if two oopifs
  // simultaneously call window.open with window features: the order
  // of their Page.windowOpen events is not guaranteed to match the order
  // of new popup targets.
  static mainFrameSession(page) {
    const crPage = page._delegate;
    return crPage._mainFrameSession;
  }

  constructor(client, targetId, browserContext, opener, bits) {
    this._mainFrameSession = void 0;
    this._sessions = new Map();
    this._page = void 0;
    this.rawMouse = void 0;
    this.rawKeyboard = void 0;
    this.rawTouchscreen = void 0;
    this._targetId = void 0;
    this._opener = void 0;
    this._pdf = void 0;
    this._coverage = void 0;
    this._browserContext = void 0;
    this._pagePromise = void 0;
    this._initializedPage = null;
    this._isBackgroundPage = void 0;
    this._nextWindowOpenPopupFeatures = [];
    this._targetId = targetId;
    this._opener = opener;
    this._isBackgroundPage = bits.isBackgroundPage;
    const dragManager = new _crDragDrop.DragManager(this);
    this.rawKeyboard = new _crInput.RawKeyboardImpl(client, browserContext._browser._platform() === 'mac', dragManager);
    this.rawMouse = new _crInput.RawMouseImpl(this, client, dragManager);
    this.rawTouchscreen = new _crInput.RawTouchscreenImpl(client);
    this._pdf = new _crPdf.CRPDF(client);
    this._coverage = new _crCoverage.CRCoverage(client);
    this._browserContext = browserContext;
    this._page = new _page.Page(this, browserContext);
    this._mainFrameSession = new FrameSession(this, client, targetId, null);

    this._sessions.set(targetId, this._mainFrameSession);

    client.once(_crConnection.CRSessionEvents.Disconnected, () => this._page._didDisconnect());

    if (opener && !browserContext._options.noDefaultViewport) {
      const features = opener._nextWindowOpenPopupFeatures.shift() || [];

      const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(features);

      if (viewportSize) this._page._emulatedSize = {
        viewport: viewportSize,
        screen: viewportSize
      };
    } // Note: it is important to call |reportAsNew| before resolving pageOrError promise,
    // so that anyone who awaits pageOrError got a ready and reported page.


    this._pagePromise = this._mainFrameSession._initialize(bits.hasUIWindow).then(async r => {
      await this._page.initOpener(this._opener);
      return r;
    }).catch(async e => {
      await this._page.initOpener(this._opener);
      throw e;
    }).then(() => {
      this._initializedPage = this._page;

      this._reportAsNew();

      return this._page;
    }).catch(e => {
      this._reportAsNew(e);

      return e;
    });
  }

  potentiallyUninitializedPage() {
    return this._page;
  }

  _reportAsNew(error) {
    this._page.reportAsNew(error, this._isBackgroundPage ? _crBrowser.CRBrowserContext.CREvents.BackgroundPage : _browserContext.BrowserContext.Events.Page);
  }

  async _forAllFrameSessions(cb) {
    const frameSessions = Array.from(this._sessions.values());
    await Promise.all(frameSessions.map(frameSession => {
      if (frameSession._isMainFrame()) return cb(frameSession);
      return cb(frameSession).catch(e => {
        // Broadcasting a message to the closed iframe shoule be a noop.
        if (e.message && (e.message.includes('Target closed.') || e.message.includes('Session closed.'))) return;
        throw e;
      });
    }));
  }

  _sessionForFrame(frame) {
    // Frame id equals target id.
    while (!this._sessions.has(frame._id)) {
      const parent = frame.parentFrame();
      if (!parent) throw new Error(`Frame has been detached.`);
      frame = parent;
    }

    return this._sessions.get(frame._id);
  }

  _sessionForHandle(handle) {
    const frame = handle._context.frame;
    return this._sessionForFrame(frame);
  }

  willBeginDownload() {
    this._mainFrameSession._willBeginDownload();
  }

  async pageOrError() {
    return this._pagePromise;
  }

  didClose() {
    for (const session of this._sessions.values()) session.dispose();

    this._page._didClose();
  }

  async navigateFrame(frame, url, referrer) {
    return this._sessionForFrame(frame)._navigate(frame, url, referrer);
  }

  async exposeBinding(binding) {
    await this._forAllFrameSessions(frame => frame._initBinding(binding));
    await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source, false, {}).catch(e => {})));
  }

  async removeExposedBindings() {
    await this._forAllFrameSessions(frame => frame._removeExposedBindings());
  }

  async updateExtraHTTPHeaders() {
    await this._forAllFrameSessions(frame => frame._updateExtraHTTPHeaders(false));
  }

  async updateGeolocation() {
    await this._forAllFrameSessions(frame => frame._updateGeolocation(false));
  }

  async updateOffline() {
    await this._forAllFrameSessions(frame => frame._updateOffline(false));
  }

  async updateHttpCredentials() {
    await this._forAllFrameSessions(frame => frame._updateHttpCredentials(false));
  }

  async updateEmulatedViewportSize(preserveWindowBoundaries) {
    await this._mainFrameSession._updateViewport(preserveWindowBoundaries);
  }

  async bringToFront() {
    await this._mainFrameSession._client.send('Page.bringToFront');
  }

  async updateEmulateMedia() {
    await this._forAllFrameSessions(frame => frame._updateEmulateMedia());
  }

  async updateUserAgent() {
    await this._forAllFrameSessions(frame => frame._updateUserAgent());
  }

  async updateRequestInterception() {
    await this._forAllFrameSessions(frame => frame._updateRequestInterception());
  }

  async updateFileChooserInterception() {
    await this._forAllFrameSessions(frame => frame._updateFileChooserInterception(false));
  }

  async reload() {
    await this._mainFrameSession._client.send('Page.reload');
  }

  async _go(delta) {
    const history = await this._mainFrameSession._client.send('Page.getNavigationHistory');
    const entry = history.entries[history.currentIndex + delta];
    if (!entry) return false;
    await this._mainFrameSession._client.send('Page.navigateToHistoryEntry', {
      entryId: entry.id
    });
    return true;
  }

  goBack() {
    return this._go(-1);
  }

  goForward() {
    return this._go(+1);
  }

  async addInitScript(source, world = 'main') {
    await this._forAllFrameSessions(frame => frame._evaluateOnNewDocument(source, world));
  }

  async removeInitScripts() {
    await this._forAllFrameSessions(frame => frame._removeEvaluatesOnNewDocument());
  }

  async closePage(runBeforeUnload) {
    if (runBeforeUnload) await this._mainFrameSession._client.send('Page.close');else await this._browserContext._browser._closePage(this);
  }

  async setBackgroundColor(color) {
    await this._mainFrameSession._client.send('Emulation.setDefaultBackgroundColorOverride', {
      color
    });
  }

  async takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {
    const {
      visualViewport
    } = await this._mainFrameSession._client.send('Page.getLayoutMetrics');

    if (!documentRect) {
      documentRect = {
        x: visualViewport.pageX + viewportRect.x,
        y: visualViewport.pageY + viewportRect.y,
        ..._helper.helper.enclosingIntSize({
          width: viewportRect.width / visualViewport.scale,
          height: viewportRect.height / visualViewport.scale
        })
      };
    } // When taking screenshots with documentRect (based on the page content, not viewport),
    // ignore current page scale.


    const clip = { ...documentRect,
      scale: viewportRect ? visualViewport.scale : 1
    };

    if (scale === 'css') {
      const deviceScaleFactor = this._browserContext._options.deviceScaleFactor || 1;
      clip.scale /= deviceScaleFactor;
    }

    progress.throwIfAborted();
    const result = await this._mainFrameSession._client.send('Page.captureScreenshot', {
      format,
      quality,
      clip,
      captureBeyondViewport: !fitsViewport
    });
    return Buffer.from(result.data, 'base64');
  }

  async getContentFrame(handle) {
    return this._sessionForHandle(handle)._getContentFrame(handle);
  }

  async getOwnerFrame(handle) {
    return this._sessionForHandle(handle)._getOwnerFrame(handle);
  }

  isElementHandle(remoteObject) {
    return remoteObject.subtype === 'node';
  }

  async getBoundingBox(handle) {
    return this._sessionForHandle(handle)._getBoundingBox(handle);
  }

  async scrollRectIntoViewIfNeeded(handle, rect) {
    return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
  }

  async setScreencastOptions(options) {
    if (options) {
      await this._mainFrameSession._startScreencast(this, {
        format: 'jpeg',
        quality: options.quality,
        maxWidth: options.width,
        maxHeight: options.height
      });
    } else {
      await this._mainFrameSession._stopScreencast(this);
    }
  }

  rafCountForStablePosition() {
    return 1;
  }

  async getContentQuads(handle) {
    return this._sessionForHandle(handle)._getContentQuads(handle);
  }

  async setInputFiles(handle, files) {
    await handle.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), files);
  }

  async setInputFilePaths(handle, files) {
    const frame = await handle.ownerFrame();
    if (!frame) throw new Error('Cannot set input files to detached input element');

    const parentSession = this._sessionForFrame(frame);

    await parentSession._client.send('DOM.setFileInputFiles', {
      objectId: handle._objectId,
      files
    });
  }

  async adoptElementHandle(handle, to) {
    return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
  }

  async getAccessibilityTree(needle) {
    return (0, _crAccessibility.getAccessibilityTree)(this._mainFrameSession._client, needle);
  }

  async inputActionEpilogue() {
    await this._mainFrameSession._client.send('Page.enable').catch(e => {});
  }

  async pdf(options) {
    return this._pdf.generate(options);
  }

  coverage() {
    return this._coverage;
  }

  async getFrameElement(frame) {
    let parent = frame.parentFrame();
    if (!parent) throw new Error('Frame has been detached.');

    const parentSession = this._sessionForFrame(parent);

    const {
      backendNodeId
    } = await parentSession._client.send('DOM.getFrameOwner', {
      frameId: frame._id
    }).catch(e => {
      if (e instanceof Error && e.message.includes('Frame with the given id was not found.')) (0, _stackTrace.rewriteErrorMessage)(e, 'Frame has been detached.');
      throw e;
    });
    parent = frame.parentFrame();
    if (!parent) throw new Error('Frame has been detached.');
    return parentSession._adoptBackendNodeId(backendNodeId, await parent._mainContext());
  }

}

exports.CRPage = CRPage;

class FrameSession {
  // Marks the oopif session that remote -> local transition has happened in the parent.
  // See Target.detachedFromTarget handler for details.
  constructor(crPage, client, targetId, parentSession) {
    this._client = void 0;
    this._crPage = void 0;
    this._page = void 0;
    this._networkManager = void 0;
    this._parentSession = void 0;
    this._childSessions = new Set();
    this._contextIdToContext = new Map();
    this._eventListeners = [];
    this._targetId = void 0;
    this._firstNonInitialNavigationCommittedPromise = void 0;

    this._firstNonInitialNavigationCommittedFulfill = () => {};

    this._firstNonInitialNavigationCommittedReject = e => {};

    this._windowId = void 0;
    this._swappedIn = false;
    this._videoRecorder = null;
    this._screencastId = null;
    this._screencastClients = new Set();
    this._evaluateOnNewDocumentIdentifiers = [];
    this._exposedBindingNames = [];
    this._metricsOverride = void 0;
    this._client = client;
    this._crPage = crPage;
    this._page = crPage._page;
    this._targetId = targetId;
    this._networkManager = new _crNetworkManager.CRNetworkManager(client, this._page, null, parentSession ? parentSession._networkManager : null);
    this._parentSession = parentSession;
    if (parentSession) parentSession._childSessions.add(this);
    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
      this._firstNonInitialNavigationCommittedFulfill = f;
      this._firstNonInitialNavigationCommittedReject = r;
    });
    client.once(_crConnection.CRSessionEvents.Disconnected, () => {
      this._firstNonInitialNavigationCommittedReject(new Error('Page closed'));
    });
  }

  _isMainFrame() {
    return this._targetId === this._crPage._targetId;
  }

  _addRendererListeners() {
    this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, 'Log.entryAdded', event => this._onLogEntryAdded(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameDetached', event => this._onFrameDetached(event.frameId, event.reason)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameRequestedNavigation', event => this._onFrameRequestedNavigation(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.javascriptDialogOpening', event => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.bindingCalled', event => this._onBindingCalled(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.consoleAPICalled', event => this._onConsoleAPI(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.exceptionThrown', exception => this._handleException(exception.exceptionDetails)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextDestroyed', event => this._onExecutionContextDestroyed(event.executionContextId)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Runtime.executionContextsCleared', event => this._onExecutionContextsCleared()), _eventsHelper.eventsHelper.addEventListener(this._client, 'Target.attachedToTarget', event => this._onAttachedToTarget(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Target.detachedFromTarget', event => this._onDetachedFromTarget(event))]);
  }

  _addBrowserListeners() {
    this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, 'Inspector.targetCrashed', event => this._onTargetCrashed()), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.screencastFrame', event => this._onScreencastFrame(event)), _eventsHelper.eventsHelper.addEventListener(this._client, 'Page.windowOpen', event => this._onWindowOpen(event))]);
  }

  async _initialize(hasUIWindow) {
    const isSettingStorageState = this._page._browserContext.isSettingStorageState();

    if (!isSettingStorageState && hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
      const {
        windowId
      } = await this._client.send('Browser.getWindowForTarget');
      this._windowId = windowId;
    }

    let screencastOptions;

    if (!isSettingStorageState && this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
      const screencastId = (0, _utils.createGuid)();

      const outputFile = _path.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + '.webm');

      screencastOptions = { // validateBrowserContextOptions ensures correct video size.
        ...this._crPage._browserContext._options.recordVideo.size,
        outputFile
      };
      await this._crPage._browserContext._ensureVideosPath(); // Note: it is important to start video recorder before sending Page.startScreencast,
      // and it is equally important to send Page.startScreencast before sending Runtime.runIfWaitingForDebugger.

      await this._createVideoRecorder(screencastId, screencastOptions);

      this._crPage.pageOrError().then(p => {
        if (p instanceof Error) this._stopVideoRecording().catch(() => {});
      });
    }

    let lifecycleEventsEnabled;
    if (!this._isMainFrame()) this._addRendererListeners();

    this._addBrowserListeners();

    const promises = [this._client.send('Page.enable'), this._client.send('Page.getFrameTree').then(({
      frameTree
    }) => {
      if (this._isMainFrame()) {
        this._handleFrameTree(frameTree);

        this._addRendererListeners();
      }

      const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];

      for (const frame of localFrames) {
        // Note: frames might be removed before we send these.
        this._client._sendMayFail('Page.createIsolatedWorld', {
          frameId: frame._id,
          grantUniveralAccess: true,
          worldName: UTILITY_WORLD_NAME
        });

        for (const binding of this._crPage._browserContext._pageBindings.values()) frame.evaluateExpression(binding.source, false, undefined).catch(e => {});

        for (const source of this._crPage._browserContext.initScripts) frame.evaluateExpression(source, false, undefined, 'main').catch(e => {});
      }

      const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ':';

      if (isInitialEmptyPage) {
        // Ignore lifecycle events for the initial empty page. It is never the final page
        // hence we are going to get more lifecycle updates after the actual navigation has
        // started (even if the target url is about:blank).
        lifecycleEventsEnabled.catch(e => {}).then(() => {
          this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
        });
      } else {
        this._firstNonInitialNavigationCommittedFulfill();

        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, 'Page.lifecycleEvent', event => this._onLifecycleEvent(event)));
      }
    }), this._client.send('Log.enable', {}), lifecycleEventsEnabled = this._client.send('Page.setLifecycleEventsEnabled', {
      enabled: true
    }), this._client.send('Runtime.enable', {}), this._client.send('Page.addScriptToEvaluateOnNewDocument', {
      source: '',
      worldName: UTILITY_WORLD_NAME
    }), this._networkManager.initialize(), this._client.send('Target.setAutoAttach', {
      autoAttach: true,
      waitForDebuggerOnStart: true,
      flatten: true
    })];

    if (!isSettingStorageState) {
      if (this._isMainFrame()) promises.push(this._client.send('Emulation.setFocusEmulationEnabled', {
        enabled: true
      }));
      const options = this._crPage._browserContext._options;
      if (options.bypassCSP) promises.push(this._client.send('Page.setBypassCSP', {
        enabled: true
      }));
      if (options.ignoreHTTPSErrors) promises.push(this._client.send('Security.setIgnoreCertificateErrors', {
        ignore: true
      }));
      if (this._isMainFrame()) promises.push(this._updateViewport());
      if (options.hasTouch) promises.push(this._client.send('Emulation.setTouchEmulationEnabled', {
        enabled: true
      }));
      if (options.javaScriptEnabled === false) promises.push(this._client.send('Emulation.setScriptExecutionDisabled', {
        value: true
      }));
      if (options.userAgent || options.locale) promises.push(this._updateUserAgent());
      if (options.locale) promises.push(emulateLocale(this._client, options.locale));
      if (options.timezoneId) promises.push(emulateTimezone(this._client, options.timezoneId));
      if (!this._crPage._browserContext._browser.options.headful) promises.push(this._setDefaultFontFamilies(this._client));
      promises.push(this._updateGeolocation(true));
      promises.push(this._updateExtraHTTPHeaders(true));
      promises.push(this._updateRequestInterception());
      promises.push(this._updateOffline(true));
      promises.push(this._updateHttpCredentials(true));
      promises.push(this._updateEmulateMedia());
      promises.push(this._updateFileChooserInterception(true));

      for (const binding of this._crPage._page.allBindings()) promises.push(this._initBinding(binding));

      for (const source of this._crPage._browserContext.initScripts) promises.push(this._evaluateOnNewDocument(source, 'main'));

      for (const source of this._crPage._page.initScripts) promises.push(this._evaluateOnNewDocument(source, 'main'));

      if (screencastOptions) promises.push(this._startVideoRecording(screencastOptions));
    }

    promises.push(this._client.send('Runtime.runIfWaitingForDebugger'));
    promises.push(this._firstNonInitialNavigationCommittedPromise);
    await Promise.all(promises);
  }

  dispose() {
    for (const childSession of this._childSessions) childSession.dispose();

    if (this._parentSession) this._parentSession._childSessions.delete(this);

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);

    this._networkManager.dispose();

    this._crPage._sessions.delete(this._targetId);
  }

  async _navigate(frame, url, referrer) {
    const response = await this._client.send('Page.navigate', {
      url,
      referrer,
      frameId: frame._id
    });
    if (response.errorText) throw new frames.NavigationAbortedError(response.loaderId, `${response.errorText} at ${url}`);
    return {
      newDocumentId: response.loaderId
    };
  }

  _onLifecycleEvent(event) {
    if (this._eventBelongsToStaleFrame(event.frameId)) return;
    if (event.name === 'load') this._page._frameManager.frameLifecycleEvent(event.frameId, 'load');else if (event.name === 'DOMContentLoaded') this._page._frameManager.frameLifecycleEvent(event.frameId, 'domcontentloaded');
  }

  _onFrameStoppedLoading(frameId) {
    if (this._eventBelongsToStaleFrame(frameId)) return;

    this._page._frameManager.frameStoppedLoading(frameId);
  }

  _handleFrameTree(frameTree) {
    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);

    this._onFrameNavigated(frameTree.frame, true);

    if (!frameTree.childFrames) return;

    for (const child of frameTree.childFrames) this._handleFrameTree(child);
  }

  _eventBelongsToStaleFrame(frameId) {
    const frame = this._page._frameManager.frame(frameId); // Subtree may be already gone because some ancestor navigation destroyed the oopif.


    if (!frame) return true; // When frame goes remote, parent process may still send some events
    // related to the local frame before it sends frameDetached.
    // In this case, we already have a new session for this frame, so events
    // in the old session should be ignored.

    const session = this._crPage._sessionForFrame(frame);

    return session && session !== this && !session._swappedIn;
  }

  _onFrameAttached(frameId, parentFrameId) {
    const frameSession = this._crPage._sessions.get(frameId);

    if (frameSession && frameId !== this._targetId) {
      // This is a remote -> local frame transition.
      frameSession._swappedIn = true;

      const frame = this._page._frameManager.frame(frameId); // Frame or even a whole subtree may be already gone, because some ancestor did navigate.


      if (frame) this._page._frameManager.removeChildFramesRecursively(frame);
      return;
    }

    if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
      // Parent frame may be gone already because some ancestor frame navigated and
      // destroyed the whole subtree of some oopif, while oopif's process is still sending us events.
      // Be careful to not confuse this with "main frame navigated cross-process" scenario
      // where parentFrameId is null.
      return;
    }

    this._page._frameManager.frameAttached(frameId, parentFrameId);
  }

  _onFrameNavigated(framePayload, initial) {
    if (this._eventBelongsToStaleFrame(framePayload.id)) return;

    this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ''), framePayload.name || '', framePayload.loaderId, initial);

    if (!initial) this._firstNonInitialNavigationCommittedFulfill();
  }

  _onFrameRequestedNavigation(payload) {
    if (this._eventBelongsToStaleFrame(payload.frameId)) return;
    if (payload.disposition === 'currentTab') this._page._frameManager.frameRequestedNavigation(payload.frameId);
  }

  _onFrameNavigatedWithinDocument(frameId, url) {
    if (this._eventBelongsToStaleFrame(frameId)) return;

    this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
  }

  _onFrameDetached(frameId, reason) {
    if (this._crPage._sessions.has(frameId)) {
      // This is a local -> remote frame transtion, where
      // Page.frameDetached arrives after Target.attachedToTarget.
      // We've already handled the new target and frame reattach - nothing to do here.
      return;
    }

    if (reason === 'swap') {
      // This is a local -> remote frame transtion, where
      // Page.frameDetached arrives before Target.attachedToTarget.
      // We should keep the frame in the tree, and it will be used for the new target.
      const frame = this._page._frameManager.frame(frameId);

      if (frame) this._page._frameManager.removeChildFramesRecursively(frame);
      return;
    } // Just a regular frame detach.


    this._page._frameManager.frameDetached(frameId);
  }

  _onExecutionContextCreated(contextPayload) {
    const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
    if (!frame || this._eventBelongsToStaleFrame(frame._id)) return;
    const delegate = new _crExecutionContext.CRExecutionContext(this._client, contextPayload);
    let worldName = null;
    if (contextPayload.auxData && !!contextPayload.auxData.isDefault) worldName = 'main';else if (contextPayload.name === UTILITY_WORLD_NAME) worldName = 'utility';
    const context = new dom.FrameExecutionContext(delegate, frame, worldName);
    context[contextDelegateSymbol] = delegate;
    if (worldName) frame._contextCreated(worldName, context);

    this._contextIdToContext.set(contextPayload.id, context);
  }

  _onExecutionContextDestroyed(executionContextId) {
    const context = this._contextIdToContext.get(executionContextId);

    if (!context) return;

    this._contextIdToContext.delete(executionContextId);

    context.frame._contextDestroyed(context);
  }

  _onExecutionContextsCleared() {
    for (const contextId of Array.from(this._contextIdToContext.keys())) this._onExecutionContextDestroyed(contextId);
  }

  _onAttachedToTarget(event) {
    const session = _crConnection.CRConnection.fromSession(this._client).session(event.sessionId);

    if (event.targetInfo.type === 'iframe') {
      // Frame id equals target id.
      const targetId = event.targetInfo.targetId;

      const frame = this._page._frameManager.frame(targetId);

      if (!frame) return; // Subtree may be already gone due to renderer/browser race.

      this._page._frameManager.removeChildFramesRecursively(frame);

      const frameSession = new FrameSession(this._crPage, session, targetId, this);

      this._crPage._sessions.set(targetId, frameSession);

      frameSession._initialize(false).catch(e => e);

      return;
    }

    if (event.targetInfo.type !== 'worker') {
      // Ideally, detaching should resume any target, but there is a bug in the backend.
      session._sendMayFail('Runtime.runIfWaitingForDebugger').then(() => {
        this._client._sendMayFail('Target.detachFromTarget', {
          sessionId: event.sessionId
        });
      });

      return;
    }

    const url = event.targetInfo.url;
    const worker = new _page.Worker(this._page, url);

    this._page._addWorker(event.sessionId, worker);

    session.once('Runtime.executionContextCreated', async event => {
      worker._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));
    }); // This might fail if the target is closed before we initialize.

    session._sendMayFail('Runtime.enable');

    session._sendMayFail('Network.enable');

    session._sendMayFail('Runtime.runIfWaitingForDebugger');

    session.on('Runtime.consoleAPICalled', event => {
      const args = event.args.map(o => worker._existingExecutionContext.createHandle(o));

      this._page._addConsoleMessage(event.type, args, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));
    });
    session.on('Runtime.exceptionThrown', exception => this._page.emit(_page.Page.Events.PageError, (0, _crProtocolHelper.exceptionToError)(exception.exceptionDetails))); // TODO: attribute workers to the right frame.

    this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));
  }

  _onDetachedFromTarget(event) {
    // This might be a worker...
    this._page._removeWorker(event.sessionId); // ... or an oopif.


    const childFrameSession = this._crPage._sessions.get(event.targetId);

    if (!childFrameSession) return; // Usually, we get frameAttached in this session first and mark child as swappedIn.

    if (childFrameSession._swappedIn) {
      childFrameSession.dispose();
      return;
    } // However, sometimes we get detachedFromTarget before frameAttached.
    // In this case we don't know wheter this is a remote frame detach,
    // or just a remote -> local transition. In the latter case, frameAttached
    // is already inflight, so let's make a safe roundtrip to ensure it arrives.


    this._client.send('Page.enable').catch(e => null).then(() => {
      // Child was not swapped in - that means frameAttached did not happen and
      // this is remote detach rather than remote -> local swap.
      if (!childFrameSession._swappedIn) this._page._frameManager.frameDetached(event.targetId);
      childFrameSession.dispose();
    });
  }

  _onWindowOpen(event) {
    this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
  }

  async _onConsoleAPI(event) {
    if (event.executionContextId === 0) {
      // DevTools protocol stores the last 1000 console messages. These
      // messages are always reported even for removed execution contexts. In
      // this case, they are marked with executionContextId = 0 and are
      // reported upon enabling Runtime agent.
      //
      // Ignore these messages since:
      // - there's no execution context we can use to operate with message
      //   arguments
      // - these messages are reported before Playwright clients can subscribe
      //   to the 'console'
      //   page event.
      //
      // @see https://github.com/GoogleChrome/puppeteer/issues/3865
      return;
    }

    const context = this._contextIdToContext.get(event.executionContextId);

    if (!context) return;
    const values = event.args.map(arg => context.createHandle(arg));

    this._page._addConsoleMessage(event.type, values, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));
  }

  async _initBinding(binding) {
    const [, response] = await Promise.all([this._client.send('Runtime.addBinding', {
      name: binding.name
    }), this._client.send('Page.addScriptToEvaluateOnNewDocument', {
      source: binding.source
    })]);

    this._exposedBindingNames.push(binding.name);

    if (!binding.name.startsWith('__pw')) this._evaluateOnNewDocumentIdentifiers.push(response.identifier);
  }

  async _removeExposedBindings() {
    const toRetain = [];
    const toRemove = [];

    for (const name of this._exposedBindingNames) (name.startsWith('__pw_') ? toRetain : toRemove).push(name);

    this._exposedBindingNames = toRetain;
    await Promise.all(toRemove.map(name => this._client.send('Runtime.removeBinding', {
      name
    })));
  }

  async _onBindingCalled(event) {
    const pageOrError = await this._crPage.pageOrError();

    if (!(pageOrError instanceof Error)) {
      const context = this._contextIdToContext.get(event.executionContextId);

      if (context) await this._page._onBindingCalled(event.payload, context);
    }
  }

  _onDialog(event) {
    if (!this._page._frameManager.frame(this._targetId)) return; // Our frame/subtree may be gone already.

    this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
      await this._client.send('Page.handleJavaScriptDialog', {
        accept,
        promptText
      });
    }, event.defaultPrompt));
  }

  _handleException(exceptionDetails) {
    this._page.firePageError((0, _crProtocolHelper.exceptionToError)(exceptionDetails));
  }

  async _onTargetCrashed() {
    this._client._markAsCrashed();

    this._page._didCrash();
  }

  _onLogEntryAdded(event) {
    const {
      level,
      text,
      args,
      source,
      url,
      lineNumber
    } = event.entry;
    if (args) args.map(arg => (0, _crProtocolHelper.releaseObject)(this._client, arg.objectId));

    if (source !== 'worker') {
      const location = {
        url: url || '',
        lineNumber: lineNumber || 0,
        columnNumber: 0
      };

      this._page._addConsoleMessage(level, [], location, text);
    }
  }

  async _onFileChooserOpened(event) {
    if (!event.backendNodeId) return;

    const frame = this._page._frameManager.frame(event.frameId);

    if (!frame) return;
    let handle;

    try {
      const utilityContext = await frame._utilityContext();
      handle = await this._adoptBackendNodeId(event.backendNodeId, utilityContext);
    } catch (e) {
      // During async processing, frame/context may go away. We should not throw.
      return;
    }

    await this._page._onFileChooserOpened(handle);
  }

  _willBeginDownload() {
    const originPage = this._crPage._initializedPage;

    if (!originPage) {
      // Resume the page creation with an error. The page will automatically close right
      // after the download begins.
      this._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));
    }
  }

  _onScreencastFrame(payload) {
    this._page.throttleScreencastFrameAck(() => {
      this._client.send('Page.screencastFrameAck', {
        sessionId: payload.sessionId
      }).catch(() => {});
    });

    const buffer = Buffer.from(payload.data, 'base64');

    this._page.emit(_page.Page.Events.ScreencastFrame, {
      buffer,
      timestamp: payload.metadata.timestamp,
      width: payload.metadata.deviceWidth,
      height: payload.metadata.deviceHeight
    });
  }

  async _createVideoRecorder(screencastId, options) {
    (0, _utils.assert)(!this._screencastId);

    const ffmpegPath = _registry.registry.findExecutable('ffmpeg').executablePathOrDie(this._page._browserContext._browser.options.sdkLanguage);

    this._videoRecorder = await _videoRecorder.VideoRecorder.launch(this._crPage._page, ffmpegPath, options);
    this._screencastId = screencastId;
  }

  async _startVideoRecording(options) {
    const screencastId = this._screencastId;
    (0, _utils.assert)(screencastId);

    this._page.once(_page.Page.Events.Close, () => this._stopVideoRecording().catch(() => {}));

    const gotFirstFrame = new Promise(f => this._client.once('Page.screencastFrame', f));
    await this._startScreencast(this._videoRecorder, {
      format: 'jpeg',
      quality: 90,
      maxWidth: options.width,
      maxHeight: options.height
    }); // Wait for the first frame before reporting video to the client.

    gotFirstFrame.then(() => {
      this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options.outputFile, this._crPage.pageOrError());
    });
  }

  async _stopVideoRecording() {
    if (!this._screencastId) return;
    const screencastId = this._screencastId;
    this._screencastId = null;
    const recorder = this._videoRecorder;
    this._videoRecorder = null;
    await this._stopScreencast(recorder);
    await recorder.stop().catch(() => {}); // Keep the video artifact in the map utntil encoding is fully finished, if the context
    // starts closing before the video is fully written to disk it will wait for it.

    const video = this._crPage._browserContext._browser._takeVideo(screencastId);

    video === null || video === void 0 ? void 0 : video.reportFinished();
  }

  async _startScreencast(client, options = {}) {
    this._screencastClients.add(client);

    if (this._screencastClients.size === 1) await this._client.send('Page.startScreencast', options);
  }

  async _stopScreencast(client) {
    this._screencastClients.delete(client);

    if (!this._screencastClients.size) await this._client._sendMayFail('Page.stopScreencast');
  }

  async _updateExtraHTTPHeaders(initial) {
    const headers = network.mergeHeaders([this._crPage._browserContext._options.extraHTTPHeaders, this._page.extraHTTPHeaders()]);
    if (!initial || headers.length) await this._client.send('Network.setExtraHTTPHeaders', {
      headers: (0, _utils.headersArrayToObject)(headers, false
      /* lowerCase */
      )
    });
  }

  async _updateGeolocation(initial) {
    const geolocation = this._crPage._browserContext._options.geolocation;
    if (!initial || geolocation) await this._client.send('Emulation.setGeolocationOverride', geolocation || {});
  }

  async _updateOffline(initial) {
    const offline = !!this._crPage._browserContext._options.offline;
    if (!initial || offline) await this._networkManager.setOffline(offline);
  }

  async _updateHttpCredentials(initial) {
    const credentials = this._crPage._browserContext._options.httpCredentials || null;
    if (!initial || credentials) await this._networkManager.authenticate(credentials);
  }

  async _updateViewport(preserveWindowBoundaries) {
    if (this._crPage._browserContext._browser.isClank()) return;
    (0, _utils.assert)(this._isMainFrame());
    const options = this._crPage._browserContext._options;

    const emulatedSize = this._page.emulatedSize();

    if (emulatedSize === null) return;
    const viewportSize = emulatedSize.viewport;
    const screenSize = emulatedSize.screen;
    const isLandscape = viewportSize.width > viewportSize.height;
    const metricsOverride = {
      mobile: !!options.isMobile,
      width: viewportSize.width,
      height: viewportSize.height,
      screenWidth: screenSize.width,
      screenHeight: screenSize.height,
      deviceScaleFactor: options.deviceScaleFactor || 1,
      screenOrientation: isLandscape ? {
        angle: 90,
        type: 'landscapePrimary'
      } : {
        angle: 0,
        type: 'portraitPrimary'
      },
      dontSetVisibleSize: preserveWindowBoundaries
    };
    if (JSON.stringify(this._metricsOverride) === JSON.stringify(metricsOverride)) return;
    const promises = [this._client.send('Emulation.setDeviceMetricsOverride', metricsOverride)];

    if (!preserveWindowBoundaries && this._windowId) {
      let insets = {
        width: 0,
        height: 0
      };

      if (this._crPage._browserContext._browser.options.headful) {
        // TODO: popup windows have their own insets.
        insets = {
          width: 24,
          height: 88
        };
        if (process.platform === 'win32') insets = {
          width: 16,
          height: 88
        };else if (process.platform === 'linux') insets = {
          width: 8,
          height: 85
        };else if (process.platform === 'darwin') insets = {
          width: 2,
          height: 80
        };

        if (this._crPage._browserContext.isPersistentContext()) {
          // FIXME: Chrome bug: OOPIF router is confused when hit target is
          // outside browser window.
          // Account for the infobar here to work around the bug.
          insets.height += 46;
        }
      }

      promises.push(this.setWindowBounds({
        width: viewportSize.width + insets.width,
        height: viewportSize.height + insets.height
      }));
    }

    await Promise.all(promises);
    this._metricsOverride = metricsOverride;
  }

  async windowBounds() {
    const {
      bounds
    } = await this._client.send('Browser.getWindowBounds', {
      windowId: this._windowId
    });
    return bounds;
  }

  async setWindowBounds(bounds) {
    return await this._client.send('Browser.setWindowBounds', {
      windowId: this._windowId,
      bounds
    });
  }

  async _updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();

    const colorScheme = emulatedMedia.colorScheme === null ? '' : emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion === null ? '' : emulatedMedia.reducedMotion;
    const forcedColors = emulatedMedia.forcedColors === null ? '' : emulatedMedia.forcedColors;
    const features = [{
      name: 'prefers-color-scheme',
      value: colorScheme
    }, {
      name: 'prefers-reduced-motion',
      value: reducedMotion
    }, {
      name: 'forced-colors',
      value: forcedColors
    }]; // Empty string disables the override.

    await this._client.send('Emulation.setEmulatedMedia', {
      media: emulatedMedia.media || '',
      features
    });
  }

  async _updateUserAgent() {
    const options = this._crPage._browserContext._options;
    await this._client.send('Emulation.setUserAgentOverride', {
      userAgent: options.userAgent || '',
      acceptLanguage: options.locale
    });
  }

  async _setDefaultFontFamilies(session) {
    const fontFamilies = _defaultFontFamilies.platformToFontFamilies[this._crPage._browserContext._browser._platform()];

    await session.send('Page.setFontFamilies', fontFamilies);
  }

  async _updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }

  async _updateFileChooserInterception(initial) {
    const enabled = this._page.fileChooserIntercepted();

    if (initial && !enabled) return;
    await this._client.send('Page.setInterceptFileChooserDialog', {
      enabled
    }).catch(() => {}); // target can be closed.
  }

  async _evaluateOnNewDocument(source, world) {
    const worldName = world === 'utility' ? UTILITY_WORLD_NAME : undefined;
    const {
      identifier
    } = await this._client.send('Page.addScriptToEvaluateOnNewDocument', {
      source,
      worldName
    });

    this._evaluateOnNewDocumentIdentifiers.push(identifier);
  }

  async _removeEvaluatesOnNewDocument() {
    const identifiers = this._evaluateOnNewDocumentIdentifiers;
    this._evaluateOnNewDocumentIdentifiers = [];
    await Promise.all(identifiers.map(identifier => this._client.send('Page.removeScriptToEvaluateOnNewDocument', {
      identifier
    })));
  }

  async _getContentFrame(handle) {
    const nodeInfo = await this._client.send('DOM.describeNode', {
      objectId: handle._objectId
    });
    if (!nodeInfo || typeof nodeInfo.node.frameId !== 'string') return null;
    return this._page._frameManager.frame(nodeInfo.node.frameId);
  }

  async _getOwnerFrame(handle) {
    // document.documentElement has frameId of the owner frame.
    const documentElement = await handle.evaluateHandle(node => {
      const doc = node;
      if (doc.documentElement && doc.documentElement.ownerDocument === doc) return doc.documentElement;
      return node.ownerDocument ? node.ownerDocument.documentElement : null;
    });
    if (!documentElement) return null;
    if (!documentElement._objectId) return null;
    const nodeInfo = await this._client.send('DOM.describeNode', {
      objectId: documentElement._objectId
    });
    const frameId = nodeInfo && typeof nodeInfo.node.frameId === 'string' ? nodeInfo.node.frameId : null;
    documentElement.dispose();
    return frameId;
  }

  async _getBoundingBox(handle) {
    const result = await this._client._sendMayFail('DOM.getBoxModel', {
      objectId: handle._objectId
    });
    if (!result) return null;
    const quad = result.model.border;
    const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
    const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
    const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
    const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
    const position = await this._framePosition();
    if (!position) return null;
    return {
      x: x + position.x,
      y: y + position.y,
      width,
      height
    };
  }

  async _framePosition() {
    const frame = this._page._frameManager.frame(this._targetId);

    if (!frame) return null;
    if (frame === this._page.mainFrame()) return {
      x: 0,
      y: 0
    };
    const element = await frame.frameElement();
    const box = await element.boundingBox();
    return box;
  }

  async _scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._client.send('DOM.scrollIntoViewIfNeeded', {
      objectId: handle._objectId,
      rect
    }).then(() => 'done').catch(e => {
      if (e instanceof Error && e.message.includes('Node does not have a layout object')) return 'error:notvisible';
      if (e instanceof Error && e.message.includes('Node is detached from document')) return 'error:notconnected';
      throw e;
    });
  }

  async _getContentQuads(handle) {
    const result = await this._client._sendMayFail('DOM.getContentQuads', {
      objectId: handle._objectId
    });
    if (!result) return null;
    const position = await this._framePosition();
    if (!position) return null;
    return result.quads.map(quad => [{
      x: quad[0] + position.x,
      y: quad[1] + position.y
    }, {
      x: quad[2] + position.x,
      y: quad[3] + position.y
    }, {
      x: quad[4] + position.x,
      y: quad[5] + position.y
    }, {
      x: quad[6] + position.x,
      y: quad[7] + position.y
    }]);
  }

  async _adoptElementHandle(handle, to) {
    const nodeInfo = await this._client.send('DOM.describeNode', {
      objectId: handle._objectId
    });
    return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
  }

  async _adoptBackendNodeId(backendNodeId, to) {
    const result = await this._client._sendMayFail('DOM.resolveNode', {
      backendNodeId,
      executionContextId: to[contextDelegateSymbol]._contextId
    });
    if (!result || result.object.subtype === 'null') throw new Error(dom.kUnableToAdoptErrorMessage);
    return to.createHandle(result.object).asElement();
  }

}

async function emulateLocale(session, locale) {
  try {
    await session.send('Emulation.setLocaleOverride', {
      locale
    });
  } catch (exception) {
    // All pages in the same renderer share locale. All such pages belong to the same
    // context and if locale is overridden for one of them its value is the same as
    // we are trying to set so it's not a problem.
    if (exception.message.includes('Another locale override is already in effect')) return;
    throw exception;
  }
}

async function emulateTimezone(session, timezoneId) {
  try {
    await session.send('Emulation.setTimezoneOverride', {
      timezoneId: timezoneId
    });
  } catch (exception) {
    if (exception.message.includes('Timezone override is already in effect')) return;
    if (exception.message.includes('Invalid timezone')) throw new Error(`Invalid timezone ID: ${timezoneId}`);
    throw exception;
  }
}

const contextDelegateSymbol = Symbol('delegate');

/***/ }),

/***/ 2206:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRPDF = void 0;

var _utils = __nccwpck_require__(3557);

var _crProtocolHelper = __nccwpck_require__(911);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PagePaperFormats = {
  letter: {
    width: 8.5,
    height: 11
  },
  legal: {
    width: 8.5,
    height: 14
  },
  tabloid: {
    width: 11,
    height: 17
  },
  ledger: {
    width: 17,
    height: 11
  },
  a0: {
    width: 33.1,
    height: 46.8
  },
  a1: {
    width: 23.4,
    height: 33.1
  },
  a2: {
    width: 16.54,
    height: 23.4
  },
  a3: {
    width: 11.7,
    height: 16.54
  },
  a4: {
    width: 8.27,
    height: 11.7
  },
  a5: {
    width: 5.83,
    height: 8.27
  },
  a6: {
    width: 4.13,
    height: 5.83
  }
};
const unitToPixels = {
  'px': 1,
  'in': 96,
  'cm': 37.8,
  'mm': 3.78
};

function convertPrintParameterToInches(text) {
  if (text === undefined) return undefined;
  let unit = text.substring(text.length - 2).toLowerCase();
  let valueText = '';

  if (unitToPixels.hasOwnProperty(unit)) {
    valueText = text.substring(0, text.length - 2);
  } else {
    // In case of unknown unit try to parse the whole parameter as number of pixels.
    // This is consistent with phantom's paperSize behavior.
    unit = 'px';
    valueText = text;
  }

  const value = Number(valueText);
  (0, _utils.assert)(!isNaN(value), 'Failed to parse parameter value: ' + text);
  const pixels = value * unitToPixels[unit];
  return pixels / 96;
}

class CRPDF {
  constructor(client) {
    this._client = void 0;
    this._client = client;
  }

  async generate(options) {
    const {
      scale = 1,
      displayHeaderFooter = false,
      headerTemplate = '',
      footerTemplate = '',
      printBackground = false,
      landscape = false,
      pageRanges = '',
      preferCSSPageSize = false,
      margin = {}
    } = options;
    let paperWidth = 8.5;
    let paperHeight = 11;

    if (options.format) {
      const format = PagePaperFormats[options.format.toLowerCase()];
      (0, _utils.assert)(format, 'Unknown paper format: ' + options.format);
      paperWidth = format.width;
      paperHeight = format.height;
    } else {
      paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
      paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
    }

    const marginTop = convertPrintParameterToInches(margin.top) || 0;
    const marginLeft = convertPrintParameterToInches(margin.left) || 0;
    const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
    const marginRight = convertPrintParameterToInches(margin.right) || 0;
    const result = await this._client.send('Page.printToPDF', {
      transferMode: 'ReturnAsStream',
      landscape,
      displayHeaderFooter,
      headerTemplate,
      footerTemplate,
      printBackground,
      scale,
      paperWidth,
      paperHeight,
      marginTop,
      marginBottom,
      marginLeft,
      marginRight,
      pageRanges,
      preferCSSPageSize
    });
    return await (0, _crProtocolHelper.readProtocolStream)(this._client, result.stream, null);
  }

}

exports.CRPDF = CRPDF;

/***/ }),

/***/ 911:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.exceptionToError = exceptionToError;
exports.getExceptionMessage = getExceptionMessage;
exports.readProtocolStream = readProtocolStream;
exports.releaseObject = releaseObject;
exports.toButtonsMask = toButtonsMask;
exports.toConsoleMessageLocation = toConsoleMessageLocation;
exports.toModifiersMask = toModifiersMask;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _fileUtils = __nccwpck_require__(6034);

var _stackTrace = __nccwpck_require__(9030);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getExceptionMessage(exceptionDetails) {
  if (exceptionDetails.exception) return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
  let message = exceptionDetails.text;

  if (exceptionDetails.stackTrace) {
    for (const callframe of exceptionDetails.stackTrace.callFrames) {
      const location = callframe.url + ':' + callframe.lineNumber + ':' + callframe.columnNumber;
      const functionName = callframe.functionName || '<anonymous>';
      message += `\n    at ${functionName} (${location})`;
    }
  }

  return message;
}

async function releaseObject(client, objectId) {
  await client.send('Runtime.releaseObject', {
    objectId
  }).catch(error => {});
}

async function readProtocolStream(client, handle, path) {
  let eof = false;
  let fd;

  if (path) {
    await (0, _fileUtils.mkdirIfNeeded)(path);
    fd = await _fs.default.promises.open(path, 'w');
  }

  const bufs = [];

  while (!eof) {
    const response = await client.send('IO.read', {
      handle
    });
    eof = response.eof;
    const buf = Buffer.from(response.data, response.base64Encoded ? 'base64' : undefined);
    bufs.push(buf);
    if (fd) await fd.write(buf);
  }

  if (fd) await fd.close();
  await client.send('IO.close', {
    handle
  });
  return Buffer.concat(bufs);
}

function toConsoleMessageLocation(stackTrace) {
  return stackTrace && stackTrace.callFrames.length ? {
    url: stackTrace.callFrames[0].url,
    lineNumber: stackTrace.callFrames[0].lineNumber,
    columnNumber: stackTrace.callFrames[0].columnNumber
  } : {
    url: '',
    lineNumber: 0,
    columnNumber: 0
  };
}

function exceptionToError(exceptionDetails) {
  const messageWithStack = getExceptionMessage(exceptionDetails);
  const lines = messageWithStack.split('\n');
  const firstStackTraceLine = lines.findIndex(line => line.startsWith('    at'));
  let messageWithName = '';
  let stack = '';

  if (firstStackTraceLine === -1) {
    messageWithName = messageWithStack;
  } else {
    messageWithName = lines.slice(0, firstStackTraceLine).join('\n');
    stack = messageWithStack;
  }

  const {
    name,
    message
  } = (0, _stackTrace.splitErrorMessage)(messageWithName);
  const err = new Error(message);
  err.stack = stack;
  err.name = name;
  return err;
}

function toModifiersMask(modifiers) {
  let mask = 0;
  if (modifiers.has('Alt')) mask |= 1;
  if (modifiers.has('Control')) mask |= 2;
  if (modifiers.has('Meta')) mask |= 4;
  if (modifiers.has('Shift')) mask |= 8;
  return mask;
}

function toButtonsMask(buttons) {
  let mask = 0;
  if (buttons.has('left')) mask |= 1;
  if (buttons.has('right')) mask |= 2;
  if (buttons.has('middle')) mask |= 4;
  return mask;
}

/***/ }),

/***/ 2594:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CRServiceWorker = void 0;

var _page = __nccwpck_require__(3555);

var _crExecutionContext = __nccwpck_require__(4244);

var _crNetworkManager = __nccwpck_require__(2969);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _browserContext = __nccwpck_require__(5985);

var _utils = __nccwpck_require__(3557);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CRServiceWorker extends _page.Worker {
  constructor(browserContext, session, url) {
    super(browserContext, url);
    this._browserContext = void 0;
    this._networkManager = void 0;
    this._session = void 0;
    this._extraHTTPHeaders = null;
    this._session = session;
    this._browserContext = browserContext;
    if (!!process.env.PW_EXPERIMENTAL_SERVICE_WORKER_NETWORK_EVENTS) this._networkManager = new _crNetworkManager.CRNetworkManager(session, null, this, null);
    session.once('Runtime.executionContextCreated', event => {
      this._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));
    });

    if (this._networkManager && this._isNetworkInspectionEnabled()) {
      this._networkManager.initialize().catch(() => {});

      this.updateRequestInterception();
      this.updateExtraHTTPHeaders(true);
      this.updateHttpCredentials(true);
      this.updateOffline(true);
    }

    session.send('Runtime.enable', {}).catch(e => {});
    session.send('Runtime.runIfWaitingForDebugger').catch(e => {});
  }

  async updateOffline(initial) {
    var _this$_networkManager;

    if (!this._isNetworkInspectionEnabled()) return;
    const offline = !!this._browserContext._options.offline;
    if (!initial || offline) await ((_this$_networkManager = this._networkManager) === null || _this$_networkManager === void 0 ? void 0 : _this$_networkManager.setOffline(offline));
  }

  async updateHttpCredentials(initial) {
    var _this$_networkManager2;

    if (!this._isNetworkInspectionEnabled()) return;
    const credentials = this._browserContext._options.httpCredentials || null;
    if (!initial || credentials) await ((_this$_networkManager2 = this._networkManager) === null || _this$_networkManager2 === void 0 ? void 0 : _this$_networkManager2.authenticate(credentials));
  }

  async updateExtraHTTPHeaders(initial) {
    if (!this._isNetworkInspectionEnabled()) return;
    const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._extraHTTPHeaders]);
    if (!initial || headers.length) await this._session.send('Network.setExtraHTTPHeaders', {
      headers: (0, _utils.headersArrayToObject)(headers, false
      /* lowerCase */
      )
    });
  }

  updateRequestInterception() {
    if (!this._networkManager || !this._isNetworkInspectionEnabled()) return Promise.resolve();
    return this._networkManager.setRequestInterception(this.needsRequestInterception()).catch(e => {});
  }

  needsRequestInterception() {
    return this._isNetworkInspectionEnabled() && !!this._browserContext._requestInterceptor;
  }

  reportRequestFinished(request, response) {
    this._browserContext.emit(_browserContext.BrowserContext.Events.RequestFinished, {
      request,
      response
    });
  }

  requestFailed(request, _canceled) {
    this._browserContext.emit(_browserContext.BrowserContext.Events.RequestFailed, request);
  }

  requestReceivedResponse(response) {
    this._browserContext.emit(_browserContext.BrowserContext.Events.Response, response);
  }

  requestStarted(request, route) {
    this._browserContext.emit(_browserContext.BrowserContext.Events.Request, request);

    if (route) {
      const r = new network.Route(request, route);

      if (this._browserContext._requestInterceptor) {
        this._browserContext._requestInterceptor(r, request);

        return;
      }

      r.continue();
    }
  }

  _isNetworkInspectionEnabled() {
    return this._browserContext._options.serviceWorkers === 'allow';
  }

}

exports.CRServiceWorker = CRServiceWorker;

/***/ }),

/***/ 5948:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.platformToFontFamilies = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// DO NOT EDIT: this map is generated from Chromium source code by utils/generate_chromium_default_font_families.js
const platformToFontFamilies = {
  'linux': {
    'fontFamilies': {
      'standard': 'Times New Roman',
      'fixed': 'Monospace',
      'serif': 'Times New Roman',
      'sansSerif': 'Arial',
      'cursive': 'Comic Sans MS',
      'fantasy': 'Impact'
    }
  },
  'mac': {
    'fontFamilies': {
      'standard': 'Times',
      'fixed': 'Courier',
      'serif': 'Times',
      'sansSerif': 'Helvetica',
      'cursive': 'Apple Chancery',
      'fantasy': 'Papyrus'
    },
    'forScripts': [{
      'script': 'jpan',
      'fontFamilies': {
        'standard': 'Hiragino Kaku Gothic ProN',
        'fixed': 'Osaka-Mono',
        'serif': 'Hiragino Mincho ProN',
        'sansSerif': 'Hiragino Kaku Gothic ProN'
      }
    }, {
      'script': 'hang',
      'fontFamilies': {
        'standard': 'Apple SD Gothic Neo',
        'serif': 'AppleMyungjo',
        'sansSerif': 'Apple SD Gothic Neo'
      }
    }, {
      'script': 'hans',
      'fontFamilies': {
        'standard': ',PingFang SC,STHeiti',
        'serif': 'Songti SC',
        'sansSerif': ',PingFang SC,STHeiti',
        'cursive': 'Kaiti SC'
      }
    }, {
      'script': 'hant',
      'fontFamilies': {
        'standard': ',PingFang TC,Heiti TC',
        'serif': 'Songti TC',
        'sansSerif': ',PingFang TC,Heiti TC',
        'cursive': 'Kaiti TC'
      }
    }]
  },
  'win': {
    'fontFamilies': {
      'standard': 'Times New Roman',
      'fixed': 'Consolas',
      'serif': 'Times New Roman',
      'sansSerif': 'Arial',
      'cursive': 'Comic Sans MS',
      'fantasy': 'Impact'
    },
    'forScripts': [{
      'script': 'cyrl',
      'fontFamilies': {
        'standard': 'Times New Roman',
        'fixed': 'Courier New',
        'serif': 'Times New Roman',
        'sansSerif': 'Arial'
      }
    }, {
      'script': 'arab',
      'fontFamilies': {
        'fixed': 'Courier New',
        'sansSerif': 'Segoe UI'
      }
    }, {
      'script': 'grek',
      'fontFamilies': {
        'standard': 'Times New Roman',
        'fixed': 'Courier New',
        'serif': 'Times New Roman',
        'sansSerif': 'Arial'
      }
    }, {
      'script': 'jpan',
      'fontFamilies': {
        'standard': ',Meiryo,Yu Gothic',
        'fixed': 'MS Gothic',
        'serif': ',Yu Mincho,MS PMincho',
        'sansSerif': ',Meiryo,Yu Gothic'
      }
    }, {
      'script': 'hang',
      'fontFamilies': {
        'standard': 'Malgun Gothic',
        'fixed': 'Gulimche',
        'serif': 'Batang',
        'sansSerif': 'Malgun Gothic',
        'cursive': 'Gungsuh'
      }
    }, {
      'script': 'hans',
      'fontFamilies': {
        'standard': 'Microsoft YaHei',
        'fixed': 'NSimsun',
        'serif': 'Simsun',
        'sansSerif': 'Microsoft YaHei',
        'cursive': 'KaiTi'
      }
    }, {
      'script': 'hant',
      'fontFamilies': {
        'standard': 'Microsoft JhengHei',
        'fixed': 'MingLiU',
        'serif': 'PMingLiU',
        'sansSerif': 'Microsoft JhengHei',
        'cursive': 'DFKai-SB'
      }
    }]
  }
};
exports.platformToFontFamilies = platformToFontFamilies;

/***/ }),

/***/ 3202:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VideoRecorder = void 0;

var _utils = __nccwpck_require__(3557);

var _page = __nccwpck_require__(3555);

var _processLauncher = __nccwpck_require__(1441);

var _progress = __nccwpck_require__(2836);

var _instrumentation = __nccwpck_require__(6686);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fps = 25;

class VideoRecorder {
  static async launch(page, ffmpegPath, options) {
    if (!options.outputFile.endsWith('.webm')) throw new Error('File must have .webm extension');
    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), page);
    controller.setLogName('browser');
    return await controller.run(async progress => {
      const recorder = new VideoRecorder(page, ffmpegPath, progress);
      await recorder._launch(options);
      return recorder;
    });
  }

  constructor(page, ffmpegPath, progress) {
    this._process = null;
    this._gracefullyClose = null;
    this._lastWritePromise = Promise.resolve();
    this._lastFrameTimestamp = 0;
    this._lastFrameBuffer = null;
    this._lastWriteTimestamp = 0;
    this._progress = void 0;
    this._frameQueue = [];
    this._isStopped = false;
    this._ffmpegPath = void 0;
    this._progress = progress;
    this._ffmpegPath = ffmpegPath;
    page.on(_page.Page.Events.ScreencastFrame, frame => this.writeFrame(frame.buffer, frame.timestamp));
  }

  async _launch(options) {
    // How to tune the codec:
    // 1. Read vp8 documentation to figure out the options.
    //   https://www.webmproject.org/docs/encoder-parameters/
    // 2. Use the following command to map the options to ffmpeg arguments.
    //   $ ./third_party/ffmpeg/ffmpeg-mac -h encoder=vp8
    // 3. A bit more about passing vp8 options to ffmpeg.
    //   https://trac.ffmpeg.org/wiki/Encode/VP8
    // 4. Tuning for VP9:
    //   https://developers.google.com/media/vp9/live-encoding
    //
    // How to stress-test video recording (runs 10 recorders in parallel to book all cpus available):
    //   $ node ./utils/video_stress.js
    //
    // We use the following vp8 options:
    //   "-qmin 0 -qmax 50" - quality variation from 0 to 50.
    //     Suggested here: https://trac.ffmpeg.org/wiki/Encode/VP8
    //   "-crf 8" - constant quality mode, 4-63, lower means better quality.
    //   "-deadline realtime -speed 8" - do not use too much cpu to keep up with incoming frames.
    //   "-b:v 1M" - video bitrate. Default value is too low for vp8
    //     Suggested here: https://trac.ffmpeg.org/wiki/Encode/VP8
    //   Note that we can switch to "-qmin 20 -qmax 50 -crf 30" for smaller video size but worse quality.
    //
    // We use "pad" and "crop" video filters (-vf option) to resize incoming frames
    // that might be of the different size to the desired video size.
    //   https://ffmpeg.org/ffmpeg-filters.html#pad-1
    //   https://ffmpeg.org/ffmpeg-filters.html#crop
    //
    // We use "image2pipe" mode to pipe frames and get a single video - https://trac.ffmpeg.org/wiki/Slideshow
    //   "-f image2pipe -c:v mjpeg -i -" forces input to be read from standard input, and forces
    //     mjpeg input image format.
    //   "-avioflags direct" reduces general buffering.
    //   "-fpsprobesize 0 -probesize 32 -analyzeduration 0" reduces initial buffering
    //     while analyzing input fps and other stats.
    //
    // "-y" means overwrite output.
    // "-an" means no audio.
    // "-threads 1" means using one thread. This drastically reduces stalling when
    //   cpu is overbooked. By default vp8 tries to use all available threads?
    const w = options.width;
    const h = options.height;
    const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(' ');
    args.push(options.outputFile);
    const progress = this._progress;
    const {
      launchedProcess,
      gracefullyClose
    } = await (0, _processLauncher.launchProcess)({
      command: this._ffmpegPath,
      args,
      stdio: 'stdin',
      log: message => progress.log(message),
      tempDirectories: [],
      attemptToGracefullyClose: async () => {
        progress.log('Closing stdin...');
        launchedProcess.stdin.end();
      },
      onExit: (exitCode, signal) => {
        progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
      }
    });
    launchedProcess.stdin.on('finish', () => {
      progress.log('ffmpeg finished input.');
    });
    launchedProcess.stdin.on('error', () => {
      progress.log('ffmpeg error.');
    });
    this._process = launchedProcess;
    this._gracefullyClose = gracefullyClose;
  }

  writeFrame(frame, timestamp) {
    (0, _utils.assert)(this._process);
    if (this._isStopped) return;

    this._progress.log(`writing frame ` + timestamp);

    if (this._lastFrameBuffer) {
      const durationSec = timestamp - this._lastFrameTimestamp;
      const repeatCount = Math.max(1, Math.round(fps * durationSec));

      for (let i = 0; i < repeatCount; ++i) this._frameQueue.push(this._lastFrameBuffer);

      this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
    }

    this._lastFrameBuffer = frame;
    this._lastFrameTimestamp = timestamp;
    this._lastWriteTimestamp = (0, _utils.monotonicTime)();
  }

  async _sendFrames() {
    while (this._frameQueue.length) await this._sendFrame(this._frameQueue.shift());
  }

  async _sendFrame(frame) {
    return new Promise(f => this._process.stdin.write(frame, f)).then(error => {
      if (error) this._progress.log(`ffmpeg failed to write: ${error}`);
    });
  }

  async stop() {
    if (this._isStopped) return;
    this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + ((0, _utils.monotonicTime)() - this._lastWriteTimestamp) / 1000);
    this._isStopped = true;
    await this._lastWritePromise;
    await this._gracefullyClose();
  }

}

exports.VideoRecorder = VideoRecorder;

/***/ }),

/***/ 8477:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConsoleMessage = void 0;

var _instrumentation = __nccwpck_require__(6686);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConsoleMessage extends _instrumentation.SdkObject {
  constructor(parent, type, text, args, location) {
    super(parent, 'console-message');
    this._type = void 0;
    this._text = void 0;
    this._args = void 0;
    this._location = void 0;
    this._type = type;
    this._text = text;
    this._args = args;
    this._location = location || {
      url: '',
      lineNumber: 0,
      columnNumber: 0
    };
  }

  type() {
    return this._type;
  }

  text() {
    if (this._text === undefined) this._text = this._args.map(arg => arg.preview()).join(' ');
    return this._text;
  }

  args() {
    return this._args;
  }

  location() {
    return this._location;
  }

}

exports.ConsoleMessage = ConsoleMessage;

/***/ }),

/***/ 9260:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CookieStore = void 0;
exports.domainMatches = domainMatches;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Cookie {
  constructor(data) {
    this._raw = void 0;
    this._raw = data;
  }

  name() {
    return this._raw.name;
  } // https://datatracker.ietf.org/doc/html/rfc6265#section-5.4


  matches(url) {
    if (this._raw.secure && url.protocol !== 'https:' && url.hostname !== 'localhost') return false;
    if (!domainMatches(url.hostname, this._raw.domain)) return false;
    if (!pathMatches(url.pathname, this._raw.path)) return false;
    return true;
  }

  equals(other) {
    return this._raw.name === other._raw.name && this._raw.domain === other._raw.domain && this._raw.path === other._raw.path;
  }

  networkCookie() {
    return this._raw;
  }

  updateExpiresFrom(other) {
    this._raw.expires = other._raw.expires;
  }

  expired() {
    if (this._raw.expires === -1) return false;
    return this._raw.expires * 1000 < Date.now();
  }

}

class CookieStore {
  constructor() {
    this._nameToCookies = new Map();
  }

  addCookies(cookies) {
    for (const cookie of cookies) this._addCookie(new Cookie(cookie));
  }

  cookies(url) {
    const result = [];

    for (const cookie of this._cookiesIterator()) {
      if (cookie.matches(url)) result.push(cookie.networkCookie());
    }

    return result;
  }

  allCookies() {
    const result = [];

    for (const cookie of this._cookiesIterator()) result.push(cookie.networkCookie());

    return result;
  }

  _addCookie(cookie) {
    if (cookie.expired()) return;

    let set = this._nameToCookies.get(cookie.name());

    if (!set) {
      set = new Set();

      this._nameToCookies.set(cookie.name(), set);
    }

    CookieStore.pruneExpired(set); // https://datatracker.ietf.org/doc/html/rfc6265#section-5.3

    for (const other of set) {
      if (other.equals(cookie)) {
        cookie.updateExpiresFrom(other);
        set.delete(other);
      }
    }

    set.add(cookie);
  }

  *_cookiesIterator() {
    for (const [name, cookies] of this._nameToCookies) {
      CookieStore.pruneExpired(cookies);

      for (const cookie of cookies) yield cookie;

      if (cookies.size === 0) this._nameToCookies.delete(name);
    }
  }

  static pruneExpired(cookies) {
    for (const cookie of cookies) {
      if (cookie.expired()) cookies.delete(cookie);
    }
  }

}

exports.CookieStore = CookieStore;

function domainMatches(value, domain) {
  if (value === domain) return true; // Only strict match is allowed if domain doesn't start with '.' (host-only-flag is true in the spec)

  if (!domain.startsWith('.')) return false;
  value = '.' + value;
  return value.endsWith(domain);
}

function pathMatches(value, path) {
  if (value === path) return true;
  if (!value.endsWith('/')) value = value + '/';
  if (!path.endsWith('/')) path = path + '/';
  return value.startsWith(path);
}

/***/ }),

/***/ 7370:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Debugger = void 0;

var _events = __nccwpck_require__(2361);

var _utils = __nccwpck_require__(3557);

var _browserContext = __nccwpck_require__(5985);

var _channels = __nccwpck_require__(6272);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const symbol = Symbol('Debugger');

class Debugger extends _events.EventEmitter {
  constructor(context) {
    super();
    this._pauseOnNextStatement = false;
    this._pausedCallsMetadata = new Map();
    this._enabled = void 0;
    this._context = void 0;
    this._muted = false;
    this._context = context;
    this._context[symbol] = this;
    this._enabled = (0, _utils.debugMode)() === 'inspector';
    if (this._enabled) this.pauseOnNextStatement();
    context.instrumentation.addListener(this, context);

    this._context.once(_browserContext.BrowserContext.Events.Close, () => {
      this._context.instrumentation.removeListener(this);
    });
  }

  static lookup(context) {
    if (!context) return;
    return context[symbol];
  }

  async setMuted(muted) {
    this._muted = muted;
  }

  async onBeforeCall(sdkObject, metadata) {
    if (this._muted) return;
    if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata)) await this.pause(sdkObject, metadata);
  }

  async onBeforeInputAction(sdkObject, metadata) {
    if (this._muted) return;
    if (this._enabled && this._pauseOnNextStatement) await this.pause(sdkObject, metadata);
  }

  async pause(sdkObject, metadata) {
    if (this._muted) return;
    this._enabled = true;
    metadata.pauseStartTime = (0, _utils.monotonicTime)();
    const result = new Promise(resolve => {
      this._pausedCallsMetadata.set(metadata, {
        resolve,
        sdkObject
      });
    });
    this.emit(Debugger.Events.PausedStateChanged);
    return result;
  }

  resume(step) {
    this._pauseOnNextStatement = step;
    const endTime = (0, _utils.monotonicTime)();

    for (const [metadata, {
      resolve
    }] of this._pausedCallsMetadata) {
      metadata.pauseEndTime = endTime;
      resolve();
    }

    this._pausedCallsMetadata.clear();

    this.emit(Debugger.Events.PausedStateChanged);
  }

  pauseOnNextStatement() {
    this._pauseOnNextStatement = true;
  }

  isPaused(metadata) {
    if (metadata) return this._pausedCallsMetadata.has(metadata);
    return !!this._pausedCallsMetadata.size;
  }

  pausedDetails() {
    const result = [];

    for (const [metadata, {
      sdkObject
    }] of this._pausedCallsMetadata) result.push({
      metadata,
      sdkObject
    });

    return result;
  }

}

exports.Debugger = Debugger;
Debugger.Events = {
  PausedStateChanged: 'pausedstatechanged'
};

function shouldPauseOnCall(sdkObject, metadata) {
  var _sdkObject$attributio;

  if (!((_sdkObject$attributio = sdkObject.attribution.browser) !== null && _sdkObject$attributio !== void 0 && _sdkObject$attributio.options.headful) && !(0, _utils.isUnderTest)()) return false;
  return metadata.method === 'pause';
}

function shouldPauseBeforeStep(metadata) {
  // Don't stop on internal.
  if (!metadata.apiName) return false; // Always stop on 'close'

  if (metadata.method === 'close') return true;
  if (metadata.method === 'waitForSelector' || metadata.method === 'waitForEventInfo') return false; // Never stop on those, primarily for the test harness.

  const step = metadata.type + '.' + metadata.method; // Stop before everything that generates snapshot. But don't stop before those marked as pausesBeforeInputActions
  // since we stop in them on a separate instrumentation signal.

  return _channels.commandsWithTracingSnapshots.has(step) && !_channels.pausesBeforeInputActions.has(metadata.type + '.' + metadata.method);
}

/***/ }),

/***/ 2327:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @type {import('./types').Devices}
 */
module.exports = __nccwpck_require__(9870)


/***/ }),

/***/ 1645:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Dialog = void 0;

var _utils = __nccwpck_require__(3557);

var _instrumentation = __nccwpck_require__(6686);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dialog extends _instrumentation.SdkObject {
  constructor(page, type, message, onHandle, defaultValue) {
    super(page, 'dialog');
    this._page = void 0;
    this._type = void 0;
    this._message = void 0;
    this._onHandle = void 0;
    this._handled = false;
    this._defaultValue = void 0;
    this._page = page;
    this._type = type;
    this._message = message;
    this._onHandle = onHandle;
    this._defaultValue = defaultValue || '';

    this._page._frameManager.dialogDidOpen(this);
  }

  type() {
    return this._type;
  }

  message() {
    return this._message;
  }

  defaultValue() {
    return this._defaultValue;
  }

  async accept(promptText) {
    (0, _utils.assert)(!this._handled, 'Cannot accept dialog which is already handled!');
    this._handled = true;

    this._page._frameManager.dialogWillClose(this);

    await this._onHandle(true, promptText);
  }

  async dismiss() {
    (0, _utils.assert)(!this._handled, 'Cannot dismiss dialog which is already handled!');
    this._handled = true;

    this._page._frameManager.dialogWillClose(this);

    await this._onHandle(false);
  }

}

exports.Dialog = Dialog;

/***/ }),

/***/ 3037:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AndroidSocketDispatcher = exports.AndroidDispatcher = exports.AndroidDeviceDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _android = __nccwpck_require__(6781);

var _browserContextDispatcher = __nccwpck_require__(6170);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AndroidDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, android) {
    super(scope, android, 'Android', {}, true);
    this._type_Android = true;
  }

  async devices(params) {
    const devices = await this._object.devices(params);
    return {
      devices: devices.map(d => AndroidDeviceDispatcher.from(this._scope, d))
    };
  }

  async setDefaultTimeoutNoReply(params) {
    this._object.setDefaultTimeout(params.timeout);
  }

}

exports.AndroidDispatcher = AndroidDispatcher;

class AndroidDeviceDispatcher extends _dispatcher.Dispatcher {
  static from(scope, device) {
    const result = (0, _dispatcher.existingDispatcher)(device);
    return result || new AndroidDeviceDispatcher(scope, device);
  }

  constructor(scope, device) {
    super(scope, device, 'AndroidDevice', {
      model: device.model,
      serial: device.serial
    }, true);
    this._type_EventTarget = true;
    this._type_AndroidDevice = true;

    for (const webView of device.webViews()) this._dispatchEvent('webViewAdded', {
      webView
    });

    this.addObjectListener(_android.AndroidDevice.Events.WebViewAdded, webView => this._dispatchEvent('webViewAdded', {
      webView
    }));
    this.addObjectListener(_android.AndroidDevice.Events.WebViewRemoved, socketName => this._dispatchEvent('webViewRemoved', {
      socketName
    }));
  }

  async wait(params) {
    await this._object.send('wait', params);
  }

  async fill(params) {
    await this._object.send('click', {
      selector: params.selector
    });
    await this._object.send('fill', params);
  }

  async tap(params) {
    await this._object.send('click', params);
  }

  async drag(params) {
    await this._object.send('drag', params);
  }

  async fling(params) {
    await this._object.send('fling', params);
  }

  async longTap(params) {
    await this._object.send('longClick', params);
  }

  async pinchClose(params) {
    await this._object.send('pinchClose', params);
  }

  async pinchOpen(params) {
    await this._object.send('pinchOpen', params);
  }

  async scroll(params) {
    await this._object.send('scroll', params);
  }

  async swipe(params) {
    await this._object.send('swipe', params);
  }

  async info(params) {
    return {
      info: await this._object.send('info', params)
    };
  }

  async inputType(params) {
    const text = params.text;
    const keyCodes = [];

    for (let i = 0; i < text.length; ++i) {
      const code = keyMap.get(text[i].toUpperCase());
      if (code === undefined) throw new Error('No mapping for ' + text[i] + ' found');
      keyCodes.push(code);
    }

    await Promise.all(keyCodes.map(keyCode => this._object.send('inputPress', {
      keyCode
    })));
  }

  async inputPress(params) {
    if (!keyMap.has(params.key)) throw new Error('Unknown key: ' + params.key);
    await this._object.send('inputPress', {
      keyCode: keyMap.get(params.key)
    });
  }

  async inputTap(params) {
    await this._object.send('inputClick', params);
  }

  async inputSwipe(params) {
    await this._object.send('inputSwipe', params);
  }

  async inputDrag(params) {
    await this._object.send('inputDrag', params);
  }

  async screenshot(params) {
    return {
      binary: await this._object.screenshot()
    };
  }

  async shell(params) {
    return {
      result: await this._object.shell(params.command)
    };
  }

  async open(params, metadata) {
    const socket = await this._object.open(params.command);
    return {
      socket: new AndroidSocketDispatcher(this._scope, socket)
    };
  }

  async installApk(params) {
    await this._object.installApk(params.file, {
      args: params.args
    });
  }

  async push(params) {
    await this._object.push(params.file, params.path, params.mode);
  }

  async launchBrowser(params) {
    const context = await this._object.launchBrowser(params.pkg, params);
    return {
      context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
    };
  }

  async close(params) {
    await this._object.close();
  }

  async setDefaultTimeoutNoReply(params) {
    this._object.setDefaultTimeout(params.timeout);
  }

  async connectToWebView(params) {
    return {
      context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, await this._object.connectToWebView(params.socketName))
    };
  }

}

exports.AndroidDeviceDispatcher = AndroidDeviceDispatcher;

class AndroidSocketDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, socket) {
    super(scope, socket, 'AndroidSocket', {}, true);
    this._type_AndroidSocket = true;
    this.addObjectListener('data', data => this._dispatchEvent('data', {
      data
    }));
    this.addObjectListener('close', () => {
      this._dispatchEvent('close');

      this._dispose();
    });
  }

  async write(params, metadata) {
    await this._object.write(params.data);
  }

  async close(params, metadata) {
    this._object.close();
  }

}

exports.AndroidSocketDispatcher = AndroidSocketDispatcher;
const keyMap = new Map([['Unknown', 0], ['SoftLeft', 1], ['SoftRight', 2], ['Home', 3], ['Back', 4], ['Call', 5], ['EndCall', 6], ['0', 7], ['1', 8], ['2', 9], ['3', 10], ['4', 11], ['5', 12], ['6', 13], ['7', 14], ['8', 15], ['9', 16], ['Star', 17], ['*', 17], ['Pound', 18], ['#', 18], ['DialUp', 19], ['DialDown', 20], ['DialLeft', 21], ['DialRight', 22], ['DialCenter', 23], ['VolumeUp', 24], ['VolumeDown', 25], ['Power', 26], ['Camera', 27], ['Clear', 28], ['A', 29], ['B', 30], ['C', 31], ['D', 32], ['E', 33], ['F', 34], ['G', 35], ['H', 36], ['I', 37], ['J', 38], ['K', 39], ['L', 40], ['M', 41], ['N', 42], ['O', 43], ['P', 44], ['Q', 45], ['R', 46], ['S', 47], ['T', 48], ['U', 49], ['V', 50], ['W', 51], ['X', 52], ['Y', 53], ['Z', 54], ['Comma', 55], [',', 55], ['Period', 56], ['.', 56], ['AltLeft', 57], ['AltRight', 58], ['ShiftLeft', 59], ['ShiftRight', 60], ['Tab', 61], ['\t', 61], ['Space', 62], [' ', 62], ['Sym', 63], ['Explorer', 64], ['Envelop', 65], ['Enter', 66], ['Del', 67], ['Grave', 68], ['Minus', 69], ['-', 69], ['Equals', 70], ['=', 70], ['LeftBracket', 71], ['(', 71], ['RightBracket', 72], [')', 72], ['Backslash', 73], ['\\', 73], ['Semicolon', 74], [';', 74], ['Apostrophe', 75], ['`', 75], ['Slash', 76], ['/', 76], ['At', 77], ['@', 77], ['Num', 78], ['HeadsetHook', 79], ['Focus', 80], ['Plus', 81], ['Menu', 82], ['Notification', 83], ['Search', 84], ['AppSwitch', 187], ['Assist', 219], ['Cut', 277], ['Copy', 278], ['Paste', 279]]);

/***/ }),

/***/ 2810:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ArtifactDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _streamDispatcher = __nccwpck_require__(3239);

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _fileUtils = __nccwpck_require__(6034);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ArtifactDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, artifact) {
    super(scope, artifact, 'Artifact', {
      absolutePath: artifact.localPath()
    });
    this._type_Artifact = true;
  }

  async pathAfterFinished() {
    const path = await this._object.localPathAfterFinished();
    return {
      value: path || undefined
    };
  }

  async saveAs(params) {
    return await new Promise((resolve, reject) => {
      this._object.saveAs(async (localPath, error) => {
        if (error !== undefined) {
          reject(new Error(error));
          return;
        }

        try {
          await (0, _fileUtils.mkdirIfNeeded)(params.path);
          await _fs.default.promises.copyFile(localPath, params.path);
          resolve();
        } catch (e) {
          reject(e);
        }
      });
    });
  }

  async saveAsStream() {
    return await new Promise((resolve, reject) => {
      this._object.saveAs(async (localPath, error) => {
        if (error !== undefined) {
          reject(new Error(error));
          return;
        }

        try {
          const readable = _fs.default.createReadStream(localPath);

          const stream = new _streamDispatcher.StreamDispatcher(this._scope, readable); // Resolve with a stream, so that client starts saving the data.

          resolve({
            stream
          }); // Block the Artifact until the stream is consumed.

          await new Promise(resolve => {
            readable.on('close', resolve);
            readable.on('end', resolve);
            readable.on('error', resolve);
          });
        } catch (e) {
          reject(e);
        }
      });
    });
  }

  async stream() {
    const fileName = await this._object.localPathAfterFinished();
    if (!fileName) return {};

    const readable = _fs.default.createReadStream(fileName);

    return {
      stream: new _streamDispatcher.StreamDispatcher(this._scope, readable)
    };
  }

  async failure() {
    const error = await this._object.failureError();
    return {
      error: error || undefined
    };
  }

  async cancel() {
    await this._object.cancel();
  }

  async delete() {
    await this._object.delete();

    this._dispose();
  }

}

exports.ArtifactDispatcher = ArtifactDispatcher;

/***/ }),

/***/ 6170:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BrowserContextDispatcher = void 0;

var _browserContext = __nccwpck_require__(5985);

var _dispatcher = __nccwpck_require__(4098);

var _pageDispatcher = __nccwpck_require__(7916);

var _networkDispatchers = __nccwpck_require__(1584);

var _crBrowser = __nccwpck_require__(2731);

var _cdpSessionDispatcher = __nccwpck_require__(5223);

var _recorder = __nccwpck_require__(8584);

var _artifactDispatcher = __nccwpck_require__(2810);

var _tracingDispatcher = __nccwpck_require__(7178);

var fs = _interopRequireWildcard(__nccwpck_require__(7147));

var path = _interopRequireWildcard(__nccwpck_require__(1017));

var _utils = __nccwpck_require__(3557);

var _writableStreamDispatcher = __nccwpck_require__(1253);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserContextDispatcher extends _dispatcher.Dispatcher {
  constructor(parentScope, context) {
    // We will reparent these to the context below.
    const requestContext = _networkDispatchers.APIRequestContextDispatcher.from(parentScope, context.fetchRequest);

    const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, context.tracing);

    super(parentScope, context, 'BrowserContext', {
      isChromium: context._browser.options.isChromium,
      requestContext,
      tracing
    }, true);
    this._type_EventTarget = true;
    this._type_BrowserContext = true;
    this._context = void 0;
    this.adopt(requestContext);
    this.adopt(tracing);
    this._context = context; // Note: when launching persistent context, dispatcher is created very late,
    // so we can already have pages, videos and everything else.

    const onVideo = artifact => {
      // Note: Video must outlive Page and BrowserContext, so that client can saveAs it
      // after closing the context. We use |scope| for it.
      const artifactDispatcher = new _artifactDispatcher.ArtifactDispatcher(parentScope, artifact);

      this._dispatchEvent('video', {
        artifact: artifactDispatcher
      });
    };

    this.addObjectListener(_browserContext.BrowserContext.Events.VideoStarted, onVideo);

    for (const video of context._browser._idToVideo.values()) {
      if (video.context === context) onVideo(video.artifact);
    }

    for (const page of context.pages()) this._dispatchEvent('page', {
      page: new _pageDispatcher.PageDispatcher(this._scope, page)
    });

    this.addObjectListener(_browserContext.BrowserContext.Events.Page, page => this._dispatchEvent('page', {
      page: new _pageDispatcher.PageDispatcher(this._scope, page)
    }));
    this.addObjectListener(_browserContext.BrowserContext.Events.Close, () => {
      this._dispatchEvent('close');

      this._dispose();
    });

    if (context._browser.options.name === 'chromium') {
      for (const page of context.backgroundPages()) this._dispatchEvent('backgroundPage', {
        page: new _pageDispatcher.PageDispatcher(this._scope, page)
      });

      this.addObjectListener(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, page => this._dispatchEvent('backgroundPage', {
        page: new _pageDispatcher.PageDispatcher(this._scope, page)
      }));

      for (const serviceWorker of context.serviceWorkers()) this._dispatchEvent('serviceWorker', {
        worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
      });

      this.addObjectListener(_crBrowser.CRBrowserContext.CREvents.ServiceWorker, serviceWorker => this._dispatchEvent('serviceWorker', {
        worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
      }));
    }

    this.addObjectListener(_browserContext.BrowserContext.Events.Request, request => {
      var _request$frame;

      return this._dispatchEvent('request', {
        request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
        page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(_browserContext.BrowserContext.Events.Response, response => {
      var _response$frame;

      return this._dispatchEvent('response', {
        response: _networkDispatchers.ResponseDispatcher.from(this._scope, response),
        page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, (_response$frame = response.frame()) === null || _response$frame === void 0 ? void 0 : _response$frame._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(_browserContext.BrowserContext.Events.RequestFailed, request => {
      var _request$frame2;

      return this._dispatchEvent('requestFailed', {
        request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
        failureText: request._failureText || undefined,
        responseEndTiming: request._responseEndTiming,
        page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, (_request$frame2 = request.frame()) === null || _request$frame2 === void 0 ? void 0 : _request$frame2._page.initializedOrUndefined())
      });
    });
    this.addObjectListener(_browserContext.BrowserContext.Events.RequestFinished, ({
      request,
      response
    }) => {
      var _request$frame3;

      return this._dispatchEvent('requestFinished', {
        request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
        response: _networkDispatchers.ResponseDispatcher.fromNullable(this._scope, response),
        responseEndTiming: request._responseEndTiming,
        page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, (_request$frame3 = request.frame()) === null || _request$frame3 === void 0 ? void 0 : _request$frame3._page.initializedOrUndefined())
      });
    });
  }

  async createTempFile(params, metadata) {
    const dir = this._context._browser.options.artifactsDir;
    const tmpDir = path.join(dir, 'upload-' + (0, _utils.createGuid)());
    await fs.promises.mkdir(tmpDir);

    this._context._tempDirs.push(tmpDir);

    const file = fs.createWriteStream(path.join(tmpDir, params.name));
    return {
      writableStream: new _writableStreamDispatcher.WritableStreamDispatcher(this._scope, file)
    };
  }

  async setDefaultNavigationTimeoutNoReply(params) {
    this._context.setDefaultNavigationTimeout(params.timeout);
  }

  async setDefaultTimeoutNoReply(params) {
    this._context.setDefaultTimeout(params.timeout);
  }

  async exposeBinding(params) {
    await this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
      const binding = new _pageDispatcher.BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);

      this._dispatchEvent('bindingCall', {
        binding
      });

      return binding.promise();
    });
  }

  async newPage(params, metadata) {
    return {
      page: (0, _dispatcher.lookupDispatcher)(await this._context.newPage(metadata))
    };
  }

  async cookies(params) {
    return {
      cookies: await this._context.cookies(params.urls)
    };
  }

  async addCookies(params) {
    await this._context.addCookies(params.cookies);
  }

  async clearCookies() {
    await this._context.clearCookies();
  }

  async grantPermissions(params) {
    await this._context.grantPermissions(params.permissions, params.origin);
  }

  async clearPermissions() {
    await this._context.clearPermissions();
  }

  async setGeolocation(params) {
    await this._context.setGeolocation(params.geolocation);
  }

  async setExtraHTTPHeaders(params) {
    await this._context.setExtraHTTPHeaders(params.headers);
  }

  async setOffline(params) {
    await this._context.setOffline(params.offline);
  }

  async setHTTPCredentials(params) {
    await this._context.setHTTPCredentials(params.httpCredentials);
  }

  async addInitScript(params) {
    await this._context.addInitScript(params.source);
  }

  async setNetworkInterceptionEnabled(params) {
    if (!params.enabled) {
      await this._context.setRequestInterceptor(undefined);
      return;
    }

    await this._context.setRequestInterceptor((route, request) => {
      this._dispatchEvent('route', {
        route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
        request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
      });
    });
  }

  async storageState(params, metadata) {
    return await this._context.storageState();
  }

  async close(params, metadata) {
    await this._context.close(metadata);
  }

  async recorderSupplementEnable(params) {
    await _recorder.Recorder.show(this._context, params);
  }

  async pause(params, metadata) {// Debugger will take care of this.
  }

  async newCDPSession(params) {
    if (!this._object._browser.options.isChromium) throw new Error(`CDP session is only available in Chromium`);
    if (!params.page && !params.frame || params.page && params.frame) throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
    const crBrowserContext = this._object;
    return {
      session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, await crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))
    };
  }

  async harStart(params) {
    const harId = await this._context._harStart(params.page ? params.page._object : null, params.options);
    return {
      harId
    };
  }

  async harExport(params) {
    const artifact = await this._context._harExport(params.harId);
    if (!artifact) throw new Error('No HAR artifact. Ensure record.harPath is set.');
    return {
      artifact: new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact)
    };
  }

  _dispose() {
    super._dispose();

    this._context.setRequestInterceptor(undefined).catch(() => {});
  }

}

exports.BrowserContextDispatcher = BrowserContextDispatcher;

/***/ }),

/***/ 9241:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConnectedBrowserDispatcher = exports.BrowserDispatcher = void 0;

var _browser = __nccwpck_require__(6705);

var _browserContextDispatcher = __nccwpck_require__(6170);

var _cdpSessionDispatcher = __nccwpck_require__(5223);

var _dispatcher = __nccwpck_require__(4098);

var _instrumentation = __nccwpck_require__(6686);

var _browserContext = __nccwpck_require__(5985);

var _selectors = __nccwpck_require__(5875);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, browser) {
    super(scope, browser, 'Browser', {
      version: browser.version(),
      name: browser.options.name
    }, true);
    this._type_Browser = true;
    this.addObjectListener(_browser.Browser.Events.Disconnected, () => this._didClose());
  }

  _didClose() {
    this._dispatchEvent('close');

    this._dispose();
  }

  async newContext(params, metadata) {
    const context = await this._object.newContext(metadata, params);
    return {
      context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
    };
  }

  async newContextForReuse(params, metadata) {
    return newContextForReuse(this._object, this._scope, params, null, metadata);
  }

  async close() {
    await this._object.close();
  }

  async killForTests() {
    await this._object.killForTests();
  }

  async newBrowserCDPSession() {
    if (!this._object.options.isChromium) throw new Error(`CDP session is only available in Chromium`);
    const crBrowser = this._object;
    return {
      session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession())
    };
  }

  async startTracing(params) {
    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    await crBrowser.startTracing(params.page ? params.page._object : undefined, params);
  }

  async stopTracing() {
    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    return {
      binary: await crBrowser.stopTracing()
    };
  }

} // This class implements multiplexing browser dispatchers over a single Browser instance.


exports.BrowserDispatcher = BrowserDispatcher;

class ConnectedBrowserDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, browser) {
    super(scope, browser, 'Browser', {
      version: browser.version(),
      name: browser.options.name
    }, true); // When we have a remotely-connected browser, each client gets a fresh Selector instance,
    // so that two clients do not interfere between each other.

    this._type_Browser = true;
    this._contexts = new Set();
    this.selectors = void 0;
    this.selectors = new _selectors.Selectors();
  }

  async newContext(params, metadata) {
    if (params.recordVideo) params.recordVideo.dir = this._object.options.artifactsDir;
    const context = await this._object.newContext(metadata, params);

    this._contexts.add(context);

    context.setSelectors(this.selectors);
    context.on(_browserContext.BrowserContext.Events.Close, () => this._contexts.delete(context));
    return {
      context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
    };
  }

  async newContextForReuse(params, metadata) {
    return newContextForReuse(this._object, this._scope, params, this.selectors, metadata);
  }

  async close() {// Client should not send us Browser.close.
  }

  async killForTests() {// Client should not send us Browser.killForTests.
  }

  async newBrowserCDPSession() {
    if (!this._object.options.isChromium) throw new Error(`CDP session is only available in Chromium`);
    const crBrowser = this._object;
    return {
      session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, await crBrowser.newBrowserCDPSession())
    };
  }

  async startTracing(params) {
    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    await crBrowser.startTracing(params.page ? params.page._object : undefined, params);
  }

  async stopTracing() {
    if (!this._object.options.isChromium) throw new Error(`Tracing is only available in Chromium`);
    const crBrowser = this._object;
    return {
      binary: await crBrowser.stopTracing()
    };
  }

  async cleanupContexts() {
    await Promise.all(Array.from(this._contexts).map(context => context.close((0, _instrumentation.serverSideCallMetadata)())));
  }

}

exports.ConnectedBrowserDispatcher = ConnectedBrowserDispatcher;

async function newContextForReuse(browser, scope, params, selectors, metadata) {
  const {
    context,
    needsReset
  } = await browser.newContextForReuse(params, metadata);

  if (needsReset) {
    const oldContextDispatcher = (0, _dispatcher.existingDispatcher)(context);
    if (oldContextDispatcher) oldContextDispatcher._dispose();
    await context.resetForReuse(metadata, params);
  }

  if (selectors) context.setSelectors(selectors);
  const contextDispatcher = new _browserContextDispatcher.BrowserContextDispatcher(scope, context);
  return {
    context: contextDispatcher
  };
}

/***/ }),

/***/ 6555:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BrowserTypeDispatcher = void 0;

var _browserDispatcher = __nccwpck_require__(9241);

var _dispatcher = __nccwpck_require__(4098);

var _browserContextDispatcher = __nccwpck_require__(6170);

var _jsonPipeDispatcher = __nccwpck_require__(9764);

var _userAgent = __nccwpck_require__(5110);

var socks = _interopRequireWildcard(__nccwpck_require__(1570));

var _events = _interopRequireDefault(__nccwpck_require__(2361));

var _progress = __nccwpck_require__(2836);

var _transport = __nccwpck_require__(1232);

var _validator = __nccwpck_require__(7989);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserTypeDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, browserType) {
    super(scope, browserType, 'BrowserType', {
      executablePath: browserType.executablePath(),
      name: browserType.name()
    }, true);
    this._type_BrowserType = true;
  }

  async launch(params, metadata) {
    const browser = await this._object.launch(metadata, params);
    return {
      browser: new _browserDispatcher.BrowserDispatcher(this._scope, browser)
    };
  }

  async launchPersistentContext(params, metadata) {
    const browserContext = await this._object.launchPersistentContext(metadata, params.userDataDir, params);
    return {
      context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, browserContext)
    };
  }

  async connectOverCDP(params, metadata) {
    const browser = await this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
    const browserDispatcher = new _browserDispatcher.BrowserDispatcher(this._scope, browser);
    return {
      browser: browserDispatcher,
      defaultContext: browser._defaultContext ? new _browserContextDispatcher.BrowserContextDispatcher(browserDispatcher._scope, browser._defaultContext) : undefined
    };
  }

  async connect(params, metadata) {
    const controller = new _progress.ProgressController(metadata, this._object);
    controller.setLogName('browser');
    return await controller.run(async progress => {
      const paramsHeaders = Object.assign({
        'User-Agent': (0, _userAgent.getUserAgent)()
      }, params.headers || {});
      const transport = await _transport.WebSocketTransport.connect(progress, params.wsEndpoint, paramsHeaders, true);
      let socksInterceptor;
      const pipe = new _jsonPipeDispatcher.JsonPipeDispatcher(this._scope);

      transport.onmessage = json => {
        var _socksInterceptor;

        if (json.method === '__create__' && json.params.type === 'SocksSupport') socksInterceptor = new SocksInterceptor(transport, params.socksProxyRedirectPortForTest, json.params.guid);
        if ((_socksInterceptor = socksInterceptor) !== null && _socksInterceptor !== void 0 && _socksInterceptor.interceptMessage(json)) return;

        const cb = () => {
          try {
            pipe.dispatch(json);
          } catch (e) {
            transport.close();
          }
        };

        if (params.slowMo) setTimeout(cb, params.slowMo);else cb();
      };

      pipe.on('message', message => {
        transport.send(message);
      });

      transport.onclose = () => {
        var _socksInterceptor2;

        (_socksInterceptor2 = socksInterceptor) === null || _socksInterceptor2 === void 0 ? void 0 : _socksInterceptor2.cleanup();
        pipe.wasClosed();
      };

      pipe.on('close', () => transport.close());
      return {
        pipe
      };
    }, params.timeout || 0);
  }

}

exports.BrowserTypeDispatcher = BrowserTypeDispatcher;

class SocksInterceptor {
  constructor(transport, redirectPortForTest, socksSupportObjectGuid) {
    this._handler = void 0;
    this._channel = void 0;
    this._socksSupportObjectGuid = void 0;
    this._ids = new Set();
    this._handler = new socks.SocksProxyHandler(redirectPortForTest);
    this._socksSupportObjectGuid = socksSupportObjectGuid;
    let lastId = -1;
    this._channel = new Proxy(new _events.default(), {
      get: (obj, prop) => {
        if (prop in obj || obj[prop] !== undefined || typeof prop !== 'string') return obj[prop];
        return params => {
          try {
            const id = --lastId;

            this._ids.add(id);

            const validator = (0, _validator.findValidator)('SocksSupport', prop, 'Params');
            params = validator(params, '', {
              tChannelImpl: tChannelForSocks,
              binary: 'toBase64'
            });
            transport.send({
              id,
              guid: socksSupportObjectGuid,
              method: prop,
              params,
              metadata: {
                stack: [],
                apiName: '',
                internal: true
              }
            });
          } catch (e) {}
        };
      }
    });

    this._handler.on(socks.SocksProxyHandler.Events.SocksConnected, payload => this._channel.socksConnected(payload));

    this._handler.on(socks.SocksProxyHandler.Events.SocksData, payload => this._channel.socksData(payload));

    this._handler.on(socks.SocksProxyHandler.Events.SocksError, payload => this._channel.socksError(payload));

    this._handler.on(socks.SocksProxyHandler.Events.SocksFailed, payload => this._channel.socksFailed(payload));

    this._handler.on(socks.SocksProxyHandler.Events.SocksEnd, payload => this._channel.socksEnd(payload));

    this._channel.on('socksRequested', payload => this._handler.socketRequested(payload));

    this._channel.on('socksClosed', payload => this._handler.socketClosed(payload));

    this._channel.on('socksData', payload => this._handler.sendSocketData(payload));
  }

  cleanup() {
    this._handler.cleanup();
  }

  interceptMessage(message) {
    if (this._ids.has(message.id)) {
      this._ids.delete(message.id);

      return true;
    }

    if (message.guid === this._socksSupportObjectGuid) {
      const validator = (0, _validator.findValidator)('SocksSupport', message.method, 'Event');
      const params = validator(message.params, '', {
        tChannelImpl: tChannelForSocks,
        binary: 'fromBase64'
      });

      this._channel.emit(message.method, params);

      return true;
    }

    return false;
  }

}

function tChannelForSocks(names, arg, path, context) {
  throw new _validator.ValidationError(`${path}: channels are not expected in SocksSupport`);
}

/***/ }),

/***/ 5223:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CDPSessionDispatcher = void 0;

var _crConnection = __nccwpck_require__(5460);

var _dispatcher = __nccwpck_require__(4098);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CDPSessionDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, crSession) {
    super(scope, crSession, 'CDPSession', {}, true);
    this._type_CDPSession = true;

    crSession._eventListener = (method, params) => {
      this._dispatchEvent('event', {
        method,
        params
      });
    };

    this.addObjectListener(_crConnection.CRSessionEvents.Disconnected, () => this._dispose());
  }

  async send(params) {
    return {
      result: await this._object.send(params.method, params.params)
    };
  }

  async detach() {
    return this._object.detach();
  }

}

exports.CDPSessionDispatcher = CDPSessionDispatcher;

/***/ }),

/***/ 3932:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ConsoleMessageDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _elementHandlerDispatcher = __nccwpck_require__(1311);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ConsoleMessageDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, message) {
    super(scope, message, 'ConsoleMessage', {
      type: message.type(),
      text: message.text(),
      args: message.args().map(a => _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, a)),
      location: message.location()
    });
    this._type_ConsoleMessage = true;
  }

}

exports.ConsoleMessageDispatcher = ConsoleMessageDispatcher;

/***/ }),

/***/ 1865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DialogDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DialogDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, dialog) {
    super(scope, dialog, 'Dialog', {
      type: dialog.type(),
      message: dialog.message(),
      defaultValue: dialog.defaultValue()
    });
    this._type_Dialog = true;
  }

  async accept(params) {
    await this._object.accept(params.promptText);
  }

  async dismiss() {
    await this._object.dismiss();
  }

}

exports.DialogDispatcher = DialogDispatcher;

/***/ }),

/***/ 4098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.dispatcherSymbol = exports.Root = exports.DispatcherConnection = exports.Dispatcher = void 0;
exports.existingDispatcher = existingDispatcher;
exports.lookupDispatcher = lookupDispatcher;
exports.lookupNullableDispatcher = lookupNullableDispatcher;

var _events = __nccwpck_require__(2361);

var _serializers = __nccwpck_require__(5644);

var _validator = __nccwpck_require__(7989);

var _utils = __nccwpck_require__(3557);

var _errors = __nccwpck_require__(542);

var _instrumentation = __nccwpck_require__(6686);

var _stackTrace = __nccwpck_require__(9030);

var _eventsHelper = __nccwpck_require__(3841);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dispatcherSymbol = Symbol('dispatcher');
exports.dispatcherSymbol = dispatcherSymbol;
const metadataValidator = (0, _validator.createMetadataValidator)();

function lookupDispatcher(object) {
  const result = object[dispatcherSymbol];
  (0, _utils.debugAssert)(result);
  return result;
}

function existingDispatcher(object) {
  return object[dispatcherSymbol];
}

function lookupNullableDispatcher(object) {
  return object ? lookupDispatcher(object) : undefined;
}

class Dispatcher extends _events.EventEmitter {
  // Parent is always "isScope".
  // Only "isScope" channel owners have registered dispatchers inside.
  constructor(parent, object, type, initializer, isScope) {
    super();
    this._connection = void 0;
    this._isScope = void 0;
    this._parent = void 0;
    this._dispatchers = new Map();
    this._disposed = false;
    this._eventListeners = [];
    this._guid = void 0;
    this._type = void 0;
    this._scope = void 0;
    this._object = void 0;
    this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
    this._isScope = !!isScope;
    this._parent = parent instanceof DispatcherConnection ? undefined : parent;
    this._scope = isScope ? this : this._parent;
    const guid = object.guid;
    (0, _utils.assert)(!this._connection._dispatchers.has(guid));

    this._connection._dispatchers.set(guid, this);

    if (this._parent) {
      (0, _utils.assert)(!this._parent._dispatchers.has(guid));

      this._parent._dispatchers.set(guid, this);
    }

    this._type = type;
    this._guid = guid;
    this._object = object;
    object[dispatcherSymbol] = this;
    if (this._parent) this._connection.sendCreate(this._parent, type, guid, initializer, this._parent._object);
  }

  addObjectListener(eventName, handler) {
    this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._object, eventName, handler));
  }

  adopt(child) {
    (0, _utils.assert)(this._isScope);
    const oldParent = child._parent;

    oldParent._dispatchers.delete(child._guid);

    this._dispatchers.set(child._guid, child);

    child._parent = this;

    this._connection.sendAdopt(this, child);
  }

  _dispatchEvent(method, params) {
    if (this._disposed) {
      if ((0, _utils.isUnderTest)()) throw new Error(`${this._guid} is sending "${String(method)}" event after being disposed`); // Just ignore this event outside of tests.

      return;
    }

    const sdkObject = this._object instanceof _instrumentation.SdkObject ? this._object : undefined;

    this._connection.sendEvent(this, method, params, sdkObject);
  }

  _dispose() {
    (0, _utils.assert)(!this._disposed, `${this._guid} is disposed more than once`);
    this._disposed = true;

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners); // Clean up from parent and connection.


    if (this._parent) this._parent._dispatchers.delete(this._guid);

    this._connection._dispatchers.delete(this._guid); // Dispose all children.


    for (const dispatcher of [...this._dispatchers.values()]) dispatcher._dispose();

    this._dispatchers.clear();

    if (this._isScope) this._connection.sendDispose(this);
    delete this._object[dispatcherSymbol];
  }

  _debugScopeState() {
    return {
      _guid: this._guid,
      objects: Array.from(this._dispatchers.values()).map(o => o._debugScopeState())
    };
  }

  async waitForEventInfo() {// Instrumentation takes care of this.
  }

}

exports.Dispatcher = Dispatcher;

class Root extends Dispatcher {
  constructor(connection, createPlaywright) {
    super(connection, {
      guid: ''
    }, 'Root', {}, true);
    this._initialized = false;
    this.createPlaywright = createPlaywright;
  }

  async initialize(params) {
    (0, _utils.assert)(this.createPlaywright);
    (0, _utils.assert)(!this._initialized);
    this._initialized = true;
    return {
      playwright: await this.createPlaywright(this, params)
    };
  }

}

exports.Root = Root;

class DispatcherConnection {
  constructor(isLocal) {
    this._dispatchers = new Map();

    this.onmessage = message => {};

    this._waitOperations = new Map();
    this._isLocal = void 0;
    this._isLocal = !!isLocal;
  }

  sendEvent(dispatcher, event, params, sdkObject) {
    const validator = (0, _validator.findValidator)(dispatcher._type, event, 'Event');
    params = validator(params, '', {
      tChannelImpl: this._tChannelImplToWire.bind(this),
      binary: this._isLocal ? 'buffer' : 'toBase64'
    });

    this._sendMessageToClient(dispatcher._guid, dispatcher._type, event, params, sdkObject);
  }

  sendCreate(parent, type, guid, initializer, sdkObject) {
    const validator = (0, _validator.findValidator)(type, '', 'Initializer');
    initializer = validator(initializer, '', {
      tChannelImpl: this._tChannelImplToWire.bind(this),
      binary: this._isLocal ? 'buffer' : 'toBase64'
    });

    this._sendMessageToClient(parent._guid, type, '__create__', {
      type,
      initializer,
      guid
    }, sdkObject);
  }

  sendAdopt(parent, dispatcher) {
    this._sendMessageToClient(parent._guid, dispatcher._type, '__adopt__', {
      guid: dispatcher._guid
    });
  }

  sendDispose(dispatcher) {
    this._sendMessageToClient(dispatcher._guid, dispatcher._type, '__dispose__', {});
  }

  _sendMessageToClient(guid, type, method, params, sdkObject) {
    if (sdkObject) {
      var _sdkObject$attributio, _sdkObject$attributio2, _sdkObject$attributio3, _sdkObject$attributio4, _sdkObject$instrument;

      const eventMetadata = {
        id: `event@${++lastEventId}`,
        objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
        pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio = sdkObject.attribution) === null || _sdkObject$attributio === void 0 ? void 0 : (_sdkObject$attributio2 = _sdkObject$attributio.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.guid,
        frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio3 = sdkObject.attribution) === null || _sdkObject$attributio3 === void 0 ? void 0 : (_sdkObject$attributio4 = _sdkObject$attributio3.frame) === null || _sdkObject$attributio4 === void 0 ? void 0 : _sdkObject$attributio4.guid,
        wallTime: Date.now(),
        startTime: (0, _utils.monotonicTime)(),
        endTime: 0,
        type,
        method,
        params: params || {},
        log: [],
        snapshots: []
      };
      (_sdkObject$instrument = sdkObject.instrumentation) === null || _sdkObject$instrument === void 0 ? void 0 : _sdkObject$instrument.onEvent(sdkObject, eventMetadata);
    }

    this.onmessage({
      guid,
      method,
      params
    });
  }

  _tChannelImplFromWire(names, arg, path, context) {
    if (arg && typeof arg === 'object' && typeof arg.guid === 'string') {
      const guid = arg.guid;

      const dispatcher = this._dispatchers.get(guid);

      if (!dispatcher) throw new _validator.ValidationError(`${path}: no object with guid ${guid}`);
      if (names !== '*' && !names.includes(dispatcher._type)) throw new _validator.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${names.toString()}`);
      return dispatcher;
    }

    throw new _validator.ValidationError(`${path}: expected guid for ${names.toString()}`);
  }

  _tChannelImplToWire(names, arg, path, context) {
    if (arg instanceof Dispatcher) {
      if (names !== '*' && !names.includes(arg._type)) throw new _validator.ValidationError(`${path}: dispatcher with guid ${arg._guid} has type ${arg._type}, expected ${names.toString()}`);
      return {
        guid: arg._guid
      };
    }

    throw new _validator.ValidationError(`${path}: expected dispatcher ${names.toString()}`);
  }

  async dispatch(message) {
    var _sdkObject$attributio5, _sdkObject$attributio6, _sdkObject$attributio7, _sdkObject$attributio8, _params$info;

    const {
      id,
      guid,
      method,
      params,
      metadata
    } = message;

    const dispatcher = this._dispatchers.get(guid);

    if (!dispatcher) {
      this.onmessage({
        id,
        error: (0, _serializers.serializeError)(new Error(_errors.kBrowserOrContextClosedError))
      });
      return;
    }

    let validParams;
    let validMetadata;

    try {
      const validator = (0, _validator.findValidator)(dispatcher._type, method, 'Params');
      validParams = validator(params, '', {
        tChannelImpl: this._tChannelImplFromWire.bind(this),
        binary: this._isLocal ? 'buffer' : 'fromBase64'
      });
      validMetadata = metadataValidator(metadata, '', {
        tChannelImpl: this._tChannelImplFromWire.bind(this),
        binary: this._isLocal ? 'buffer' : 'fromBase64'
      });
      if (typeof dispatcher[method] !== 'function') throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
    } catch (e) {
      this.onmessage({
        id,
        error: (0, _serializers.serializeError)(e)
      });
      return;
    }

    const sdkObject = dispatcher._object instanceof _instrumentation.SdkObject ? dispatcher._object : undefined;
    const callMetadata = {
      id: `call@${id}`,
      stack: validMetadata.stack,
      apiName: validMetadata.apiName,
      internal: validMetadata.internal,
      objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
      pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio5 = sdkObject.attribution) === null || _sdkObject$attributio5 === void 0 ? void 0 : (_sdkObject$attributio6 = _sdkObject$attributio5.page) === null || _sdkObject$attributio6 === void 0 ? void 0 : _sdkObject$attributio6.guid,
      frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio7 = sdkObject.attribution) === null || _sdkObject$attributio7 === void 0 ? void 0 : (_sdkObject$attributio8 = _sdkObject$attributio7.frame) === null || _sdkObject$attributio8 === void 0 ? void 0 : _sdkObject$attributio8.guid,
      wallTime: Date.now(),
      startTime: (0, _utils.monotonicTime)(),
      endTime: 0,
      type: dispatcher._type,
      method,
      params: params || {},
      log: [],
      snapshots: []
    };

    if (sdkObject && params !== null && params !== void 0 && (_params$info = params.info) !== null && _params$info !== void 0 && _params$info.waitId) {
      // Process logs for waitForNavigation/waitForLoadState/etc.
      const info = params.info;

      switch (info.phase) {
        case 'before':
          {
            this._waitOperations.set(info.waitId, callMetadata);

            await sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
            this.onmessage({
              id
            });
            return;
          }

        case 'log':
          {
            const originalMetadata = this._waitOperations.get(info.waitId);

            originalMetadata.log.push(info.message);
            sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, 'api', info.message);
            this.onmessage({
              id
            });
            return;
          }

        case 'after':
          {
            const originalMetadata = this._waitOperations.get(info.waitId);

            originalMetadata.endTime = (0, _utils.monotonicTime)();
            originalMetadata.error = info.error ? {
              error: {
                name: 'Error',
                message: info.error
              }
            } : undefined;

            this._waitOperations.delete(info.waitId);

            await sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
            this.onmessage({
              id
            });
            return;
          }
      }
    }

    let error;
    await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata));

    try {
      const result = await dispatcher[method](validParams, callMetadata);
      const validator = (0, _validator.findValidator)(dispatcher._type, method, 'Result');
      callMetadata.result = validator(result, '', {
        tChannelImpl: this._tChannelImplToWire.bind(this),
        binary: this._isLocal ? 'buffer' : 'toBase64'
      });
    } catch (e) {
      // Dispatching error
      // We want original, unmodified error in metadata.
      callMetadata.error = (0, _serializers.serializeError)(e);
      if (callMetadata.log.length) (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(callMetadata.log));
      error = (0, _serializers.serializeError)(e);
    } finally {
      callMetadata.endTime = (0, _utils.monotonicTime)();
      await (sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata));
    }

    const response = {
      id
    };
    if (callMetadata.result) response.result = callMetadata.result;
    if (error) response.error = error;
    this.onmessage(response);
  }

}

exports.DispatcherConnection = DispatcherConnection;

function formatLogRecording(log) {
  if (!log.length) return '';
  const header = ` logs `;
  const headerLength = 60;
  const leftLength = (headerLength - header.length) / 2;
  const rightLength = headerLength - header.length - leftLength;
  return `\n${'='.repeat(leftLength)}${header}${'='.repeat(rightLength)}\n${log.join('\n')}\n${'='.repeat(headerLength)}`;
}

let lastEventId = 0;

/***/ }),

/***/ 1733:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ElectronDispatcher = exports.ElectronApplicationDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _electron = __nccwpck_require__(9229);

var _browserContextDispatcher = __nccwpck_require__(6170);

var _jsHandleDispatcher = __nccwpck_require__(3652);

var _elementHandlerDispatcher = __nccwpck_require__(1311);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ElectronDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, electron) {
    super(scope, electron, 'Electron', {}, true);
    this._type_Electron = true;
  }

  async launch(params) {
    const electronApplication = await this._object.launch(params);
    return {
      electronApplication: new ElectronApplicationDispatcher(this._scope, electronApplication)
    };
  }

}

exports.ElectronDispatcher = ElectronDispatcher;

class ElectronApplicationDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, electronApplication) {
    super(scope, electronApplication, 'ElectronApplication', {
      context: new _browserContextDispatcher.BrowserContextDispatcher(scope, electronApplication.context())
    }, true);
    this._type_EventTarget = true;
    this._type_ElectronApplication = true;
    this.addObjectListener(_electron.ElectronApplication.Events.Close, () => {
      this._dispatchEvent('close');

      this._dispose();
    });
  }

  async browserWindow(params) {
    const handle = await this._object.browserWindow(params.page.page());
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, handle)
    };
  }

  async evaluateExpression(params) {
    const handle = await this._object._nodeElectronHandlePromise;
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true
      /* returnByValue */
      , (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

  async evaluateExpressionHandle(params) {
    const handle = await this._object._nodeElectronHandlePromise;
    const result = await handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false
    /* returnByValue */
    , (0, _jsHandleDispatcher.parseArgument)(params.arg));
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, result)
    };
  }

  async close() {
    await this._object.close();
  }

}

exports.ElectronApplicationDispatcher = ElectronApplicationDispatcher;

/***/ }),

/***/ 1311:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ElementHandleDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _jsHandleDispatcher = __nccwpck_require__(3652);

var _utils = __nccwpck_require__(3557);

var _path = _interopRequireDefault(__nccwpck_require__(1017));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ElementHandleDispatcher extends _jsHandleDispatcher.JSHandleDispatcher {
  static from(scope, handle) {
    return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
  }

  static fromNullable(scope, handle) {
    if (!handle) return undefined;
    return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
  }

  static fromJSHandle(scope, handle) {
    const result = (0, _dispatcher.existingDispatcher)(handle);
    if (result) return result;
    return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new _jsHandleDispatcher.JSHandleDispatcher(scope, handle);
  }

  constructor(scope, elementHandle) {
    super(scope, elementHandle);
    this._type_ElementHandle = true;
    this._elementHandle = void 0;
    this._elementHandle = elementHandle;
  }

  async ownerFrame(params, metadata) {
    return {
      frame: (0, _dispatcher.lookupNullableDispatcher)(await this._elementHandle.ownerFrame())
    };
  }

  async contentFrame(params, metadata) {
    return {
      frame: (0, _dispatcher.lookupNullableDispatcher)(await this._elementHandle.contentFrame())
    };
  }

  async getAttribute(params, metadata) {
    const value = await this._elementHandle.getAttribute(params.name);
    return {
      value: value === null ? undefined : value
    };
  }

  async inputValue(params, metadata) {
    const value = await this._elementHandle.inputValue();
    return {
      value
    };
  }

  async textContent(params, metadata) {
    const value = await this._elementHandle.textContent();
    return {
      value: value === null ? undefined : value
    };
  }

  async innerText(params, metadata) {
    return {
      value: await this._elementHandle.innerText()
    };
  }

  async innerHTML(params, metadata) {
    return {
      value: await this._elementHandle.innerHTML()
    };
  }

  async isChecked(params, metadata) {
    return {
      value: await this._elementHandle.isChecked()
    };
  }

  async isDisabled(params, metadata) {
    return {
      value: await this._elementHandle.isDisabled()
    };
  }

  async isEditable(params, metadata) {
    return {
      value: await this._elementHandle.isEditable()
    };
  }

  async isEnabled(params, metadata) {
    return {
      value: await this._elementHandle.isEnabled()
    };
  }

  async isHidden(params, metadata) {
    return {
      value: await this._elementHandle.isHidden()
    };
  }

  async isVisible(params, metadata) {
    return {
      value: await this._elementHandle.isVisible()
    };
  }

  async dispatchEvent(params, metadata) {
    await this._elementHandle.dispatchEvent(params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit));
  }

  async scrollIntoViewIfNeeded(params, metadata) {
    await this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
  }

  async hover(params, metadata) {
    return await this._elementHandle.hover(metadata, params);
  }

  async click(params, metadata) {
    return await this._elementHandle.click(metadata, params);
  }

  async dblclick(params, metadata) {
    return await this._elementHandle.dblclick(metadata, params);
  }

  async tap(params, metadata) {
    return await this._elementHandle.tap(metadata, params);
  }

  async selectOption(params, metadata) {
    const elements = (params.elements || []).map(e => e._elementHandle);
    return {
      values: await this._elementHandle.selectOption(metadata, elements, params.options || [], params)
    };
  }

  async fill(params, metadata) {
    return await this._elementHandle.fill(metadata, params.value, params);
  }

  async selectText(params, metadata) {
    await this._elementHandle.selectText(metadata, params);
  }

  async setInputFiles(params, metadata) {
    return await this._elementHandle.setInputFiles(metadata, {
      files: params.files
    }, params);
  }

  async setInputFilePaths(params, metadata) {
    let {
      localPaths
    } = params;

    if (!localPaths) {
      if (!params.streams) throw new Error('Neither localPaths nor streams is specified');
      localPaths = params.streams.map(c => c.path());
    }

    for (const p of localPaths) (0, _utils.assert)(_path.default.isAbsolute(p) && _path.default.resolve(p) === p, 'Paths provided to localPaths must be absolute and fully resolved.');

    return await this._elementHandle.setInputFiles(metadata, {
      localPaths
    }, params);
  }

  async focus(params, metadata) {
    await this._elementHandle.focus(metadata);
  }

  async type(params, metadata) {
    return await this._elementHandle.type(metadata, params.text, params);
  }

  async press(params, metadata) {
    return await this._elementHandle.press(metadata, params.key, params);
  }

  async check(params, metadata) {
    return await this._elementHandle.check(metadata, params);
  }

  async uncheck(params, metadata) {
    return await this._elementHandle.uncheck(metadata, params);
  }

  async boundingBox(params, metadata) {
    const value = await this._elementHandle.boundingBox();
    return {
      value: value || undefined
    };
  }

  async screenshot(params, metadata) {
    const mask = (params.mask || []).map(({
      frame,
      selector
    }) => ({
      frame: frame._object,
      selector
    }));
    return {
      binary: await this._elementHandle.screenshot(metadata, { ...params,
        mask
      })
    };
  }

  async querySelector(params, metadata) {
    const handle = await this._elementHandle.querySelector(params.selector, params);
    return {
      element: ElementHandleDispatcher.fromNullable(this._scope, handle)
    };
  }

  async querySelectorAll(params, metadata) {
    const elements = await this._elementHandle.querySelectorAll(params.selector);
    return {
      elements: elements.map(e => ElementHandleDispatcher.from(this._scope, e))
    };
  }

  async evalOnSelector(params, metadata) {
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

  async evalOnSelectorAll(params, metadata) {
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

  async waitForElementState(params, metadata) {
    await this._elementHandle.waitForElementState(metadata, params.state, params);
  }

  async waitForSelector(params, metadata) {
    return {
      element: ElementHandleDispatcher.fromNullable(this._scope, await this._elementHandle.waitForSelector(metadata, params.selector, params))
    };
  }

}

exports.ElementHandleDispatcher = ElementHandleDispatcher;

/***/ }),

/***/ 9151:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FrameDispatcher = void 0;

var _frames = __nccwpck_require__(8895);

var _dispatcher = __nccwpck_require__(4098);

var _elementHandlerDispatcher = __nccwpck_require__(1311);

var _jsHandleDispatcher = __nccwpck_require__(3652);

var _networkDispatchers = __nccwpck_require__(1584);

var _utils = __nccwpck_require__(3557);

var _path = _interopRequireDefault(__nccwpck_require__(1017));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FrameDispatcher extends _dispatcher.Dispatcher {
  static from(scope, frame) {
    const result = (0, _dispatcher.existingDispatcher)(frame);
    return result || new FrameDispatcher(scope, frame);
  }

  static fromNullable(scope, frame) {
    if (!frame) return;
    return FrameDispatcher.from(scope, frame);
  }

  constructor(scope, frame) {
    super(scope, frame, 'Frame', {
      url: frame.url(),
      name: frame.name(),
      parentFrame: FrameDispatcher.fromNullable(scope, frame.parentFrame()),
      loadStates: Array.from(frame._subtreeLifecycleEvents)
    });
    this._type_Frame = true;
    this._frame = void 0;
    this._frame = frame;
    this.addObjectListener(_frames.Frame.Events.AddLifecycle, lifecycleEvent => {
      this._dispatchEvent('loadstate', {
        add: lifecycleEvent
      });
    });
    this.addObjectListener(_frames.Frame.Events.RemoveLifecycle, lifecycleEvent => {
      this._dispatchEvent('loadstate', {
        remove: lifecycleEvent
      });
    });
    this.addObjectListener(_frames.Frame.Events.InternalNavigation, event => {
      if (!event.isPublic) return;
      const params = {
        url: event.url,
        name: event.name,
        error: event.error ? event.error.message : undefined
      };
      if (event.newDocument) params.newDocument = {
        request: _networkDispatchers.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null)
      };

      this._dispatchEvent('navigated', params);
    });
  }

  async goto(params, metadata) {
    return {
      response: (0, _dispatcher.lookupNullableDispatcher)(await this._frame.goto(metadata, params.url, params))
    };
  }

  async frameElement() {
    return {
      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, await this._frame.frameElement())
    };
  }

  async evaluateExpression(params, metadata) {
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), 'main'))
    };
  }

  async evaluateExpressionHandle(params, metadata) {
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), 'main'))
    };
  }

  async waitForSelector(params, metadata) {
    return {
      element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.waitForSelector(metadata, params.selector, params))
    };
  }

  async dispatchEvent(params, metadata) {
    return this._frame.dispatchEvent(metadata, params.selector, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit), params);
  }

  async evalOnSelector(params, metadata) {
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

  async evalOnSelectorAll(params, metadata) {
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

  async querySelector(params, metadata) {
    return {
      element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, await this._frame.querySelector(params.selector, params))
    };
  }

  async querySelectorAll(params, metadata) {
    const elements = await this._frame.querySelectorAll(params.selector);
    return {
      elements: elements.map(e => _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, e))
    };
  }

  async queryCount(params) {
    return {
      value: await this._frame.queryCount(params.selector)
    };
  }

  async content() {
    return {
      value: await this._frame.content()
    };
  }

  async setContent(params, metadata) {
    return await this._frame.setContent(metadata, params.html, params);
  }

  async addScriptTag(params, metadata) {
    return {
      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, await this._frame.addScriptTag(params))
    };
  }

  async addStyleTag(params, metadata) {
    return {
      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, await this._frame.addStyleTag(params))
    };
  }

  async click(params, metadata) {
    return await this._frame.click(metadata, params.selector, params);
  }

  async dblclick(params, metadata) {
    return await this._frame.dblclick(metadata, params.selector, params);
  }

  async dragAndDrop(params, metadata) {
    return await this._frame.dragAndDrop(metadata, params.source, params.target, params);
  }

  async tap(params, metadata) {
    return await this._frame.tap(metadata, params.selector, params);
  }

  async fill(params, metadata) {
    return await this._frame.fill(metadata, params.selector, params.value, params);
  }

  async focus(params, metadata) {
    await this._frame.focus(metadata, params.selector, params);
  }

  async textContent(params, metadata) {
    const value = await this._frame.textContent(metadata, params.selector, params);
    return {
      value: value === null ? undefined : value
    };
  }

  async innerText(params, metadata) {
    return {
      value: await this._frame.innerText(metadata, params.selector, params)
    };
  }

  async innerHTML(params, metadata) {
    return {
      value: await this._frame.innerHTML(metadata, params.selector, params)
    };
  }

  async getAttribute(params, metadata) {
    const value = await this._frame.getAttribute(metadata, params.selector, params.name, params);
    return {
      value: value === null ? undefined : value
    };
  }

  async inputValue(params, metadata) {
    const value = await this._frame.inputValue(metadata, params.selector, params);
    return {
      value
    };
  }

  async isChecked(params, metadata) {
    return {
      value: await this._frame.isChecked(metadata, params.selector, params)
    };
  }

  async isDisabled(params, metadata) {
    return {
      value: await this._frame.isDisabled(metadata, params.selector, params)
    };
  }

  async isEditable(params, metadata) {
    return {
      value: await this._frame.isEditable(metadata, params.selector, params)
    };
  }

  async isEnabled(params, metadata) {
    return {
      value: await this._frame.isEnabled(metadata, params.selector, params)
    };
  }

  async isHidden(params, metadata) {
    return {
      value: await this._frame.isHidden(metadata, params.selector, params)
    };
  }

  async isVisible(params, metadata) {
    return {
      value: await this._frame.isVisible(metadata, params.selector, params)
    };
  }

  async hover(params, metadata) {
    return await this._frame.hover(metadata, params.selector, params);
  }

  async selectOption(params, metadata) {
    const elements = (params.elements || []).map(e => e._elementHandle);
    return {
      values: await this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)
    };
  }

  async setInputFiles(params, metadata) {
    return await this._frame.setInputFiles(metadata, params.selector, {
      files: params.files
    }, params);
  }

  async setInputFilePaths(params, metadata) {
    let {
      localPaths
    } = params;

    if (!localPaths) {
      if (!params.streams) throw new Error('Neither localPaths nor streams is specified');
      localPaths = params.streams.map(c => c.path());
    }

    for (const p of localPaths) (0, _utils.assert)(_path.default.isAbsolute(p) && _path.default.resolve(p) === p, 'Paths provided to localPaths must be absolute and fully resolved.');

    return await this._frame.setInputFiles(metadata, params.selector, {
      localPaths
    }, params);
  }

  async type(params, metadata) {
    return await this._frame.type(metadata, params.selector, params.text, params);
  }

  async press(params, metadata) {
    return await this._frame.press(metadata, params.selector, params.key, params);
  }

  async check(params, metadata) {
    return await this._frame.check(metadata, params.selector, params);
  }

  async uncheck(params, metadata) {
    return await this._frame.uncheck(metadata, params.selector, params);
  }

  async waitForTimeout(params, metadata) {
    return await this._frame.waitForTimeout(metadata, params.timeout);
  }

  async waitForFunction(params, metadata) {
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, await this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), params))
    };
  }

  async title(params, metadata) {
    return {
      value: await this._frame.title()
    };
  }

  async highlight(params, metadata) {
    return await this._frame.highlight(params.selector);
  }

  async expect(params, metadata) {
    const expectedValue = params.expectedValue ? (0, _jsHandleDispatcher.parseArgument)(params.expectedValue) : undefined;
    const result = await this._frame.expect(metadata, params.selector, { ...params,
      expectedValue
    });
    if (result.received !== undefined) result.received = (0, _jsHandleDispatcher.serializeResult)(result.received);
    if (result.matches === params.isNot) metadata.error = {
      error: {
        name: 'Expect',
        message: 'Expect failed'
      }
    };
    return result;
  }

}

exports.FrameDispatcher = FrameDispatcher;

/***/ }),

/***/ 3652:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JSHandleDispatcher = void 0;
exports.parseArgument = parseArgument;
exports.parseValue = parseValue;
exports.serializeResult = serializeResult;

var _dispatcher = __nccwpck_require__(4098);

var _elementHandlerDispatcher = __nccwpck_require__(1311);

var _serializers = __nccwpck_require__(5644);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JSHandleDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, jsHandle) {
    // Do not call this directly, use createHandle() instead.
    super(scope, jsHandle, jsHandle.asElement() ? 'ElementHandle' : 'JSHandle', {
      preview: jsHandle.toString()
    });
    this._type_JSHandle = true;

    jsHandle._setPreviewCallback(preview => this._dispatchEvent('previewUpdated', {
      preview
    }));
  }

  async evaluateExpression(params) {
    return {
      value: serializeResult(await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true
      /* returnByValue */
      , parseArgument(params.arg)))
    };
  }

  async evaluateExpressionHandle(params) {
    const jsHandle = await this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false
    /* returnByValue */
    , parseArgument(params.arg));
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
    };
  }

  async getProperty(params) {
    const jsHandle = await this._object.getProperty(params.name);
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
    };
  }

  async getPropertyList() {
    const map = await this._object.getProperties();
    const properties = [];

    for (const [name, value] of map) properties.push({
      name,
      value: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, value)
    });

    return {
      properties
    };
  }

  async jsonValue() {
    return {
      value: serializeResult(await this._object.jsonValue())
    };
  }

  async dispose() {
    await this._object.dispose();
  }

} // Generic channel parser converts guids to JSHandleDispatchers,
// and this function takes care of coverting them into underlying JSHandles.


exports.JSHandleDispatcher = JSHandleDispatcher;

function parseArgument(arg) {
  return (0, _serializers.parseSerializedValue)(arg.value, arg.handles.map(a => a._object));
}

function parseValue(v) {
  return (0, _serializers.parseSerializedValue)(v, []);
}

function serializeResult(arg) {
  return (0, _serializers.serializeValue)(arg, value => ({
    fallThrough: value
  }));
}

/***/ }),

/***/ 9764:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JsonPipeDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _utils = __nccwpck_require__(3557);

var _serializers = __nccwpck_require__(5644);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JsonPipeDispatcher extends _dispatcher.Dispatcher {
  constructor(scope) {
    super(scope, {
      guid: 'jsonPipe@' + (0, _utils.createGuid)()
    }, 'JsonPipe', {});
    this._type_JsonPipe = true;
  }

  async send(params) {
    this.emit('message', params.message);
  }

  async close() {
    this.emit('close');

    if (!this._disposed) {
      this._dispatchEvent('closed', {});

      this._dispose();
    }
  }

  dispatch(message) {
    if (!this._disposed) this._dispatchEvent('message', {
      message
    });
  }

  wasClosed(error) {
    if (!this._disposed) {
      const params = error ? {
        error: (0, _serializers.serializeError)(error)
      } : {};

      this._dispatchEvent('closed', params);

      this._dispose();
    }
  }

  dispose() {
    this._dispose();
  }

}

exports.JsonPipeDispatcher = JsonPipeDispatcher;

/***/ }),

/***/ 1392:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LocalUtilsDispatcher = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _manualPromise = __nccwpck_require__(6729);

var _utils = __nccwpck_require__(3557);

var _dispatcher = __nccwpck_require__(4098);

var _zipBundle = __nccwpck_require__(6383);

var _zipFile = __nccwpck_require__(6435);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocalUtilsDispatcher extends _dispatcher.Dispatcher {
  constructor(scope) {
    super(scope, {
      guid: 'localUtils@' + (0, _utils.createGuid)()
    }, 'LocalUtils', {});
    this._type_LocalUtils = void 0;
    this._harBakends = new Map();
    this._type_LocalUtils = true;
  }

  async zip(params, metadata) {
    const promise = new _manualPromise.ManualPromise();
    const zipFile = new _zipBundle.yazl.ZipFile();
    zipFile.on('error', error => promise.reject(error));

    for (const entry of params.entries) {
      try {
        if (_fs.default.statSync(entry.value).isFile()) zipFile.addFile(entry.value, entry.name);
      } catch (e) {}
    }

    if (!_fs.default.existsSync(params.zipFile)) {
      // New file, just compress the entries.
      await _fs.default.promises.mkdir(_path.default.dirname(params.zipFile), {
        recursive: true
      });
      zipFile.end(undefined, () => {
        zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on('close', () => promise.resolve());
      });
      return promise;
    } // File already exists. Repack and add new entries.


    const tempFile = params.zipFile + '.tmp';
    await _fs.default.promises.rename(params.zipFile, tempFile);

    _zipBundle.yauzl.open(tempFile, (err, inZipFile) => {
      if (err) {
        promise.reject(err);
        return;
      }

      (0, _utils.assert)(inZipFile);
      let pendingEntries = inZipFile.entryCount;
      inZipFile.on('entry', entry => {
        inZipFile.openReadStream(entry, (err, readStream) => {
          if (err) {
            promise.reject(err);
            return;
          }

          zipFile.addReadStream(readStream, entry.fileName);

          if (--pendingEntries === 0) {
            zipFile.end(undefined, () => {
              zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on('close', () => {
                _fs.default.promises.unlink(tempFile).then(() => {
                  promise.resolve();
                });
              });
            });
          }
        });
      });
    });

    return promise;
  }

  async harOpen(params, metadata) {
    let harBackend;

    if (params.file.endsWith('.zip')) {
      const zipFile = new _zipFile.ZipFile(params.file);
      const entryNames = await zipFile.entries();
      const harEntryName = entryNames.find(e => e.endsWith('.har'));
      if (!harEntryName) return {
        error: 'Specified archive does not have a .har file'
      };
      const har = await zipFile.read(harEntryName);
      const harFile = JSON.parse(har.toString());
      harBackend = new HarBackend(harFile, null, zipFile);
    } else {
      const harFile = JSON.parse(await _fs.default.promises.readFile(params.file, 'utf-8'));
      harBackend = new HarBackend(harFile, _path.default.dirname(params.file), null);
    }

    this._harBakends.set(harBackend.id, harBackend);

    return {
      harId: harBackend.id
    };
  }

  async harLookup(params, metadata) {
    const harBackend = this._harBakends.get(params.harId);

    if (!harBackend) return {
      action: 'error',
      message: `Internal error: har was not opened`
    };
    return await harBackend.lookup(params.url, params.method, params.headers, params.postData, params.isNavigationRequest);
  }

  async harClose(params, metadata) {
    const harBackend = this._harBakends.get(params.harId);

    if (harBackend) {
      this._harBakends.delete(harBackend.id);

      harBackend.dispose();
    }
  }

  async harUnzip(params, metadata) {
    const dir = _path.default.dirname(params.zipFile);

    const zipFile = new _zipFile.ZipFile(params.zipFile);

    for (const entry of await zipFile.entries()) {
      const buffer = await zipFile.read(entry);
      if (entry === 'har.har') await _fs.default.promises.writeFile(params.harFile, buffer);else await _fs.default.promises.writeFile(_path.default.join(dir, entry), buffer);
    }

    zipFile.close();
    await _fs.default.promises.unlink(params.zipFile);
  }

}

exports.LocalUtilsDispatcher = LocalUtilsDispatcher;
const redirectStatus = [301, 302, 303, 307, 308];

class HarBackend {
  constructor(harFile, baseDir, zipFile) {
    this.id = (0, _utils.createGuid)();
    this._harFile = void 0;
    this._zipFile = void 0;
    this._baseDir = void 0;
    this._harFile = harFile;
    this._baseDir = baseDir;
    this._zipFile = zipFile;
  }

  async lookup(url, method, headers, postData, isNavigationRequest) {
    let entry;

    try {
      entry = await this._harFindResponse(url, method, headers, postData);
    } catch (e) {
      return {
        action: 'error',
        message: 'HAR error: ' + e.message
      };
    }

    if (!entry) return {
      action: 'noentry'
    }; // If navigation is being redirected, restart it with the final url to ensure the document's url changes.

    if (entry.request.url !== url && isNavigationRequest) return {
      action: 'redirect',
      redirectURL: entry.request.url
    };
    const response = entry.response;

    try {
      const buffer = await this._loadContent(response.content);
      return {
        action: 'fulfill',
        status: response.status,
        headers: response.headers,
        body: buffer
      };
    } catch (e) {
      return {
        action: 'error',
        message: e.message
      };
    }
  }

  async _loadContent(content) {
    const file = content._file;
    let buffer;

    if (file) {
      if (this._zipFile) buffer = await this._zipFile.read(file);else buffer = await _fs.default.promises.readFile(_path.default.resolve(this._baseDir, file));
    } else {
      buffer = Buffer.from(content.text || '', content.encoding === 'base64' ? 'base64' : 'utf-8');
    }

    return buffer;
  }

  async _harFindResponse(url, method, headers, postData) {
    const harLog = this._harFile.log;
    const visited = new Set();

    while (true) {
      const entries = [];

      for (const candidate of harLog.entries) {
        if (candidate.request.url !== url || candidate.request.method !== method) continue;

        if (method === 'POST' && postData && candidate.request.postData) {
          const buffer = await this._loadContent(candidate.request.postData);
          if (!buffer.equals(postData)) continue;
        }

        entries.push(candidate);
      }

      if (!entries.length) return;
      let entry = entries[0]; // Disambiguate using headers - then one with most matching headers wins.

      if (entries.length > 1) {
        const list = [];

        for (const candidate of entries) {
          const matchingHeaders = countMatchingHeaders(candidate.request.headers, headers);
          list.push({
            candidate,
            matchingHeaders
          });
        }

        list.sort((a, b) => b.matchingHeaders - a.matchingHeaders);
        entry = list[0].candidate;
      }

      if (visited.has(entry)) throw new Error(`Found redirect cycle for ${url}`);
      visited.add(entry); // Follow redirects.

      const locationHeader = entry.response.headers.find(h => h.name.toLowerCase() === 'location');

      if (redirectStatus.includes(entry.response.status) && locationHeader) {
        const locationURL = new URL(locationHeader.value, url);
        url = locationURL.toString();

        if ((entry.response.status === 301 || entry.response.status === 302) && method === 'POST' || entry.response.status === 303 && !['GET', 'HEAD'].includes(method)) {
          // HTTP-redirect fetch step 13 (https://fetch.spec.whatwg.org/#http-redirect-fetch)
          method = 'GET';
        }

        continue;
      }

      return entry;
    }
  }

  dispose() {
    var _this$_zipFile;

    (_this$_zipFile = this._zipFile) === null || _this$_zipFile === void 0 ? void 0 : _this$_zipFile.close();
  }

}

function countMatchingHeaders(harHeaders, headers) {
  const set = new Set(headers.map(h => h.name.toLowerCase() + ':' + h.value));
  let matches = 0;

  for (const h of harHeaders) {
    if (set.has(h.name.toLowerCase() + ':' + h.value)) ++matches;
  }

  return matches;
}

/***/ }),

/***/ 1584:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocketDispatcher = exports.RouteDispatcher = exports.ResponseDispatcher = exports.RequestDispatcher = exports.APIRequestContextDispatcher = void 0;

var _network = __nccwpck_require__(3824);

var _dispatcher = __nccwpck_require__(4098);

var _frameDispatcher = __nccwpck_require__(9151);

var _pageDispatcher = __nccwpck_require__(7916);

var _tracingDispatcher = __nccwpck_require__(7178);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RequestDispatcher extends _dispatcher.Dispatcher {
  static from(scope, request) {
    const result = (0, _dispatcher.existingDispatcher)(request);
    return result || new RequestDispatcher(scope, request);
  }

  static fromNullable(scope, request) {
    return request ? RequestDispatcher.from(scope, request) : undefined;
  }

  constructor(scope, request) {
    const postData = request.postDataBuffer();
    super(scope, request, 'Request', {
      frame: _frameDispatcher.FrameDispatcher.fromNullable(scope, request.frame()),
      serviceWorker: _pageDispatcher.WorkerDispatcher.fromNullable(scope, request.serviceWorker()),
      url: request.url(),
      resourceType: request.resourceType(),
      method: request.method(),
      postData: postData === null ? undefined : postData,
      headers: request.headers(),
      isNavigationRequest: request.isNavigationRequest(),
      redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
    });
    this._type_Request = void 0;
    this._type_Request = true;
  }

  async rawRequestHeaders(params) {
    return {
      headers: await this._object.rawRequestHeaders()
    };
  }

  async response() {
    return {
      response: (0, _dispatcher.lookupNullableDispatcher)(await this._object.response())
    };
  }

}

exports.RequestDispatcher = RequestDispatcher;

class ResponseDispatcher extends _dispatcher.Dispatcher {
  static from(scope, response) {
    const result = (0, _dispatcher.existingDispatcher)(response);
    return result || new ResponseDispatcher(scope, response);
  }

  static fromNullable(scope, response) {
    return response ? ResponseDispatcher.from(scope, response) : undefined;
  }

  constructor(scope, response) {
    super(scope, response, 'Response', {
      // TODO: responses in popups can point to non-reported requests.
      request: RequestDispatcher.from(scope, response.request()),
      url: response.url(),
      status: response.status(),
      statusText: response.statusText(),
      headers: response.headers(),
      timing: response.timing(),
      fromServiceWorker: response.fromServiceWorker()
    });
    this._type_Response = true;
  }

  async body() {
    return {
      binary: await this._object.body()
    };
  }

  async securityDetails() {
    return {
      value: (await this._object.securityDetails()) || undefined
    };
  }

  async serverAddr() {
    return {
      value: (await this._object.serverAddr()) || undefined
    };
  }

  async rawResponseHeaders(params) {
    return {
      headers: await this._object.rawResponseHeaders()
    };
  }

  async sizes(params) {
    return {
      sizes: await this._object.sizes()
    };
  }

}

exports.ResponseDispatcher = ResponseDispatcher;

class RouteDispatcher extends _dispatcher.Dispatcher {
  static from(scope, route) {
    const result = (0, _dispatcher.existingDispatcher)(route);
    return result || new RouteDispatcher(scope, route);
  }

  constructor(scope, route) {
    super(scope, route, 'Route', {
      // Context route can point to a non-reported request.
      request: RequestDispatcher.from(scope, route.request())
    });
    this._type_Route = true;
  }

  async continue(params, metadata) {
    await this._object.continue({
      url: params.url,
      method: params.method,
      headers: params.headers,
      postData: params.postData
    });
  }

  async fulfill(params) {
    await this._object.fulfill(params);
  }

  async abort(params) {
    await this._object.abort(params.errorCode || 'failed');
  }

  async redirectNavigationRequest(params) {
    await this._object.redirectNavigationRequest(params.url);
  }

}

exports.RouteDispatcher = RouteDispatcher;

class WebSocketDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, webSocket) {
    super(scope, webSocket, 'WebSocket', {
      url: webSocket.url()
    });
    this._type_EventTarget = true;
    this._type_WebSocket = true;
    this.addObjectListener(_network.WebSocket.Events.FrameSent, event => this._dispatchEvent('frameSent', event));
    this.addObjectListener(_network.WebSocket.Events.FrameReceived, event => this._dispatchEvent('frameReceived', event));
    this.addObjectListener(_network.WebSocket.Events.SocketError, error => this._dispatchEvent('socketError', {
      error
    }));
    this.addObjectListener(_network.WebSocket.Events.Close, () => this._dispatchEvent('close', {}));
  }

}

exports.WebSocketDispatcher = WebSocketDispatcher;

class APIRequestContextDispatcher extends _dispatcher.Dispatcher {
  static from(scope, request) {
    const result = (0, _dispatcher.existingDispatcher)(request);
    return result || new APIRequestContextDispatcher(scope, request);
  }

  static fromNullable(scope, request) {
    return request ? APIRequestContextDispatcher.from(scope, request) : undefined;
  }

  constructor(parentScope, request) {
    // We will reparent these to the context below.
    const tracing = _tracingDispatcher.TracingDispatcher.from(parentScope, request.tracing());

    super(parentScope, request, 'APIRequestContext', {
      tracing
    }, true);
    this._type_APIRequestContext = true;
    this.adopt(tracing);
  }

  async storageState(params) {
    return this._object.storageState();
  }

  async dispose(params) {
    await this._object.dispose();
  }

  async fetch(params, metadata) {
    const fetchResponse = await this._object.fetch(params, metadata);
    return {
      response: {
        url: fetchResponse.url,
        status: fetchResponse.status,
        statusText: fetchResponse.statusText,
        headers: fetchResponse.headers,
        fetchUid: fetchResponse.fetchUid
      }
    };
  }

  async fetchResponseBody(params, metadata) {
    return {
      binary: this._object.fetchResponses.get(params.fetchUid)
    };
  }

  async fetchLog(params, metadata) {
    const log = this._object.fetchLog.get(params.fetchUid) || [];
    return {
      log
    };
  }

  async disposeAPIResponse(params, metadata) {
    this._object.disposeResponse(params.fetchUid);
  }

}

exports.APIRequestContextDispatcher = APIRequestContextDispatcher;

/***/ }),

/***/ 7916:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WorkerDispatcher = exports.PageDispatcher = exports.BindingCallDispatcher = void 0;

var _page = __nccwpck_require__(3555);

var _dispatcher = __nccwpck_require__(4098);

var _serializers = __nccwpck_require__(5644);

var _consoleMessageDispatcher = __nccwpck_require__(3932);

var _dialogDispatcher = __nccwpck_require__(1865);

var _frameDispatcher = __nccwpck_require__(9151);

var _networkDispatchers = __nccwpck_require__(1584);

var _jsHandleDispatcher = __nccwpck_require__(3652);

var _elementHandlerDispatcher = __nccwpck_require__(1311);

var _artifactDispatcher = __nccwpck_require__(2810);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PageDispatcher extends _dispatcher.Dispatcher {
  static fromNullable(parentScope, page) {
    if (!page) return undefined;
    const result = (0, _dispatcher.existingDispatcher)(page);
    return result || new PageDispatcher(parentScope, page);
  }

  constructor(parentScope, page) {
    // TODO: theoretically, there could be more than one frame already.
    // If we split pageCreated and pageReady, there should be no main frame during pageCreated.
    // We will reparent it to the page below using adopt.
    const mainFrame = _frameDispatcher.FrameDispatcher.from(parentScope, page.mainFrame());

    super(parentScope, page, 'Page', {
      mainFrame,
      viewportSize: page.viewportSize() || undefined,
      isClosed: page.isClosed(),
      opener: PageDispatcher.fromNullable(parentScope, page.opener())
    }, true);
    this._type_EventTarget = true;
    this._type_Page = true;
    this._page = void 0;
    this.adopt(mainFrame);
    this._page = page;
    this.addObjectListener(_page.Page.Events.Close, () => {
      this._dispatchEvent('close');

      this._dispose();
    });
    this.addObjectListener(_page.Page.Events.Console, message => this._dispatchEvent('console', {
      message: new _consoleMessageDispatcher.ConsoleMessageDispatcher(this._scope, message)
    }));
    this.addObjectListener(_page.Page.Events.Crash, () => this._dispatchEvent('crash'));
    this.addObjectListener(_page.Page.Events.Dialog, dialog => this._dispatchEvent('dialog', {
      dialog: new _dialogDispatcher.DialogDispatcher(this._scope, dialog)
    }));
    this.addObjectListener(_page.Page.Events.Download, download => {
      // Artifact can outlive the page, so bind to the context scope.
      this._dispatchEvent('download', {
        url: download.url,
        suggestedFilename: download.suggestedFilename(),
        artifact: new _artifactDispatcher.ArtifactDispatcher(parentScope, download.artifact)
      });
    });
    this.addObjectListener(_page.Page.Events.FileChooser, fileChooser => this._dispatchEvent('fileChooser', {
      element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, fileChooser.element()),
      isMultiple: fileChooser.isMultiple()
    }));
    this.addObjectListener(_page.Page.Events.FrameAttached, frame => this._onFrameAttached(frame));
    this.addObjectListener(_page.Page.Events.FrameDetached, frame => this._onFrameDetached(frame));
    this.addObjectListener(_page.Page.Events.PageError, error => this._dispatchEvent('pageError', {
      error: (0, _serializers.serializeError)(error)
    }));
    this.addObjectListener(_page.Page.Events.WebSocket, webSocket => this._dispatchEvent('webSocket', {
      webSocket: new _networkDispatchers.WebSocketDispatcher(this._scope, webSocket)
    }));
    this.addObjectListener(_page.Page.Events.Worker, worker => this._dispatchEvent('worker', {
      worker: new WorkerDispatcher(this._scope, worker)
    }));
    this.addObjectListener(_page.Page.Events.Video, artifact => this._dispatchEvent('video', {
      artifact: (0, _dispatcher.existingDispatcher)(artifact)
    }));
    if (page._video) this._dispatchEvent('video', {
      artifact: (0, _dispatcher.existingDispatcher)(page._video)
    }); // Ensure client knows about all frames.

    const frames = page._frameManager.frames();

    for (let i = 1; i < frames.length; i++) this._onFrameAttached(frames[i]);
  }

  page() {
    return this._page;
  }

  async setDefaultNavigationTimeoutNoReply(params, metadata) {
    this._page.setDefaultNavigationTimeout(params.timeout);
  }

  async setDefaultTimeoutNoReply(params, metadata) {
    this._page.setDefaultTimeout(params.timeout);
  }

  async exposeBinding(params, metadata) {
    await this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
      const binding = new BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);

      this._dispatchEvent('bindingCall', {
        binding
      });

      return binding.promise();
    });
  }

  async setExtraHTTPHeaders(params, metadata) {
    await this._page.setExtraHTTPHeaders(params.headers);
  }

  async reload(params, metadata) {
    return {
      response: (0, _dispatcher.lookupNullableDispatcher)(await this._page.reload(metadata, params))
    };
  }

  async goBack(params, metadata) {
    return {
      response: (0, _dispatcher.lookupNullableDispatcher)(await this._page.goBack(metadata, params))
    };
  }

  async goForward(params, metadata) {
    return {
      response: (0, _dispatcher.lookupNullableDispatcher)(await this._page.goForward(metadata, params))
    };
  }

  async emulateMedia(params, metadata) {
    await this._page.emulateMedia({
      media: params.media === 'null' ? null : params.media,
      colorScheme: params.colorScheme === 'null' ? null : params.colorScheme,
      reducedMotion: params.reducedMotion === 'null' ? null : params.reducedMotion,
      forcedColors: params.forcedColors === 'null' ? null : params.forcedColors
    });
  }

  async setViewportSize(params, metadata) {
    await this._page.setViewportSize(params.viewportSize);
  }

  async addInitScript(params, metadata) {
    await this._page.addInitScript(params.source);
  }

  async setNetworkInterceptionEnabled(params, metadata) {
    if (!params.enabled) {
      await this._page.setClientRequestInterceptor(undefined);
      return;
    }

    await this._page.setClientRequestInterceptor((route, request) => {
      this._dispatchEvent('route', {
        route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
        request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
      });
    });
  }

  async expectScreenshot(params, metadata) {
    var _params$screenshotOpt;

    const mask = (((_params$screenshotOpt = params.screenshotOptions) === null || _params$screenshotOpt === void 0 ? void 0 : _params$screenshotOpt.mask) || []).map(({
      frame,
      selector
    }) => ({
      frame: frame._object,
      selector
    }));
    const locator = params.locator ? {
      frame: params.locator.frame._object,
      selector: params.locator.selector
    } : undefined;
    return await this._page.expectScreenshot(metadata, { ...params,
      locator,
      screenshotOptions: { ...params.screenshotOptions,
        mask
      }
    });
  }

  async screenshot(params, metadata) {
    const mask = (params.mask || []).map(({
      frame,
      selector
    }) => ({
      frame: frame._object,
      selector
    }));
    return {
      binary: await this._page.screenshot(metadata, { ...params,
        mask
      })
    };
  }

  async close(params, metadata) {
    await this._page.close(metadata, params);
  }

  async setFileChooserInterceptedNoReply(params, metadata) {
    await this._page.setFileChooserIntercepted(params.intercepted);
  }

  async keyboardDown(params, metadata) {
    await this._page.keyboard.down(params.key);
  }

  async keyboardUp(params, metadata) {
    await this._page.keyboard.up(params.key);
  }

  async keyboardInsertText(params, metadata) {
    await this._page.keyboard.insertText(params.text);
  }

  async keyboardType(params, metadata) {
    await this._page.keyboard.type(params.text, params);
  }

  async keyboardPress(params, metadata) {
    await this._page.keyboard.press(params.key, params);
  }

  async mouseMove(params, metadata) {
    await this._page.mouse.move(params.x, params.y, params);
  }

  async mouseDown(params, metadata) {
    await this._page.mouse.down(params);
  }

  async mouseUp(params, metadata) {
    await this._page.mouse.up(params);
  }

  async mouseClick(params, metadata) {
    await this._page.mouse.click(params.x, params.y, params);
  }

  async mouseWheel(params, metadata) {
    await this._page.mouse.wheel(params.deltaX, params.deltaY);
  }

  async touchscreenTap(params, metadata) {
    await this._page.touchscreen.tap(params.x, params.y);
  }

  async accessibilitySnapshot(params, metadata) {
    const rootAXNode = await this._page.accessibility.snapshot({
      interestingOnly: params.interestingOnly,
      root: params.root ? params.root._elementHandle : undefined
    });
    return {
      rootAXNode: rootAXNode || undefined
    };
  }

  async pdf(params, metadata) {
    if (!this._page.pdf) throw new Error('PDF generation is only supported for Headless Chromium');
    const buffer = await this._page.pdf(params);
    return {
      pdf: buffer
    };
  }

  async bringToFront(params, metadata) {
    await this._page.bringToFront();
  }

  async startJSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    await coverage.startJSCoverage(params);
  }

  async stopJSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    return await coverage.stopJSCoverage();
  }

  async startCSSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    await coverage.startCSSCoverage(params);
  }

  async stopCSSCoverage(params, metadata) {
    const coverage = this._page.coverage;
    return await coverage.stopCSSCoverage();
  }

  _onFrameAttached(frame) {
    this._dispatchEvent('frameAttached', {
      frame: _frameDispatcher.FrameDispatcher.from(this._scope, frame)
    });
  }

  _onFrameDetached(frame) {
    this._dispatchEvent('frameDetached', {
      frame: (0, _dispatcher.lookupDispatcher)(frame)
    });
  }

  _dispose() {
    super._dispose();

    this._page.setClientRequestInterceptor(undefined).catch(() => {});
  }

}

exports.PageDispatcher = PageDispatcher;

class WorkerDispatcher extends _dispatcher.Dispatcher {
  static fromNullable(scope, worker) {
    if (!worker) return undefined;
    const result = (0, _dispatcher.existingDispatcher)(worker);
    return result || new WorkerDispatcher(scope, worker);
  }

  constructor(scope, worker) {
    super(scope, worker, 'Worker', {
      url: worker.url()
    });
    this._type_Worker = true;
    this.addObjectListener(_page.Worker.Events.Close, () => this._dispatchEvent('close'));
  }

  async evaluateExpression(params, metadata) {
    return {
      value: (0, _jsHandleDispatcher.serializeResult)(await this._object.evaluateExpression(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

  async evaluateExpressionHandle(params, metadata) {
    return {
      handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, await this._object.evaluateExpressionHandle(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
    };
  }

}

exports.WorkerDispatcher = WorkerDispatcher;

class BindingCallDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, name, needsHandle, source, args) {
    super(scope, {
      guid: 'bindingCall@' + (0, _utils.createGuid)()
    }, 'BindingCall', {
      frame: (0, _dispatcher.lookupDispatcher)(source.frame),
      name,
      args: needsHandle ? undefined : args.map(_jsHandleDispatcher.serializeResult),
      handle: needsHandle ? _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : undefined
    });
    this._type_BindingCall = true;
    this._resolve = void 0;
    this._reject = void 0;
    this._promise = void 0;
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
  }

  promise() {
    return this._promise;
  }

  async resolve(params, metadata) {
    this._resolve((0, _jsHandleDispatcher.parseArgument)(params.result));
  }

  async reject(params, metadata) {
    this._reject((0, _serializers.parseError)(params.error));
  }

}

exports.BindingCallDispatcher = BindingCallDispatcher;

/***/ }),

/***/ 8650:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PlaywrightDispatcher = void 0;

var _fetch = __nccwpck_require__(2857);

var _socksProxy = __nccwpck_require__(1570);

var _androidDispatcher = __nccwpck_require__(3037);

var _browserTypeDispatcher = __nccwpck_require__(6555);

var _dispatcher = __nccwpck_require__(4098);

var _electronDispatcher = __nccwpck_require__(1733);

var _localUtilsDispatcher = __nccwpck_require__(1392);

var _networkDispatchers = __nccwpck_require__(1584);

var _selectorsDispatcher = __nccwpck_require__(2222);

var _browserDispatcher = __nccwpck_require__(9241);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlaywrightDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, playwright, socksProxy, preLaunchedBrowser) {
    const descriptors = __nccwpck_require__(2327);

    const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({
      name,
      descriptor
    }));
    const browserDispatcher = preLaunchedBrowser ? new _browserDispatcher.ConnectedBrowserDispatcher(scope, preLaunchedBrowser) : undefined;
    super(scope, playwright, 'Playwright', {
      chromium: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.chromium),
      firefox: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.firefox),
      webkit: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.webkit),
      android: new _androidDispatcher.AndroidDispatcher(scope, playwright.android),
      electron: new _electronDispatcher.ElectronDispatcher(scope, playwright.electron),
      utils: new _localUtilsDispatcher.LocalUtilsDispatcher(scope),
      deviceDescriptors,
      selectors: new _selectorsDispatcher.SelectorsDispatcher(scope, (browserDispatcher === null || browserDispatcher === void 0 ? void 0 : browserDispatcher.selectors) || playwright.selectors),
      preLaunchedBrowser: browserDispatcher,
      socksSupport: socksProxy ? new SocksSupportDispatcher(scope, socksProxy) : undefined
    }, false);
    this._type_Playwright = void 0;
    this._browserDispatcher = void 0;
    this._type_Playwright = true;
    this._browserDispatcher = browserDispatcher;
  }

  async newRequest(params, metadata) {
    const request = new _fetch.GlobalAPIRequestContext(this._object, params);
    return {
      request: _networkDispatchers.APIRequestContextDispatcher.from(this._scope, request)
    };
  }

  async hideHighlight(params, metadata) {
    await this._object.hideHighlight();
  }

  async cleanup() {
    var _this$_browserDispatc;

    // Cleanup contexts upon disconnect.
    await ((_this$_browserDispatc = this._browserDispatcher) === null || _this$_browserDispatc === void 0 ? void 0 : _this$_browserDispatc.cleanupContexts());
  }

}

exports.PlaywrightDispatcher = PlaywrightDispatcher;

class SocksSupportDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, socksProxy) {
    super(scope, {
      guid: 'socksSupport@' + (0, _utils.createGuid)()
    }, 'SocksSupport', {});
    this._type_SocksSupport = void 0;
    this._socksProxy = void 0;
    this._type_SocksSupport = true;
    this._socksProxy = socksProxy;
    socksProxy.on(_socksProxy.SocksProxy.Events.SocksRequested, payload => this._dispatchEvent('socksRequested', payload));
    socksProxy.on(_socksProxy.SocksProxy.Events.SocksData, payload => this._dispatchEvent('socksData', payload));
    socksProxy.on(_socksProxy.SocksProxy.Events.SocksClosed, payload => this._dispatchEvent('socksClosed', payload));
  }

  async socksConnected(params) {
    var _this$_socksProxy;

    (_this$_socksProxy = this._socksProxy) === null || _this$_socksProxy === void 0 ? void 0 : _this$_socksProxy.socketConnected(params);
  }

  async socksFailed(params) {
    var _this$_socksProxy2;

    (_this$_socksProxy2 = this._socksProxy) === null || _this$_socksProxy2 === void 0 ? void 0 : _this$_socksProxy2.socketFailed(params);
  }

  async socksData(params) {
    var _this$_socksProxy3;

    (_this$_socksProxy3 = this._socksProxy) === null || _this$_socksProxy3 === void 0 ? void 0 : _this$_socksProxy3.sendSocketData(params);
  }

  async socksError(params) {
    var _this$_socksProxy4;

    (_this$_socksProxy4 = this._socksProxy) === null || _this$_socksProxy4 === void 0 ? void 0 : _this$_socksProxy4.sendSocketError(params);
  }

  async socksEnd(params) {
    var _this$_socksProxy5;

    (_this$_socksProxy5 = this._socksProxy) === null || _this$_socksProxy5 === void 0 ? void 0 : _this$_socksProxy5.sendSocketEnd(params);
  }

}

/***/ }),

/***/ 2222:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SelectorsDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SelectorsDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, selectors) {
    super(scope, selectors, 'Selectors', {});
    this._type_Selectors = true;
  }

  async register(params) {
    await this._object.register(params.name, params.source, params.contentScript);
  }

}

exports.SelectorsDispatcher = SelectorsDispatcher;

/***/ }),

/***/ 3239:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StreamDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StreamDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, stream) {
    super(scope, {
      guid: 'stream@' + (0, _utils.createGuid)(),
      stream
    }, 'Stream', {}); // In Node v12.9.0+ we can use readableEnded.

    this._type_Stream = true;
    this._ended = false;
    stream.once('end', () => this._ended = true);
    stream.once('error', () => this._ended = true);
  }

  async read(params) {
    const stream = this._object.stream;
    if (this._ended) return {
      binary: Buffer.from('')
    };

    if (!stream.readableLength) {
      await new Promise((fulfill, reject) => {
        stream.once('readable', fulfill);
        stream.once('end', fulfill);
        stream.once('error', reject);
      });
    }

    const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
    return {
      binary: buffer || Buffer.from('')
    };
  }

  async close() {
    this._object.stream.destroy();
  }

}

exports.StreamDispatcher = StreamDispatcher;

/***/ }),

/***/ 7178:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TracingDispatcher = void 0;

var _artifactDispatcher = __nccwpck_require__(2810);

var _dispatcher = __nccwpck_require__(4098);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TracingDispatcher extends _dispatcher.Dispatcher {
  static from(scope, tracing) {
    const result = (0, _dispatcher.existingDispatcher)(tracing);
    return result || new TracingDispatcher(scope, tracing);
  }

  constructor(scope, tracing) {
    super(scope, tracing, 'Tracing', {}, true);
    this._type_Tracing = true;
  }

  async tracingStart(params) {
    await this._object.start(params);
  }

  async tracingStartChunk(params) {
    await this._object.startChunk(params);
  }

  async tracingStopChunk(params) {
    const {
      artifact,
      sourceEntries
    } = await this._object.stopChunk(params);
    return {
      artifact: artifact ? new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact) : undefined,
      sourceEntries
    };
  }

  async tracingStop(params) {
    await this._object.stop();
  }

}

exports.TracingDispatcher = TracingDispatcher;

/***/ }),

/***/ 1253:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WritableStreamDispatcher = void 0;

var _dispatcher = __nccwpck_require__(4098);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WritableStreamDispatcher extends _dispatcher.Dispatcher {
  constructor(scope, stream) {
    super(scope, {
      guid: 'writableStream@' + (0, _utils.createGuid)(),
      stream
    }, 'WritableStream', {});
    this._type_WritableStream = true;
  }

  async write(params) {
    const stream = this._object.stream;
    await new Promise((fulfill, reject) => {
      stream.write(params.binary, error => {
        if (error) reject(error);else fulfill();
      });
    });
  }

  async close() {
    const stream = this._object.stream;
    await new Promise(fulfill => stream.end(fulfill));
  }

  path() {
    return this._object.stream.path;
  }

}

exports.WritableStreamDispatcher = WritableStreamDispatcher;

/***/ }),

/***/ 8139:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NonRecoverableDOMError = exports.InjectedScriptPollHandler = exports.FrameExecutionContext = exports.ElementHandle = void 0;
exports.assertDone = assertDone;
exports.isNonRecoverableDOMError = isNonRecoverableDOMError;
exports.kUnableToAdoptErrorMessage = void 0;
exports.throwRetargetableDOMError = throwRetargetableDOMError;
exports.waitForSelectorTask = waitForSelectorTask;

var _utilsBundle = __nccwpck_require__(1319);

var injectedScriptSource = _interopRequireWildcard(__nccwpck_require__(6390));

var _protocolError = __nccwpck_require__(7314);

var js = _interopRequireWildcard(__nccwpck_require__(804));

var _progress = __nccwpck_require__(2836);

var _utils = __nccwpck_require__(3557);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NonRecoverableDOMError extends Error {}

exports.NonRecoverableDOMError = NonRecoverableDOMError;

function isNonRecoverableDOMError(error) {
  return error instanceof NonRecoverableDOMError;
}

class FrameExecutionContext extends js.ExecutionContext {
  constructor(delegate, frame, world) {
    super(frame, delegate);
    this.frame = void 0;
    this._injectedScriptPromise = void 0;
    this.world = void 0;
    this.frame = frame;
    this.world = world;
  }

  async waitForSignalsCreatedBy(action) {
    return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);
  }

  adoptIfNeeded(handle) {
    if (handle instanceof ElementHandle && handle._context !== this) return this.frame._page._delegate.adoptElementHandle(handle, this);
    return null;
  }

  async evaluate(pageFunction, arg) {
    return js.evaluate(this, true
    /* returnByValue */
    , pageFunction, arg);
  }

  async evaluateHandle(pageFunction, arg) {
    return js.evaluate(this, false
    /* returnByValue */
    , pageFunction, arg);
  }

  async evaluateExpression(expression, isFunction, arg) {
    return js.evaluateExpression(this, true
    /* returnByValue */
    , expression, isFunction, arg);
  }

  async evaluateExpressionAndWaitForSignals(expression, isFunction, arg) {
    return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false
    /* noWaitFor */
    , async () => {
      return this.evaluateExpression(expression, isFunction, arg);
    });
  }

  async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg) {
    return await this.frame._page._frameManager.waitForSignalsCreatedBy(null, false
    /* noWaitFor */
    , async () => {
      return js.evaluateExpression(this, false
      /* returnByValue */
      , expression, isFunction, arg);
    });
  }

  createHandle(remoteObject) {
    if (this.frame._page._delegate.isElementHandle(remoteObject)) return new ElementHandle(this, remoteObject.objectId);
    return super.createHandle(remoteObject);
  }

  injectedScript() {
    if (!this._injectedScriptPromise) {
      const custom = [];

      for (const [name, {
        source
      }] of this.frame._page.selectors._engines) custom.push(`{ name: '${name}', engine: (${source}) }`);

      const source = `
        (() => {
        const module = {};
        ${injectedScriptSource.source}
        return new module.exports(
          ${(0, _utils.isUnderTest)()},
          ${this.frame._page._delegate.rafCountForStablePosition()},
          "${this.frame._page._browserContext._browser.options.name}",
          [${custom.join(',\n')}]
        );
        })();
      `;
      this._injectedScriptPromise = this.rawEvaluateHandle(source).then(objectId => new js.JSHandle(this, 'object', undefined, objectId));
    }

    return this._injectedScriptPromise;
  }

  async doSlowMo() {
    return this.frame._page._doSlowMo();
  }

}

exports.FrameExecutionContext = FrameExecutionContext;

class ElementHandle extends js.JSHandle {
  constructor(context, objectId) {
    super(context, 'node', undefined, objectId);
    this._page = void 0;
    this._frame = void 0;
    this._page = context.frame._page;
    this._frame = context.frame;

    this._initializePreview().catch(e => {});
  }

  async _initializePreview() {
    const utility = await this._context.injectedScript();

    this._setPreview(await utility.evaluate((injected, e) => 'JSHandle@' + injected.previewNode(e), this));
  }

  asElement() {
    return this;
  }

  async evaluateInUtility(pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      return await utility.evaluate(pageFunction, [await utility.injectedScript(), this, arg]);
    } catch (e) {
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;
      return 'error:notconnected';
    }
  }

  async evaluateHandleInUtility(pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      return await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
    } catch (e) {
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;
      return 'error:notconnected';
    }
  }

  async evaluatePoll(progress, pageFunction, arg) {
    try {
      const utility = await this._frame._utilityContext();
      const poll = await utility.evaluateHandle(pageFunction, [await utility.injectedScript(), this, arg]);
      const pollHandler = new InjectedScriptPollHandler(progress, poll);
      return await pollHandler.finish();
    } catch (e) {
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;
      return 'error:notconnected';
    }
  }

  async ownerFrame() {
    const frameId = await this._page._delegate.getOwnerFrame(this);
    if (!frameId) return null;

    const frame = this._page._frameManager.frame(frameId);

    if (frame) return frame;

    for (const page of this._page._browserContext.pages()) {
      const frame = page._frameManager.frame(frameId);

      if (frame) return frame;
    }

    return null;
  }

  async isIframeElement() {
    return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === 'IFRAME' || node.nodeName === 'FRAME'), {});
  }

  async contentFrame() {
    const isFrameElement = throwRetargetableDOMError(await this.isIframeElement());
    if (!isFrameElement) return null;
    return this._page._delegate.getContentFrame(this);
  }

  async getAttribute(name) {
    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node, name]) => {
      if (node.nodeType !== Node.ELEMENT_NODE) throw injected.createStacklessError('Node is not an element');
      const element = node;
      return {
        value: element.getAttribute(name)
      };
    }, name)).value;
  }

  async inputValue() {
    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
      const element = injected.retarget(node, 'follow-label');
      if (!element || element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA' && element.nodeName !== 'SELECT') throw injected.createStacklessError('Node is not an <input>, <textarea> or <select> element');
      return {
        value: element.value
      };
    }, undefined)).value;
  }

  async textContent() {
    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
      return {
        value: node.textContent
      };
    }, undefined)).value;
  }

  async innerText() {
    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
      if (node.nodeType !== Node.ELEMENT_NODE) throw injected.createStacklessError('Node is not an element');
      if (node.namespaceURI !== 'http://www.w3.org/1999/xhtml') throw injected.createStacklessError('Node is not an HTMLElement');
      const element = node;
      return {
        value: element.innerText
      };
    }, undefined)).value;
  }

  async innerHTML() {
    return throwRetargetableDOMError(await this.evaluateInUtility(([injected, node]) => {
      if (node.nodeType !== Node.ELEMENT_NODE) throw injected.createStacklessError('Node is not an element');
      const element = node;
      return {
        value: element.innerHTML
      };
    }, undefined)).value;
  }

  async dispatchEvent(type, eventInit = {}) {
    const main = await this._frame._mainContext();
    await this._page._frameManager.waitForSignalsCreatedBy(null, false
    /* noWaitFor */
    , async () => {
      return main.evaluate(([injected, node, {
        type,
        eventInit
      }]) => injected.dispatchEvent(node, type, eventInit), [await main.injectedScript(), this, {
        type,
        eventInit
      }]);
    });
    await this._page._doSlowMo();
  }

  async _scrollRectIntoViewIfNeeded(rect) {
    return await this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
  }

  async _waitAndScrollIntoViewIfNeeded(progress, waitForVisible) {
    const timeouts = [0, 50, 100, 250];

    while (progress.isRunning()) {
      assertDone(throwRetargetableDOMError(await this._waitForElementStates(progress, waitForVisible ? ['visible', 'stable'] : ['stable'], false
      /* force */
      )));
      progress.throwIfAborted(); // Avoid action that has side-effects.

      const result = throwRetargetableDOMError(await this._scrollRectIntoViewIfNeeded());

      if (result === 'error:notvisible') {
        if (!waitForVisible) {
          var _timeouts$shift;

          // Wait for a timeout to avoid retrying too often when not waiting for visible.
          // If we wait for visible, this should be covered by _waitForElementStates instead.
          const timeout = (_timeouts$shift = timeouts.shift()) !== null && _timeouts$shift !== void 0 ? _timeouts$shift : 500;
          progress.log(`  element is not displayed, retrying in ${timeout}ms`);
          await new Promise(f => setTimeout(f, timeout));
        }

        continue;
      }

      assertDone(result);
      return;
    }
  }

  async scrollIntoViewIfNeeded(metadata, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this._waitAndScrollIntoViewIfNeeded(progress, false
    /* waitForVisible */
    ), this._page._timeoutSettings.timeout(options));
  }

  async _clickablePoint() {
    const intersectQuadWithViewport = quad => {
      return quad.map(point => ({
        x: Math.min(Math.max(point.x, 0), metrics.width),
        y: Math.min(Math.max(point.y, 0), metrics.height)
      }));
    };

    const computeQuadArea = quad => {
      // Compute sum of all directed areas of adjacent triangles
      // https://en.wikipedia.org/wiki/Polygon#Simple_polygons
      let area = 0;

      for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
      }

      return Math.abs(area);
    };

    const [quads, metrics] = await Promise.all([this._page._delegate.getContentQuads(this), this._page.mainFrame()._utilityContext().then(utility => utility.evaluate(() => ({
      width: innerWidth,
      height: innerHeight
    })))]);
    if (!quads || !quads.length) return 'error:notvisible'; // Allow 1x1 elements. Compensate for rounding errors by comparing with 0.99 instead.

    const filtered = quads.map(quad => intersectQuadWithViewport(quad)).filter(quad => computeQuadArea(quad) > 0.99);
    if (!filtered.length) return 'error:notinviewport'; // Return the middle point of the first quad.

    const result = {
      x: 0,
      y: 0
    };

    for (const point of filtered[0]) {
      result.x += point.x / 4;
      result.y += point.y / 4;
    }

    compensateHalfIntegerRoundingError(result);
    return result;
  }

  async _offsetPoint(offset) {
    const [box, border] = await Promise.all([this.boundingBox(), this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch(e => {})]);
    if (!box || !border) return 'error:notvisible';
    if (border === 'error:notconnected') return border; // Make point relative to the padding box to align with offsetX/offsetY.

    return {
      x: box.x + border.left + offset.x,
      y: box.y + border.top + offset.y
    };
  }

  async _retryPointerAction(progress, actionName, waitForEnabled, action, options) {
    let retry = 0; // We progressively wait longer between retries, up to 500ms.

    const waitTime = [0, 20, 100, 100, 500]; // By default, we scroll with protocol method to reveal the action point.
    // However, that might not work to scroll from under position:sticky elements
    // that overlay the target element. To fight this, we cycle through different
    // scroll alignments. This works in most scenarios.

    const scrollOptions = [undefined, {
      block: 'end',
      inline: 'end'
    }, {
      block: 'center',
      inline: 'center'
    }, {
      block: 'start',
      inline: 'start'
    }];

    while (progress.isRunning()) {
      if (retry) {
        progress.log(`retrying ${actionName} action${options.trial ? ' (trial run)' : ''}, attempt #${retry}`);
        const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];

        if (timeout) {
          progress.log(`  waiting ${timeout}ms`);
          const result = await this.evaluateInUtility(([injected, node, timeout]) => new Promise(f => setTimeout(f, timeout)), timeout);
          if (result === 'error:notconnected') return result;
        }
      } else {
        progress.log(`attempting ${actionName} action${options.trial ? ' (trial run)' : ''}`);
      }

      const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
      const result = await this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options);
      ++retry;

      if (result === 'error:notvisible') {
        if (options.force) throw new NonRecoverableDOMError('Element is not visible');
        progress.log('  element is not visible');
        continue;
      }

      if (result === 'error:notinviewport') {
        if (options.force) throw new NonRecoverableDOMError('Element is outside of the viewport');
        progress.log('  element is outside of the viewport');
        continue;
      }

      if (typeof result === 'object' && 'hitTargetDescription' in result) {
        progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);
        continue;
      }

      return result;
    }

    return 'done';
  }

  async _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options) {
    const {
      force = false,
      position
    } = options;
    if (options.__testHookBeforeStable) await options.__testHookBeforeStable();
    const result = await this._waitForElementStates(progress, waitForEnabled ? ['visible', 'enabled', 'stable'] : ['visible', 'stable'], force);
    if (result !== 'done') return result;
    if (options.__testHookAfterStable) await options.__testHookAfterStable();
    progress.log('  scrolling into view if needed');
    progress.throwIfAborted(); // Avoid action that has side-effects.

    if (forceScrollOptions) {
      const scrolled = await this.evaluateInUtility(([injected, node, options]) => {
        if (node.nodeType === 1
        /* Node.ELEMENT_NODE */
        ) node.scrollIntoView(options);
      }, forceScrollOptions);
      if (scrolled === 'error:notconnected') return scrolled;
    } else {
      const scrolled = await this._scrollRectIntoViewIfNeeded(position ? {
        x: position.x,
        y: position.y,
        width: 0,
        height: 0
      } : undefined);
      if (scrolled !== 'done') return scrolled;
    }

    progress.log('  done scrolling');
    const maybePoint = position ? await this._offsetPoint(position) : await this._clickablePoint();
    if (typeof maybePoint === 'string') return maybePoint;
    const point = roundPoint(maybePoint);
    progress.metadata.point = point;
    await progress.beforeInputAction(this);
    let hitTargetInterceptionHandle;

    if (!options.force) {
      if (options.__testHookBeforeHitTarget) await options.__testHookBeforeHitTarget();
      const frameCheckResult = await this._checkFrameIsHitTarget(point);
      if (frameCheckResult === 'error:notconnected' || 'hitTargetDescription' in frameCheckResult) return frameCheckResult;
      const hitPoint = frameCheckResult.framePoint;
      const actionType = actionName === 'move and up' ? 'drag' : actionName === 'hover' || actionName === 'tap' ? actionName : 'mouse';
      const handle = await this.evaluateHandleInUtility(([injected, node, {
        actionType,
        hitPoint,
        trial
      }]) => injected.setupHitTargetInterceptor(node, actionType, hitPoint, trial), {
        actionType,
        hitPoint,
        trial: !!options.trial
      });
      if (handle === 'error:notconnected') return handle;

      if (!handle._objectId) {
        const error = handle.rawValue();
        if (error === 'error:notconnected') return error;
        return {
          hitTargetDescription: error
        };
      }

      hitTargetInterceptionHandle = handle;
      progress.cleanupWhenAborted(() => {
        // Do not await here, just in case the renderer is stuck (e.g. on alert)
        // and we won't be able to cleanup.
        hitTargetInterceptionHandle.evaluate(h => h.stop()).catch(e => {});
      });
    }

    const actionResult = await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
      if (options.__testHookBeforePointerAction) await options.__testHookBeforePointerAction();
      progress.throwIfAborted(); // Avoid action that has side-effects.

      let restoreModifiers;
      if (options && options.modifiers) restoreModifiers = await this._page.keyboard._ensureModifiers(options.modifiers);
      progress.log(`  performing ${actionName} action`);
      await action(point);
      if (restoreModifiers) await this._page.keyboard._ensureModifiers(restoreModifiers);

      if (hitTargetInterceptionHandle) {
        const stopHitTargetInterception = hitTargetInterceptionHandle.evaluate(h => h.stop()).catch(e => 'done');

        if (!options.noWaitAfter) {
          // When noWaitAfter is passed, we do not want to accidentally stall on
          // non-committed navigation blocking the evaluate.
          const hitTargetResult = await stopHitTargetInterception;
          if (hitTargetResult !== 'done') return hitTargetResult;
        }
      }

      progress.log(`  ${options.trial ? 'trial ' : ''}${actionName} action done`);
      progress.log('  waiting for scheduled navigations to finish');
      if (options.__testHookAfterPointerAction) await options.__testHookAfterPointerAction();
      return 'done';
    }, 'input');
    if (actionResult !== 'done') return actionResult;
    progress.log('  navigations have finished');
    return 'done';
  }

  async hover(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._hover(progress, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  _hover(progress, options) {
    return this._retryPointerAction(progress, 'hover', false
    /* waitForEnabled */
    , point => this._page.mouse.move(point.x, point.y), options);
  }

  async click(metadata, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._click(progress, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  _click(progress, options) {
    return this._retryPointerAction(progress, 'click', true
    /* waitForEnabled */
    , point => this._page.mouse.click(point.x, point.y, options), options);
  }

  async dblclick(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._dblclick(progress, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  _dblclick(progress, options) {
    return this._retryPointerAction(progress, 'dblclick', true
    /* waitForEnabled */
    , point => this._page.mouse.dblclick(point.x, point.y, options), options);
  }

  async tap(metadata, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._tap(progress, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  _tap(progress, options) {
    return this._retryPointerAction(progress, 'tap', true
    /* waitForEnabled */
    , point => this._page.touchscreen.tap(point.x, point.y), options);
  }

  async selectOption(metadata, elements, values, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._selectOption(progress, elements, values, options);
      return throwRetargetableDOMError(result);
    }, this._page._timeoutSettings.timeout(options));
  }

  async _selectOption(progress, elements, values, options) {
    const optionsToSelect = [...elements, ...values];
    await progress.beforeInputAction(this);
    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
      progress.throwIfAborted(); // Avoid action that has side-effects.

      progress.log('  selecting specified option(s)');
      const result = await this.evaluatePoll(progress, ([injected, node, {
        optionsToSelect,
        force
      }]) => {
        return injected.waitForElementStatesAndPerformAction(node, ['visible', 'enabled'], force, injected.selectOptions.bind(injected, optionsToSelect));
      }, {
        optionsToSelect,
        force: options.force
      });
      await this._page._doSlowMo();
      return result;
    });
  }

  async fill(metadata, value, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._fill(progress, value, options);
      assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async _fill(progress, value, options) {
    progress.log(`elementHandle.fill("${value}")`);
    await progress.beforeInputAction(this);
    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
      progress.log('  waiting for element to be visible, enabled and editable');
      const filled = await this.evaluatePoll(progress, ([injected, node, {
        value,
        force
      }]) => {
        return injected.waitForElementStatesAndPerformAction(node, ['visible', 'enabled', 'editable'], force, injected.fill.bind(injected, value));
      }, {
        value,
        force: options.force
      });
      progress.throwIfAborted(); // Avoid action that has side-effects.

      if (filled === 'error:notconnected') return filled;
      progress.log('  element is visible, enabled and editable');

      if (filled === 'needsinput') {
        progress.throwIfAborted(); // Avoid action that has side-effects.

        if (value) await this._page.keyboard.insertText(value);else await this._page.keyboard.press('Delete');
      } else {
        assertDone(filled);
      }

      return 'done';
    }, 'input');
  }

  async selectText(metadata, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      progress.throwIfAborted(); // Avoid action that has side-effects.

      const result = await this.evaluatePoll(progress, ([injected, node, force]) => {
        return injected.waitForElementStatesAndPerformAction(node, ['visible'], force, injected.selectText.bind(injected));
      }, options.force);
      assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async setInputFiles(metadata, items, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._setInputFiles(progress, items, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async _setInputFiles(progress, items, options) {
    const {
      files,
      localPaths
    } = items;
    let filePayloads;

    if (files) {
      filePayloads = [];

      for (const payload of files) {
        filePayloads.push({
          name: payload.name,
          mimeType: payload.mimeType || _utilsBundle.mime.getType(payload.name) || 'application/octet-stream',
          buffer: payload.buffer.toString('base64')
        });
      }
    }

    const multiple = files && files.length > 1 || localPaths && localPaths.length > 1;
    const result = await this.evaluateHandleInUtility(([injected, node, multiple]) => {
      const element = injected.retarget(node, 'follow-label');
      if (!element) return;
      if (element.tagName !== 'INPUT') throw injected.createStacklessError('Node is not an HTMLInputElement');
      if (multiple && !element.multiple) throw injected.createStacklessError('Non-multiple file input can only accept single file');
      return element;
    }, multiple);
    if (result === 'error:notconnected' || !result.asElement()) return 'error:notconnected';
    const retargeted = result.asElement();
    await progress.beforeInputAction(this);
    await this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
      progress.throwIfAborted(); // Avoid action that has side-effects.

      if (localPaths) await this._page._delegate.setInputFilePaths(retargeted, localPaths);else await this._page._delegate.setInputFiles(retargeted, filePayloads);
    });
    await this._page._doSlowMo();
    return 'done';
  }

  async focus(metadata) {
    const controller = new _progress.ProgressController(metadata, this);
    await controller.run(async progress => {
      const result = await this._focus(progress);
      await this._page._doSlowMo();
      return assertDone(throwRetargetableDOMError(result));
    }, 0);
  }

  async _focus(progress, resetSelectionIfNotFocused) {
    progress.throwIfAborted(); // Avoid action that has side-effects.

    return await this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused]) => injected.focusNode(node, resetSelectionIfNotFocused), resetSelectionIfNotFocused);
  }

  async type(metadata, text, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._type(progress, text, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async _type(progress, text, options) {
    progress.log(`elementHandle.type("${text}")`);
    await progress.beforeInputAction(this);
    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
      const result = await this._focus(progress, true
      /* resetSelectionIfNotFocused */
      );
      if (result !== 'done') return result;
      progress.throwIfAborted(); // Avoid action that has side-effects.

      await this._page.keyboard.type(text, options);
      return 'done';
    }, 'input');
  }

  async press(metadata, key, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._press(progress, key, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async _press(progress, key, options) {
    progress.log(`elementHandle.press("${key}")`);
    await progress.beforeInputAction(this);
    return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, async () => {
      const result = await this._focus(progress, true
      /* resetSelectionIfNotFocused */
      );
      if (result !== 'done') return result;
      progress.throwIfAborted(); // Avoid action that has side-effects.

      await this._page.keyboard.press(key, options);
      return 'done';
    }, 'input');
  }

  async check(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._setChecked(progress, true, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async uncheck(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      const result = await this._setChecked(progress, false, options);
      return assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async _setChecked(progress, state, options) {
    const isChecked = async () => {
      const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'checked'), {});
      return throwRetargetableDOMError(result);
    };

    if ((await isChecked()) === state) return 'done';
    const result = await this._click(progress, options);
    if (result !== 'done') return result;
    if (options.trial) return 'done';
    if ((await isChecked()) !== state) throw new NonRecoverableDOMError('Clicking the checkbox did not change its state');
    return 'done';
  }

  async boundingBox() {
    return this._page._delegate.getBoundingBox(this);
  }

  async screenshot(metadata, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this._page._screenshotter.screenshotElement(progress, this, options), this._page._timeoutSettings.timeout(options));
  }

  async querySelector(selector, options) {
    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, options, this);
    if (!pair) return null;
    const {
      frame,
      info
    } = pair; // If we end up in the same frame => use the scope again, line above was noop.

    return this._page.selectors.query(frame, info, this._frame === frame ? this : undefined);
  }

  async querySelectorAll(selector) {
    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
    if (!pair) return [];
    const {
      frame,
      info
    } = pair; // If we end up in the same frame => use the scope again, line above was noop.

    return this._page.selectors._queryAll(frame, info, this._frame === frame ? this : undefined, true
    /* adoptToMain */
    );
  }

  async evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {
      strict
    }, this); // If we end up in the same frame => use the scope again, line above was noop.

    const handle = pair ? await this._page.selectors.query(pair.frame, pair.info, this._frame === pair.frame ? this : undefined) : null;
    if (!handle) throw new Error(`Error: failed to find element matching selector "${selector}"`);
    const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
    handle.dispose();
    return result;
  }

  async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
    const pair = await this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
    if (!pair) throw new Error(`Error: failed to find frame for selector "${selector}"`);
    const {
      frame,
      info
    } = pair; // If we end up in the same frame => use the scope again, line above was noop.

    const arrayHandle = await this._page.selectors._queryArrayInMainWorld(frame, info, this._frame === frame ? this : undefined);
    const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
    arrayHandle.dispose();
    return result;
  }

  async isVisible() {
    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'visible'), {});
    if (result === 'error:notconnected') return false;
    return result;
  }

  async isHidden() {
    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'hidden'), {});
    return throwRetargetableDOMError(result);
  }

  async isEnabled() {
    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'enabled'), {});
    return throwRetargetableDOMError(result);
  }

  async isDisabled() {
    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'disabled'), {});
    return throwRetargetableDOMError(result);
  }

  async isEditable() {
    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'editable'), {});
    return throwRetargetableDOMError(result);
  }

  async isChecked() {
    const result = await this.evaluateInUtility(([injected, node]) => injected.elementState(node, 'checked'), {});
    return throwRetargetableDOMError(result);
  }

  async waitForElementState(metadata, state, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      progress.log(`  waiting for element to be ${state}`);
      const result = await this.evaluatePoll(progress, ([injected, node, state]) => {
        return injected.waitForElementStatesAndPerformAction(node, [state], false, () => 'done');
      }, state);
      assertDone(throwRetargetableDOMError(result));
    }, this._page._timeoutSettings.timeout(options));
  }

  async waitForSelector(metadata, selector, options = {}) {
    return this._frame.waitForSelector(metadata, selector, options, this);
  }

  async _adoptTo(context) {
    if (this._context !== context) {
      const adopted = await this._page._delegate.adoptElementHandle(this, context);
      this.dispose();
      return adopted;
    }

    return this;
  }

  async _waitForElementStates(progress, states, force) {
    const title = joinWithAnd(states);
    progress.log(`  waiting for element to be ${title}`);
    const result = await this.evaluatePoll(progress, ([injected, node, {
      states,
      force
    }]) => {
      return injected.waitForElementStatesAndPerformAction(node, states, force, () => 'done');
    }, {
      states,
      force
    });
    if (result === 'error:notconnected') return result;
    progress.log(`  element is ${title}`);
    return result;
  }

  async _checkFrameIsHitTarget(point) {
    let frame = this._frame;
    const data = [];

    while (frame.parentFrame()) {
      const frameElement = await frame.frameElement();
      const box = await frameElement.boundingBox();
      if (!box) return 'error:notconnected'; // Translate from viewport coordinates to frame coordinates.

      const pointInFrame = {
        x: point.x - box.x,
        y: point.y - box.y
      };
      data.push({
        frame,
        frameElement,
        pointInFrame
      });
      frame = frame.parentFrame();
    } // Add main frame.


    data.push({
      frame,
      frameElement: null,
      pointInFrame: point
    });

    for (let i = data.length - 1; i > 0; i--) {
      const element = data[i - 1].frameElement;
      const point = data[i].pointInFrame; // Hit target in the parent frame should hit the child frame element.

      const hitTargetResult = await element.evaluateInUtility(([injected, element, hitPoint]) => {
        const hitElement = injected.deepElementFromPoint(document, hitPoint.x, hitPoint.y);
        return injected.expectHitTargetParent(hitElement, element);
      }, point);
      if (hitTargetResult !== 'done') return hitTargetResult;
    }

    return {
      framePoint: data[0].pointInFrame
    };
  }

} // Handles an InjectedScriptPoll running in injected script:
// - streams logs into progress;
// - cancels the poll when progress cancels.


exports.ElementHandle = ElementHandle;

class InjectedScriptPollHandler {
  constructor(progress, poll) {
    this._progress = void 0;
    this._poll = void 0;
    this._progress = progress;
    this._poll = poll; // Ensure we cancel the poll before progress aborts and returns:
    //   - no unnecessary work in the page;
    //   - no possible side effects after progress promsie rejects.

    this._progress.cleanupWhenAborted(() => this.cancel());

    this._streamLogs();
  }

  async _streamLogs() {
    while (this._poll && this._progress.isRunning()) {
      const log = await this._poll.evaluate(poll => poll.takeNextLogs()).catch(e => []);
      if (!this._poll || !this._progress.isRunning()) return;

      for (const entry of log) this._progress.logEntry(entry);
    }
  }

  async finishHandle() {
    try {
      const result = await this._poll.evaluateHandle(poll => poll.run());
      await this._finishInternal();
      return result;
    } finally {
      await this.cancel();
    }
  }

  async finish() {
    try {
      const result = await this._poll.evaluate(poll => poll.run());
      await this._finishInternal();
      return result;
    } finally {
      await this.cancel();
    }
  }

  async _finishInternal() {
    if (!this._poll) return; // Retrieve all the logs before continuing.

    const log = await this._poll.evaluate(poll => poll.takeLastLogs()).catch(e => []);

    for (const entry of log) this._progress.logEntry(entry);
  }

  async cancel() {
    if (!this._poll) return;
    const copy = this._poll;
    this._poll = null;
    await copy.evaluate(p => p.cancel()).catch(e => {});
    copy.dispose();
  }

}

exports.InjectedScriptPollHandler = InjectedScriptPollHandler;

function throwRetargetableDOMError(result) {
  if (result === 'error:notconnected') throw new Error('Element is not attached to the DOM');
  return result;
}

function assertDone(result) {// This function converts 'done' to void and ensures typescript catches unhandled errors.
}

function roundPoint(point) {
  return {
    x: (point.x * 100 | 0) / 100,
    y: (point.y * 100 | 0) / 100
  };
}

function compensateHalfIntegerRoundingError(point) {
  // Firefox internally uses integer coordinates, so 8.5 is converted to 9 when clicking.
  //
  // This does not work nicely for small elements. For example, 1x1 square with corners
  // (8;8) and (9;9) is targeted when clicking at (8;8) but not when clicking at (9;9).
  // So, clicking at (8.5;8.5) will effectively click at (9;9) and miss the target.
  //
  // Therefore, we skew half-integer values from the interval (8.49, 8.51) towards
  // (8.47, 8.49) that is rounded towards 8. This means clicking at (8.5;8.5) will
  // be replaced with (8.48;8.48) and will effectively click at (8;8).
  //
  // Other browsers use float coordinates, so this change should not matter.
  const remainderX = point.x - Math.floor(point.x);
  if (remainderX > 0.49 && remainderX < 0.51) point.x -= 0.02;
  const remainderY = point.y - Math.floor(point.y);
  if (remainderY > 0.49 && remainderY < 0.51) point.y -= 0.02;
}

function waitForSelectorTask(selector, state, omitReturnValue, root) {
  return injectedScript => injectedScript.evaluateHandle((injected, {
    parsed,
    strict,
    state,
    omitReturnValue,
    root
  }) => {
    let lastElement;
    return injected.pollRaf(progress => {
      const elements = injected.querySelectorAll(parsed, root || document);
      let element = elements[0];
      const visible = element ? injected.isVisible(element) : false;

      if (lastElement !== element) {
        lastElement = element;

        if (!element) {
          progress.log(`  selector did not resolve to any element`);
        } else {
          if (elements.length > 1) {
            if (strict) throw injected.strictModeViolationError(parsed, elements);
            progress.log(`  selector resolved to ${elements.length} elements. Proceeding with the first one.`);
          }

          progress.log(`  selector resolved to ${visible ? 'visible' : 'hidden'} ${injected.previewNode(element)}`);
        }
      }

      const hasElement = !!element;
      if (omitReturnValue) element = undefined;

      switch (state) {
        case 'attached':
          return hasElement ? element : progress.continuePolling;

        case 'detached':
          return !hasElement ? undefined : progress.continuePolling;

        case 'visible':
          return visible ? element : progress.continuePolling;

        case 'hidden':
          return !visible ? undefined : progress.continuePolling;
      }
    });
  }, {
    parsed: selector.parsed,
    strict: selector.strict,
    state,
    omitReturnValue,
    root
  });
}

function joinWithAnd(strings) {
  if (strings.length < 1) return strings.join(', ');
  return strings.slice(0, strings.length - 1).join(', ') + ' and ' + strings[strings.length - 1];
}

const kUnableToAdoptErrorMessage = 'Unable to adopt element handle from a different document';
exports.kUnableToAdoptErrorMessage = kUnableToAdoptErrorMessage;

/***/ }),

/***/ 3404:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Download = void 0;

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _page = __nccwpck_require__(3555);

var _utils = __nccwpck_require__(3557);

var _artifact = __nccwpck_require__(1796);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Download {
  constructor(page, downloadsPath, uuid, url, suggestedFilename) {
    this.artifact = void 0;
    this.url = void 0;
    this._page = void 0;
    this._suggestedFilename = void 0;
    const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? 'Pass { acceptDownloads: true } when you are creating your browser context.' : undefined;
    this.artifact = new _artifact.Artifact(page, _path.default.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
      return this._page._browserContext.cancelDownload(uuid);
    });
    this._page = page;
    this.url = url;
    this._suggestedFilename = suggestedFilename;

    page._browserContext._downloads.add(this);

    if (suggestedFilename !== undefined) this._page.emit(_page.Page.Events.Download, this);
  }

  _filenameSuggested(suggestedFilename) {
    (0, _utils.assert)(this._suggestedFilename === undefined);
    this._suggestedFilename = suggestedFilename;

    this._page.emit(_page.Page.Events.Download, this);
  }

  suggestedFilename() {
    return this._suggestedFilename;
  }

}

exports.Download = Download;

/***/ }),

/***/ 9229:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ElectronApplication = exports.Electron = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _crBrowser = __nccwpck_require__(2731);

var _crConnection = __nccwpck_require__(5460);

var _crExecutionContext = __nccwpck_require__(4244);

var js = _interopRequireWildcard(__nccwpck_require__(804));

var _timeoutSettings = __nccwpck_require__(9053);

var _utils = __nccwpck_require__(3557);

var _transport = __nccwpck_require__(1232);

var _processLauncher = __nccwpck_require__(1441);

var _browserContext = __nccwpck_require__(5985);

var _progress = __nccwpck_require__(2836);

var _helper = __nccwpck_require__(9175);

var _eventsHelper = __nccwpck_require__(3841);

var readline = _interopRequireWildcard(__nccwpck_require__(4521));

var _debugLogger = __nccwpck_require__(2003);

var _instrumentation = __nccwpck_require__(6686);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), 'playwright-artifacts-');

class ElectronApplication extends _instrumentation.SdkObject {
  constructor(parent, browser, nodeConnection, process) {
    super(parent, 'electron-app');
    this._browserContext = void 0;
    this._nodeConnection = void 0;
    this._nodeSession = void 0;
    this._nodeExecutionContext = void 0;
    this._nodeElectronHandlePromise = void 0;
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
    this._process = void 0;
    this._process = process;
    this._browserContext = browser._defaultContext;

    this._browserContext.on(_browserContext.BrowserContext.Events.Close, () => {
      // Emit application closed after context closed.
      Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
    });

    this._nodeConnection = nodeConnection;
    this._nodeSession = nodeConnection.rootSession;
    this._nodeElectronHandlePromise = new Promise(f => {
      this._nodeSession.on('Runtime.executionContextCreated', async event => {
        if (event.context.auxData && event.context.auxData.isDefault) {
          this._nodeExecutionContext = new js.ExecutionContext(this, new _crExecutionContext.CRExecutionContext(this._nodeSession, event.context));
          f(await js.evaluate(this._nodeExecutionContext, false
          /* returnByValue */
          , `process.mainModule.require('electron')`));
        }
      });
    });

    this._browserContext.setCustomCloseHandler(async () => {
      const electronHandle = await this._nodeElectronHandlePromise;
      await electronHandle.evaluate(({
        app
      }) => app.quit());
    });

    this._nodeSession.send('Runtime.enable', {}).catch(e => {});
  }

  process() {
    return this._process;
  }

  context() {
    return this._browserContext;
  }

  async close() {
    const progressController = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
    const closed = progressController.run(progress => _helper.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise);
    await this._browserContext.close((0, _instrumentation.serverSideCallMetadata)());

    this._nodeConnection.close();

    await closed;
  }

  async browserWindow(page) {
    // Assume CRPage as Electron is always Chromium.
    const targetId = page._delegate._targetId;
    const electronHandle = await this._nodeElectronHandlePromise;
    return await electronHandle.evaluateHandle(({
      BrowserWindow,
      webContents
    }, targetId) => {
      const wc = webContents.fromDevToolsTargetId(targetId);
      return BrowserWindow.fromWebContents(wc);
    }, targetId);
  }

}

exports.ElectronApplication = ElectronApplication;
ElectronApplication.Events = {
  Close: 'close'
};

class Electron extends _instrumentation.SdkObject {
  constructor(playwrightOptions) {
    super(playwrightOptions.rootSdkObject, 'electron');
    this._playwrightOptions = void 0;
    this._playwrightOptions = playwrightOptions;
  }

  async launch(options) {
    const {
      args = []
    } = options;
    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
    controller.setLogName('browser');
    return controller.run(async progress => {
      let app = undefined;
      const electronArguments = ['--inspect=0', '--remote-debugging-port=0', ...args];

      if (_os.default.platform() === 'linux') {
        const runningAsRoot = process.geteuid && process.geteuid() === 0;
        if (runningAsRoot && electronArguments.indexOf('--no-sandbox') === -1) electronArguments.push('--no-sandbox');
      }

      const artifactsDir = await _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
      const browserLogsCollector = new _debugLogger.RecentLogsCollector();
      const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
      let command;

      if (options.executablePath) {
        command = options.executablePath;
      } else {
        try {
          // By default we fallback to the Electron App executable path.
          // 'electron/index.js' resolves to the actual Electron App.
          command = __nccwpck_require__(4964);
        } catch (error) {
          if ((error === null || error === void 0 ? void 0 : error.code) === 'MODULE_NOT_FOUND') {
            throw new Error('\n' + (0, _utils.wrapInASCIIBox)(['Electron executablePath not found!', 'Please install it using `npm install -D electron` or set the executablePath to your Electron executable.'].join('\n'), 1));
          }

          throw error;
        }
      } // When debugging Playwright test that runs Electron, NODE_OPTIONS
      // will make the debugger attach to Electron's Node. But Playwright
      // also needs to attach to drive the automation. Disable external debugging.


      delete env.NODE_OPTIONS;
      const {
        launchedProcess,
        gracefullyClose,
        kill
      } = await (0, _processLauncher.launchProcess)({
        command,
        args: electronArguments,
        env,
        log: message => {
          progress.log(message);
          browserLogsCollector.log(message);
        },
        stdio: 'pipe',
        cwd: options.cwd,
        tempDirectories: [artifactsDir],
        attemptToGracefullyClose: () => app.close(),
        handleSIGINT: true,
        handleSIGTERM: true,
        handleSIGHUP: true,
        onExit: () => {}
      });
      const waitForXserverError = new Promise(async (resolve, reject) => {
        waitForLine(progress, launchedProcess, /Unable to open X display/).then(() => reject(new Error(['Unable to open X display!', `================================`, 'Most likely this is because there is no X server available.', "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.", "For example: 'xvfb-run npm run test:e2e'", `================================`, progress.metadata.log].join('\n')))).catch(() => {});
      });
      const nodeMatch = await waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
      const nodeTransport = await _transport.WebSocketTransport.connect(progress, nodeMatch[1]);
      const nodeConnection = new _crConnection.CRConnection(nodeTransport, _helper.helper.debugProtocolLogger(), browserLogsCollector); // Immediately release exiting process under debug.

      waitForLine(progress, launchedProcess, /Waiting for the debugger to disconnect\.\.\./).then(() => {
        nodeTransport.close();
      }).catch(() => {});
      const chromeMatch = await Promise.race([waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/), waitForXserverError]);
      const chromeTransport = await _transport.WebSocketTransport.connect(progress, chromeMatch[1]);
      const browserProcess = {
        onclose: undefined,
        process: launchedProcess,
        close: gracefullyClose,
        kill
      };
      const contextOptions = { ...options,
        noDefaultViewport: true
      };
      const browserOptions = { ...this._playwrightOptions,
        name: 'electron',
        isChromium: true,
        headful: true,
        persistent: contextOptions,
        browserProcess,
        protocolLogger: _helper.helper.debugProtocolLogger(),
        browserLogsCollector,
        artifactsDir,
        downloadsPath: artifactsDir,
        tracesDir: artifactsDir,
        originalLaunchOptions: {}
      };
      (0, _browserContext.validateBrowserContextOptions)(contextOptions, browserOptions);
      const browser = await _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
      app = new ElectronApplication(this, browser, nodeConnection, launchedProcess);
      return app;
    }, _timeoutSettings.TimeoutSettings.timeout(options));
  }

}

exports.Electron = Electron;

function waitForLine(progress, process, regex) {
  return new Promise((resolve, reject) => {
    const rl = readline.createInterface({
      input: process.stderr
    });
    const failError = new Error('Process failed to launch!');
    const listeners = [_eventsHelper.eventsHelper.addEventListener(rl, 'line', onLine), _eventsHelper.eventsHelper.addEventListener(rl, 'close', reject.bind(null, failError)), _eventsHelper.eventsHelper.addEventListener(process, 'exit', reject.bind(null, failError)), // It is Ok to remove error handler because we did not create process and there is another listener.
    _eventsHelper.eventsHelper.addEventListener(process, 'error', reject.bind(null, failError))];
    progress.cleanupWhenAborted(cleanup);

    function onLine(line) {
      const match = line.match(regex);
      if (!match) return;
      cleanup();
      resolve(match);
    }

    function cleanup() {
      _eventsHelper.eventsHelper.removeEventListeners(listeners);
    }
  });
}

/***/ }),

/***/ 2857:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlobalAPIRequestContext = exports.BrowserContextAPIRequestContext = exports.APIRequestContext = void 0;

var http = _interopRequireWildcard(__nccwpck_require__(3685));

var https = _interopRequireWildcard(__nccwpck_require__(5687));

var _stream = __nccwpck_require__(2781);

var _url = _interopRequireDefault(__nccwpck_require__(7310));

var _zlib = _interopRequireDefault(__nccwpck_require__(9796));

var _timeoutSettings = __nccwpck_require__(9053);

var _userAgent = __nccwpck_require__(5110);

var _utils = __nccwpck_require__(3557);

var _browserContext = __nccwpck_require__(5985);

var _cookieStore = __nccwpck_require__(9260);

var _formData = __nccwpck_require__(7291);

var _instrumentation = __nccwpck_require__(6686);

var _progress = __nccwpck_require__(2836);

var _tracing = __nccwpck_require__(865);

var _utilsBundle = __nccwpck_require__(1319);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class APIRequestContext extends _instrumentation.SdkObject {
  static findResponseBody(guid) {
    for (const request of APIRequestContext.allInstances) {
      const body = request.fetchResponses.get(guid);
      if (body) return body;
    }

    return undefined;
  }

  constructor(parent) {
    super(parent, 'request-context');
    this.fetchResponses = new Map();
    this.fetchLog = new Map();
    APIRequestContext.allInstances.add(this);
  }

  _disposeImpl() {
    APIRequestContext.allInstances.delete(this);
    this.fetchResponses.clear();
    this.fetchLog.clear();
    this.emit(APIRequestContext.Events.Dispose);
  }

  disposeResponse(fetchUid) {
    this.fetchResponses.delete(fetchUid);
    this.fetchLog.delete(fetchUid);
  }

  _storeResponseBody(body) {
    const uid = (0, _utils.createGuid)();
    this.fetchResponses.set(uid, body);
    return uid;
  }

  async fetch(params, metadata) {
    var _params$method;

    const headers = {};

    const defaults = this._defaultOptions();

    headers['user-agent'] = defaults.userAgent;
    headers['accept'] = '*/*';
    headers['accept-encoding'] = 'gzip,deflate,br';

    if (defaults.extraHTTPHeaders) {
      for (const {
        name,
        value
      } of defaults.extraHTTPHeaders) headers[name.toLowerCase()] = value;
    }

    if (params.headers) {
      for (const {
        name,
        value
      } of params.headers) headers[name.toLowerCase()] = value;
    }

    const method = ((_params$method = params.method) === null || _params$method === void 0 ? void 0 : _params$method.toUpperCase()) || 'GET';
    const proxy = defaults.proxy;
    let agent;

    if (proxy && proxy.server !== 'per-context') {
      var _proxyOpts$protocol;

      // TODO: support bypass proxy
      const proxyOpts = _url.default.parse(proxy.server);

      if ((_proxyOpts$protocol = proxyOpts.protocol) !== null && _proxyOpts$protocol !== void 0 && _proxyOpts$protocol.startsWith('socks')) {
        agent = new _utilsBundle.SocksProxyAgent({
          host: proxyOpts.hostname,
          port: proxyOpts.port || undefined
        });
      } else {
        if (proxy.username) proxyOpts.auth = `${proxy.username}:${proxy.password || ''}`;
        agent = new _utilsBundle.HttpsProxyAgent(proxyOpts);
      }
    }

    const timeout = defaults.timeoutSettings.timeout(params);
    const deadline = timeout && (0, _utils.monotonicTime)() + timeout;
    const options = {
      method,
      headers,
      agent,
      maxRedirects: 20,
      timeout,
      deadline
    }; // rejectUnauthorized = undefined is treated as true in node 12.

    if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors) options.rejectUnauthorized = false;
    const requestUrl = new URL(params.url, defaults.baseURL);

    if (params.params) {
      for (const {
        name,
        value
      } of params.params) requestUrl.searchParams.set(name, value);
    }

    let postData;
    if (['POST', 'PUT', 'PATCH', 'DELETE'].includes(method)) postData = serializePostData(params, headers);else if (params.postData || params.jsonData || params.formData || params.multipartData) throw new Error(`Method ${method} does not accept post data`);
    if (postData) headers['content-length'] = String(postData.byteLength);
    const controller = new _progress.ProgressController(metadata, this);
    const fetchResponse = await controller.run(progress => {
      return this._sendRequest(progress, requestUrl, options, postData);
    });

    const fetchUid = this._storeResponseBody(fetchResponse.body);

    this.fetchLog.set(fetchUid, controller.metadata.log);
    if (params.failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400)) throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}`);
    return { ...fetchResponse,
      fetchUid
    };
  }

  _parseSetCookieHeader(responseUrl, setCookie) {
    if (!setCookie) return [];
    const url = new URL(responseUrl); // https://datatracker.ietf.org/doc/html/rfc6265#section-5.1.4

    const defaultPath = '/' + url.pathname.substr(1).split('/').slice(0, -1).join('/');
    const cookies = [];

    for (const header of setCookie) {
      // Decode cookie value?
      const cookie = parseCookie(header);
      if (!cookie) continue; // https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.3

      if (!cookie.domain) cookie.domain = url.hostname;else (0, _utils.assert)(cookie.domain.startsWith('.'));
      if (!(0, _cookieStore.domainMatches)(url.hostname, cookie.domain)) continue; // https://datatracker.ietf.org/doc/html/rfc6265#section-5.2.4

      if (!cookie.path || !cookie.path.startsWith('/')) cookie.path = defaultPath;
      cookies.push(cookie);
    }

    return cookies;
  }

  async _updateRequestCookieHeader(url, options) {
    if (options.headers['cookie'] !== undefined) return;
    const cookies = await this._cookies(url);

    if (cookies.length) {
      const valueArray = cookies.map(c => `${c.name}=${c.value}`);
      options.headers['cookie'] = valueArray.join('; ');
    }
  }

  async _sendRequest(progress, url, options, postData) {
    var _cookie;

    await this._updateRequestCookieHeader(url, options);
    const requestCookies = ((_cookie = options.headers['cookie']) === null || _cookie === void 0 ? void 0 : _cookie.split(';').map(p => {
      const [name, value] = p.split('=').map(v => v.trim());
      return {
        name,
        value
      };
    })) || [];
    const requestEvent = {
      url,
      method: options.method,
      headers: options.headers,
      cookies: requestCookies,
      postData
    };
    this.emit(APIRequestContext.Events.Request, requestEvent);
    return new Promise((fulfill, reject) => {
      const requestConstructor = (url.protocol === 'https:' ? https : http).request;
      const request = requestConstructor(url, options, async response => {
        const notifyRequestFinished = body => {
          const requestFinishedEvent = {
            requestEvent,
            httpVersion: response.httpVersion,
            statusCode: response.statusCode || 0,
            statusMessage: response.statusMessage || '',
            headers: response.headers,
            rawHeaders: response.rawHeaders,
            cookies,
            body
          };
          this.emit(APIRequestContext.Events.RequestFinished, requestFinishedEvent);
        };

        progress.log(`← ${response.statusCode} ${response.statusMessage}`);

        for (const [name, value] of Object.entries(response.headers)) progress.log(`  ${name}: ${value}`);

        const cookies = this._parseSetCookieHeader(response.url || url.toString(), response.headers['set-cookie']);

        if (cookies.length) await this._addCookies(cookies);

        if (redirectStatus.includes(response.statusCode)) {
          if (!options.maxRedirects) {
            reject(new Error('Max redirect count exceeded'));
            request.destroy();
            return;
          }

          const headers = { ...options.headers
          };
          delete headers[`cookie`]; // HTTP-redirect fetch step 13 (https://fetch.spec.whatwg.org/#http-redirect-fetch)

          const status = response.statusCode;
          let method = options.method;

          if ((status === 301 || status === 302) && method === 'POST' || status === 303 && !['GET', 'HEAD'].includes(method)) {
            method = 'GET';
            postData = undefined;
            delete headers[`content-encoding`];
            delete headers[`content-language`];
            delete headers[`content-length`];
            delete headers[`content-location`];
            delete headers[`content-type`];
          }

          const redirectOptions = {
            method,
            headers,
            agent: options.agent,
            maxRedirects: options.maxRedirects - 1,
            timeout: options.timeout,
            deadline: options.deadline
          }; // rejectUnauthorized = undefined is treated as true in node 12.

          if (options.rejectUnauthorized === false) redirectOptions.rejectUnauthorized = false; // HTTP-redirect fetch step 4: If locationURL is null, then return response.

          if (response.headers.location) {
            const locationURL = new URL(response.headers.location, url);
            notifyRequestFinished();
            fulfill(this._sendRequest(progress, locationURL, redirectOptions, postData));
            request.destroy();
            return;
          }
        }

        if (response.statusCode === 401 && !options.headers['authorization']) {
          const auth = response.headers['www-authenticate'];

          const credentials = this._defaultOptions().httpCredentials;

          if (auth !== null && auth !== void 0 && auth.trim().startsWith('Basic') && credentials) {
            const {
              username,
              password
            } = credentials;
            const encoded = Buffer.from(`${username || ''}:${password || ''}`).toString('base64');
            options.headers['authorization'] = `Basic ${encoded}`;
            notifyRequestFinished();
            fulfill(this._sendRequest(progress, url, options, postData));
            request.destroy();
            return;
          }
        }

        response.on('aborted', () => reject(new Error('aborted')));
        const chunks = [];

        const notifyBodyFinished = () => {
          const body = Buffer.concat(chunks);
          notifyRequestFinished(body);
          fulfill({
            url: response.url || url.toString(),
            status: response.statusCode || 0,
            statusText: response.statusMessage || '',
            headers: toHeadersArray(response.rawHeaders),
            body
          });
        };

        let body = response;
        let transform;
        const encoding = response.headers['content-encoding'];

        if (encoding === 'gzip' || encoding === 'x-gzip') {
          transform = _zlib.default.createGunzip({
            flush: _zlib.default.constants.Z_SYNC_FLUSH,
            finishFlush: _zlib.default.constants.Z_SYNC_FLUSH
          });
        } else if (encoding === 'br') {
          transform = _zlib.default.createBrotliDecompress();
        } else if (encoding === 'deflate') {
          transform = _zlib.default.createInflate();
        }

        if (transform) {
          // Brotli and deflate decompressors throw if the input stream is empty.
          const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);
          body = (0, _stream.pipeline)(response, emptyStreamTransform, transform, e => {
            if (e) reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`));
          });
        } else {
          body.on('error', reject);
        }

        body.on('data', chunk => chunks.push(chunk));
        body.on('end', notifyBodyFinished);
      });
      request.on('error', reject);

      const disposeListener = () => {
        reject(new Error('Request context disposed.'));
        request.destroy();
      };

      this.on(APIRequestContext.Events.Dispose, disposeListener);
      request.on('close', () => this.off(APIRequestContext.Events.Dispose, disposeListener));
      progress.log(`→ ${options.method} ${url.toString()}`);

      if (options.headers) {
        for (const [name, value] of Object.entries(options.headers)) progress.log(`  ${name}: ${value}`);
      }

      if (options.deadline) {
        const rejectOnTimeout = () => {
          reject(new Error(`Request timed out after ${options.timeout}ms`));
          request.destroy();
        };

        const remaining = options.deadline - (0, _utils.monotonicTime)();

        if (remaining <= 0) {
          rejectOnTimeout();
          return;
        }

        request.setTimeout(remaining, rejectOnTimeout);
      }

      if (postData) request.write(postData);
      request.end();
    });
  }

}

exports.APIRequestContext = APIRequestContext;
APIRequestContext.Events = {
  Dispose: 'dispose',
  Request: 'request',
  RequestFinished: 'requestfinished'
};
APIRequestContext.allInstances = new Set();

class SafeEmptyStreamTransform extends _stream.Transform {
  constructor(onEmptyStreamCallback) {
    super();
    this._receivedSomeData = false;
    this._onEmptyStreamCallback = void 0;
    this._onEmptyStreamCallback = onEmptyStreamCallback;
  }

  _transform(chunk, encoding, callback) {
    this._receivedSomeData = true;
    callback(null, chunk);
  }

  _flush(callback) {
    if (this._receivedSomeData) callback(null);else this._onEmptyStreamCallback();
  }

}

class BrowserContextAPIRequestContext extends APIRequestContext {
  constructor(context) {
    super(context);
    this._context = void 0;
    this._context = context;
    context.once(_browserContext.BrowserContext.Events.Close, () => this._disposeImpl());
  }

  tracing() {
    return this._context.tracing;
  }

  async dispose() {
    this.fetchResponses.clear();
  }

  _defaultOptions() {
    return {
      userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
      extraHTTPHeaders: this._context._options.extraHTTPHeaders,
      httpCredentials: this._context._options.httpCredentials,
      proxy: this._context._options.proxy || this._context._browser.options.proxy,
      timeoutSettings: this._context._timeoutSettings,
      ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
      baseURL: this._context._options.baseURL
    };
  }

  async _addCookies(cookies) {
    await this._context.addCookies(cookies);
  }

  async _cookies(url) {
    return await this._context.cookies(url.toString());
  }

  async storageState() {
    return this._context.storageState();
  }

}

exports.BrowserContextAPIRequestContext = BrowserContextAPIRequestContext;

class GlobalAPIRequestContext extends APIRequestContext {
  constructor(playwright, options) {
    super(playwright);
    this._cookieStore = new _cookieStore.CookieStore();
    this._options = void 0;
    this._origins = void 0;
    this._tracing = void 0;
    this.attribution.context = this;
    const timeoutSettings = new _timeoutSettings.TimeoutSettings();
    if (options.timeout !== undefined) timeoutSettings.setDefaultTimeout(options.timeout);
    const proxy = options.proxy;

    if (proxy !== null && proxy !== void 0 && proxy.server) {
      let url = proxy === null || proxy === void 0 ? void 0 : proxy.server.trim();
      if (!/^\w+:\/\//.test(url)) url = 'http://' + url;
      proxy.server = url;
    }

    if (options.storageState) {
      this._origins = options.storageState.origins;

      this._cookieStore.addCookies(options.storageState.cookies);
    }

    this._options = {
      baseURL: options.baseURL,
      userAgent: options.userAgent || (0, _userAgent.getUserAgent)(),
      extraHTTPHeaders: options.extraHTTPHeaders,
      ignoreHTTPSErrors: !!options.ignoreHTTPSErrors,
      httpCredentials: options.httpCredentials,
      proxy,
      timeoutSettings
    };
    this._tracing = new _tracing.Tracing(this, options.tracesDir);
  }

  tracing() {
    return this._tracing;
  }

  async dispose() {
    await this._tracing.flush();
    await this._tracing.deleteTmpTracesDir();

    this._tracing.dispose();

    this._disposeImpl();
  }

  _defaultOptions() {
    return this._options;
  }

  async _addCookies(cookies) {
    this._cookieStore.addCookies(cookies);
  }

  async _cookies(url) {
    return this._cookieStore.cookies(url);
  }

  async storageState() {
    return {
      cookies: this._cookieStore.allCookies(),
      origins: this._origins || []
    };
  }

}

exports.GlobalAPIRequestContext = GlobalAPIRequestContext;

function toHeadersArray(rawHeaders) {
  const result = [];

  for (let i = 0; i < rawHeaders.length; i += 2) result.push({
    name: rawHeaders[i],
    value: rawHeaders[i + 1]
  });

  return result;
}

const redirectStatus = [301, 302, 303, 307, 308];

function parseCookie(header) {
  const pairs = header.split(';').filter(s => s.trim().length > 0).map(p => {
    let key = '';
    let value = '';
    const separatorPos = p.indexOf('=');

    if (separatorPos === -1) {
      // If only a key is specified, the value is left undefined.
      key = p.trim();
    } else {
      // Otherwise we assume that the key is the element before the first `=`
      key = p.slice(0, separatorPos).trim(); // And the value is the rest of the string.

      value = p.slice(separatorPos + 1).trim();
    }

    return [key, value];
  });
  if (!pairs.length) return null;
  const [name, value] = pairs[0];
  const cookie = {
    name,
    value,
    domain: '',
    path: '',
    expires: -1,
    httpOnly: false,
    secure: false,
    sameSite: 'Lax' // None for non-chromium

  };

  for (let i = 1; i < pairs.length; i++) {
    const [name, value] = pairs[i];

    switch (name.toLowerCase()) {
      case 'expires':
        const expiresMs = +new Date(value);
        if (isFinite(expiresMs)) cookie.expires = expiresMs / 1000;
        break;

      case 'max-age':
        const maxAgeSec = parseInt(value, 10);
        if (isFinite(maxAgeSec)) cookie.expires = Date.now() / 1000 + maxAgeSec;
        break;

      case 'domain':
        cookie.domain = value.toLocaleLowerCase() || '';
        if (cookie.domain && !cookie.domain.startsWith('.')) cookie.domain = '.' + cookie.domain;
        break;

      case 'path':
        cookie.path = value || '';
        break;

      case 'secure':
        cookie.secure = true;
        break;

      case 'httponly':
        cookie.httpOnly = true;
        break;
    }
  }

  return cookie;
}

function isJsonParsable(value) {
  if (typeof value !== 'string') return false;

  try {
    JSON.parse(value);
    return true;
  } catch (e) {
    if (e instanceof SyntaxError) return false;else throw e;
  }
}

function serializePostData(params, headers) {
  (0, _utils.assert)((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);

  if (params.jsonData !== undefined) {
    var _contentType, _headers$_contentType;

    const json = isJsonParsable(params.jsonData) ? params.jsonData : JSON.stringify(params.jsonData);
    (_headers$_contentType = headers[_contentType = 'content-type']) !== null && _headers$_contentType !== void 0 ? _headers$_contentType : headers[_contentType] = 'application/json';
    return Buffer.from(json, 'utf8');
  } else if (params.formData) {
    var _contentType2, _headers$_contentType2;

    const searchParams = new URLSearchParams();

    for (const {
      name,
      value
    } of params.formData) searchParams.append(name, value);

    (_headers$_contentType2 = headers[_contentType2 = 'content-type']) !== null && _headers$_contentType2 !== void 0 ? _headers$_contentType2 : headers[_contentType2] = 'application/x-www-form-urlencoded';
    return Buffer.from(searchParams.toString(), 'utf8');
  } else if (params.multipartData) {
    var _contentType3, _headers$_contentType3;

    const formData = new _formData.MultipartFormData();

    for (const field of params.multipartData) {
      if (field.file) formData.addFileField(field.name, field.file);else if (field.value) formData.addField(field.name, field.value);
    }

    (_headers$_contentType3 = headers[_contentType3 = 'content-type']) !== null && _headers$_contentType3 !== void 0 ? _headers$_contentType3 : headers[_contentType3] = formData.contentTypeHeader();
    return formData.finish();
  } else if (params.postData !== undefined) {
    var _contentType4, _headers$_contentType4;

    (_headers$_contentType4 = headers[_contentType4 = 'content-type']) !== null && _headers$_contentType4 !== void 0 ? _headers$_contentType4 : headers[_contentType4] = 'application/octet-stream';
    return params.postData;
  }

  return undefined;
}

/***/ }),

/***/ 2337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileChooser = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileChooser {
  constructor(page, elementHandle, isMultiple) {
    this._page = void 0;
    this._elementHandle = void 0;
    this._isMultiple = void 0;
    this._page = page;
    this._elementHandle = elementHandle;
    this._isMultiple = isMultiple;
  }

  element() {
    return this._elementHandle;
  }

  isMultiple() {
    return this._isMultiple;
  }

  page() {
    return this._page;
  }

}

exports.FileChooser = FileChooser;

/***/ }),

/***/ 1112:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getAccessibilityTree = getAccessibilityTree;

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getAccessibilityTree(session, needle) {
  const objectId = needle ? needle._objectId : undefined;
  const {
    tree
  } = await session.send('Accessibility.getFullAXTree', {
    objectId
  });
  const axNode = new FFAXNode(tree);
  return {
    tree: axNode,
    needle: needle ? axNode._findNeedle() : null
  };
}

const FFRoleToARIARole = new Map(Object.entries({
  'pushbutton': 'button',
  'checkbutton': 'checkbox',
  'editcombobox': 'combobox',
  'content deletion': 'deletion',
  'footnote': 'doc-footnote',
  'non-native document': 'document',
  'grouping': 'group',
  'graphic': 'img',
  'content insertion': 'insertion',
  'animation': 'marquee',
  'flat equation': 'math',
  'menupopup': 'menu',
  'check menu item': 'menuitemcheckbox',
  'radio menu item': 'menuitemradio',
  'listbox option': 'option',
  'radiobutton': 'radio',
  'statusbar': 'status',
  'pagetab': 'tab',
  'pagetablist': 'tablist',
  'propertypage': 'tabpanel',
  'entry': 'textbox',
  'outline': 'tree',
  'tree table': 'treegrid',
  'outlineitem': 'treeitem'
}));

class FFAXNode {
  constructor(payload) {
    this._children = void 0;
    this._payload = void 0;
    this._editable = void 0;
    this._richlyEditable = void 0;
    this._focusable = void 0;
    this._expanded = void 0;
    this._name = void 0;
    this._role = void 0;
    this._cachedHasFocusableChild = void 0;
    this._payload = payload;
    this._children = (payload.children || []).map(x => new FFAXNode(x));
    this._editable = !!payload.editable;
    this._richlyEditable = this._editable && payload.tag !== 'textarea' && payload.tag !== 'input';
    this._focusable = !!payload.focusable;
    this._expanded = !!payload.expanded;
    this._name = this._payload.name;
    this._role = this._payload.role;
  }

  _isPlainTextField() {
    if (this._richlyEditable) return false;
    if (this._editable) return true;
    return this._role === 'entry';
  }

  _isTextOnlyObject() {
    const role = this._role;
    return role === 'text leaf' || role === 'text' || role === 'statictext';
  }

  _hasFocusableChild() {
    if (this._cachedHasFocusableChild === undefined) {
      this._cachedHasFocusableChild = false;

      for (const child of this._children) {
        if (child._focusable || child._hasFocusableChild()) {
          this._cachedHasFocusableChild = true;
          break;
        }
      }
    }

    return this._cachedHasFocusableChild;
  }

  children() {
    return this._children;
  }

  _findNeedle() {
    if (this._payload.foundObject) return this;

    for (const child of this._children) {
      const found = child._findNeedle();

      if (found) return found;
    }

    return null;
  }

  isLeafNode() {
    if (!this._children.length) return true; // These types of objects may have children that we use as internal
    // implementation details, but we want to expose them as leaves to platform
    // accessibility APIs because screen readers might be confused if they find
    // any children.

    if (this._isPlainTextField() || this._isTextOnlyObject()) return true; // Roles whose children are only presentational according to the ARIA and
    // HTML5 Specs should be hidden from screen readers.
    // (Note that whilst ARIA buttons can have only presentational children, HTML5
    // buttons are allowed to have content.)

    switch (this._role) {
      case 'graphic':
      case 'scrollbar':
      case 'slider':
      case 'separator':
      case 'progressbar':
        return true;

      default:
        break;
    } // Here and below: Android heuristics


    if (this._hasFocusableChild()) return false;
    if (this._focusable && this._role !== 'document' && this._name) return true;
    if (this._role === 'heading' && this._name) return true;
    return false;
  }

  isControl() {
    switch (this._role) {
      case 'checkbutton':
      case 'check menu item':
      case 'check rich option':
      case 'combobox':
      case 'combobox option':
      case 'color chooser':
      case 'listbox':
      case 'listbox option':
      case 'listbox rich option':
      case 'popup menu':
      case 'menupopup':
      case 'menuitem':
      case 'menubar':
      case 'button':
      case 'pushbutton':
      case 'radiobutton':
      case 'radio menuitem':
      case 'scrollbar':
      case 'slider':
      case 'spinbutton':
      case 'switch':
      case 'pagetab':
      case 'entry':
      case 'tree table':
        return true;

      default:
        return false;
    }
  }

  isInteresting(insideControl) {
    if (this._focusable || this._richlyEditable) return true; // If it's not focusable but has a control role, then it's interesting.

    if (this.isControl()) return true; // A non focusable child of a control is not interesting

    if (insideControl) return false;
    return this.isLeafNode() && !!this._name.trim();
  }

  serialize() {
    const node = {
      role: FFRoleToARIARole.get(this._role) || this._role,
      name: this._name || ''
    };
    const userStringProperties = ['name', 'description', 'roledescription', 'valuetext', 'keyshortcuts'];

    for (const userStringProperty of userStringProperties) {
      if (!(userStringProperty in this._payload)) continue;
      node[userStringProperty] = this._payload[userStringProperty];
    }

    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];

    for (const booleanProperty of booleanProperties) {
      if (this._role === 'document' && booleanProperty === 'focused') continue; // document focusing is strange

      const value = this._payload[booleanProperty];
      if (!value) continue;
      node[booleanProperty] = value;
    }

    const numericalProperties = ['level'];

    for (const numericalProperty of numericalProperties) {
      if (!(numericalProperty in this._payload)) continue;
      node[numericalProperty] = this._payload[numericalProperty];
    }

    const tokenProperties = ['autocomplete', 'haspopup', 'invalid', 'orientation'];

    for (const tokenProperty of tokenProperties) {
      const value = this._payload[tokenProperty];
      if (!value || value === 'false') continue;
      node[tokenProperty] = value;
    }

    const axNode = node;
    axNode.valueString = this._payload.value;
    if ('checked' in this._payload) axNode.checked = this._payload.checked === true ? 'checked' : this._payload.checked === 'mixed' ? 'mixed' : 'unchecked';
    if ('pressed' in this._payload) axNode.pressed = this._payload.pressed === true ? 'pressed' : 'released';
    return axNode;
  }

}

/***/ }),

/***/ 923:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FFBrowserContext = exports.FFBrowser = void 0;

var _errors = __nccwpck_require__(542);

var _utils = __nccwpck_require__(3557);

var _browser = __nccwpck_require__(6705);

var _browserContext = __nccwpck_require__(5985);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _ffConnection = __nccwpck_require__(4327);

var _ffPage = __nccwpck_require__(1674);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FFBrowser extends _browser.Browser {
  static async connect(transport, options) {
    const connection = new _ffConnection.FFConnection(transport, options.protocolLogger, options.browserLogsCollector);
    const browser = new FFBrowser(connection, options);
    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();
    const promises = [connection.send('Browser.enable', {
      attachToDefaultContext: !!options.persistent
    }), browser._initVersion()];

    if (options.persistent) {
      browser._defaultContext = new FFBrowserContext(browser, undefined, options.persistent);
      promises.push(browser._defaultContext._initialize());
    }

    if (options.proxy) promises.push(browser._connection.send('Browser.setBrowserProxy', toJugglerProxyOptions(options.proxy)));
    await Promise.all(promises);
    return browser;
  }

  constructor(connection, options) {
    super(options);
    this._connection = void 0;
    this._ffPages = void 0;
    this._contexts = void 0;
    this._version = '';
    this._userAgent = '';
    this._connection = connection;
    this._ffPages = new Map();
    this._contexts = new Map();

    this._connection.on(_ffConnection.ConnectionEvents.Disconnected, () => this._onDisconnect());

    this._connection.on('Browser.attachedToTarget', this._onAttachedToTarget.bind(this));

    this._connection.on('Browser.detachedFromTarget', this._onDetachedFromTarget.bind(this));

    this._connection.on('Browser.downloadCreated', this._onDownloadCreated.bind(this));

    this._connection.on('Browser.downloadFinished', this._onDownloadFinished.bind(this));

    this._connection.on('Browser.videoRecordingFinished', this._onVideoRecordingFinished.bind(this));
  }

  async _initVersion() {
    const result = await this._connection.send('Browser.getInfo');
    this._version = result.version.substring(result.version.indexOf('/') + 1);
    this._userAgent = result.userAgent;
  }

  isConnected() {
    return !this._connection._closed;
  }

  async doCreateNewContext(options) {
    if (options.isMobile) throw new Error('options.isMobile is not supported in Firefox');
    const {
      browserContextId
    } = await this._connection.send('Browser.createBrowserContext', {
      removeOnDetach: true
    });
    const context = new FFBrowserContext(this, browserContextId, options);
    await context._initialize();

    this._contexts.set(browserContextId, context);

    return context;
  }

  contexts() {
    return Array.from(this._contexts.values());
  }

  version() {
    return this._version;
  }

  userAgent() {
    return this._userAgent;
  }

  _onDetachedFromTarget(payload) {
    const ffPage = this._ffPages.get(payload.targetId);

    this._ffPages.delete(payload.targetId);

    ffPage.didClose();
  }

  _onAttachedToTarget(payload) {
    const {
      targetId,
      browserContextId,
      openerId,
      type
    } = payload.targetInfo;
    (0, _utils.assert)(type === 'page');
    const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
    (0, _utils.assert)(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);

    const session = this._connection.createSession(payload.sessionId);

    const opener = openerId ? this._ffPages.get(openerId) : null;
    const ffPage = new _ffPage.FFPage(session, context, opener);

    this._ffPages.set(targetId, ffPage);
  }

  _onDownloadCreated(payload) {
    const ffPage = this._ffPages.get(payload.pageTargetId);

    (0, _utils.assert)(ffPage);
    if (!ffPage) return;
    let originPage = ffPage._initializedPage; // If it's a new window download, report it on the opener page.

    if (!originPage) {
      // Resume the page creation with an error. The page will automatically close right
      // after the download begins.
      ffPage._markAsError(new Error('Starting new page download'));

      if (ffPage._opener) originPage = ffPage._opener._initializedPage;
    }

    if (!originPage) return;

    this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
  }

  _onDownloadFinished(payload) {
    const error = payload.canceled ? 'canceled' : payload.error;

    this._downloadFinished(payload.uuid, error);
  }

  _onVideoRecordingFinished(payload) {
    var _this$_takeVideo;

    (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
  }

  _onDisconnect() {
    for (const video of this._idToVideo.values()) video.artifact.reportFinished(_errors.kBrowserClosedError);

    this._idToVideo.clear();

    this._didClose();
  }

}

exports.FFBrowser = FFBrowser;

class FFBrowserContext extends _browserContext.BrowserContext {
  constructor(browser, browserContextId, options) {
    super(browser, options, browserContextId);
  }

  async _initialize() {
    (0, _utils.assert)(!this._ffPages().length);
    const browserContextId = this._browserContextId;
    const promises = [super._initialize()];
    promises.push(this._browser._connection.send('Browser.setDownloadOptions', {
      browserContextId,
      downloadOptions: {
        behavior: this._options.acceptDownloads ? 'saveToDisk' : 'cancel',
        downloadsDir: this._browser.options.downloadsPath
      }
    }));

    if (this._options.viewport) {
      const viewport = {
        viewportSize: {
          width: this._options.viewport.width,
          height: this._options.viewport.height
        },
        deviceScaleFactor: this._options.deviceScaleFactor || 1
      };
      promises.push(this._browser._connection.send('Browser.setDefaultViewport', {
        browserContextId,
        viewport
      }));
    }

    if (this._options.hasTouch) promises.push(this._browser._connection.send('Browser.setTouchOverride', {
      browserContextId,
      hasTouch: true
    }));
    if (this._options.userAgent) promises.push(this._browser._connection.send('Browser.setUserAgentOverride', {
      browserContextId,
      userAgent: this._options.userAgent
    }));
    if (this._options.bypassCSP) promises.push(this._browser._connection.send('Browser.setBypassCSP', {
      browserContextId,
      bypassCSP: true
    }));
    if (this._options.ignoreHTTPSErrors) promises.push(this._browser._connection.send('Browser.setIgnoreHTTPSErrors', {
      browserContextId,
      ignoreHTTPSErrors: true
    }));
    if (this._options.javaScriptEnabled === false) promises.push(this._browser._connection.send('Browser.setJavaScriptDisabled', {
      browserContextId,
      javaScriptDisabled: true
    }));
    if (this._options.locale) promises.push(this._browser._connection.send('Browser.setLocaleOverride', {
      browserContextId,
      locale: this._options.locale
    }));
    if (this._options.timezoneId) promises.push(this._browser._connection.send('Browser.setTimezoneOverride', {
      browserContextId,
      timezoneId: this._options.timezoneId
    }));
    if (this._options.extraHTTPHeaders || this._options.locale) promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
    if (this._options.httpCredentials) promises.push(this.setHTTPCredentials(this._options.httpCredentials));
    if (this._options.geolocation) promises.push(this.setGeolocation(this._options.geolocation));
    if (this._options.offline) promises.push(this.setOffline(this._options.offline));
    promises.push(this._browser._connection.send('Browser.setColorScheme', {
      browserContextId,
      colorScheme: this._options.colorScheme !== undefined ? this._options.colorScheme : 'light'
    }));
    promises.push(this._browser._connection.send('Browser.setReducedMotion', {
      browserContextId,
      reducedMotion: this._options.reducedMotion !== undefined ? this._options.reducedMotion : 'no-preference'
    }));
    promises.push(this._browser._connection.send('Browser.setForcedColors', {
      browserContextId,
      forcedColors: this._options.forcedColors !== undefined ? this._options.forcedColors : 'none'
    }));

    if (this._options.recordVideo) {
      promises.push(this._ensureVideosPath().then(() => {
        return this._browser._connection.send('Browser.setVideoRecordingOptions', {
          // validateBrowserContextOptions ensures correct video size.
          options: { ...this._options.recordVideo.size,
            dir: this._options.recordVideo.dir
          },
          browserContextId: this._browserContextId
        });
      }));
    }

    if (this._options.proxy) {
      promises.push(this._browser._connection.send('Browser.setContextProxy', {
        browserContextId: this._browserContextId,
        ...toJugglerProxyOptions(this._options.proxy)
      }));
    }

    await Promise.all(promises);
  }

  _ffPages() {
    return Array.from(this._browser._ffPages.values()).filter(ffPage => ffPage._browserContext === this);
  }

  pages() {
    return this._ffPages().map(ffPage => ffPage._initializedPage).filter(pageOrNull => !!pageOrNull);
  }

  async newPageDelegate() {
    (0, _browserContext.assertBrowserContextIsNotOwned)(this);
    const {
      targetId
    } = await this._browser._connection.send('Browser.newPage', {
      browserContextId: this._browserContextId
    }).catch(e => {
      if (e.message.includes('Failed to override timezone')) throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
      throw e;
    });
    return this._browser._ffPages.get(targetId);
  }

  async doGetCookies(urls) {
    const {
      cookies
    } = await this._browser._connection.send('Browser.getCookies', {
      browserContextId: this._browserContextId
    });
    return network.filterCookies(cookies.map(c => {
      const copy = { ...c
      };
      delete copy.size;
      delete copy.session;
      return copy;
    }), urls);
  }

  async addCookies(cookies) {
    const cc = network.rewriteCookies(cookies).map(c => ({ ...c,
      expires: c.expires && c.expires !== -1 ? c.expires : undefined
    }));
    await this._browser._connection.send('Browser.setCookies', {
      browserContextId: this._browserContextId,
      cookies: cc
    });
  }

  async clearCookies() {
    await this._browser._connection.send('Browser.clearCookies', {
      browserContextId: this._browserContextId
    });
  }

  async doGrantPermissions(origin, permissions) {
    const webPermissionToProtocol = new Map([['geolocation', 'geo'], ['persistent-storage', 'persistent-storage'], ['push', 'push'], ['notifications', 'desktop-notification']]);
    const filtered = permissions.map(permission => {
      const protocolPermission = webPermissionToProtocol.get(permission);
      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);
      return protocolPermission;
    });
    await this._browser._connection.send('Browser.grantPermissions', {
      origin: origin,
      browserContextId: this._browserContextId,
      permissions: filtered
    });
  }

  async doClearPermissions() {
    await this._browser._connection.send('Browser.resetPermissions', {
      browserContextId: this._browserContextId
    });
  }

  async setGeolocation(geolocation) {
    (0, _browserContext.verifyGeolocation)(geolocation);
    this._options.geolocation = geolocation;
    await this._browser._connection.send('Browser.setGeolocationOverride', {
      browserContextId: this._browserContextId,
      geolocation: geolocation || null
    });
  }

  async setExtraHTTPHeaders(headers) {
    this._options.extraHTTPHeaders = headers;
    let allHeaders = this._options.extraHTTPHeaders;
    if (this._options.locale) allHeaders = network.mergeHeaders([allHeaders, network.singleHeader('Accept-Language', this._options.locale)]);
    await this._browser._connection.send('Browser.setExtraHTTPHeaders', {
      browserContextId: this._browserContextId,
      headers: allHeaders
    });
  }

  async setUserAgent(userAgent) {
    await this._browser._connection.send('Browser.setUserAgentOverride', {
      browserContextId: this._browserContextId,
      userAgent: userAgent || null
    });
  }

  async setOffline(offline) {
    this._options.offline = offline;
    await this._browser._connection.send('Browser.setOnlineOverride', {
      browserContextId: this._browserContextId,
      override: offline ? 'offline' : 'online'
    });
  }

  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;
    await this._browser._connection.send('Browser.setHTTPCredentials', {
      browserContextId: this._browserContextId,
      credentials: httpCredentials || null
    });
  }

  async doAddInitScript(source) {
    await this._browser._connection.send('Browser.setInitScripts', {
      browserContextId: this._browserContextId,
      scripts: this.initScripts.map(script => ({
        script
      }))
    });
  }

  async doRemoveInitScripts() {
    await this._browser._connection.send('Browser.setInitScripts', {
      browserContextId: this._browserContextId,
      scripts: []
    });
  }

  async doExposeBinding(binding) {
    await this._browser._connection.send('Browser.addBinding', {
      browserContextId: this._browserContextId,
      name: binding.name,
      script: binding.source
    });
  }

  async doRemoveExposedBindings() {// TODO: implement me.
    // This is not a critical problem, what ends up happening is
    // an old binding will be restored upon page reload and will point nowhere.
  }

  async doUpdateRequestInterception() {
    await this._browser._connection.send('Browser.setRequestInterception', {
      browserContextId: this._browserContextId,
      enabled: !!this._requestInterceptor
    });
  }

  onClosePersistent() {}

  async doClose() {
    (0, _utils.assert)(this._browserContextId);
    await this._browser._connection.send('Browser.removeBrowserContext', {
      browserContextId: this._browserContextId
    });

    this._browser._contexts.delete(this._browserContextId);
  }

  async cancelDownload(uuid) {
    await this._browser._connection.send('Browser.cancelDownload', {
      uuid
    });
  }

}

exports.FFBrowserContext = FFBrowserContext;

function toJugglerProxyOptions(proxy) {
  const proxyServer = new URL(proxy.server);
  let port = parseInt(proxyServer.port, 10);
  let type = 'http';
  if (proxyServer.protocol === 'socks5:') type = 'socks';else if (proxyServer.protocol === 'socks4:') type = 'socks4';else if (proxyServer.protocol === 'https:') type = 'https';

  if (proxyServer.port === '') {
    if (proxyServer.protocol === 'http:') port = 80;else if (proxyServer.protocol === 'https:') port = 443;
  }

  return {
    type,
    bypass: proxy.bypass ? proxy.bypass.split(',').map(domain => domain.trim()) : [],
    host: proxyServer.hostname,
    port,
    username: proxy.username,
    password: proxy.password
  };
}

/***/ }),

/***/ 4327:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.kBrowserCloseMessageId = exports.FFSessionEvents = exports.FFSession = exports.FFConnection = exports.ConnectionEvents = void 0;

var _events = __nccwpck_require__(2361);

var _utils = __nccwpck_require__(3557);

var _stackTrace = __nccwpck_require__(9030);

var _debugLogger = __nccwpck_require__(2003);

var _helper = __nccwpck_require__(9175);

var _protocolError = __nccwpck_require__(7314);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ConnectionEvents = {
  Disconnected: Symbol('Disconnected')
}; // FFPlaywright uses this special id to issue Browser.close command which we
// should ignore.

exports.ConnectionEvents = ConnectionEvents;
const kBrowserCloseMessageId = -9999;
exports.kBrowserCloseMessageId = kBrowserCloseMessageId;

class FFConnection extends _events.EventEmitter {
  constructor(transport, protocolLogger, browserLogsCollector) {
    super();
    this._lastId = void 0;
    this._callbacks = void 0;
    this._transport = void 0;
    this._protocolLogger = void 0;
    this._browserLogsCollector = void 0;
    this._sessions = void 0;
    this._closed = void 0;
    this.on = void 0;
    this.addListener = void 0;
    this.off = void 0;
    this.removeListener = void 0;
    this.once = void 0;
    this.setMaxListeners(0);
    this._transport = transport;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this._lastId = 0;
    this._callbacks = new Map();
    this._sessions = new Map();
    this._closed = false;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
    this._transport.onmessage = this._onMessage.bind(this); // onclose should be set last, since it can be immediately called.

    this._transport.onclose = this._onClose.bind(this);
  }

  async send(method, params) {
    this._checkClosed(method);

    const id = this.nextMessageId();

    this._rawSend({
      id,
      method,
      params
    });

    return new Promise((resolve, reject) => {
      this._callbacks.set(id, {
        resolve,
        reject,
        error: new _protocolError.ProtocolError(false),
        method
      });
    });
  }

  nextMessageId() {
    return ++this._lastId;
  }

  _checkClosed(method) {
    if (this._closed) throw new _protocolError.ProtocolError(true, `${method}): Browser closed.` + _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
  }

  _rawSend(message) {
    this._protocolLogger('send', message);

    this._transport.send(message);
  }

  async _onMessage(message) {
    this._protocolLogger('receive', message);

    if (message.id === kBrowserCloseMessageId) return;

    if (message.sessionId) {
      const session = this._sessions.get(message.sessionId);

      if (session) session.dispatchMessage(message);
    } else if (message.id) {
      const callback = this._callbacks.get(message.id); // Callbacks could be all rejected if someone has called `.dispose()`.


      if (callback) {
        this._callbacks.delete(message.id);

        if (message.error) callback.reject(createProtocolError(callback.error, callback.method, message.error));else callback.resolve(message.result);
      }
    } else {
      Promise.resolve().then(() => this.emit(message.method, message.params));
    }
  }

  _onClose() {
    this._closed = true;
    this._transport.onmessage = undefined;
    this._transport.onclose = undefined;

    const formattedBrowserLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());

    for (const session of this._sessions.values()) session.dispose();

    this._sessions.clear();

    for (const callback of this._callbacks.values()) {
      const error = (0, _stackTrace.rewriteErrorMessage)(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs);
      error.sessionClosed = true;
      callback.reject(error);
    }

    this._callbacks.clear();

    Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
  }

  close() {
    if (!this._closed) this._transport.close();
  }

  createSession(sessionId) {
    const session = new FFSession(this, sessionId, message => this._rawSend({ ...message,
      sessionId
    }));

    this._sessions.set(sessionId, session);

    return session;
  }

}

exports.FFConnection = FFConnection;
const FFSessionEvents = {
  Disconnected: Symbol('Disconnected')
};
exports.FFSessionEvents = FFSessionEvents;

class FFSession extends _events.EventEmitter {
  constructor(connection, sessionId, rawSend) {
    super();
    this._connection = void 0;
    this._disposed = false;
    this._callbacks = void 0;
    this._sessionId = void 0;
    this._rawSend = void 0;
    this._crashed = false;
    this.on = void 0;
    this.addListener = void 0;
    this.off = void 0;
    this.removeListener = void 0;
    this.once = void 0;
    this.setMaxListeners(0);
    this._callbacks = new Map();
    this._connection = connection;
    this._sessionId = sessionId;
    this._rawSend = rawSend;
    this.on = super.on;
    this.addListener = super.addListener;
    this.off = super.removeListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }

  markAsCrashed() {
    this._crashed = true;
  }

  async send(method, params) {
    if (this._crashed) throw new _protocolError.ProtocolError(true, 'Target crashed');

    this._connection._checkClosed(method);

    if (this._disposed) throw new _protocolError.ProtocolError(true, 'Target closed');

    const id = this._connection.nextMessageId();

    this._rawSend({
      method,
      params,
      id
    });

    return new Promise((resolve, reject) => {
      this._callbacks.set(id, {
        resolve,
        reject,
        error: new _protocolError.ProtocolError(false),
        method
      });
    });
  }

  sendMayFail(method, params) {
    return this.send(method, params).catch(error => _debugLogger.debugLogger.log('error', error));
  }

  dispatchMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);

      this._callbacks.delete(object.id);

      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object.error));else callback.resolve(object.result);
    } else {
      (0, _utils.assert)(!object.id);
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }

  dispose() {
    for (const callback of this._callbacks.values()) {
      callback.error.sessionClosed = true;
      callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, 'Target closed'));
    }

    this._callbacks.clear();

    this._disposed = true;

    this._connection._sessions.delete(this._sessionId);

    Promise.resolve().then(() => this.emit(FFSessionEvents.Disconnected));
  }

}

exports.FFSession = FFSession;

function createProtocolError(error, method, protocolError) {
  let message = `Protocol error (${method}): ${protocolError.message}`;
  if ('data' in protocolError) message += ` ${protocolError.data}`;
  return (0, _stackTrace.rewriteErrorMessage)(error, message);
}

/***/ }),

/***/ 131:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FFExecutionContext = void 0;

var js = _interopRequireWildcard(__nccwpck_require__(804));

var _stackTrace = __nccwpck_require__(9030);

var _utilityScriptSerializers = __nccwpck_require__(9012);

var _protocolError = __nccwpck_require__(7314);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FFExecutionContext {
  constructor(session, executionContextId) {
    this._session = void 0;
    this._executionContextId = void 0;
    this._session = session;
    this._executionContextId = executionContextId;
  }

  async rawEvaluateJSON(expression) {
    const payload = await this._session.send('Runtime.evaluate', {
      expression,
      returnByValue: true,
      executionContextId: this._executionContextId
    }).catch(rewriteError);
    checkException(payload.exceptionDetails);
    return payload.result.value;
  }

  async rawEvaluateHandle(expression) {
    const payload = await this._session.send('Runtime.evaluate', {
      expression,
      returnByValue: false,
      executionContextId: this._executionContextId
    }).catch(rewriteError);
    checkException(payload.exceptionDetails);
    return payload.result.objectId;
  }

  rawCallFunctionNoReply(func, ...args) {
    this._session.send('Runtime.callFunction', {
      functionDeclaration: func.toString(),
      args: args.map(a => a instanceof js.JSHandle ? {
        objectId: a._objectId
      } : {
        value: a
      }),
      returnByValue: true,
      executionContextId: this._executionContextId
    }).catch(() => {});
  }

  async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
    const payload = await this._session.send('Runtime.callFunction', {
      functionDeclaration: expression,
      args: [{
        objectId: utilityScript._objectId,
        value: undefined
      }, ...values.map(value => ({
        value
      })), ...objectIds.map(objectId => ({
        objectId,
        value: undefined
      }))],
      returnByValue,
      executionContextId: this._executionContextId
    }).catch(rewriteError);
    checkException(payload.exceptionDetails);
    if (returnByValue) return (0, _utilityScriptSerializers.parseEvaluationResultValue)(payload.result.value);
    return utilityScript._context.createHandle(payload.result);
  }

  async getProperties(context, objectId) {
    const response = await this._session.send('Runtime.getObjectProperties', {
      executionContextId: this._executionContextId,
      objectId
    });
    const result = new Map();

    for (const property of response.properties) result.set(property.name, context.createHandle(property.value));

    return result;
  }

  createHandle(context, remoteObject) {
    return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || '', renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
  }

  async releaseHandle(objectId) {
    await this._session.send('Runtime.disposeObject', {
      executionContextId: this._executionContextId,
      objectId
    });
  }

}

exports.FFExecutionContext = FFExecutionContext;

function checkException(exceptionDetails) {
  if (!exceptionDetails) return;
  if (exceptionDetails.value) throw new js.JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));else throw new js.JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? '\n' + exceptionDetails.stack : ''));
}

function rewriteError(error) {
  if (error.message.includes('cyclic object value') || error.message.includes('Object is not serializable')) return {
    result: {
      type: 'undefined',
      value: undefined
    }
  };
  if (error instanceof TypeError && error.message.startsWith('Converting circular structure to JSON')) (0, _stackTrace.rewriteErrorMessage)(error, error.message + ' Are you passing a nested JSHandle?');
  if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error)) throw new Error('Execution context was destroyed, most likely because of a navigation.');
  throw error;
}

function potentiallyUnserializableValue(remoteObject) {
  const value = remoteObject.value;
  const unserializableValue = remoteObject.unserializableValue;
  return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
}

function renderPreview(object) {
  if (object.type === 'undefined') return 'undefined';
  if (object.unserializableValue) return String(object.unserializableValue);
  if (object.type === 'symbol') return 'Symbol()';
  if (object.subtype === 'regexp') return 'RegExp';
  if (object.subtype === 'weakmap') return 'WeakMap';
  if (object.subtype === 'weakset') return 'WeakSet';
  if (object.subtype) return object.subtype[0].toUpperCase() + object.subtype.slice(1);
  if ('value' in object) return String(object.value);
}

/***/ }),

/***/ 7848:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function toModifiersMask(modifiers) {
  let mask = 0;
  if (modifiers.has('Alt')) mask |= 1;
  if (modifiers.has('Control')) mask |= 2;
  if (modifiers.has('Shift')) mask |= 4;
  if (modifiers.has('Meta')) mask |= 8;
  return mask;
}

function toButtonNumber(button) {
  if (button === 'left') return 0;
  if (button === 'middle') return 1;
  if (button === 'right') return 2;
  return 0;
}

function toButtonsMask(buttons) {
  let mask = 0;
  if (buttons.has('left')) mask |= 1;
  if (buttons.has('right')) mask |= 2;
  if (buttons.has('middle')) mask |= 4;
  return mask;
}

class RawKeyboardImpl {
  constructor(client) {
    this._client = void 0;
    this._client = client;
  }

  async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
    if (code === 'MetaLeft') code = 'OSLeft';
    if (code === 'MetaRight') code = 'OSRight'; // Firefox will figure out Enter by itself

    if (text === '\r') text = '';
    await this._client.send('Page.dispatchKeyEvent', {
      type: 'keydown',
      keyCode: keyCodeWithoutLocation,
      code,
      key,
      repeat: autoRepeat,
      location,
      text
    });
  }

  async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
    if (code === 'MetaLeft') code = 'OSLeft';
    if (code === 'MetaRight') code = 'OSRight';
    await this._client.send('Page.dispatchKeyEvent', {
      type: 'keyup',
      key,
      keyCode: keyCodeWithoutLocation,
      code,
      location,
      repeat: false
    });
  }

  async sendText(text) {
    await this._client.send('Page.insertText', {
      text
    });
  }

}

exports.RawKeyboardImpl = RawKeyboardImpl;

class RawMouseImpl {
  constructor(client) {
    this._client = void 0;
    this._page = void 0;
    this._client = client;
  }

  async move(x, y, button, buttons, modifiers, forClick) {
    await this._client.send('Page.dispatchMouseEvent', {
      type: 'mousemove',
      button: 0,
      buttons: toButtonsMask(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask(modifiers)
    });
  }

  async down(x, y, button, buttons, modifiers, clickCount) {
    await this._client.send('Page.dispatchMouseEvent', {
      type: 'mousedown',
      button: toButtonNumber(button),
      buttons: toButtonsMask(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask(modifiers),
      clickCount
    });
  }

  async up(x, y, button, buttons, modifiers, clickCount) {
    await this._client.send('Page.dispatchMouseEvent', {
      type: 'mouseup',
      button: toButtonNumber(button),
      buttons: toButtonsMask(buttons),
      x: Math.floor(x),
      y: Math.floor(y),
      modifiers: toModifiersMask(modifiers),
      clickCount
    });
  }

  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    // Wheel events hit the compositor first, so wait one frame for it to be synced.
    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, 'utility');
    await this._client.send('Page.dispatchWheelEvent', {
      deltaX,
      deltaY,
      x: Math.floor(x),
      y: Math.floor(y),
      deltaZ: 0,
      modifiers: toModifiersMask(modifiers)
    });
  }

  setPage(page) {
    this._page = page;
  }

}

exports.RawMouseImpl = RawMouseImpl;

class RawTouchscreenImpl {
  constructor(client) {
    this._client = void 0;
    this._client = client;
  }

  async tap(x, y, modifiers) {
    await this._client.send('Page.dispatchTapEvent', {
      x,
      y,
      modifiers: toModifiersMask(modifiers)
    });
  }

}

exports.RawTouchscreenImpl = RawTouchscreenImpl;

/***/ }),

/***/ 6427:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FFNetworkManager = void 0;

var _eventsHelper = __nccwpck_require__(3841);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FFNetworkManager {
  constructor(session, page) {
    this._session = void 0;
    this._requests = void 0;
    this._page = void 0;
    this._eventListeners = void 0;
    this._session = session;
    this._requests = new Map();
    this._page = page;
    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSent', this._onRequestWillBeSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceived', this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestFinished', this._onRequestFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestFailed', this._onRequestFailed.bind(this))];
  }

  dispose() {
    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
  }

  async setRequestInterception(enabled) {
    await this._session.send('Network.setRequestInterception', {
      enabled
    });
  }

  _onRequestWillBeSent(event) {
    const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
    const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
    if (!frame) return;
    if (redirectedFrom) this._requests.delete(redirectedFrom._id);
    const request = new InterceptableRequest(frame, redirectedFrom, event);
    let route;
    if (event.isIntercepted) route = new FFRouteImpl(this._session, request);

    this._requests.set(request._id, request);

    this._page._frameManager.requestStarted(request.request, route);
  }

  _onResponseReceived(event) {
    var _event$securityDetail, _event$securityDetail2, _event$securityDetail3, _event$securityDetail4, _event$securityDetail5;

    const request = this._requests.get(event.requestId);

    if (!request) return;

    const getResponseBody = async () => {
      const response = await this._session.send('Network.getResponseBody', {
        requestId: request._id
      });
      if (response.evicted) throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
      return Buffer.from(response.base64body, 'base64');
    };

    const startTime = event.timing.startTime;

    function relativeToStart(time) {
      if (!time) return -1;
      return (time - startTime) / 1000;
    }

    const timing = {
      startTime: startTime / 1000,
      domainLookupStart: relativeToStart(event.timing.domainLookupStart),
      domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
      connectStart: relativeToStart(event.timing.connectStart),
      secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
      connectEnd: relativeToStart(event.timing.connectEnd),
      requestStart: relativeToStart(event.timing.requestStart),
      responseStart: relativeToStart(event.timing.responseStart)
    };
    const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody, event.fromServiceWorker);

    if (event !== null && event !== void 0 && event.remoteIPAddress && typeof (event === null || event === void 0 ? void 0 : event.remotePort) === 'number') {
      response._serverAddrFinished({
        ipAddress: event.remoteIPAddress,
        port: event.remotePort
      });
    } else {
      response._serverAddrFinished();
    }

    response._securityDetailsFinished({
      protocol: event === null || event === void 0 ? void 0 : (_event$securityDetail = event.securityDetails) === null || _event$securityDetail === void 0 ? void 0 : _event$securityDetail.protocol,
      subjectName: event === null || event === void 0 ? void 0 : (_event$securityDetail2 = event.securityDetails) === null || _event$securityDetail2 === void 0 ? void 0 : _event$securityDetail2.subjectName,
      issuer: event === null || event === void 0 ? void 0 : (_event$securityDetail3 = event.securityDetails) === null || _event$securityDetail3 === void 0 ? void 0 : _event$securityDetail3.issuer,
      validFrom: event === null || event === void 0 ? void 0 : (_event$securityDetail4 = event.securityDetails) === null || _event$securityDetail4 === void 0 ? void 0 : _event$securityDetail4.validFrom,
      validTo: event === null || event === void 0 ? void 0 : (_event$securityDetail5 = event.securityDetails) === null || _event$securityDetail5 === void 0 ? void 0 : _event$securityDetail5.validTo
    }); // "raw" headers are the same as "provisional" headers in Firefox.


    response.setRawResponseHeaders(null); // Headers size are not available in Firefox.

    response.setResponseHeadersSize(null);

    this._page._frameManager.requestReceivedResponse(response);
  }

  _onRequestFinished(event) {
    const request = this._requests.get(event.requestId);

    if (!request) return;

    const response = request.request._existingResponse();

    response.setTransferSize(event.transferSize);
    response.setEncodedBodySize(event.encodedBodySize); // Keep redirected requests in the map for future reference as redirectedFrom.

    const isRedirected = response.status() >= 300 && response.status() <= 399;
    const responseEndTime = event.responseEndTime ? event.responseEndTime / 1000 - response.timing().startTime : -1;

    if (isRedirected) {
      response._requestFinished(responseEndTime);
    } else {
      this._requests.delete(request._id);

      response._requestFinished(responseEndTime);
    }

    if (event.protocolVersion) response._setHttpVersion(event.protocolVersion);

    this._page._frameManager.reportRequestFinished(request.request, response);
  }

  _onRequestFailed(event) {
    const request = this._requests.get(event.requestId);

    if (!request) return;

    this._requests.delete(request._id);

    const response = request.request._existingResponse();

    if (response) {
      response.setTransferSize(null);
      response.setEncodedBodySize(null);

      response._requestFinished(-1);
    }

    request.request._setFailureText(event.errorCode);

    this._page._frameManager.requestFailed(request.request, event.errorCode === 'NS_BINDING_ABORTED');
  }

}

exports.FFNetworkManager = FFNetworkManager;
const causeToResourceType = {
  TYPE_INVALID: 'other',
  TYPE_OTHER: 'other',
  TYPE_SCRIPT: 'script',
  TYPE_IMAGE: 'image',
  TYPE_STYLESHEET: 'stylesheet',
  TYPE_OBJECT: 'other',
  TYPE_DOCUMENT: 'document',
  TYPE_SUBDOCUMENT: 'document',
  TYPE_REFRESH: 'document',
  TYPE_XBL: 'other',
  TYPE_PING: 'other',
  TYPE_XMLHTTPREQUEST: 'xhr',
  TYPE_OBJECT_SUBREQUEST: 'other',
  TYPE_DTD: 'other',
  TYPE_FONT: 'font',
  TYPE_MEDIA: 'media',
  TYPE_WEBSOCKET: 'websocket',
  TYPE_CSP_REPORT: 'other',
  TYPE_XSLT: 'other',
  TYPE_BEACON: 'other',
  TYPE_FETCH: 'fetch',
  TYPE_IMAGESET: 'images',
  TYPE_WEB_MANIFEST: 'manifest'
};
const internalCauseToResourceType = {
  TYPE_INTERNAL_EVENTSOURCE: 'eventsource'
};

class InterceptableRequest {
  constructor(frame, redirectedFrom, payload) {
    this.request = void 0;
    this._id = void 0;
    this._redirectedTo = void 0;
    this._id = payload.requestId;
    if (redirectedFrom) redirectedFrom._redirectedTo = this;
    let postDataBuffer = null;
    if (payload.postData) postDataBuffer = Buffer.from(payload.postData, 'base64');
    this.request = new network.Request(frame._page._browserContext, frame, null, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || 'other', payload.method, postDataBuffer, payload.headers); // "raw" headers are the same as "provisional" headers in Firefox.

    this.request.setRawRequestHeaders(null);
  }

  _finalRequest() {
    let request = this;

    while (request._redirectedTo) request = request._redirectedTo;

    return request;
  }

}

class FFRouteImpl {
  constructor(session, request) {
    this._request = void 0;
    this._session = void 0;
    this._session = session;
    this._request = request;
  }

  async continue(request, overrides) {
    await this._session.sendMayFail('Network.resumeInterceptedRequest', {
      requestId: this._request._id,
      url: overrides.url,
      method: overrides.method,
      headers: overrides.headers,
      postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
    });
  }

  async fulfill(response) {
    const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString('base64');
    await this._session.sendMayFail('Network.fulfillInterceptedRequest', {
      requestId: this._request._id,
      status: response.status,
      statusText: network.STATUS_TEXTS[String(response.status)] || '',
      headers: response.headers,
      base64body
    });
  }

  async abort(errorCode) {
    await this._session.sendMayFail('Network.abortInterceptedRequest', {
      requestId: this._request._id,
      errorCode
    });
  }

}

function parseMultivalueHeaders(headers) {
  const result = [];

  for (const header of headers) {
    const separator = header.name.toLowerCase() === 'set-cookie' ? '\n' : ',';
    const tokens = header.value.split(separator).map(s => s.trim());

    for (const token of tokens) result.push({
      name: header.name,
      value: token
    });
  }

  return result;
}

/***/ }),

/***/ 1674:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.UTILITY_WORLD_NAME = exports.FFPage = void 0;

var dialog = _interopRequireWildcard(__nccwpck_require__(1645));

var dom = _interopRequireWildcard(__nccwpck_require__(8139));

var _eventsHelper = __nccwpck_require__(3841);

var _page = __nccwpck_require__(3555);

var _ffAccessibility = __nccwpck_require__(1112);

var _ffConnection = __nccwpck_require__(4327);

var _ffExecutionContext = __nccwpck_require__(131);

var _ffInput = __nccwpck_require__(7848);

var _ffNetworkManager = __nccwpck_require__(6427);

var _stackTrace = __nccwpck_require__(9030);

var _debugLogger = __nccwpck_require__(2003);

var _manualPromise = __nccwpck_require__(6729);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const UTILITY_WORLD_NAME = '__playwright_utility_world__';
exports.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;

class FFPage {
  constructor(session, browserContext, opener) {
    this.cspErrorsAsynchronousForInlineScipts = true;
    this.rawMouse = void 0;
    this.rawKeyboard = void 0;
    this.rawTouchscreen = void 0;
    this._session = void 0;
    this._page = void 0;
    this._networkManager = void 0;
    this._browserContext = void 0;
    this._pagePromise = new _manualPromise.ManualPromise();
    this._initializedPage = null;
    this._initializationFailed = false;
    this._opener = void 0;
    this._contextIdToContext = void 0;
    this._eventListeners = void 0;
    this._workers = new Map();
    this._screencastId = void 0;
    this._initScripts = [];
    this._session = session;
    this._opener = opener;
    this.rawKeyboard = new _ffInput.RawKeyboardImpl(session);
    this.rawMouse = new _ffInput.RawMouseImpl(session);
    this.rawTouchscreen = new _ffInput.RawTouchscreenImpl(session);
    this._contextIdToContext = new Map();
    this._browserContext = browserContext;
    this._page = new _page.Page(this, browserContext);
    this.rawMouse.setPage(this._page);
    this._networkManager = new _ffNetworkManager.FFNetworkManager(session, this._page);

    this._page.on(_page.Page.Events.FrameDetached, frame => this._removeContextsForFrame(frame)); // TODO: remove Page.willOpenNewWindowAsynchronously from the protocol.


    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, 'Page.eventFired', this._onEventFired.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameAttached', this._onFrameAttached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameDetached', this._onFrameDetached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigationAborted', this._onNavigationAborted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigationCommitted', this._onNavigationCommitted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigationStarted', this._onNavigationStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.sameDocumentNavigation', this._onSameDocumentNavigation.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextCreated', this._onExecutionContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextDestroyed', this._onExecutionContextDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.linkClicked', event => this._onLinkClicked(event.phase)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.uncaughtError', this._onUncaughtError.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.console', this._onConsole.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.dialogOpened', this._onDialogOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.bindingCalled', this._onBindingCalled.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.fileChooserOpened', this._onFileChooserOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.workerCreated', this._onWorkerCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.workerDestroyed', this._onWorkerDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.dispatchMessageFromWorker', this._onDispatchMessageFromWorker.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.crashed', this._onCrashed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.videoRecordingStarted', this._onVideoRecordingStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketCreated', this._onWebSocketCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketClosed', this._onWebSocketClosed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketFrameReceived', this._onWebSocketFrameReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.webSocketFrameSent', this._onWebSocketFrameSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.screencastFrame', this._onScreencastFrame.bind(this))];
    session.once(_ffConnection.FFSessionEvents.Disconnected, () => {
      this._markAsError(new Error('Page closed'));

      this._page._didDisconnect();
    });

    this._session.once('Page.ready', async () => {
      await this._page.initOpener(this._opener);
      if (this._initializationFailed) return; // Note: it is important to call |reportAsNew| before resolving pageOrError promise,
      // so that anyone who awaits pageOrError got a ready and reported page.

      this._initializedPage = this._page;

      this._page.reportAsNew();

      this._pagePromise.resolve(this._page);
    }); // Ideally, we somehow ensure that utility world is created before Page.ready arrives, but currently it is racy.
    // Therefore, we can end up with an initialized page without utility world, although very unlikely.


    this.addInitScript('', UTILITY_WORLD_NAME).catch(e => this._markAsError(e));
  }

  potentiallyUninitializedPage() {
    return this._page;
  }

  async _markAsError(error) {
    // Same error may be report twice: channer disconnected and session.send fails.
    if (this._initializationFailed) return;
    this._initializationFailed = true;

    if (!this._initializedPage) {
      await this._page.initOpener(this._opener);

      this._page.reportAsNew(error);

      this._pagePromise.resolve(error);
    }
  }

  async pageOrError() {
    return this._pagePromise;
  }

  _onWebSocketCreated(event) {
    this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);

    this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
  }

  _onWebSocketClosed(event) {
    if (event.error) this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);

    this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
  }

  _onWebSocketFrameReceived(event) {
    this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
  }

  _onWebSocketFrameSent(event) {
    this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
  }

  _onExecutionContextCreated(payload) {
    const {
      executionContextId,
      auxData
    } = payload;

    const frame = this._page._frameManager.frame(auxData.frameId);

    if (!frame) return;
    const delegate = new _ffExecutionContext.FFExecutionContext(this._session, executionContextId);
    let worldName = null;
    if (auxData.name === UTILITY_WORLD_NAME) worldName = 'utility';else if (!auxData.name) worldName = 'main';
    const context = new dom.FrameExecutionContext(delegate, frame, worldName);
    context[contextDelegateSymbol] = delegate;
    if (worldName) frame._contextCreated(worldName, context);

    this._contextIdToContext.set(executionContextId, context);
  }

  _onExecutionContextDestroyed(payload) {
    const {
      executionContextId
    } = payload;

    const context = this._contextIdToContext.get(executionContextId);

    if (!context) return;

    this._contextIdToContext.delete(executionContextId);

    context.frame._contextDestroyed(context);
  }

  _removeContextsForFrame(frame) {
    for (const [contextId, context] of this._contextIdToContext) {
      if (context.frame === frame) this._contextIdToContext.delete(contextId);
    }
  }

  _onLinkClicked(phase) {
    if (phase === 'before') this._page._frameManager.frameWillPotentiallyRequestNavigation();else this._page._frameManager.frameDidPotentiallyRequestNavigation();
  }

  _onNavigationStarted(params) {
    this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
  }

  _onNavigationAborted(params) {
    this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
  }

  _onNavigationCommitted(params) {
    for (const [workerId, worker] of this._workers) {
      if (worker.frameId === params.frameId) this._onWorkerDestroyed({
        workerId
      });
    }

    this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || '', params.navigationId || '', false);
  }

  _onSameDocumentNavigation(params) {
    this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
  }

  _onFrameAttached(params) {
    this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
  }

  _onFrameDetached(params) {
    this._page._frameManager.frameDetached(params.frameId);
  }

  _onEventFired(payload) {
    const {
      frameId,
      name
    } = payload;
    if (name === 'load') this._page._frameManager.frameLifecycleEvent(frameId, 'load');
    if (name === 'DOMContentLoaded') this._page._frameManager.frameLifecycleEvent(frameId, 'domcontentloaded');
  }

  _onUncaughtError(params) {
    const {
      name,
      message
    } = (0, _stackTrace.splitErrorMessage)(params.message);
    const error = new Error(message);
    error.stack = params.message + '\n' + params.stack.split('\n').filter(Boolean).map(a => a.replace(/([^@]*)@(.*)/, '    at $1 ($2)')).join('\n');
    error.name = name;

    this._page.firePageError(error);
  }

  _onConsole(payload) {
    const {
      type,
      args,
      executionContextId,
      location
    } = payload;

    const context = this._contextIdToContext.get(executionContextId);

    if (!context) return;

    this._page._addConsoleMessage(type, args.map(arg => context.createHandle(arg)), location);
  }

  _onDialogOpened(params) {
    this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, async (accept, promptText) => {
      await this._session.sendMayFail('Page.handleDialog', {
        dialogId: params.dialogId,
        accept,
        promptText
      });
    }, params.defaultValue));
  }

  async _onBindingCalled(event) {
    const pageOrError = await this.pageOrError();

    if (!(pageOrError instanceof Error)) {
      const context = this._contextIdToContext.get(event.executionContextId);

      if (context) await this._page._onBindingCalled(event.payload, context);
    }
  }

  async _onFileChooserOpened(payload) {
    const {
      executionContextId,
      element
    } = payload;

    const context = this._contextIdToContext.get(executionContextId);

    if (!context) return;
    const handle = context.createHandle(element).asElement();
    await this._page._onFileChooserOpened(handle);
  }

  async _onWorkerCreated(event) {
    const workerId = event.workerId;
    const worker = new _page.Worker(this._page, event.url);
    const workerSession = new _ffConnection.FFSession(this._session._connection, workerId, message => {
      this._session.send('Page.sendMessageToWorker', {
        frameId: event.frameId,
        workerId: workerId,
        message: JSON.stringify(message)
      }).catch(e => {
        workerSession.dispatchMessage({
          id: message.id,
          method: '',
          params: {},
          error: {
            message: e.message,
            data: undefined
          }
        });
      });
    });

    this._workers.set(workerId, {
      session: workerSession,
      frameId: event.frameId
    });

    this._page._addWorker(workerId, worker);

    workerSession.once('Runtime.executionContextCreated', event => {
      worker._createExecutionContext(new _ffExecutionContext.FFExecutionContext(workerSession, event.executionContextId));
    });
    workerSession.on('Runtime.console', event => {
      const {
        type,
        args,
        location
      } = event;
      const context = worker._existingExecutionContext;

      this._page._addConsoleMessage(type, args.map(arg => context.createHandle(arg)), location);
    }); // Note: we receive worker exceptions directly from the page.
  }

  _onWorkerDestroyed(event) {
    const workerId = event.workerId;

    const worker = this._workers.get(workerId);

    if (!worker) return;
    worker.session.dispose();

    this._workers.delete(workerId);

    this._page._removeWorker(workerId);
  }

  async _onDispatchMessageFromWorker(event) {
    const worker = this._workers.get(event.workerId);

    if (!worker) return;
    worker.session.dispatchMessage(JSON.parse(event.message));
  }

  async _onCrashed(event) {
    this._session.markAsCrashed();

    this._page._didCrash();
  }

  _onVideoRecordingStarted(event) {
    this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
  }

  async exposeBinding(binding) {
    await this._session.send('Page.addBinding', {
      name: binding.name,
      script: binding.source
    });
  }

  async removeExposedBindings() {// TODO: implement me.
  }

  didClose() {
    this._session.dispose();

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);

    this._networkManager.dispose();

    this._page._didClose();
  }

  async navigateFrame(frame, url, referer) {
    const response = await this._session.send('Page.navigate', {
      url,
      referer,
      frameId: frame._id
    });
    return {
      newDocumentId: response.navigationId || undefined
    };
  }

  async updateExtraHTTPHeaders() {
    await this._session.send('Network.setExtraHTTPHeaders', {
      headers: this._page.extraHTTPHeaders() || []
    });
  }

  async updateEmulatedViewportSize() {
    const viewportSize = this._page.viewportSize();

    await this._session.send('Page.setViewportSize', {
      viewportSize
    });
  }

  async bringToFront() {
    await this._session.send('Page.bringToFront', {});
  }

  async updateEmulateMedia() {
    var _emulatedMedia$colorS, _emulatedMedia$reduce, _emulatedMedia$forced;

    const emulatedMedia = this._page.emulatedMedia();

    const colorScheme = (_emulatedMedia$colorS = emulatedMedia.colorScheme) !== null && _emulatedMedia$colorS !== void 0 ? _emulatedMedia$colorS : undefined;
    const reducedMotion = (_emulatedMedia$reduce = emulatedMedia.reducedMotion) !== null && _emulatedMedia$reduce !== void 0 ? _emulatedMedia$reduce : undefined;
    const forcedColors = (_emulatedMedia$forced = emulatedMedia.forcedColors) !== null && _emulatedMedia$forced !== void 0 ? _emulatedMedia$forced : undefined;
    await this._session.send('Page.setEmulatedMedia', {
      // Empty string means reset.
      type: emulatedMedia.media === null ? '' : emulatedMedia.media,
      colorScheme,
      reducedMotion,
      forcedColors
    });
  }

  async updateRequestInterception() {
    await this._networkManager.setRequestInterception(this._page.needsRequestInterception());
  }

  async updateFileChooserInterception() {
    const enabled = this._page.fileChooserIntercepted();

    await this._session.send('Page.setInterceptFileChooserDialog', {
      enabled
    }).catch(() => {}); // target can be closed.
  }

  async reload() {
    await this._session.send('Page.reload', {
      frameId: this._page.mainFrame()._id
    });
  }

  async goBack() {
    const {
      success
    } = await this._session.send('Page.goBack', {
      frameId: this._page.mainFrame()._id
    });
    return success;
  }

  async goForward() {
    const {
      success
    } = await this._session.send('Page.goForward', {
      frameId: this._page.mainFrame()._id
    });
    return success;
  }

  async addInitScript(script, worldName) {
    this._initScripts.push({
      script,
      worldName
    });

    await this._session.send('Page.setInitScripts', {
      scripts: this._initScripts
    });
  }

  async removeInitScripts() {
    this._initScripts = [];
    await this._session.send('Page.setInitScripts', {
      scripts: []
    });
  }

  async closePage(runBeforeUnload) {
    await this._session.send('Page.close', {
      runBeforeUnload
    });
  }

  async setBackgroundColor(color) {
    if (color) throw new Error('Not implemented');
  }

  async takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {
    if (!documentRect) {
      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
        x: window.scrollX,
        y: window.scrollY
      }));
      documentRect = {
        x: viewportRect.x + scrollOffset.x,
        y: viewportRect.y + scrollOffset.y,
        width: viewportRect.width,
        height: viewportRect.height
      };
    }

    progress.throwIfAborted();
    const {
      data
    } = await this._session.send('Page.screenshot', {
      mimeType: 'image/' + format,
      clip: documentRect,
      omitDeviceScaleFactor: scale === 'css'
    });
    return Buffer.from(data, 'base64');
  }

  async getContentFrame(handle) {
    const {
      contentFrameId
    } = await this._session.send('Page.describeNode', {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    if (!contentFrameId) return null;
    return this._page._frameManager.frame(contentFrameId);
  }

  async getOwnerFrame(handle) {
    const {
      ownerFrameId
    } = await this._session.send('Page.describeNode', {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    return ownerFrameId || null;
  }

  isElementHandle(remoteObject) {
    return remoteObject.subtype === 'node';
  }

  async getBoundingBox(handle) {
    const quads = await this.getContentQuads(handle);
    if (!quads || !quads.length) return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;

    for (const quad of quads) {
      for (const point of quad) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._session.send('Page.scrollIntoViewIfNeeded', {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      rect
    }).then(() => 'done').catch(e => {
      if (e instanceof Error && e.message.includes('Node is detached from document')) return 'error:notconnected';
      if (e instanceof Error && e.message.includes('Node does not have a layout object')) return 'error:notvisible';
      throw e;
    });
  }

  async setScreencastOptions(options) {
    if (options) {
      const {
        screencastId
      } = await this._session.send('Page.startScreencast', options);
      this._screencastId = screencastId;
    } else {
      await this._session.send('Page.stopScreencast');
    }
  }

  _onScreencastFrame(event) {
    if (!this._screencastId) return;
    const screencastId = this._screencastId;

    this._page.throttleScreencastFrameAck(() => {
      this._session.send('Page.screencastFrameAck', {
        screencastId
      }).catch(e => _debugLogger.debugLogger.log('error', e));
    });

    const buffer = Buffer.from(event.data, 'base64');

    this._page.emit(_page.Page.Events.ScreencastFrame, {
      buffer,
      width: event.deviceWidth,
      height: event.deviceHeight
    });
  }

  rafCountForStablePosition() {
    return 1;
  }

  async getContentQuads(handle) {
    const result = await this._session.sendMayFail('Page.getContentQuads', {
      frameId: handle._context.frame._id,
      objectId: handle._objectId
    });
    if (!result) return null;
    return result.quads.map(quad => [quad.p1, quad.p2, quad.p3, quad.p4]);
  }

  async setInputFiles(handle, files) {
    await handle.evaluateInUtility(([injected, node, files]) => injected.setInputFiles(node, files), files);
  }

  async setInputFilePaths(handle, files) {
    await Promise.all([this._session.send('Page.setFileInputFiles', {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      files
    }), handle.dispatchEvent('input'), handle.dispatchEvent('change')]);
  }

  async adoptElementHandle(handle, to) {
    const result = await this._session.send('Page.adoptNode', {
      frameId: handle._context.frame._id,
      objectId: handle._objectId,
      executionContextId: to[contextDelegateSymbol]._executionContextId
    });
    if (!result.remoteObject) throw new Error(dom.kUnableToAdoptErrorMessage);
    return to.createHandle(result.remoteObject);
  }

  async getAccessibilityTree(needle) {
    return (0, _ffAccessibility.getAccessibilityTree)(this._session, needle);
  }

  async inputActionEpilogue() {}

  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent) throw new Error('Frame has been detached.');

    const info = this._page.parseSelector('frame,iframe');

    const handles = await this._page.selectors._queryAll(parent, info);
    const items = await Promise.all(handles.map(async handle => {
      const frame = await handle.contentFrame().catch(e => null);
      return {
        handle,
        frame
      };
    }));
    const result = items.find(item => item.frame === frame);
    items.map(item => item === result ? Promise.resolve() : item.handle.dispose());
    if (!result) throw new Error('Frame has been detached.');
    return result.handle;
  }

}

exports.FFPage = FFPage;

function webSocketId(frameId, wsid) {
  return `${frameId}---${wsid}`;
}

const contextDelegateSymbol = Symbol('delegate');

/***/ }),

/***/ 2792:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Firefox = void 0;

var os = _interopRequireWildcard(__nccwpck_require__(2037));

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _ffBrowser = __nccwpck_require__(923);

var _ffConnection = __nccwpck_require__(4327);

var _browserType = __nccwpck_require__(1192);

var _stackTrace = __nccwpck_require__(9030);

var _utils = __nccwpck_require__(3557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Firefox extends _browserType.BrowserType {
  constructor(playwrightOptions) {
    super('firefox', playwrightOptions);
  }

  _connectToTransport(transport, options) {
    return _ffBrowser.FFBrowser.connect(transport, options);
  }

  _rewriteStartupError(error) {
    if (error.message.includes('no DISPLAY environment variable specified')) return (0, _stackTrace.rewriteErrorMessage)(error, '\n' + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
    return error;
  }

  _amendEnvironment(env, userDataDir, executable, browserArguments) {
    if (!_path.default.isAbsolute(os.homedir())) throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === 'win32' ? 'USERPROFILE' : 'HOME'} to a relative path?`);

    if (os.platform() === 'linux') {
      return { ...env,
        // On linux Juggler ships the libstdc++ it was linked against.
        LD_LIBRARY_PATH: `${_path.default.dirname(executable)}:${process.env.LD_LIBRARY_PATH}`
      };
    }

    return env;
  }

  _attemptToGracefullyCloseBrowser(transport) {
    const message = {
      method: 'Browser.close',
      params: {},
      id: _ffConnection.kBrowserCloseMessageId
    };
    transport.send(message);
  }

  _defaultArgs(options, isPersistent, userDataDir) {
    const {
      args = [],
      headless
    } = options;
    const userDataDirArg = args.find(arg => arg.startsWith('-profile') || arg.startsWith('--profile'));
    if (userDataDirArg) throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument');
    if (args.find(arg => arg.startsWith('-juggler'))) throw new Error('Use the port parameter instead of -juggler argument');
    const firefoxUserPrefs = isPersistent ? undefined : options.firefoxUserPrefs;

    if (firefoxUserPrefs) {
      const lines = [];

      for (const [name, value] of Object.entries(firefoxUserPrefs)) lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);

      _fs.default.writeFileSync(_path.default.join(userDataDir, 'user.js'), lines.join('\n'));
    }

    const firefoxArguments = ['-no-remote'];

    if (headless) {
      firefoxArguments.push('-headless');
    } else {
      firefoxArguments.push('-wait-for-browser');
      firefoxArguments.push('-foreground');
    }

    firefoxArguments.push(`-profile`, userDataDir);
    firefoxArguments.push('-juggler-pipe');
    firefoxArguments.push(...args);
    if (isPersistent) firefoxArguments.push('about:blank');else firefoxArguments.push('-silent');
    return firefoxArguments;
  }

}

exports.Firefox = Firefox;

/***/ }),

/***/ 7291:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MultipartFormData = void 0;

var _utilsBundle = __nccwpck_require__(1319);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultipartFormData {
  constructor() {
    this._boundary = void 0;
    this._chunks = [];
    this._boundary = generateUniqueBoundaryString();
  }

  contentTypeHeader() {
    return `multipart/form-data; boundary=${this._boundary}`;
  }

  addField(name, value) {
    this._beginMultiPartHeader(name);

    this._finishMultiPartHeader();

    this._chunks.push(Buffer.from(value));

    this._finishMultiPartField();
  }

  addFileField(name, value) {
    this._beginMultiPartHeader(name);

    this._chunks.push(Buffer.from(`; filename="${value.name}"`));

    this._chunks.push(Buffer.from(`\r\ncontent-type: ${value.mimeType || _utilsBundle.mime.getType(value.name) || 'application/octet-stream'}`));

    this._finishMultiPartHeader();

    this._chunks.push(value.buffer);

    this._finishMultiPartField();
  }

  finish() {
    this._addBoundary(true);

    return Buffer.concat(this._chunks);
  }

  _beginMultiPartHeader(name) {
    this._addBoundary();

    this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
  }

  _finishMultiPartHeader() {
    this._chunks.push(Buffer.from(`\r\n\r\n`));
  }

  _finishMultiPartField() {
    this._chunks.push(Buffer.from(`\r\n`));
  }

  _addBoundary(isLastBoundary) {
    this._chunks.push(Buffer.from('--' + this._boundary));

    if (isLastBoundary) this._chunks.push(Buffer.from('--'));

    this._chunks.push(Buffer.from('\r\n'));
  }

}

exports.MultipartFormData = MultipartFormData;
const alphaNumericEncodingMap = [0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42]; // See generateUniqueBoundaryString() in WebKit

function generateUniqueBoundaryString() {
  const charCodes = [];

  for (let i = 0; i < 16; i++) charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);

  return '----WebKitFormBoundary' + String.fromCharCode(...charCodes);
}

/***/ }),

/***/ 8895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NavigationAbortedError = exports.FrameManager = exports.Frame = void 0;

var dom = _interopRequireWildcard(__nccwpck_require__(8139));

var _helper = __nccwpck_require__(9175);

var _eventsHelper = __nccwpck_require__(3841);

var js = _interopRequireWildcard(__nccwpck_require__(804));

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _page = __nccwpck_require__(3555);

var types = _interopRequireWildcard(__nccwpck_require__(6919));

var _browserContext = __nccwpck_require__(5985);

var _progress = __nccwpck_require__(2836);

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

var _debugLogger = __nccwpck_require__(2003);

var _instrumentation = __nccwpck_require__(6686);

var _protocolError = __nccwpck_require__(7314);

var _selectorParser = __nccwpck_require__(377);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NavigationAbortedError extends Error {
  constructor(documentId, message) {
    super(message);
    this.documentId = void 0;
    this.documentId = documentId;
  }

}

exports.NavigationAbortedError = NavigationAbortedError;
const kDummyFrameId = '<dummy>';

class FrameManager {
  constructor(page) {
    this._page = void 0;
    this._frames = new Map();
    this._mainFrame = void 0;
    this._consoleMessageTags = new Map();
    this._signalBarriers = new Set();
    this._webSockets = new Map();
    this._openedDialogs = new Set();
    this._page = page;
    this._mainFrame = undefined;
  }

  createDummyMainFrameIfNeeded() {
    if (!this._mainFrame) this.frameAttached(kDummyFrameId, null);
  }

  dispose() {
    for (const frame of this._frames.values()) {
      frame._stopNetworkIdleTimer();

      frame._invalidateNonStallingEvaluations('Target crashed');
    }
  }

  mainFrame() {
    return this._mainFrame;
  }

  frames() {
    const frames = [];
    collect(this._mainFrame);
    return frames;

    function collect(frame) {
      frames.push(frame);

      for (const subframe of frame.childFrames()) collect(subframe);
    }
  }

  frame(frameId) {
    return this._frames.get(frameId) || null;
  }

  frameAttached(frameId, parentFrameId) {
    const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;

    if (!parentFrame) {
      if (this._mainFrame) {
        // Update frame id to retain frame identity on cross-process navigation.
        this._frames.delete(this._mainFrame._id);

        this._mainFrame._id = frameId;
      } else {
        (0, _utils.assert)(!this._frames.has(frameId));
        this._mainFrame = new Frame(this._page, frameId, parentFrame);
      }

      this._frames.set(frameId, this._mainFrame);

      return this._mainFrame;
    } else {
      (0, _utils.assert)(!this._frames.has(frameId));
      const frame = new Frame(this._page, frameId, parentFrame);

      this._frames.set(frameId, frame);

      this._page.emit(_page.Page.Events.FrameAttached, frame);

      return frame;
    }
  }

  async waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
    if (noWaitAfter) return action();
    const barrier = new SignalBarrier(progress);

    this._signalBarriers.add(barrier);

    if (progress) progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
    const result = await action();
    if (source === 'input') await this._page._delegate.inputActionEpilogue();
    await barrier.waitFor();

    this._signalBarriers.delete(barrier); // Resolve in the next task, after all waitForNavigations.


    await new Promise((0, _utils.makeWaitForNextTask)());
    return result;
  }

  frameWillPotentiallyRequestNavigation() {
    for (const barrier of this._signalBarriers) barrier.retain();
  }

  frameDidPotentiallyRequestNavigation() {
    for (const barrier of this._signalBarriers) barrier.release();
  }

  frameRequestedNavigation(frameId, documentId) {
    const frame = this._frames.get(frameId);

    if (!frame) return;

    for (const barrier of this._signalBarriers) barrier.addFrameNavigation(frame);

    if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
      // Do not override request with undefined.
      return;
    }

    frame.setPendingDocument({
      documentId,
      request: undefined
    });
  }

  frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
    const frame = this._frames.get(frameId);

    this.removeChildFramesRecursively(frame);
    this.clearWebSockets(frame);
    frame._url = url;
    frame._name = name;
    let keepPending;
    const pendingDocument = frame.pendingDocument();

    if (pendingDocument) {
      if (pendingDocument.documentId === undefined) {
        // Pending with unknown documentId - assume it is the one being committed.
        pendingDocument.documentId = documentId;
      }

      if (pendingDocument.documentId === documentId) {
        // Committing a pending document.
        frame._currentDocument = pendingDocument;
      } else {
        // Sometimes, we already have a new pending when the old one commits.
        // An example would be Chromium error page followed by a new navigation request,
        // where the error page commit arrives after Network.requestWillBeSent for the
        // new navigation.
        // We commit, but keep the pending request since it's not done yet.
        keepPending = pendingDocument;
        frame._currentDocument = {
          documentId,
          request: undefined
        };
      }

      frame.setPendingDocument(undefined);
    } else {
      // No pending - just commit a new document.
      frame._currentDocument = {
        documentId,
        request: undefined
      };
    }

    frame._onClearLifecycle();

    const navigationEvent = {
      url,
      name,
      newDocument: frame._currentDocument,
      isPublic: true
    };

    this._fireInternalFrameNavigation(frame, navigationEvent);

    if (!initial) {
      _debugLogger.debugLogger.log('api', `  navigated to "${url}"`);

      this._page.frameNavigatedToNewDocument(frame);
    } // Restore pending if any - see comments above about keepPending.


    frame.setPendingDocument(keepPending);
  }

  frameCommittedSameDocumentNavigation(frameId, url) {
    const frame = this._frames.get(frameId);

    if (!frame) return;
    frame._url = url;
    const navigationEvent = {
      url,
      name: frame._name,
      isPublic: true
    };

    this._fireInternalFrameNavigation(frame, navigationEvent);

    _debugLogger.debugLogger.log('api', `  navigated to "${url}"`);
  }

  frameAbortedNavigation(frameId, errorText, documentId) {
    const frame = this._frames.get(frameId);

    if (!frame || !frame.pendingDocument()) return;
    if (documentId !== undefined && frame.pendingDocument().documentId !== documentId) return;
    const navigationEvent = {
      url: frame._url,
      name: frame._name,
      newDocument: frame.pendingDocument(),
      error: new NavigationAbortedError(documentId, errorText),
      isPublic: !(documentId && frame._redirectedNavigations.has(documentId))
    };
    frame.setPendingDocument(undefined);

    this._fireInternalFrameNavigation(frame, navigationEvent);
  }

  frameDetached(frameId) {
    const frame = this._frames.get(frameId);

    if (frame) {
      this._removeFramesRecursively(frame); // Recalculate subtree lifecycle for the whole tree - it should not be that big.


      this._page.mainFrame()._recalculateLifecycle();
    }
  }

  frameStoppedLoading(frameId) {
    this.frameLifecycleEvent(frameId, 'domcontentloaded');
    this.frameLifecycleEvent(frameId, 'load');
  }

  frameLifecycleEvent(frameId, event) {
    const frame = this._frames.get(frameId);

    if (frame) frame._onLifecycleEvent(event);
  }

  requestStarted(request, route) {
    const frame = request.frame();

    this._inflightRequestStarted(request);

    if (request._documentId) frame.setPendingDocument({
      documentId: request._documentId,
      request
    });

    if (request._isFavicon) {
      if (route) route.continue(request, {});
      return;
    }

    this._page.emitOnContext(_browserContext.BrowserContext.Events.Request, request);

    if (route) {
      const r = new network.Route(request, route);

      if (this._page._serverRequestInterceptor) {
        this._page._serverRequestInterceptor(r, request);

        return;
      }

      if (this._page._clientRequestInterceptor) {
        this._page._clientRequestInterceptor(r, request);

        return;
      }

      if (this._page._browserContext._requestInterceptor) {
        this._page._browserContext._requestInterceptor(r, request);

        return;
      }

      r.continue();
    }
  }

  requestReceivedResponse(response) {
    if (response.request()._isFavicon) return;

    this._page.emitOnContext(_browserContext.BrowserContext.Events.Response, response);
  }

  reportRequestFinished(request, response) {
    this._inflightRequestFinished(request);

    if (request._isFavicon) return;

    this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFinished, {
      request,
      response
    });
  }

  requestFailed(request, canceled) {
    const frame = request.frame();

    this._inflightRequestFinished(request);

    if (frame.pendingDocument() && frame.pendingDocument().request === request) {
      let errorText = request.failure().errorText;
      if (canceled) errorText += '; maybe frame was detached?';
      this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
    }

    if (request._isFavicon) return;

    this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFailed, request);
  }

  dialogDidOpen(dialog) {
    // Any ongoing evaluations will be stalled until the dialog is closed.
    for (const frame of this._frames.values()) frame._invalidateNonStallingEvaluations('JavaScript dialog interrupted evaluation');

    this._openedDialogs.add(dialog);
  }

  dialogWillClose(dialog) {
    this._openedDialogs.delete(dialog);
  }

  async closeOpenDialogs() {
    await Promise.all([...this._openedDialogs].map(dialog => dialog.dismiss())).catch(() => {});

    this._openedDialogs.clear();
  }

  removeChildFramesRecursively(frame) {
    for (const child of frame.childFrames()) this._removeFramesRecursively(child);
  }

  _removeFramesRecursively(frame) {
    this.removeChildFramesRecursively(frame);

    frame._onDetached();

    this._frames.delete(frame._id);

    if (!this._page.isClosed()) this._page.emit(_page.Page.Events.FrameDetached, frame);
  }

  _inflightRequestFinished(request) {
    const frame = request.frame();
    if (request._isFavicon) return;
    if (!frame._inflightRequests.has(request)) return;

    frame._inflightRequests.delete(request);

    if (frame._inflightRequests.size === 0) frame._startNetworkIdleTimer();
  }

  _inflightRequestStarted(request) {
    const frame = request.frame();
    if (request._isFavicon) return;

    frame._inflightRequests.add(request);

    if (frame._inflightRequests.size === 1) frame._stopNetworkIdleTimer();
  }

  interceptConsoleMessage(message) {
    if (message.type() !== 'debug') return false;
    const tag = message.text();

    const handler = this._consoleMessageTags.get(tag);

    if (!handler) return false;

    this._consoleMessageTags.delete(tag);

    handler();
    return true;
  }

  clearWebSockets(frame) {
    // TODO: attribute sockets to frames.
    if (frame.parentFrame()) return;

    this._webSockets.clear();
  }

  onWebSocketCreated(requestId, url) {
    const ws = new network.WebSocket(this._page, url);

    this._webSockets.set(requestId, ws);
  }

  onWebSocketRequest(requestId) {
    const ws = this._webSockets.get(requestId);

    if (ws && ws.markAsNotified()) this._page.emit(_page.Page.Events.WebSocket, ws);
  }

  onWebSocketResponse(requestId, status, statusText) {
    const ws = this._webSockets.get(requestId);

    if (status < 400) return;
    if (ws) ws.error(`${statusText}: ${status}`);
  }

  onWebSocketFrameSent(requestId, opcode, data) {
    const ws = this._webSockets.get(requestId);

    if (ws) ws.frameSent(opcode, data);
  }

  webSocketFrameReceived(requestId, opcode, data) {
    const ws = this._webSockets.get(requestId);

    if (ws) ws.frameReceived(opcode, data);
  }

  webSocketClosed(requestId) {
    const ws = this._webSockets.get(requestId);

    if (ws) ws.closed();

    this._webSockets.delete(requestId);
  }

  webSocketError(requestId, errorMessage) {
    const ws = this._webSockets.get(requestId);

    if (ws) ws.error(errorMessage);
  }

  _fireInternalFrameNavigation(frame, event) {
    frame.emit(Frame.Events.InternalNavigation, event);
    if (event.isPublic && !frame.parentFrame()) frame.instrumentation.onPageNavigated(frame._page, event.url);
  }

}

exports.FrameManager = FrameManager;

class Frame extends _instrumentation.SdkObject {
  // documentId -> data
  constructor(page, id, parentFrame) {
    super(page, 'frame');
    this._id = void 0;
    this._firedLifecycleEvents = new Set();
    this._subtreeLifecycleEvents = new Set();
    this._currentDocument = void 0;
    this._pendingDocument = void 0;
    this._page = void 0;
    this._parentFrame = void 0;
    this._url = '';
    this._detached = false;
    this._contextData = new Map();
    this._childFrames = new Set();
    this._name = '';
    this._inflightRequests = new Set();
    this._networkIdleTimer = void 0;
    this._setContentCounter = 0;
    this._detachedPromise = void 0;

    this._detachedCallback = () => {};

    this._raceAgainstEvaluationStallingEventsPromises = new Set();
    this._redirectedNavigations = new Map();
    this.attribution.frame = this;
    this._id = id;
    this._page = page;
    this._parentFrame = parentFrame;
    this._currentDocument = {
      documentId: undefined,
      request: undefined
    };
    this._detachedPromise = new Promise(x => this._detachedCallback = x);

    this._contextData.set('main', {
      contextPromise: new _manualPromise.ManualPromise(),
      context: null,
      rerunnableTasks: new Set()
    });

    this._contextData.set('utility', {
      contextPromise: new _manualPromise.ManualPromise(),
      context: null,
      rerunnableTasks: new Set()
    });

    this._setContext('main', null);

    this._setContext('utility', null);

    if (this._parentFrame) this._parentFrame._childFrames.add(this);

    this._firedLifecycleEvents.add('commit');

    this._subtreeLifecycleEvents.add('commit');

    if (id !== kDummyFrameId) this._startNetworkIdleTimer();
  }

  isDetached() {
    return this._detached;
  }

  _onLifecycleEvent(event) {
    if (this._firedLifecycleEvents.has(event)) return;

    this._firedLifecycleEvents.add(event); // Recalculate subtree lifecycle for the whole tree - it should not be that big.


    this._page.mainFrame()._recalculateLifecycle();
  }

  _onClearLifecycle() {
    this._firedLifecycleEvents.clear(); // Recalculate subtree lifecycle for the whole tree - it should not be that big.


    this._page.mainFrame()._recalculateLifecycle(this); // Keep the current navigation request if any.


    this._inflightRequests = new Set(Array.from(this._inflightRequests).filter(request => request === this._currentDocument.request));

    this._stopNetworkIdleTimer();

    if (this._inflightRequests.size === 0) this._startNetworkIdleTimer();

    this._onLifecycleEvent('commit');
  }

  setPendingDocument(documentInfo) {
    this._pendingDocument = documentInfo;
    if (documentInfo) this._invalidateNonStallingEvaluations('Navigation interrupted the evaluation');
  }

  pendingDocument() {
    return this._pendingDocument;
  }

  _invalidateNonStallingEvaluations(message) {
    if (!this._raceAgainstEvaluationStallingEventsPromises.size) return;
    const error = new Error(message);

    for (const promise of this._raceAgainstEvaluationStallingEventsPromises) promise.reject(error);
  }

  async raceAgainstEvaluationStallingEvents(cb) {
    if (this._pendingDocument) throw new Error('Frame is currently attempting a navigation');
    if (this._page._frameManager._openedDialogs.size) throw new Error('Open JavaScript dialog prevents evaluation');
    const promise = new _manualPromise.ManualPromise();

    this._raceAgainstEvaluationStallingEventsPromises.add(promise);

    try {
      return await Promise.race([cb(), promise]);
    } finally {
      this._raceAgainstEvaluationStallingEventsPromises.delete(promise);
    }
  }

  nonStallingRawEvaluateInExistingMainContext(expression) {
    return this.raceAgainstEvaluationStallingEvents(() => {
      const context = this._existingMainContext();

      if (!context) throw new Error('Frame does not yet have a main execution context');
      return context.rawEvaluateJSON(expression);
    });
  }

  nonStallingEvaluateInExistingContext(expression, isFunction, world) {
    return this.raceAgainstEvaluationStallingEvents(() => {
      var _this$_contextData$ge;

      const context = (_this$_contextData$ge = this._contextData.get(world)) === null || _this$_contextData$ge === void 0 ? void 0 : _this$_contextData$ge.context;
      if (!context) throw new Error('Frame does not yet have the execution context');
      return context.evaluateExpression(expression, isFunction);
    });
  }

  _recalculateLifecycle(frameThatAllowsRemovingLifecycleEvents) {
    const events = new Set(this._firedLifecycleEvents);

    for (const child of this._childFrames) {
      child._recalculateLifecycle(frameThatAllowsRemovingLifecycleEvents); // We require a particular lifecycle event to be fired in the whole
      // frame subtree, and then consider it done.


      for (const event of events) {
        if (!child._subtreeLifecycleEvents.has(event)) events.delete(event);
      }
    }

    if (frameThatAllowsRemovingLifecycleEvents !== this) {
      // Usually, lifecycle events are fired once and not removed after that, so we keep existing ones.
      // However, when we clear them right before a new commit, this is allowed for a particular frame.
      for (const event of this._subtreeLifecycleEvents) events.add(event);
    }

    const mainFrame = this._page.mainFrame();

    for (const event of events) {
      // Checking whether we have already notified about this event.
      if (!this._subtreeLifecycleEvents.has(event)) {
        this.emit(Frame.Events.AddLifecycle, event);
        if (this === mainFrame && this._url !== 'about:blank') _debugLogger.debugLogger.log('api', `  "${event}" event fired`);
      }
    }

    for (const event of this._subtreeLifecycleEvents) {
      if (!events.has(event)) this.emit(Frame.Events.RemoveLifecycle, event);
    }

    this._subtreeLifecycleEvents = events;
  }

  async raceNavigationAction(progress, options, action) {
    return Promise.race([this._page._disconnectedPromise.then(() => {
      throw new Error('Navigation failed because page was closed!');
    }), this._page._crashedPromise.then(() => {
      throw new Error('Navigation failed because page crashed!');
    }), this._detachedPromise.then(() => {
      throw new Error('Navigating frame was detached!');
    }), action().catch(e => {
      if (e instanceof NavigationAbortedError && e.documentId) {
        const data = this._redirectedNavigations.get(e.documentId);

        if (data) {
          progress.log(`waiting for redirected navigation to "${data.url}"`);
          return data.gotoPromise;
        }
      }

      throw e;
    })]);
  }

  redirectNavigation(url, documentId, referer) {
    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
    const data = {
      url,
      gotoPromise: controller.run(progress => this._gotoAction(progress, url, {
        referer
      }), 0)
    };

    this._redirectedNavigations.set(documentId, data);

    data.gotoPromise.finally(() => this._redirectedNavigations.delete(documentId));
  }

  async goto(metadata, url, options = {}) {
    const constructedNavigationURL = (0, _utils.constructURLBasedOnBaseURL)(this._page._browserContext._options.baseURL, url);
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this._goto(progress, constructedNavigationURL, options), this._page._timeoutSettings.navigationTimeout(options));
  }

  async _goto(progress, url, options) {
    return this.raceNavigationAction(progress, options, async () => this._gotoAction(progress, url, options));
  }

  async _gotoAction(progress, url, options) {
    const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    progress.log(`navigating to "${url}", waiting until "${waitUntil}"`);
    const headers = this._page.extraHTTPHeaders() || [];
    const refererHeader = headers.find(h => h.name.toLowerCase() === 'referer');
    let referer = refererHeader ? refererHeader.value : undefined;

    if (options.referer !== undefined) {
      if (referer !== undefined && referer !== options.referer) throw new Error('"referer" is already specified as extra HTTP header');
      referer = options.referer;
    }

    url = _helper.helper.completeUserURL(url);

    const sameDocument = _helper.helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, e => !e.newDocument);

    const navigateResult = await this._page._delegate.navigateFrame(this, url, referer);
    let event;

    if (navigateResult.newDocumentId) {
      sameDocument.dispose();
      event = await _helper.helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, event => {
        // We are interested either in this specific document, or any other document that
        // did commit and replaced the expected document.
        return event.newDocument && (event.newDocument.documentId === navigateResult.newDocumentId || !event.error);
      }).promise;

      if (event.newDocument.documentId !== navigateResult.newDocumentId) {
        // This is just a sanity check. In practice, new navigation should
        // cancel the previous one and report "request cancelled"-like error.
        throw new NavigationAbortedError(navigateResult.newDocumentId, 'Navigation interrupted by another one');
      }

      if (event.error) throw event.error;
    } else {
      event = await sameDocument.promise;
    }

    if (!this._subtreeLifecycleEvents.has(waitUntil)) await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, e => e === waitUntil).promise;
    const request = event.newDocument ? event.newDocument.request : undefined;
    const response = request ? request._finalRequest().response() : null;
    await this._page._doSlowMo();
    return response;
  }

  async _waitForNavigation(progress, options) {
    const waitUntil = verifyLifecycle('waitUntil', options.waitUntil === undefined ? 'load' : options.waitUntil);
    progress.log(`waiting for navigation until "${waitUntil}"`);
    const navigationEvent = await _helper.helper.waitForEvent(progress, this, Frame.Events.InternalNavigation, event => {
      // Any failed navigation results in a rejection.
      if (event.error) return true;
      progress.log(`  navigated to "${this._url}"`);
      return true;
    }).promise;
    if (navigationEvent.error) throw navigationEvent.error;
    if (!this._subtreeLifecycleEvents.has(waitUntil)) await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, e => e === waitUntil).promise;
    const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : undefined;
    return request ? request._finalRequest().response() : null;
  }

  async _waitForLoadState(progress, state) {
    const waitUntil = verifyLifecycle('state', state);
    if (!this._subtreeLifecycleEvents.has(waitUntil)) await _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, e => e === waitUntil).promise;
  }

  async frameElement() {
    return this._page._delegate.getFrameElement(this);
  }

  _context(world) {
    return this._contextData.get(world).contextPromise.then(contextOrError => {
      if (contextOrError instanceof js.ExecutionContext) return contextOrError;
      throw contextOrError;
    });
  }

  _mainContext() {
    return this._context('main');
  }

  _existingMainContext() {
    var _this$_contextData$ge2;

    return ((_this$_contextData$ge2 = this._contextData.get('main')) === null || _this$_contextData$ge2 === void 0 ? void 0 : _this$_contextData$ge2.context) || null;
  }

  _utilityContext() {
    return this._context('utility');
  }

  async evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = 'main') {
    const context = await this._context(world);
    const handle = await context.evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg);
    if (world === 'main') await this._page._doSlowMo();
    return handle;
  }

  async evaluateExpression(expression, isFunction, arg, world = 'main') {
    const context = await this._context(world);
    const value = await context.evaluateExpression(expression, isFunction, arg);
    if (world === 'main') await this._page._doSlowMo();
    return value;
  }

  async evaluateExpressionAndWaitForSignals(expression, isFunction, arg, world = 'main') {
    const context = await this._context(world);
    const value = await context.evaluateExpressionAndWaitForSignals(expression, isFunction, arg);
    if (world === 'main') await this._page._doSlowMo();
    return value;
  }

  async querySelector(selector, options) {
    _debugLogger.debugLogger.log('api', `    finding element using the selector "${selector}"`);

    const result = await this.resolveFrameForSelectorNoWait(selector, options);
    if (!result) return null;
    return this._page.selectors.query(result.frame, result.info);
  }

  async waitForSelector(metadata, selector, options, scope) {
    const controller = new _progress.ProgressController(metadata, this);
    if (options.visibility) throw new Error('options.visibility is not supported, did you mean options.state?');
    if (options.waitFor && options.waitFor !== 'visible') throw new Error('options.waitFor is not supported, did you mean options.state?');
    const {
      state = 'visible'
    } = options;
    if (!['attached', 'detached', 'visible', 'hidden'].includes(state)) throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
    return controller.run(async progress => {
      progress.log(`waiting for selector "${selector}"${state === 'attached' ? '' : ' to be ' + state}`);
      return this.retryWithProgress(progress, selector, options, async (selectorInFrame, continuePolling) => {
        // Be careful, |this| can be different from |frame|.
        // We did not pass omitAttached, so it is non-null.
        const {
          frame,
          info
        } = selectorInFrame;
        const actualScope = this === frame ? scope : undefined;
        const task = dom.waitForSelectorTask(info, state, options.omitReturnValue, actualScope);
        const result = actualScope ? await frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : await frame._scheduleRerunnableHandleTask(progress, info.world, task);

        if (!result.asElement()) {
          result.dispose();
          return null;
        }

        if (options.__testHookBeforeAdoptNode) await options.__testHookBeforeAdoptNode();
        const handle = result.asElement();

        try {
          return await handle._adoptTo(await frame._mainContext());
        } catch (e) {
          return continuePolling;
        }
      }, scope);
    }, this._page._timeoutSettings.timeout(options));
  }

  async dispatchEvent(metadata, selector, type, eventInit = {}, options = {}) {
    await this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
      progress.injectedScript.dispatchEvent(element, data.type, data.eventInit);
    }, {
      type,
      eventInit
    }, {
      mainWorld: true,
      ...options
    });
    await this._page._doSlowMo();
  }

  async evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
    const pair = await this.resolveFrameForSelectorNoWait(selector, {
      strict
    });
    const handle = pair ? await this._page.selectors.query(pair.frame, pair.info) : null;
    if (!handle) throw new Error(`Error: failed to find element matching selector "${selector}"`);
    const result = await handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
    handle.dispose();
    return result;
  }

  async evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
    const pair = await this.resolveFrameForSelectorNoWait(selector, {});
    if (!pair) throw new Error(`Error: failed to find frame for selector "${selector}"`);
    const arrayHandle = await this._page.selectors._queryArrayInMainWorld(pair.frame, pair.info);
    const result = await arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
    arrayHandle.dispose();
    return result;
  }

  async maskSelectors(selectors) {
    const context = await this._utilityContext();
    const injectedScript = await context.injectedScript();
    await injectedScript.evaluate((injected, {
      parsed
    }) => {
      injected.maskSelectors(parsed);
    }, {
      parsed: selectors
    });
  }

  async querySelectorAll(selector) {
    const pair = await this.resolveFrameForSelectorNoWait(selector, {});
    if (!pair) return [];
    return this._page.selectors._queryAll(pair.frame, pair.info, undefined, true
    /* adoptToMain */
    );
  }

  async queryCount(selector) {
    const pair = await this.resolveFrameForSelectorNoWait(selector);
    if (!pair) throw new Error(`Error: failed to find frame for selector "${selector}"`);
    return await this._page.selectors._queryCount(pair.frame, pair.info);
  }

  async content() {
    try {
      const context = await this._utilityContext();
      return await context.evaluate(() => {
        let retVal = '';
        if (document.doctype) retVal = new XMLSerializer().serializeToString(document.doctype);
        if (document.documentElement) retVal += document.documentElement.outerHTML;
        return retVal;
      });
    } catch (e) {
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e;
      throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
    }
  }

  async setContent(metadata, html, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      await this.raceNavigationAction(progress, options, async () => {
        const waitUntil = options.waitUntil === undefined ? 'load' : options.waitUntil;
        progress.log(`setting frame content, waiting until "${waitUntil}"`);
        const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
        const context = await this._utilityContext();
        const lifecyclePromise = new Promise((resolve, reject) => {
          this._page._frameManager._consoleMessageTags.set(tag, () => {
            // Clear lifecycle right after document.open() - see 'tag' below.
            this._onClearLifecycle();

            this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
          });
        });
        const contentPromise = context.evaluate(({
          html,
          tag
        }) => {
          window.stop();
          document.open();
          console.debug(tag); // eslint-disable-line no-console

          document.write(html);
          document.close();
        }, {
          html,
          tag
        });
        await Promise.all([contentPromise, lifecyclePromise]);
        await this._page._doSlowMo();
        return null;
      });
    }, this._page._timeoutSettings.navigationTimeout(options));
  }

  name() {
    return this._name || '';
  }

  url() {
    return this._url;
  }

  parentFrame() {
    return this._parentFrame;
  }

  childFrames() {
    return Array.from(this._childFrames);
  }

  async addScriptTag(params) {
    const {
      url = null,
      content = null,
      type = ''
    } = params;
    if (!url && !content) throw new Error('Provide an object with a `url`, `path` or `content` property');
    const context = await this._mainContext();
    return this._raceWithCSPError(async () => {
      if (url !== null) return (await context.evaluateHandle(addScriptUrl, {
        url,
        type
      })).asElement();
      const result = (await context.evaluateHandle(addScriptContent, {
        content: content,
        type
      })).asElement(); // Another round trip to the browser to ensure that we receive CSP error messages
      // (if any) logged asynchronously in a separate task on the content main thread.

      if (this._page._delegate.cspErrorsAsynchronousForInlineScipts) await context.evaluate(() => true);
      return result;
    });

    async function addScriptUrl(params) {
      const script = document.createElement('script');
      script.src = params.url;
      if (params.type) script.type = params.type;
      const promise = new Promise((res, rej) => {
        script.onload = res;

        script.onerror = e => rej(typeof e === 'string' ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
      });
      document.head.appendChild(script);
      await promise;
      return script;
    }

    function addScriptContent(params) {
      const script = document.createElement('script');
      script.type = params.type || 'text/javascript';
      script.text = params.content;
      let error = null;

      script.onerror = e => error = e;

      document.head.appendChild(script);
      if (error) throw error;
      return script;
    }
  }

  async addStyleTag(params) {
    const {
      url = null,
      content = null
    } = params;
    if (!url && !content) throw new Error('Provide an object with a `url`, `path` or `content` property');
    const context = await this._mainContext();
    return this._raceWithCSPError(async () => {
      if (url !== null) return (await context.evaluateHandle(addStyleUrl, url)).asElement();
      return (await context.evaluateHandle(addStyleContent, content)).asElement();
    });

    async function addStyleUrl(url) {
      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      const promise = new Promise((res, rej) => {
        link.onload = res;
        link.onerror = rej;
      });
      document.head.appendChild(link);
      await promise;
      return link;
    }

    async function addStyleContent(content) {
      const style = document.createElement('style');
      style.type = 'text/css';
      style.appendChild(document.createTextNode(content));
      const promise = new Promise((res, rej) => {
        style.onload = res;
        style.onerror = rej;
      });
      document.head.appendChild(style);
      await promise;
      return style;
    }
  }

  async _raceWithCSPError(func) {
    const listeners = [];
    let result;
    let error;
    let cspMessage;
    const actionPromise = func().then(r => result = r).catch(e => error = e);
    const errorPromise = new Promise(resolve => {
      listeners.push(_eventsHelper.eventsHelper.addEventListener(this._page, _page.Page.Events.Console, message => {
        if (message.type() === 'error' && message.text().includes('Content Security Policy')) {
          cspMessage = message;
          resolve();
        }
      }));
    });
    await Promise.race([actionPromise, errorPromise]);

    _eventsHelper.eventsHelper.removeEventListeners(listeners);

    if (cspMessage) throw new Error(cspMessage.text());
    if (error) throw error;
    return result;
  }

  async retryWithProgress(progress, selector, options, action, scope) {
    const continuePolling = Symbol('continuePolling');

    while (progress.isRunning()) {
      let selectorInFrame;

      if (options.omitAttached) {
        selectorInFrame = await this.resolveFrameForSelectorNoWait(selector, options, scope);
      } else {
        selectorInFrame = await this._resolveFrameForSelector(progress, selector, options, scope);

        if (!selectorInFrame) {
          // Missing content frame.
          await new Promise(f => setTimeout(f, 100));
          continue;
        }
      }

      try {
        const result = await action(selectorInFrame, continuePolling);
        if (result === continuePolling) continue;
        return result;
      } catch (e) {
        var _selectorInFrame;

        // Always fail on JavaScript errors or when the main connection is closed.
        if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) throw e; // Certain error opt-out of the retries, throw.

        if (dom.isNonRecoverableDOMError(e)) throw e; // If the call is made on the detached frame - throw.

        if (this.isDetached()) throw e; // If there is scope, and scope is within the frame we use to select, assume context is destroyed and
        // operation is not recoverable.

        if (scope && scope._context.frame === ((_selectorInFrame = selectorInFrame) === null || _selectorInFrame === void 0 ? void 0 : _selectorInFrame.frame)) throw e; // Retry upon all other errors.

        continue;
      }
    }

    progress.throwIfAborted();
    return undefined;
  }

  async _retryWithProgressIfNotConnected(progress, selector, strict, action) {
    return this.retryWithProgress(progress, selector, {
      strict
    }, async (selectorInFrame, continuePolling) => {
      // We did not pass omitAttached, so selectorInFrame is not null.
      const {
        frame,
        info
      } = selectorInFrame; // Be careful, |this| can be different from |frame|.

      const task = dom.waitForSelectorTask(info, 'attached');
      progress.log(`waiting for selector "${selector}"`);
      const handle = await frame._scheduleRerunnableHandleTask(progress, info.world, task);
      const element = handle.asElement();

      try {
        const result = await action(element);

        if (result === 'error:notconnected') {
          progress.log('element was detached from the DOM, retrying');
          return continuePolling;
        }

        return result;
      } finally {
        element === null || element === void 0 ? void 0 : element.dispose();
      }
    });
  }

  async rafrafTimeoutScreenshotElementWithProgress(progress, selector, timeout, options) {
    return await this._retryWithProgressIfNotConnected(progress, selector, true
    /* strict */
    , async handle => {
      await handle._frame.rafrafTimeout(timeout);
      return await this._page._screenshotter.screenshotElement(progress, handle, options);
    });
  }

  async click(metadata, selector, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._click(progress, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async dblclick(metadata, selector, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._dblclick(progress, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async dragAndDrop(metadata, source, target, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    await controller.run(async progress => {
      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, source, options.strict, async handle => {
        return handle._retryPointerAction(progress, 'move and down', false, async point => {
          await this._page.mouse.move(point.x, point.y);
          await this._page.mouse.down();
        }, { ...options,
          position: options.sourcePosition,
          timeout: progress.timeUntilDeadline()
        });
      }));
      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, target, options.strict, async handle => {
        return handle._retryPointerAction(progress, 'move and up', false, async point => {
          await this._page.mouse.move(point.x, point.y);
          await this._page.mouse.up();
        }, { ...options,
          position: options.targetPosition,
          timeout: progress.timeUntilDeadline()
        });
      }));
    }, this._page._timeoutSettings.timeout(options));
  }

  async tap(metadata, selector, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._tap(progress, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async fill(metadata, selector, value, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._fill(progress, value, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async focus(metadata, selector, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    await controller.run(async progress => {
      dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._focus(progress)));
      await this._page._doSlowMo();
    }, this._page._timeoutSettings.timeout(options));
  }

  async textContent(metadata, selector, options = {}) {
    return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.textContent, undefined, options);
  }

  async innerText(metadata, selector, options = {}) {
    return this._scheduleRerunnableTask(metadata, selector, (progress, element) => {
      if (element.namespaceURI !== 'http://www.w3.org/1999/xhtml') throw progress.injectedScript.createStacklessError('Node is not an HTMLElement');
      return element.innerText;
    }, undefined, options);
  }

  async innerHTML(metadata, selector, options = {}) {
    return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.innerHTML, undefined, options);
  }

  async getAttribute(metadata, selector, name, options = {}) {
    return this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => element.getAttribute(data.name), {
      name
    }, options);
  }

  async inputValue(metadata, selector, options = {}) {
    return this._scheduleRerunnableTask(metadata, selector, (progress, node) => {
      const element = progress.injectedScript.retarget(node, 'follow-label');
      if (!element || element.nodeName !== 'INPUT' && element.nodeName !== 'TEXTAREA' && element.nodeName !== 'SELECT') throw progress.injectedScript.createStacklessError('Node is not an <input>, <textarea> or <select> element');
      return element.value;
    }, undefined, options);
  }

  async highlight(selector) {
    const pair = await this.resolveFrameForSelectorNoWait(selector);
    if (!pair) return;
    const context = await pair.frame._utilityContext();
    const injectedScript = await context.injectedScript();
    return await injectedScript.evaluate((injected, {
      parsed
    }) => {
      return injected.highlight(parsed);
    }, {
      parsed: pair.info.parsed
    });
  }

  async hideHighlight() {
    return this.raceAgainstEvaluationStallingEvents(async () => {
      const context = await this._utilityContext();
      const injectedScript = await context.injectedScript();
      return await injectedScript.evaluate(injected => {
        return injected.hideHighlight();
      });
    });
  }

  async _elementState(metadata, selector, state, options = {}) {
    const result = await this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
      const injected = progress.injectedScript;
      return injected.elementState(element, data.state);
    }, {
      state
    }, options);
    return dom.throwRetargetableDOMError(result);
  }

  async isVisible(metadata, selector, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      progress.log(`  checking visibility of "${selector}"`);
      const pair = await this.resolveFrameForSelectorNoWait(selector, options);
      if (!pair) return false;
      const context = await pair.frame._context(pair.info.world);
      const injectedScript = await context.injectedScript();
      return await injectedScript.evaluate((injected, {
        parsed,
        strict
      }) => {
        const element = injected.querySelector(parsed, document, strict);
        const state = element ? injected.elementState(element, 'visible') : false;
        return state === 'error:notconnected' ? false : state;
      }, {
        parsed: pair.info.parsed,
        strict: pair.info.strict
      });
    }, this._page._timeoutSettings.timeout({}));
  }

  async isHidden(metadata, selector, options = {}) {
    return !(await this.isVisible(metadata, selector, options));
  }

  async isDisabled(metadata, selector, options = {}) {
    return this._elementState(metadata, selector, 'disabled', options);
  }

  async isEnabled(metadata, selector, options = {}) {
    return this._elementState(metadata, selector, 'enabled', options);
  }

  async isEditable(metadata, selector, options = {}) {
    return this._elementState(metadata, selector, 'editable', options);
  }

  async isChecked(metadata, selector, options = {}) {
    return this._elementState(metadata, selector, 'checked', options);
  }

  async hover(metadata, selector, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._hover(progress, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async selectOption(metadata, selector, elements, values, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._selectOption(progress, elements, values, options));
    }, this._page._timeoutSettings.timeout(options));
  }

  async setInputFiles(metadata, selector, items, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._setInputFiles(progress, items, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async type(metadata, selector, text, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._type(progress, text, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async press(metadata, selector, key, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._press(progress, key, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async check(metadata, selector, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._setChecked(progress, true, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async uncheck(metadata, selector, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return dom.assertDone(await this._retryWithProgressIfNotConnected(progress, selector, options.strict, handle => handle._setChecked(progress, false, options)));
    }, this._page._timeoutSettings.timeout(options));
  }

  async waitForTimeout(metadata, timeout) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async () => {
      await new Promise(resolve => setTimeout(resolve, timeout));
    });
  }

  async expect(metadata, selector, options) {
    const controller = new _progress.ProgressController(metadata, this);
    const isArray = options.expression === 'to.have.count' || options.expression.endsWith('.array');
    const mainWorld = options.expression === 'to.have.property';

    const timeout = this._page._timeoutSettings.timeout(options); // List all combinations that are satisfied with the detached node(s).


    let omitAttached = false;
    if (!options.isNot && options.expression === 'to.be.hidden') omitAttached = true;else if (options.isNot && options.expression === 'to.be.visible') omitAttached = true;else if (!options.isNot && options.expression === 'to.have.count' && options.expectedNumber === 0) omitAttached = true;else if (options.isNot && options.expression === 'to.have.count' && options.expectedNumber !== 0) omitAttached = true;else if (!options.isNot && options.expression.endsWith('.array') && options.expectedText.length === 0) omitAttached = true;else if (options.isNot && options.expression.endsWith('.array') && options.expectedText.length > 0) omitAttached = true;
    return controller.run(async outerProgress => {
      outerProgress.log(`${metadata.apiName}${timeout ? ` with timeout ${timeout}ms` : ''}`);
      return await this._scheduleRerunnableTaskWithProgress(outerProgress, selector, (progress, element, options, elements) => {
        let result;

        if (options.isArray) {
          result = progress.injectedScript.expectArray(elements, options);
        } else {
          if (!element) {
            // expect(locator).toBeHidden() passes when there is no element.
            if (!options.isNot && options.expression === 'to.be.hidden') return {
              matches: true
            }; // expect(locator).not.toBeVisible() passes when there is no element.

            if (options.isNot && options.expression === 'to.be.visible') return {
              matches: false
            }; // When none of the above applies, keep waiting for the element.

            return progress.continuePolling;
          }

          result = progress.injectedScript.expectSingleElement(progress, element, options);
        }

        if (result.matches === options.isNot) {
          // Keep waiting in these cases:
          // expect(locator).conditionThatDoesNotMatch
          // expect(locator).not.conditionThatDoesMatch
          progress.setIntermediateResult(result.received);
          if (!Array.isArray(result.received)) progress.log(`  unexpected value "${result.received}"`);
          return progress.continuePolling;
        } // Reached the expected state!


        return result;
      }, { ...options,
        isArray
      }, {
        strict: true,
        querySelectorAll: isArray,
        mainWorld,
        omitAttached,
        logScale: true,
        ...options
      });
    }, timeout).catch(e => {
      // Q: Why not throw upon isSessionClosedError(e) as in other places?
      // A: We want user to receive a friendly message containing the last intermediate result.
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e)) throw e;
      return {
        received: controller.lastIntermediateResult(),
        matches: options.isNot,
        log: metadata.log
      };
    });
  }

  async _waitForFunctionExpression(metadata, expression, isFunction, arg, options, world = 'main') {
    const controller = new _progress.ProgressController(metadata, this);
    if (typeof options.pollingInterval === 'number') (0, _utils.assert)(options.pollingInterval > 0, 'Cannot poll with non-positive interval: ' + options.pollingInterval);
    expression = js.normalizeEvaluationExpression(expression, isFunction);

    const task = injectedScript => injectedScript.evaluateHandle((injectedScript, {
      expression,
      isFunction,
      polling,
      arg
    }) => {
      const predicate = arg => {
        let result = self.eval(expression);

        if (isFunction === true) {
          result = result(arg);
        } else if (isFunction === false) {
          result = result;
        } else {
          // auto detect.
          if (typeof result === 'function') result = result(arg);
        }

        return result;
      };

      if (typeof polling !== 'number') return injectedScript.pollRaf(progress => predicate(arg) || progress.continuePolling);
      return injectedScript.pollInterval(polling, progress => predicate(arg) || progress.continuePolling);
    }, {
      expression,
      isFunction,
      polling: options.pollingInterval,
      arg
    });

    return controller.run(progress => this._scheduleRerunnableHandleTask(progress, world, task), this._page._timeoutSettings.timeout(options));
  }

  async waitForFunctionValueInUtility(progress, pageFunction) {
    const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
    const handle = await this._waitForFunctionExpression((0, _instrumentation.serverSideCallMetadata)(), expression, true, undefined, {
      timeout: progress.timeUntilDeadline()
    }, 'utility');
    return JSON.parse(handle.rawValue());
  }

  async title() {
    const context = await this._utilityContext();
    return context.evaluate(() => document.title);
  }

  async rafrafTimeout(timeout) {
    if (timeout === 0) return;
    const context = await this._utilityContext();
    await Promise.all([// wait for double raf
    context.evaluate(() => new Promise(x => {
      requestAnimationFrame(() => {
        requestAnimationFrame(x);
      });
    })), new Promise(fulfill => setTimeout(fulfill, timeout))]);
  }

  _onDetached() {
    this._stopNetworkIdleTimer();

    this._detached = true;

    this._detachedCallback();

    const error = new Error('Frame was detached');

    for (const data of this._contextData.values()) {
      if (data.context) data.context.contextDestroyed(error);
      data.contextPromise.resolve(error);

      for (const rerunnableTask of data.rerunnableTasks) rerunnableTask.terminate(error);
    }

    if (this._parentFrame) this._parentFrame._childFrames.delete(this);
    this._parentFrame = null;
  }

  async _scheduleRerunnableTask(metadata, selector, body, taskData, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(async progress => {
      return await this._scheduleRerunnableTaskWithProgress(progress, selector, body, taskData, options);
    }, this._page._timeoutSettings.timeout(options));
  }

  async _scheduleRerunnableTaskWithProgress(progress, selector, body, taskData, options = {}) {
    const callbackText = body.toString();
    return this.retryWithProgress(progress, selector, options, async selectorInFrame => {
      // Be careful, |this| can be different from |frame|.
      progress.log(`waiting for selector "${selector}"`);
      const {
        frame,
        info
      } = selectorInFrame || {
        frame: this,
        info: {
          parsed: {
            parts: [{
              name: 'control',
              body: 'return-empty',
              source: 'control=return-empty'
            }]
          },
          world: 'utility',
          strict: !!options.strict
        }
      };
      return await frame._scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options);
    });
  }

  async _scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options) {
    progress.throwIfAborted();

    const data = this._contextData.get(options.mainWorld ? 'main' : info.world); // This potentially runs in a sub-frame.


    {
      const rerunnableTask = new RerunnableTask(data, progress, injectedScript => {
        return injectedScript.evaluateHandle((injected, {
          info,
          taskData,
          callbackText,
          querySelectorAll,
          logScale,
          omitAttached,
          snapshotName
        }) => {
          const callback = injected.eval(callbackText);
          const poller = logScale ? injected.pollLogScale.bind(injected) : injected.pollRaf.bind(injected);
          let markedElements = new Set();
          return poller(progress => {
            let element;
            let elements = [];

            if (querySelectorAll) {
              elements = injected.querySelectorAll(info.parsed, document);
              element = elements[0];
              progress.logRepeating(`  selector resolved to ${elements.length} element${elements.length === 1 ? '' : 's'}`);
            } else {
              element = injected.querySelector(info.parsed, document, info.strict);
              elements = element ? [element] : [];
              if (element) progress.logRepeating(`  selector resolved to ${injected.previewNode(element)}`);
            }

            if (!element && !omitAttached) return progress.continuePolling;

            if (snapshotName) {
              const previouslyMarkedElements = markedElements;
              markedElements = new Set(elements);

              for (const e of previouslyMarkedElements) {
                if (!markedElements.has(e)) e.removeAttribute('__playwright_target__');
              }

              for (const e of markedElements) {
                if (!previouslyMarkedElements.has(e)) e.setAttribute('__playwright_target__', snapshotName);
              }
            }

            return callback(progress, element, taskData, elements);
          });
        }, {
          info,
          taskData,
          callbackText,
          querySelectorAll: options.querySelectorAll,
          logScale: options.logScale,
          omitAttached: options.omitAttached,
          snapshotName: progress.metadata.afterSnapshot
        });
      }, true);
      if (this._detached) rerunnableTask.terminate(new Error('Frame got detached.'));
      if (data.context) rerunnableTask.rerun(data.context);
      return await rerunnableTask.promise;
    }
  }

  _scheduleRerunnableHandleTask(progress, world, task) {
    const data = this._contextData.get(world);

    const rerunnableTask = new RerunnableTask(data, progress, task, false
    /* returnByValue */
    );
    if (this._detached) rerunnableTask.terminate(new Error('waitForFunction failed: frame got detached.'));
    if (data.context) rerunnableTask.rerun(data.context);
    return rerunnableTask.handlePromise;
  }

  _setContext(world, context) {
    const data = this._contextData.get(world);

    data.context = context;

    if (context) {
      data.contextPromise.resolve(context);

      for (const rerunnableTask of data.rerunnableTasks) rerunnableTask.rerun(context);
    } else {
      data.contextPromise = new _manualPromise.ManualPromise();
    }
  }

  _contextCreated(world, context) {
    const data = this._contextData.get(world); // In case of multiple sessions to the same target, there's a race between
    // connections so we might end up creating multiple isolated worlds.
    // We can use either.


    if (data.context) {
      data.context.contextDestroyed(new Error('Execution context was destroyed, most likely because of a navigation'));

      this._setContext(world, null);
    }

    this._setContext(world, context);
  }

  _contextDestroyed(context) {
    // Sometimes we get this after detach, in which case we should not reset
    // our already destroyed contexts to something that will never resolve.
    if (this._detached) return;
    context.contextDestroyed(new Error('Execution context was destroyed, most likely because of a navigation'));

    for (const [world, data] of this._contextData) {
      if (data.context === context) this._setContext(world, null);
    }
  }

  _startNetworkIdleTimer() {
    (0, _utils.assert)(!this._networkIdleTimer); // We should not start a timer and report networkidle in detached frames.
    // This happens at least in Firefox for child frames, where we may get requestFinished
    // after the frame was detached - probably a race in the Firefox itself.

    if (this._firedLifecycleEvents.has('networkidle') || this._detached) return;
    this._networkIdleTimer = setTimeout(() => this._onLifecycleEvent('networkidle'), 500);
  }

  _stopNetworkIdleTimer() {
    if (this._networkIdleTimer) clearTimeout(this._networkIdleTimer);
    this._networkIdleTimer = undefined;
  }

  async extendInjectedScript(source, arg) {
    const context = await this._context('main');
    const injectedScriptHandle = await context.injectedScript();
    return injectedScriptHandle.evaluateHandle((injectedScript, {
      source,
      arg
    }) => {
      return injectedScript.extend(source, arg);
    }, {
      source,
      arg
    });
  }

  async _resolveFrameForSelector(progress, selector, options, scope) {
    const elementPath = [];
    progress.cleanupWhenAborted(() => {
      // Do not await here to avoid being blocked, either by stalled
      // page (e.g. alert) or unresolved navigation in Chromium.
      for (const element of elementPath) element.dispose();
    });
    let frame = this;
    const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);

    for (let i = 0; i < frameChunks.length - 1 && progress.isRunning(); ++i) {
      const info = this._page.parseSelector(frameChunks[i], options);

      const task = dom.waitForSelectorTask(info, 'attached', false, i === 0 ? scope : undefined);
      progress.log(`  waiting for frame "${(0, _selectorParser.stringifySelector)(frameChunks[i])}"`);
      const handle = i === 0 && scope ? await frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : await frame._scheduleRerunnableHandleTask(progress, info.world, task);
      const element = handle.asElement();
      const isIframe = await element.isIframeElement();
      if (isIframe === 'error:notconnected') return null; // retry

      if (!isIframe) throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
      frame = await element.contentFrame();
      element.dispose();
      if (!frame) return null; // retry
    }

    return {
      frame,
      info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)
    };
  }

  async resolveFrameForSelectorNoWait(selector, options = {}, scope) {
    let frame = this;
    const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);

    for (let i = 0; i < frameChunks.length - 1; ++i) {
      const info = this._page.parseSelector(frameChunks[i], options);

      const element = await this._page.selectors.query(frame, info, i === 0 ? scope : undefined);
      if (!element) return null;
      frame = await element.contentFrame();
      element.dispose();
      if (!frame) throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
    }

    return {
      frame,
      info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)
    };
  }

  async _runWaitForSelectorTaskOnce(progress, selector, world, task) {
    const context = await this._context(world);
    const injected = await context.injectedScript();

    try {
      const pollHandler = new dom.InjectedScriptPollHandler(progress, await task(injected));
      const result = await pollHandler.finishHandle();
      progress.cleanupWhenAborted(() => result.dispose());
      return result;
    } catch (e) {
      throw new Error(`Error: frame navigated while waiting for selector "${selector}"`);
    }
  }

  async clearStorageForCurrentOriginBestEffort() {
    const context = await this._utilityContext();
    await context.evaluate(async () => {
      // Clean DOMStorage
      sessionStorage.clear();
      localStorage.clear(); // Clean Service Workers

      const registrations = await navigator.serviceWorker.getRegistrations();
      await Promise.all(registrations.map(r => r.unregister())); // Clean IndexedDB

      for (const db of (await ((_indexedDB$databases = (_indexedDB = indexedDB).databases) === null || _indexedDB$databases === void 0 ? void 0 : _indexedDB$databases.call(_indexedDB))) || []) {
        var _indexedDB$databases, _indexedDB;

        // Do not wait for the callback - it is called on timer in Chromium (slow).
        if (db.name) indexedDB.deleteDatabase(db.name);
      }
    });
  }

}

exports.Frame = Frame;
Frame.Events = {
  InternalNavigation: 'internalnavigation',
  AddLifecycle: 'addlifecycle',
  RemoveLifecycle: 'removelifecycle'
};

class RerunnableTask {
  constructor(data, progress, task, returnByValue) {
    this.promise = void 0;
    this.handlePromise = void 0;
    this._task = void 0;
    this._progress = void 0;
    this._returnByValue = void 0;
    this._contextData = void 0;
    this._task = task;
    this._progress = progress;
    this._returnByValue = returnByValue;
    if (returnByValue) this.promise = new _manualPromise.ManualPromise();else this.handlePromise = new _manualPromise.ManualPromise();
    this._contextData = data;

    this._contextData.rerunnableTasks.add(this);
  }

  terminate(error) {
    this._reject(error);
  }

  _resolve(value) {
    if (this.promise) this.promise.resolve(value);
    if (this.handlePromise) this.handlePromise.resolve(value);
  }

  _reject(error) {
    if (this.promise) this.promise.reject(error);
    if (this.handlePromise) this.handlePromise.reject(error);
  }

  async rerun(context) {
    try {
      const injectedScript = await context.injectedScript();
      const pollHandler = new dom.InjectedScriptPollHandler(this._progress, await this._task(injectedScript));
      const result = this._returnByValue ? await pollHandler.finish() : await pollHandler.finishHandle();

      this._contextData.rerunnableTasks.delete(this);

      this._resolve(result);
    } catch (e) {
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) {
        this._contextData.rerunnableTasks.delete(this);

        this._reject(e);
      } // Unlike other places, we don't check frame for being detached since the whole scope of this
      // evaluation is within the frame's execution context. So we only let JavaScript errors and
      // session termination errors go through.
      // We will try again in the new execution context.

    }
  }

}

class SignalBarrier {
  constructor(progress) {
    this._progress = void 0;
    this._protectCount = 0;
    this._promise = new _manualPromise.ManualPromise();
    this._progress = progress;
    this.retain();
  }

  waitFor() {
    this.release();
    return this._promise;
  }

  async addFrameNavigation(frame) {
    // Auto-wait top-level navigations only.
    if (frame.parentFrame()) return;
    this.retain();

    const waiter = _helper.helper.waitForEvent(null, frame, Frame.Events.InternalNavigation, e => {
      if (!e.isPublic) return false;
      if (!e.error && this._progress) this._progress.log(`  navigated to "${frame._url}"`);
      return true;
    });

    await Promise.race([frame._page._disconnectedPromise, frame._page._crashedPromise, frame._detachedPromise, waiter.promise]).catch(e => {});
    waiter.dispose();
    this.release();
  }

  retain() {
    ++this._protectCount;
  }

  release() {
    --this._protectCount;
    if (!this._protectCount) this._promise.resolve();
  }

}

function verifyLifecycle(name, waitUntil) {
  if (waitUntil === 'networkidle0') waitUntil = 'networkidle';
  if (!types.kLifecycleEvents.has(waitUntil)) throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
  return waitUntil;
}

/***/ }),

/***/ 746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HarRecorder = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _artifact = __nccwpck_require__(1796);

var _harTracer = __nccwpck_require__(4012);

var _zipBundle = __nccwpck_require__(6383);

var _manualPromise = __nccwpck_require__(6729);

var _utils = __nccwpck_require__(3557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HarRecorder {
  constructor(context, page, options) {
    this._artifact = void 0;
    this._isFlushed = false;
    this._tracer = void 0;
    this._entries = [];
    this._zipFile = null;
    this._writtenZipEntries = new Set();
    this._artifact = new _artifact.Artifact(context, _path.default.join(context._browser.options.artifactsDir, `${(0, _utils.createGuid)()}.har`));
    const urlFilterRe = options.urlRegexSource !== undefined && options.urlRegexFlags !== undefined ? new RegExp(options.urlRegexSource, options.urlRegexFlags) : undefined;
    const expectsZip = options.path.endsWith('.zip');
    const content = options.content || (expectsZip ? 'attach' : 'embed');
    this._tracer = new _harTracer.HarTracer(context, page, this, {
      content,
      slimMode: options.mode === 'minimal',
      includeTraceInfo: false,
      waitForContentOnStop: true,
      skipScripts: false,
      urlFilter: urlFilterRe !== null && urlFilterRe !== void 0 ? urlFilterRe : options.urlGlob
    });
    this._zipFile = content === 'attach' || expectsZip ? new _zipBundle.yazl.ZipFile() : null;

    this._tracer.start();
  }

  onEntryStarted(entry) {
    this._entries.push(entry);
  }

  onEntryFinished(entry) {}

  onContentBlob(sha1, buffer) {
    if (!this._zipFile || this._writtenZipEntries.has(sha1)) return;

    this._writtenZipEntries.add(sha1);

    this._zipFile.addBuffer(buffer, sha1);
  }

  async flush() {
    if (this._isFlushed) return;
    this._isFlushed = true;
    await this._tracer.flush();

    const log = this._tracer.stop();

    log.entries = this._entries;
    const harFileContent = jsonStringify({
      log
    });

    if (this._zipFile) {
      const result = new _manualPromise.ManualPromise();

      this._zipFile.on('error', error => result.reject(error));

      this._zipFile.addBuffer(Buffer.from(harFileContent, 'utf-8'), 'har.har');

      this._zipFile.end();

      this._zipFile.outputStream.pipe(_fs.default.createWriteStream(this._artifact.localPath())).on('close', () => {
        result.resolve();
      });

      await result;
    } else {
      await _fs.default.promises.writeFile(this._artifact.localPath(), harFileContent);
    }
  }

  async export() {
    await this.flush();

    this._artifact.reportFinished();

    return this._artifact;
  }

}

exports.HarRecorder = HarRecorder;

function jsonStringify(object) {
  const tokens = [];
  innerJsonStringify(object, tokens, '', false, undefined);
  return tokens.join('');
}

function innerJsonStringify(object, tokens, indent, flat, parentKey) {
  if (typeof object !== 'object' || object === null) {
    tokens.push(JSON.stringify(object));
    return;
  }

  const isArray = Array.isArray(object);

  if (!isArray && object.constructor.name !== 'Object') {
    tokens.push(JSON.stringify(object));
    return;
  }

  const entries = isArray ? object : Object.entries(object).filter(e => e[1] !== undefined);

  if (!entries.length) {
    tokens.push(isArray ? `[]` : `{}`);
    return;
  }

  const childIndent = `${indent}  `;
  let brackets;
  if (isArray) brackets = flat ? {
    open: '[',
    close: ']'
  } : {
    open: `[\n${childIndent}`,
    close: `\n${indent}]`
  };else brackets = flat ? {
    open: '{ ',
    close: ' }'
  } : {
    open: `{\n${childIndent}`,
    close: `\n${indent}}`
  };
  tokens.push(brackets.open);

  for (let i = 0; i < entries.length; ++i) {
    const entry = entries[i];
    if (i) tokens.push(flat ? `, ` : `,\n${childIndent}`);
    if (!isArray) tokens.push(`${JSON.stringify(entry[0])}: `);
    const key = isArray ? undefined : entry[0];
    const flatten = flat || key === 'timings' || parentKey === 'headers';
    innerJsonStringify(isArray ? entry : entry[1], tokens, childIndent, flatten, key);
  }

  tokens.push(brackets.close);
}

/***/ }),

/***/ 4012:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.HarTracer = void 0;

var _browserContext = __nccwpck_require__(5985);

var _fetch = __nccwpck_require__(2857);

var _helper = __nccwpck_require__(9175);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _utils = __nccwpck_require__(3557);

var _eventsHelper = __nccwpck_require__(3841);

var _utilsBundle = __nccwpck_require__(1319);

var _manualPromise = __nccwpck_require__(6729);

var _userAgent = __nccwpck_require__(5110);

var _netUtils = __nccwpck_require__(989);

var _frames = __nccwpck_require__(8895);

var _mimeType = __nccwpck_require__(5746);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const FALLBACK_HTTP_VERSION = 'HTTP/1.1';

class HarTracer {
  constructor(context, page, delegate, options) {
    this._context = void 0;
    this._barrierPromises = new Set();
    this._delegate = void 0;
    this._options = void 0;
    this._pageEntries = new Map();
    this._eventListeners = [];
    this._started = false;
    this._entrySymbol = void 0;
    this._baseURL = void 0;
    this._page = void 0;
    this._context = context;
    this._page = page;
    this._delegate = delegate;
    this._options = options;

    if (options.slimMode) {
      options.omitSecurityDetails = true;
      options.omitCookies = true;
      options.omitTiming = true;
      options.omitServerIP = true;
      options.omitSizes = true;
      options.omitPages = true;
    }

    this._entrySymbol = Symbol('requestHarEntry');
    this._baseURL = context instanceof _fetch.APIRequestContext ? context._defaultOptions().baseURL : context._options.baseURL;
  }

  start() {
    if (this._started) return;
    this._started = true;
    const apiRequest = this._context instanceof _fetch.APIRequestContext ? this._context : this._context.fetchRequest;
    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.Request, event => this._onAPIRequest(event)), _eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.RequestFinished, event => this._onAPIRequestFinished(event))];

    if (this._context instanceof _browserContext.BrowserContext) {
      this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, page => this._createPageEntryIfNeeded(page)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Request, request => this._onRequest(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFinished, ({
        request,
        response
      }) => this._onRequestFinished(request, response).catch(() => {})), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFailed, request => this._onRequestFailed(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Response, response => this._onResponse(response)));
    }
  }

  _shouldIncludeEntryWithUrl(urlString) {
    return !this._options.urlFilter || (0, _netUtils.urlMatches)(this._baseURL, urlString, this._options.urlFilter);
  }

  _entryForRequest(request) {
    return request[this._entrySymbol];
  }

  _createPageEntryIfNeeded(page) {
    if (!page) return;
    if (this._options.omitPages) return;
    if (this._page && page !== this._page) return;

    let pageEntry = this._pageEntries.get(page);

    if (!pageEntry) {
      pageEntry = {
        startedDateTime: new Date(),
        id: page.guid,
        title: '',
        pageTimings: this._options.omitTiming ? {} : {
          onContentLoad: -1,
          onLoad: -1
        }
      };
      page.mainFrame().on(_frames.Frame.Events.AddLifecycle, event => {
        if (event === 'load') this._onLoad(page, pageEntry);
        if (event === 'domcontentloaded') this._onDOMContentLoaded(page, pageEntry);
      });

      this._pageEntries.set(page, pageEntry);
    }

    return pageEntry;
  }

  _onDOMContentLoaded(page, pageEntry) {
    const promise = page.mainFrame().evaluateExpression(String(() => {
      return {
        title: document.title,
        domContentLoaded: performance.timing.domContentLoadedEventStart
      };
    }), true, undefined, 'utility').then(result => {
      pageEntry.title = result.title;
      if (!this._options.omitTiming) pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
    }).catch(() => {});

    this._addBarrier(page, promise);
  }

  _onLoad(page, pageEntry) {
    const promise = page.mainFrame().evaluateExpression(String(() => {
      return {
        title: document.title,
        loaded: performance.timing.loadEventStart
      };
    }), true, undefined, 'utility').then(result => {
      pageEntry.title = result.title;
      if (!this._options.omitTiming) pageEntry.pageTimings.onLoad = result.loaded;
    }).catch(() => {});

    this._addBarrier(page, promise);
  }

  _addBarrier(target, promise) {
    if (!target) return null;
    if (!this._options.waitForContentOnStop) return;
    const race = Promise.race([new Promise(f => target.on('close', () => {
      this._barrierPromises.delete(race);

      f();
    })), promise]);

    this._barrierPromises.add(race);

    race.then(() => this._barrierPromises.delete(race));
  }

  _onAPIRequest(event) {
    var _event$postData;

    if (!this._shouldIncludeEntryWithUrl(event.url.toString())) return;
    const harEntry = createHarEntry(event.method, event.url, undefined, this._options);
    if (!this._options.omitCookies) harEntry.request.cookies = event.cookies;
    harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({
      name,
      value
    }));
    harEntry.request.postData = this._postDataForBuffer(event.postData || null, event.headers['content-type'], this._options.content);
    if (!this._options.omitSizes) harEntry.request.bodySize = ((_event$postData = event.postData) === null || _event$postData === void 0 ? void 0 : _event$postData.length) || 0;
    event[this._entrySymbol] = harEntry;
    if (this._started) this._delegate.onEntryStarted(harEntry);
  }

  _onAPIRequestFinished(event) {
    const harEntry = this._entryForRequest(event.requestEvent);

    if (!harEntry) return;
    harEntry.response.status = event.statusCode;
    harEntry.response.statusText = event.statusMessage;
    harEntry.response.httpVersion = event.httpVersion;
    harEntry.response.redirectURL = event.headers.location || '';

    for (let i = 0; i < event.rawHeaders.length; i += 2) {
      harEntry.response.headers.push({
        name: event.rawHeaders[i],
        value: event.rawHeaders[i + 1]
      });
    }

    harEntry.response.cookies = this._options.omitCookies ? [] : event.cookies.map(c => {
      return { ...c,
        expires: c.expires === -1 ? undefined : new Date(c.expires)
      };
    });
    const content = harEntry.response.content;
    const contentType = event.headers['content-type'];
    if (contentType) content.mimeType = contentType;

    this._storeResponseContent(event.body, content, 'other');

    if (this._started) this._delegate.onEntryFinished(harEntry);
  }

  _onRequest(request) {
    var _request$frame, _request$frame2;

    if (!this._shouldIncludeEntryWithUrl(request.url())) return;
    const page = (_request$frame = request.frame()) === null || _request$frame === void 0 ? void 0 : _request$frame._page;
    if (this._page && page !== this._page) return;
    const url = network.parsedURL(request.url());
    if (!url) return;

    const pageEntry = this._createPageEntryIfNeeded(page);

    const harEntry = createHarEntry(request.method(), url, (_request$frame2 = request.frame()) === null || _request$frame2 === void 0 ? void 0 : _request$frame2.guid, this._options);
    if (pageEntry) harEntry.pageref = pageEntry.id;
    harEntry.request.postData = this._postDataForRequest(request, this._options.content);
    if (!this._options.omitSizes) harEntry.request.bodySize = request.bodySize();

    if (request.redirectedFrom()) {
      const fromEntry = this._entryForRequest(request.redirectedFrom());

      if (fromEntry) fromEntry.response.redirectURL = request.url();
    }

    request[this._entrySymbol] = harEntry;
    (0, _utils.assert)(this._started);

    this._delegate.onEntryStarted(harEntry);
  }

  async _onRequestFinished(request, response) {
    var _request$frame3;

    if (!response) return;

    const harEntry = this._entryForRequest(request);

    if (!harEntry) return;
    const page = (_request$frame3 = request.frame()) === null || _request$frame3 === void 0 ? void 0 : _request$frame3._page;
    const httpVersion = response.httpVersion();
    harEntry.request.httpVersion = httpVersion;
    harEntry.response.httpVersion = httpVersion;
    const compressionCalculationBarrier = this._options.omitSizes ? undefined : {
      _encodedBodySize: -1,
      _decodedBodySize: -1,
      barrier: new _manualPromise.ManualPromise(),
      _check: function () {
        if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
          harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
          this.barrier.resolve();
        }
      },
      setEncodedBodySize: function (encodedBodySize) {
        this._encodedBodySize = encodedBodySize;

        this._check();
      },
      setDecodedBodySize: function (decodedBodySize) {
        this._decodedBodySize = decodedBodySize;

        this._check();
      }
    };
    if (compressionCalculationBarrier) this._addBarrier(page || request.serviceWorker(), compressionCalculationBarrier.barrier);
    const promise = response.body().then(buffer => {
      if (this._options.skipScripts && request.resourceType() === 'script') {
        compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(0);
        return;
      }

      const content = harEntry.response.content;
      compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(buffer.length);

      this._storeResponseContent(buffer, content, request.resourceType());
    }).catch(() => {
      compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setDecodedBodySize(0);
    }).then(() => {
      if (this._started) this._delegate.onEntryFinished(harEntry);
    });

    this._addBarrier(page || request.serviceWorker(), promise);

    if (!this._options.omitSizes) {
      this._addBarrier(page || request.serviceWorker(), response.sizes().then(sizes => {
        harEntry.response.bodySize = sizes.responseBodySize;
        harEntry.response.headersSize = sizes.responseHeadersSize;
        harEntry.response._transferSize = sizes.transferSize;
        harEntry.request.headersSize = sizes.requestHeadersSize;
        compressionCalculationBarrier === null || compressionCalculationBarrier === void 0 ? void 0 : compressionCalculationBarrier.setEncodedBodySize(sizes.responseBodySize);
      }));
    }
  }

  async _onRequestFailed(request) {
    const harEntry = this._entryForRequest(request);

    if (!harEntry) return;
    if (request._failureText !== null) harEntry.response._failureText = request._failureText;
    if (this._started) this._delegate.onEntryFinished(harEntry);
  }

  _storeResponseContent(buffer, content, resourceType) {
    if (!buffer) {
      content.size = 0;
      return;
    }

    if (!this._options.omitSizes) content.size = buffer.length;

    if (this._options.content === 'embed') {
      // Sometimes, we can receive a font/media file with textual mime type. Browser
      // still interprets them correctly, but the 'content-type' header is obviously wrong.
      if ((0, _mimeType.isTextualMimeType)(content.mimeType) && resourceType !== 'font') {
        content.text = buffer.toString();
      } else {
        content.text = buffer.toString('base64');
        content.encoding = 'base64';
      }
    } else if (this._options.content === 'attach') {
      const sha1 = (0, _utils.calculateSha1)(buffer) + '.' + (_utilsBundle.mime.getExtension(content.mimeType) || 'dat');
      if (this._options.includeTraceInfo) content._sha1 = sha1;else content._file = sha1;
      if (this._started) this._delegate.onContentBlob(sha1, buffer);
    }
  }

  _onResponse(response) {
    var _response$frame;

    const harEntry = this._entryForRequest(response.request());

    if (!harEntry) return;
    const page = (_response$frame = response.frame()) === null || _response$frame === void 0 ? void 0 : _response$frame._page;

    const pageEntry = this._createPageEntryIfNeeded(page);

    const request = response.request();
    harEntry.response = {
      status: response.status(),
      statusText: response.statusText(),
      httpVersion: response.httpVersion(),
      // These are bad values that will be overwritten bellow.
      cookies: [],
      headers: [],
      content: {
        size: -1,
        mimeType: 'x-unknown'
      },
      headersSize: -1,
      bodySize: -1,
      redirectURL: '',
      _transferSize: this._options.omitSizes ? undefined : -1
    };

    if (!this._options.omitTiming) {
      const timing = response.timing();
      if (pageEntry && pageEntry.startedDateTime.valueOf() > timing.startTime) pageEntry.startedDateTime = new Date(timing.startTime);
      const dns = timing.domainLookupEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
      const connect = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
      const ssl = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
      const wait = timing.responseStart !== -1 ? _helper.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
      const receive = response.request()._responseEndTiming !== -1 ? _helper.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
      harEntry.timings = {
        dns,
        connect,
        ssl,
        send: 0,
        wait,
        receive
      };
      harEntry.time = [dns, connect, ssl, wait, receive].reduce((pre, cur) => cur > 0 ? cur + pre : pre, 0);
    }

    if (!this._options.omitServerIP) {
      this._addBarrier(page || request.serviceWorker(), response.serverAddr().then(server => {
        if (server !== null && server !== void 0 && server.ipAddress) harEntry.serverIPAddress = server.ipAddress;
        if (server !== null && server !== void 0 && server.port) harEntry._serverPort = server.port;
      }));
    }

    if (!this._options.omitSecurityDetails) {
      this._addBarrier(page || request.serviceWorker(), response.securityDetails().then(details => {
        if (details) harEntry._securityDetails = details;
      }));
    }

    this._addBarrier(page || request.serviceWorker(), request.rawRequestHeaders().then(headers => {
      if (!this._options.omitCookies) {
        for (const header of headers.filter(header => header.name.toLowerCase() === 'cookie')) harEntry.request.cookies.push(...header.value.split(';').map(parseCookie));
      }

      harEntry.request.headers = headers;
    }));

    this._addBarrier(page || request.serviceWorker(), response.rawResponseHeaders().then(headers => {
      if (!this._options.omitCookies) {
        for (const header of headers.filter(header => header.name.toLowerCase() === 'set-cookie')) harEntry.response.cookies.push(parseCookie(header.value));
      }

      harEntry.response.headers = headers;
      const contentType = headers.find(header => header.name.toLowerCase() === 'content-type');
      if (contentType) harEntry.response.content.mimeType = contentType.value;
    }));
  }

  async flush() {
    await Promise.all(this._barrierPromises);
  }

  stop() {
    this._started = false;

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);

    this._barrierPromises.clear();

    const context = this._context instanceof _browserContext.BrowserContext ? this._context : undefined;
    const log = {
      version: '1.2',
      creator: {
        name: 'Playwright',
        version: (0, _userAgent.getPlaywrightVersion)()
      },
      browser: {
        name: (context === null || context === void 0 ? void 0 : context._browser.options.name) || '',
        version: (context === null || context === void 0 ? void 0 : context._browser.version()) || ''
      },
      pages: this._pageEntries.size ? Array.from(this._pageEntries.values()) : undefined,
      entries: []
    };

    if (!this._options.omitTiming) {
      for (const pageEntry of log.pages || []) {
        if (typeof pageEntry.pageTimings.onContentLoad === 'number' && pageEntry.pageTimings.onContentLoad >= 0) pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();else pageEntry.pageTimings.onContentLoad = -1;
        if (typeof pageEntry.pageTimings.onLoad === 'number' && pageEntry.pageTimings.onLoad >= 0) pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();else pageEntry.pageTimings.onLoad = -1;
      }
    }

    this._pageEntries.clear();

    return log;
  }

  _postDataForRequest(request, content) {
    const postData = request.postDataBuffer();
    if (!postData) return;
    const contentType = request.headerValue('content-type');
    return this._postDataForBuffer(postData, contentType, content);
  }

  _postDataForBuffer(postData, contentType, content) {
    var _contentType;

    if (!postData) return;
    (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : contentType = 'application/octet-stream';
    const result = {
      mimeType: contentType,
      text: '',
      params: []
    };
    if (content === 'embed' && contentType !== 'application/octet-stream') result.text = postData.toString();

    if (content === 'attach') {
      const sha1 = (0, _utils.calculateSha1)(postData) + '.' + (_utilsBundle.mime.getExtension(contentType) || 'dat');
      if (this._options.includeTraceInfo) result._sha1 = sha1;else result._file = sha1;

      this._delegate.onContentBlob(sha1, postData);
    }

    if (contentType === 'application/x-www-form-urlencoded') {
      const parsed = new URLSearchParams(postData.toString());

      for (const [name, value] of parsed.entries()) result.params.push({
        name,
        value
      });
    }

    return result;
  }

}

exports.HarTracer = HarTracer;

function createHarEntry(method, url, frameref, options) {
  const harEntry = {
    _frameref: options.includeTraceInfo ? frameref : undefined,
    _monotonicTime: options.includeTraceInfo ? (0, _utils.monotonicTime)() : undefined,
    startedDateTime: new Date(),
    time: -1,
    request: {
      method: method,
      url: url.toString(),
      httpVersion: FALLBACK_HTTP_VERSION,
      cookies: [],
      headers: [],
      queryString: [...url.searchParams].map(e => ({
        name: e[0],
        value: e[1]
      })),
      headersSize: -1,
      bodySize: -1
    },
    response: {
      status: -1,
      statusText: '',
      httpVersion: FALLBACK_HTTP_VERSION,
      cookies: [],
      headers: [],
      content: {
        size: -1,
        mimeType: 'x-unknown'
      },
      headersSize: -1,
      bodySize: -1,
      redirectURL: '',
      _transferSize: options.omitSizes ? undefined : -1
    },
    cache: {},
    timings: {
      send: -1,
      wait: -1,
      receive: -1
    }
  };
  return harEntry;
}

function parseCookie(c) {
  const cookie = {
    name: '',
    value: ''
  };
  let first = true;

  for (const pair of c.split(/; */)) {
    const indexOfEquals = pair.indexOf('=');
    const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
    const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : '';

    if (first) {
      first = false;
      cookie.name = name;
      cookie.value = value;
      continue;
    }

    if (name === 'Domain') cookie.domain = value;
    if (name === 'Expires') cookie.expires = new Date(value);
    if (name === 'HttpOnly') cookie.httpOnly = true;
    if (name === 'Max-Age') cookie.expires = new Date(Date.now() + +value * 1000);
    if (name === 'Path') cookie.path = value;
    if (name === 'SameSite') cookie.sameSite = value;
    if (name === 'Secure') cookie.secure = true;
  }

  return cookie;
}

/***/ }),

/***/ 9175:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.helper = void 0;

var _debugLogger = __nccwpck_require__(2003);

var _eventsHelper = __nccwpck_require__(3841);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Helper {
  static completeUserURL(urlString) {
    if (urlString.startsWith('localhost') || urlString.startsWith('127.0.0.1')) urlString = 'http://' + urlString;
    return urlString;
  }

  static enclosingIntRect(rect) {
    const x = Math.floor(rect.x + 1e-3);
    const y = Math.floor(rect.y + 1e-3);
    const x2 = Math.ceil(rect.x + rect.width - 1e-3);
    const y2 = Math.ceil(rect.y + rect.height - 1e-3);
    return {
      x,
      y,
      width: x2 - x,
      height: y2 - y
    };
  }

  static enclosingIntSize(size) {
    return {
      width: Math.floor(size.width + 1e-3),
      height: Math.floor(size.height + 1e-3)
    };
  }

  static getViewportSizeFromWindowFeatures(features) {
    const widthString = features.find(f => f.startsWith('width='));
    const heightString = features.find(f => f.startsWith('height='));
    const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
    const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
    if (!Number.isNaN(width) && !Number.isNaN(height)) return {
      width,
      height
    };
    return null;
  }

  static waitForEvent(progress, emitter, event, predicate) {
    const listeners = [];
    const promise = new Promise((resolve, reject) => {
      listeners.push(_eventsHelper.eventsHelper.addEventListener(emitter, event, eventArg => {
        try {
          if (predicate && !predicate(eventArg)) return;

          _eventsHelper.eventsHelper.removeEventListeners(listeners);

          resolve(eventArg);
        } catch (e) {
          _eventsHelper.eventsHelper.removeEventListeners(listeners);

          reject(e);
        }
      }));
    });

    const dispose = () => _eventsHelper.eventsHelper.removeEventListeners(listeners);

    if (progress) progress.cleanupWhenAborted(dispose);
    return {
      promise,
      dispose
    };
  }

  static secondsToRoundishMillis(value) {
    return (value * 1000000 | 0) / 1000;
  }

  static millisToRoundishMillis(value) {
    return (value * 1000 | 0) / 1000;
  }

  static debugProtocolLogger(protocolLogger) {
    return (direction, message) => {
      if (protocolLogger) protocolLogger(direction, message);
      if (_debugLogger.debugLogger.isEnabled('protocol')) _debugLogger.debugLogger.log('protocol', (direction === 'send' ? 'SEND ► ' : '◀ RECV ') + JSON.stringify(message));
    };
  }

  static formatBrowserLogs(logs) {
    if (!logs.length) return '';
    return '\n' + '='.repeat(20) + ' Browser output: ' + '='.repeat(20) + '\n' + logs.join('\n');
  }

}

const helper = Helper;
exports.helper = helper;

/***/ }),

/***/ 4540:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "DispatcherConnection", ({
  enumerable: true,
  get: function () {
    return _dispatcher.DispatcherConnection;
  }
}));
Object.defineProperty(exports, "PlaywrightDispatcher", ({
  enumerable: true,
  get: function () {
    return _playwrightDispatcher.PlaywrightDispatcher;
  }
}));
Object.defineProperty(exports, "Registry", ({
  enumerable: true,
  get: function () {
    return _registry.Registry;
  }
}));
Object.defineProperty(exports, "Root", ({
  enumerable: true,
  get: function () {
    return _dispatcher.Root;
  }
}));
Object.defineProperty(exports, "createPlaywright", ({
  enumerable: true,
  get: function () {
    return _playwright.createPlaywright;
  }
}));
Object.defineProperty(exports, "installBrowsersForNpmInstall", ({
  enumerable: true,
  get: function () {
    return _registry.installBrowsersForNpmInstall;
  }
}));
Object.defineProperty(exports, "installDefaultBrowsersForNpmInstall", ({
  enumerable: true,
  get: function () {
    return _registry.installDefaultBrowsersForNpmInstall;
  }
}));
Object.defineProperty(exports, "registry", ({
  enumerable: true,
  get: function () {
    return _registry.registry;
  }
}));
Object.defineProperty(exports, "registryDirectory", ({
  enumerable: true,
  get: function () {
    return _registry.registryDirectory;
  }
}));
Object.defineProperty(exports, "writeDockerVersion", ({
  enumerable: true,
  get: function () {
    return _registry.writeDockerVersion;
  }
}));

var _registry = __nccwpck_require__(9048);

var _dispatcher = __nccwpck_require__(4098);

var _playwrightDispatcher = __nccwpck_require__(8650);

var _playwright = __nccwpck_require__(4506);

/***/ }),

/***/ 2654:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.keypadLocation = exports.Touchscreen = exports.Mouse = exports.Keyboard = void 0;

var _utils = __nccwpck_require__(3557);

var keyboardLayout = _interopRequireWildcard(__nccwpck_require__(574));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const keypadLocation = keyboardLayout.keypadLocation;
exports.keypadLocation = keypadLocation;
const kModifiers = ['Alt', 'Control', 'Meta', 'Shift'];

class Keyboard {
  constructor(raw, page) {
    this._pressedModifiers = new Set();
    this._pressedKeys = new Set();
    this._raw = void 0;
    this._page = void 0;
    this._raw = raw;
    this._page = page;
  }

  async down(key) {
    const description = this._keyDescriptionForString(key);

    const autoRepeat = this._pressedKeys.has(description.code);

    this._pressedKeys.add(description.code);

    if (kModifiers.includes(description.key)) this._pressedModifiers.add(description.key);
    const text = description.text;
    await this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
    await this._page._doSlowMo();
  }

  _keyDescriptionForString(keyString) {
    let description = usKeyboardLayout.get(keyString);
    (0, _utils.assert)(description, `Unknown key: "${keyString}"`);

    const shift = this._pressedModifiers.has('Shift');

    description = shift && description.shifted ? description.shifted : description; // if any modifiers besides shift are pressed, no text should be sent

    if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has('Shift') && this._pressedModifiers.size === 1) return { ...description,
      text: ''
    };
    return description;
  }

  async up(key) {
    const description = this._keyDescriptionForString(key);

    if (kModifiers.includes(description.key)) this._pressedModifiers.delete(description.key);

    this._pressedKeys.delete(description.code);

    await this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
    await this._page._doSlowMo();
  }

  async insertText(text) {
    await this._raw.sendText(text);
    await this._page._doSlowMo();
  }

  async type(text, options) {
    const delay = options && options.delay || undefined;

    for (const char of text) {
      if (usKeyboardLayout.has(char)) {
        await this.press(char, {
          delay
        });
      } else {
        if (delay) await new Promise(f => setTimeout(f, delay));
        await this.insertText(char);
      }
    }
  }

  async press(key, options = {}) {
    function split(keyString) {
      const keys = [];
      let building = '';

      for (const char of keyString) {
        if (char === '+' && building) {
          keys.push(building);
          building = '';
        } else {
          building += char;
        }
      }

      keys.push(building);
      return keys;
    }

    const tokens = split(key);
    const promises = [];
    key = tokens[tokens.length - 1];

    for (let i = 0; i < tokens.length - 1; ++i) promises.push(this.down(tokens[i]));

    promises.push(this.down(key));

    if (options.delay) {
      await Promise.all(promises);
      await new Promise(f => setTimeout(f, options.delay));
    }

    promises.push(this.up(key));

    for (let i = tokens.length - 2; i >= 0; --i) promises.push(this.up(tokens[i]));

    await Promise.all(promises);
  }

  async _ensureModifiers(modifiers) {
    for (const modifier of modifiers) {
      if (!kModifiers.includes(modifier)) throw new Error('Unknown modifier ' + modifier);
    }

    const restore = Array.from(this._pressedModifiers);
    const promises = [];

    for (const key of kModifiers) {
      const needDown = modifiers.includes(key);

      const isDown = this._pressedModifiers.has(key);

      if (needDown && !isDown) promises.push(this.down(key));else if (!needDown && isDown) promises.push(this.up(key));
    }

    await Promise.all(promises);
    return restore;
  }

  _modifiers() {
    return this._pressedModifiers;
  }

}

exports.Keyboard = Keyboard;

class Mouse {
  constructor(raw, page) {
    this._keyboard = void 0;
    this._x = 0;
    this._y = 0;
    this._lastButton = 'none';
    this._buttons = new Set();
    this._raw = void 0;
    this._page = void 0;
    this._raw = raw;
    this._page = page;
    this._keyboard = this._page.keyboard;
  }

  async move(x, y, options = {}) {
    const {
      steps = 1
    } = options;
    const fromX = this._x;
    const fromY = this._y;
    this._x = x;
    this._y = y;

    for (let i = 1; i <= steps; i++) {
      const middleX = fromX + (x - fromX) * (i / steps);
      const middleY = fromY + (y - fromY) * (i / steps);
      await this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options.forClick);
      await this._page._doSlowMo();
    }
  }

  async down(options = {}) {
    const {
      button = 'left',
      clickCount = 1
    } = options;
    this._lastButton = button;

    this._buttons.add(button);

    await this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
    await this._page._doSlowMo();
  }

  async up(options = {}) {
    const {
      button = 'left',
      clickCount = 1
    } = options;
    this._lastButton = 'none';

    this._buttons.delete(button);

    await this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
    await this._page._doSlowMo();
  }

  async click(x, y, options = {}) {
    const {
      delay = null,
      clickCount = 1
    } = options;

    if (delay) {
      this.move(x, y, {
        forClick: true
      });

      for (let cc = 1; cc <= clickCount; ++cc) {
        await this.down({ ...options,
          clickCount: cc
        });
        await new Promise(f => setTimeout(f, delay));
        await this.up({ ...options,
          clickCount: cc
        });
        if (cc < clickCount) await new Promise(f => setTimeout(f, delay));
      }
    } else {
      const promises = [];
      promises.push(this.move(x, y, {
        forClick: true
      }));

      for (let cc = 1; cc <= clickCount; ++cc) {
        promises.push(this.down({ ...options,
          clickCount: cc
        }));
        promises.push(this.up({ ...options,
          clickCount: cc
        }));
      }

      await Promise.all(promises);
    }
  }

  async dblclick(x, y, options = {}) {
    await this.click(x, y, { ...options,
      clickCount: 2
    });
  }

  async wheel(deltaX, deltaY) {
    await this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
    await this._page._doSlowMo();
  }

}

exports.Mouse = Mouse;
const aliases = new Map([['ShiftLeft', ['Shift']], ['ControlLeft', ['Control']], ['AltLeft', ['Alt']], ['MetaLeft', ['Meta']], ['Enter', ['\n', '\r']]]);
const usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);

function buildLayoutClosure(layout) {
  const result = new Map();

  for (const code in layout) {
    const definition = layout[code];
    const description = {
      key: definition.key || '',
      keyCode: definition.keyCode || 0,
      keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
      code,
      text: definition.text || '',
      location: definition.location || 0
    };
    if (definition.key.length === 1) description.text = description.key; // Generate shifted definition.

    let shiftedDescription;

    if (definition.shiftKey) {
      (0, _utils.assert)(definition.shiftKey.length === 1);
      shiftedDescription = { ...description
      };
      shiftedDescription.key = definition.shiftKey;
      shiftedDescription.text = definition.shiftKey;
      if (definition.shiftKeyCode) shiftedDescription.keyCode = definition.shiftKeyCode;
    } // Map from code: Digit3 -> { ... descrption, shifted }


    result.set(code, { ...description,
      shifted: shiftedDescription
    }); // Map from aliases: Shift -> non-shiftable definition

    if (aliases.has(code)) {
      for (const alias of aliases.get(code)) result.set(alias, description);
    } // Do not use numpad when converting keys to codes.


    if (definition.location) continue; // Map from key, no shifted

    if (description.key.length === 1) result.set(description.key, description); // Map from shiftKey, no shifted

    if (shiftedDescription) result.set(shiftedDescription.key, { ...shiftedDescription,
      shifted: undefined
    });
  }

  return result;
}

class Touchscreen {
  constructor(raw, page) {
    this._raw = void 0;
    this._page = void 0;
    this._raw = raw;
    this._page = page;
  }

  async tap(x, y) {
    if (!this._page._browserContext._options.hasTouch) throw new Error('hasTouch must be enabled on the browser context before using the touchscreen.');
    await this._raw.tap(x, y, this._page.keyboard._modifiers());
    await this._page._doSlowMo();
  }

}

exports.Touchscreen = Touchscreen;

/***/ }),

/***/ 6686:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SdkObject = void 0;
exports.createInstrumentation = createInstrumentation;
exports.kTestSdkObjects = void 0;
exports.serverSideCallMetadata = serverSideCallMetadata;

var _events = __nccwpck_require__(2361);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kTestSdkObjects = new WeakSet();
exports.kTestSdkObjects = kTestSdkObjects;

class SdkObject extends _events.EventEmitter {
  constructor(parent, guidPrefix, guid) {
    super();
    this.guid = void 0;
    this.attribution = void 0;
    this.instrumentation = void 0;
    this.guid = guid || `${guidPrefix || ''}@${(0, _utils.createGuid)()}`;
    this.setMaxListeners(0);
    this.attribution = { ...parent.attribution
    };
    this.instrumentation = parent.instrumentation;
    if (process.env._PW_INTERNAL_COUNT_SDK_OBJECTS) kTestSdkObjects.add(this);
  }

}

exports.SdkObject = SdkObject;

function createInstrumentation() {
  const listeners = new Map();
  return new Proxy({}, {
    get: (obj, prop) => {
      if (prop === 'addListener') return (listener, context) => listeners.set(listener, context);
      if (prop === 'removeListener') return listener => listeners.delete(listener);
      if (!prop.startsWith('on')) return obj[prop];
      return async (sdkObject, ...params) => {
        for (const [listener, context] of listeners) {
          var _prop, _ref;

          if (!context || sdkObject.attribution.context === context) await ((_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, sdkObject, ...params));
        }
      };
    }
  });
}

function serverSideCallMetadata() {
  return {
    id: '',
    wallTime: 0,
    startTime: 0,
    endTime: 0,
    type: 'Internal',
    method: '',
    params: {},
    log: [],
    snapshots: [],
    isServerSide: true
  };
}

/***/ }),

/***/ 3706:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InvalidSelectorError = void 0;
exports.isInvalidSelectorError = isInvalidSelectorError;
exports.parseCSS = parseCSS;
exports.serializeSelector = serializeSelector;

var css = _interopRequireWildcard(__nccwpck_require__(6172));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InvalidSelectorError extends Error {}

exports.InvalidSelectorError = InvalidSelectorError;

function isInvalidSelectorError(error) {
  return error instanceof InvalidSelectorError;
} // Note: '>=' is used internally for text engine to preserve backwards compatibility.


function parseCSS(selector, customNames) {
  let tokens;

  try {
    tokens = css.tokenize(selector);
    if (!(tokens[tokens.length - 1] instanceof css.EOFToken)) tokens.push(new css.EOFToken());
  } catch (e) {
    const newMessage = e.message + ` while parsing selector "${selector}"`;
    const index = (e.stack || '').indexOf(e.message);
    if (index !== -1) e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
    e.message = newMessage;
    throw e;
  }

  const unsupportedToken = tokens.find(token => {
    return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || // TODO: Consider using these for something, e.g. to escape complex strings.
    // For example :xpath{ (//div/bar[@attr="foo"])[2]/baz }
    // Or this way :xpath( {complex-xpath-goes-here("hello")} )
    token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || // TODO: Consider treating these as strings?
    token instanceof css.URLToken || token instanceof css.PercentageToken;
  });
  if (unsupportedToken) throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
  let pos = 0;
  const names = new Set();

  function unexpected() {
    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
  }

  function skipWhitespace() {
    while (tokens[pos] instanceof css.WhitespaceToken) pos++;
  }

  function isIdent(p = pos) {
    return tokens[p] instanceof css.IdentToken;
  }

  function isString(p = pos) {
    return tokens[p] instanceof css.StringToken;
  }

  function isNumber(p = pos) {
    return tokens[p] instanceof css.NumberToken;
  }

  function isComma(p = pos) {
    return tokens[p] instanceof css.CommaToken;
  }

  function isCloseParen(p = pos) {
    return tokens[p] instanceof css.CloseParenToken;
  }

  function isStar(p = pos) {
    return tokens[p] instanceof css.DelimToken && tokens[p].value === '*';
  }

  function isEOF(p = pos) {
    return tokens[p] instanceof css.EOFToken;
  }

  function isClauseCombinator(p = pos) {
    return tokens[p] instanceof css.DelimToken && ['>', '+', '~'].includes(tokens[p].value);
  }

  function isSelectorClauseEnd(p = pos) {
    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;
  }

  function consumeFunctionArguments() {
    const result = [consumeArgument()];

    while (true) {
      skipWhitespace();
      if (!isComma()) break;
      pos++;
      result.push(consumeArgument());
    }

    return result;
  }

  function consumeArgument() {
    skipWhitespace();
    if (isNumber()) return tokens[pos++].value;
    if (isString()) return tokens[pos++].value;
    return consumeComplexSelector();
  }

  function consumeComplexSelector() {
    const result = {
      simples: []
    };
    skipWhitespace();

    if (isClauseCombinator()) {
      // Put implicit ":scope" at the start. https://drafts.csswg.org/selectors-4/#absolutize
      result.simples.push({
        selector: {
          functions: [{
            name: 'scope',
            args: []
          }]
        },
        combinator: ''
      });
    } else {
      result.simples.push({
        selector: consumeSimpleSelector(),
        combinator: ''
      });
    }

    while (true) {
      skipWhitespace();

      if (isClauseCombinator()) {
        result.simples[result.simples.length - 1].combinator = tokens[pos++].value;
        skipWhitespace();
      } else if (isSelectorClauseEnd()) {
        break;
      }

      result.simples.push({
        combinator: '',
        selector: consumeSimpleSelector()
      });
    }

    return result;
  }

  function consumeSimpleSelector() {
    let rawCSSString = '';
    const functions = [];

    while (!isSelectorClauseEnd()) {
      if (isIdent() || isStar()) {
        rawCSSString += tokens[pos++].toSource();
      } else if (tokens[pos] instanceof css.HashToken) {
        rawCSSString += tokens[pos++].toSource();
      } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === '.') {
        pos++;
        if (isIdent()) rawCSSString += '.' + tokens[pos++].toSource();else throw unexpected();
      } else if (tokens[pos] instanceof css.ColonToken) {
        pos++;

        if (isIdent()) {
          if (!customNames.has(tokens[pos].value.toLowerCase())) {
            rawCSSString += ':' + tokens[pos++].toSource();
          } else {
            const name = tokens[pos++].value.toLowerCase();
            functions.push({
              name,
              args: []
            });
            names.add(name);
          }
        } else if (tokens[pos] instanceof css.FunctionToken) {
          const name = tokens[pos++].value.toLowerCase();

          if (!customNames.has(name)) {
            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
          } else {
            functions.push({
              name,
              args: consumeFunctionArguments()
            });
            names.add(name);
          }

          skipWhitespace();
          if (!isCloseParen()) throw unexpected();
          pos++;
        } else {
          throw unexpected();
        }
      } else if (tokens[pos] instanceof css.OpenSquareToken) {
        rawCSSString += '[';
        pos++;

        while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF()) rawCSSString += tokens[pos++].toSource();

        if (!(tokens[pos] instanceof css.CloseSquareToken)) throw unexpected();
        rawCSSString += ']';
        pos++;
      } else {
        throw unexpected();
      }
    }

    if (!rawCSSString && !functions.length) throw unexpected();
    return {
      css: rawCSSString || undefined,
      functions
    };
  }

  function consumeBuiltinFunctionArguments() {
    let s = '';

    while (!isCloseParen() && !isEOF()) s += tokens[pos++].toSource();

    return s;
  }

  const result = consumeFunctionArguments();
  if (!isEOF()) throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);
  if (result.some(arg => typeof arg !== 'object' || !('simples' in arg))) throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);
  return {
    selector: result,
    names: Array.from(names)
  };
}

function serializeSelector(args) {
  return args.map(arg => {
    if (typeof arg === 'string') return `"${arg}"`;
    if (typeof arg === 'number') return String(arg);
    return arg.simples.map(({
      selector,
      combinator
    }) => {
      let s = selector.css || '';
      s = s + selector.functions.map(func => `:${func.name}(${serializeSelector(func.args)})`).join('');
      if (combinator) s += ' ' + combinator;
      return s;
    }).join(' ');
  }).join(', ');
}

/***/ }),

/***/ 6172:
/***/ ((__unused_webpack_module, exports) => {

/*
 * Original at https://github.com/tabatkins/parse-css
 * licensed under http://creativecommons.org/publicdomain/zero/1.0/
 *
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Changes from https://github.com/tabatkins/parse-css
//   - Tabs are replaced with two spaces.
//   - Universal Module Definition wrapper is removed.
//   - Everything not related to tokenizing - below the first exports block - is removed.

// @ts-nocheck


var between = function (num, first, last) { return num >= first && num <= last; }
function digit(code) { return between(code, 0x30,0x39); }
function hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }
function uppercaseletter(code) { return between(code, 0x41,0x5a); }
function lowercaseletter(code) { return between(code, 0x61,0x7a); }
function letter(code) { return uppercaseletter(code) || lowercaseletter(code); }
function nonascii(code) { return code >= 0x80; }
function namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }
function namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }
function nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }
function newline(code) { return code == 0xa; }
function whitespace(code) { return newline(code) || code == 9 || code == 0x20; }
function badescape(code) { return newline(code) || isNaN(code); }

var maximumallowedcodepoint = 0x10ffff;

var InvalidCharacterError = function(message) {
  this.message = message;
};
InvalidCharacterError.prototype = new Error;
InvalidCharacterError.prototype.name = 'InvalidCharacterError';

function preprocess(str) {
  // Turn a string into an array of code points,
  // following the preprocessing cleanup rules.
  var codepoints = [];
  for(var i = 0; i < str.length; i++) {
    var code = str.charCodeAt(i);
    if(code == 0xd && str.charCodeAt(i+1) == 0xa) {
      code = 0xa; i++;
    }
    if(code == 0xd || code == 0xc) code = 0xa;
    if(code == 0x0) code = 0xfffd;
    if(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {
      // Decode a surrogate pair into an astral codepoint.
      var lead = code - 0xd800;
      var trail = str.charCodeAt(i+1) - 0xdc00;
      code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
      i++;
    }
    codepoints.push(code);
  }
  return codepoints;
}

function stringFromCode(code) {
  if(code <= 0xffff) return String.fromCharCode(code);
  // Otherwise, encode astral char as surrogate pair.
  code -= Math.pow(2, 16);
  var lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;
  var trail = code % Math.pow(2, 10) + 0xdc00;
  return String.fromCharCode(lead) + String.fromCharCode(trail);
}

function tokenize(str) {
  str = preprocess(str);
  var i = -1;
  var tokens = [];
  var code;

  // Line number information.
  var line = 0;
  var column = 0;
  // The only use of lastLineLength is in reconsume().
  var lastLineLength = 0;
  var incrLineno = function() {
    line += 1;
    lastLineLength = column;
    column = 0;
  };
  var locStart = {line:line, column:column};

  var codepoint = function(i) {
    if(i >= str.length) {
      return -1;
    }
    return str[i];
  }
  var next = function(num) {
    if(num === undefined)
      num = 1;
    if(num > 3)
      throw "Spec Error: no more than three codepoints of lookahead.";
    return codepoint(i+num);
  };
  var consume = function(num) {
    if(num === undefined)
      num = 1;
    i += num;
    code = codepoint(i);
    if(newline(code)) incrLineno();
    else column += num;
    //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));
    return true;
  };
  var reconsume = function() {
    i -= 1;
    if (newline(code)) {
      line -= 1;
      column = lastLineLength;
    } else {
      column -= 1;
    }
    locStart.line = line;
    locStart.column = column;
    return true;
  };
  var eof = function(codepoint) {
    if(codepoint === undefined) codepoint = code;
    return codepoint == -1;
  };
  var donothing = function() {};
  var parseerror = function() { console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");return true; };

  var consumeAToken = function() {
    consumeComments();
    consume();
    if(whitespace(code)) {
      while(whitespace(next())) consume();
      return new WhitespaceToken;
    }
    else if(code == 0x22) return consumeAStringToken();
    else if(code == 0x23) {
      if(namechar(next()) || areAValidEscape(next(1), next(2))) {
        var token = new HashToken();
        if(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = "id";
        token.value = consumeAName();
        return token;
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x24) {
      if(next() == 0x3d) {
        consume();
        return new SuffixMatchToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x27) return consumeAStringToken();
    else if(code == 0x28) return new OpenParenToken();
    else if(code == 0x29) return new CloseParenToken();
    else if(code == 0x2a) {
      if(next() == 0x3d) {
        consume();
        return new SubstringMatchToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x2b) {
      if(startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x2c) return new CommaToken();
    else if(code == 0x2d) {
      if(startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else if(next(1) == 0x2d && next(2) == 0x3e) {
        consume(2);
        return new CDCToken();
      } else if(startsWithAnIdentifier()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x2e) {
      if(startsWithANumber()) {
        reconsume();
        return consumeANumericToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x3a) return new ColonToken;
    else if(code == 0x3b) return new SemicolonToken;
    else if(code == 0x3c) {
      if(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {
        consume(3);
        return new CDOToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x40) {
      if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
        return new AtKeywordToken(consumeAName());
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x5b) return new OpenSquareToken();
    else if(code == 0x5c) {
      if(startsWithAValidEscape()) {
        reconsume();
        return consumeAnIdentlikeToken();
      } else {
        parseerror();
        return new DelimToken(code);
      }
    }
    else if(code == 0x5d) return new CloseSquareToken();
    else if(code == 0x5e) {
      if(next() == 0x3d) {
        consume();
        return new PrefixMatchToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x7b) return new OpenCurlyToken();
    else if(code == 0x7c) {
      if(next() == 0x3d) {
        consume();
        return new DashMatchToken();
      } else if(next() == 0x7c) {
        consume();
        return new ColumnToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(code == 0x7d) return new CloseCurlyToken();
    else if(code == 0x7e) {
      if(next() == 0x3d) {
        consume();
        return new IncludeMatchToken();
      } else {
        return new DelimToken(code);
      }
    }
    else if(digit(code)) {
      reconsume();
      return consumeANumericToken();
    }
    else if(namestartchar(code)) {
      reconsume();
      return consumeAnIdentlikeToken();
    }
    else if(eof()) return new EOFToken();
    else return new DelimToken(code);
  };

  var consumeComments = function() {
    while(next(1) == 0x2f && next(2) == 0x2a) {
      consume(2);
      while(true) {
        consume();
        if(code == 0x2a && next() == 0x2f) {
          consume();
          break;
        } else if(eof()) {
          parseerror();
          return;
        }
      }
    }
  };

  var consumeANumericToken = function() {
    var num = consumeANumber();
    if(wouldStartAnIdentifier(next(1), next(2), next(3))) {
      var token = new DimensionToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      token.unit = consumeAName();
      return token;
    } else if(next() == 0x25) {
      consume();
      var token = new PercentageToken();
      token.value = num.value;
      token.repr = num.repr;
      return token;
    } else {
      var token = new NumberToken();
      token.value = num.value;
      token.repr = num.repr;
      token.type = num.type;
      return token;
    }
  };

  var consumeAnIdentlikeToken = function() {
    var str = consumeAName();
    if(str.toLowerCase() == "url" && next() == 0x28) {
      consume();
      while(whitespace(next(1)) && whitespace(next(2))) consume();
      if(next() == 0x22 || next() == 0x27) {
        return new FunctionToken(str);
      } else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {
        return new FunctionToken(str);
      } else {
        return consumeAURLToken();
      }
    } else if(next() == 0x28) {
      consume();
      return new FunctionToken(str);
    } else {
      return new IdentToken(str);
    }
  };

  var consumeAStringToken = function(endingCodePoint) {
    if(endingCodePoint === undefined) endingCodePoint = code;
    var string = "";
    while(consume()) {
      if(code == endingCodePoint || eof()) {
        return new StringToken(string);
      } else if(newline(code)) {
        parseerror();
        reconsume();
        return new BadStringToken();
      } else if(code == 0x5c) {
        if(eof(next())) {
          donothing();
        } else if(newline(next())) {
          consume();
        } else {
          string += stringFromCode(consumeEscape())
        }
      } else {
        string += stringFromCode(code);
      }
    }
  };

  var consumeAURLToken = function() {
    var token = new URLToken("");
    while(whitespace(next())) consume();
    if(eof(next())) return token;
    while(consume()) {
      if(code == 0x29 || eof()) {
        return token;
      } else if(whitespace(code)) {
        while(whitespace(next())) consume();
        if(next() == 0x29 || eof(next())) {
          consume();
          return token;
        } else {
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {
        parseerror();
        consumeTheRemnantsOfABadURL();
        return new BadURLToken();
      } else if(code == 0x5c) {
        if(startsWithAValidEscape()) {
          token.value += stringFromCode(consumeEscape());
        } else {
          parseerror();
          consumeTheRemnantsOfABadURL();
          return new BadURLToken();
        }
      } else {
        token.value += stringFromCode(code);
      }
    }
  };

  var consumeEscape = function() {
    // Assume the the current character is the \
    // and the next code point is not a newline.
    consume();
    if(hexdigit(code)) {
      // Consume 1-6 hex digits
      var digits = [code];
      for(var total = 0; total < 5; total++) {
        if(hexdigit(next())) {
          consume();
          digits.push(code);
        } else {
          break;
        }
      }
      if(whitespace(next())) consume();
      var value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);
      if( value > maximumallowedcodepoint ) value = 0xfffd;
      return value;
    } else if(eof()) {
      return 0xfffd;
    } else {
      return code;
    }
  };

  var areAValidEscape = function(c1, c2) {
    if(c1 != 0x5c) return false;
    if(newline(c2)) return false;
    return true;
  };
  var startsWithAValidEscape = function() {
    return areAValidEscape(code, next());
  };

  var wouldStartAnIdentifier = function(c1, c2, c3) {
    if(c1 == 0x2d) {
      return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);
    } else if(namestartchar(c1)) {
      return true;
    } else if(c1 == 0x5c) {
      return areAValidEscape(c1, c2);
    } else {
      return false;
    }
  };
  var startsWithAnIdentifier = function() {
    return wouldStartAnIdentifier(code, next(1), next(2));
  };

  var wouldStartANumber = function(c1, c2, c3) {
    if(c1 == 0x2b || c1 == 0x2d) {
      if(digit(c2)) return true;
      if(c2 == 0x2e && digit(c3)) return true;
      return false;
    } else if(c1 == 0x2e) {
      if(digit(c2)) return true;
      return false;
    } else if(digit(c1)) {
      return true;
    } else {
      return false;
    }
  };
  var startsWithANumber = function() {
    return wouldStartANumber(code, next(1), next(2));
  };

  var consumeAName = function() {
    var result = "";
    while(consume()) {
      if(namechar(code)) {
        result += stringFromCode(code);
      } else if(startsWithAValidEscape()) {
        result += stringFromCode(consumeEscape());
      } else {
        reconsume();
        return result;
      }
    }
  };

  var consumeANumber = function() {
    var repr = [];
    var type = "integer";
    if(next() == 0x2b || next() == 0x2d) {
      consume();
      repr += stringFromCode(code);
    }
    while(digit(next())) {
      consume();
      repr += stringFromCode(code);
    }
    if(next(1) == 0x2e && digit(next(2))) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type = "number";
      while(digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    var c1 = next(1), c2 = next(2), c3 = next(3);
    if((c1 == 0x45 || c1 == 0x65) && digit(c2)) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type = "number";
      while(digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    } else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      consume();
      repr += stringFromCode(code);
      type = "number";
      while(digit(next())) {
        consume();
        repr += stringFromCode(code);
      }
    }
    var value = convertAStringToANumber(repr);
    return {type:type, value:value, repr:repr};
  };

  var convertAStringToANumber = function(string) {
    // CSS's number rules are identical to JS, afaik.
    return +string;
  };

  var consumeTheRemnantsOfABadURL = function() {
    while(consume()) {
      if(code == 0x29 || eof()) {
        return;
      } else if(startsWithAValidEscape()) {
        consumeEscape();
        donothing();
      } else {
        donothing();
      }
    }
  };



  var iterationCount = 0;
  while(!eof(next())) {
    tokens.push(consumeAToken());
    iterationCount++;
    if(iterationCount > str.length*2) return "I'm infinite-looping!";
  }
  return tokens;
}

function CSSParserToken() { throw "Abstract Base Class"; }
CSSParserToken.prototype.toJSON = function() {
  return {token: this.tokenType};
}
CSSParserToken.prototype.toString = function() { return this.tokenType; }
CSSParserToken.prototype.toSource = function() { return ''+this; }

function BadStringToken() { return this; }
BadStringToken.prototype = Object.create(CSSParserToken.prototype);
BadStringToken.prototype.tokenType = "BADSTRING";

function BadURLToken() { return this; }
BadURLToken.prototype = Object.create(CSSParserToken.prototype);
BadURLToken.prototype.tokenType = "BADURL";

function WhitespaceToken() { return this; }
WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
WhitespaceToken.prototype.tokenType = "WHITESPACE";
WhitespaceToken.prototype.toString = function() { return "WS"; }
WhitespaceToken.prototype.toSource = function() { return " "; }

function CDOToken() { return this; }
CDOToken.prototype = Object.create(CSSParserToken.prototype);
CDOToken.prototype.tokenType = "CDO";
CDOToken.prototype.toSource = function() { return "<!--"; }

function CDCToken() { return this; }
CDCToken.prototype = Object.create(CSSParserToken.prototype);
CDCToken.prototype.tokenType = "CDC";
CDCToken.prototype.toSource = function() { return "-->"; }

function ColonToken() { return this; }
ColonToken.prototype = Object.create(CSSParserToken.prototype);
ColonToken.prototype.tokenType = ":";

function SemicolonToken() { return this; }
SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
SemicolonToken.prototype.tokenType = ";";

function CommaToken() { return this; }
CommaToken.prototype = Object.create(CSSParserToken.prototype);
CommaToken.prototype.tokenType = ",";

function GroupingToken() { throw "Abstract Base Class"; }
GroupingToken.prototype = Object.create(CSSParserToken.prototype);

function OpenCurlyToken() { this.value = "{"; this.mirror = "}"; return this; }
OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
OpenCurlyToken.prototype.tokenType = "{";

function CloseCurlyToken() { this.value = "}"; this.mirror = "{"; return this; }
CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
CloseCurlyToken.prototype.tokenType = "}";

function OpenSquareToken() { this.value = "["; this.mirror = "]"; return this; }
OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
OpenSquareToken.prototype.tokenType = "[";

function CloseSquareToken() { this.value = "]"; this.mirror = "["; return this; }
CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
CloseSquareToken.prototype.tokenType = "]";

function OpenParenToken() { this.value = "("; this.mirror = ")"; return this; }
OpenParenToken.prototype = Object.create(GroupingToken.prototype);
OpenParenToken.prototype.tokenType = "(";

function CloseParenToken() { this.value = ")"; this.mirror = "("; return this; }
CloseParenToken.prototype = Object.create(GroupingToken.prototype);
CloseParenToken.prototype.tokenType = ")";

function IncludeMatchToken() { return this; }
IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
IncludeMatchToken.prototype.tokenType = "~=";

function DashMatchToken() { return this; }
DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
DashMatchToken.prototype.tokenType = "|=";

function PrefixMatchToken() { return this; }
PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
PrefixMatchToken.prototype.tokenType = "^=";

function SuffixMatchToken() { return this; }
SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
SuffixMatchToken.prototype.tokenType = "$=";

function SubstringMatchToken() { return this; }
SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
SubstringMatchToken.prototype.tokenType = "*=";

function ColumnToken() { return this; }
ColumnToken.prototype = Object.create(CSSParserToken.prototype);
ColumnToken.prototype.tokenType = "||";

function EOFToken() { return this; }
EOFToken.prototype = Object.create(CSSParserToken.prototype);
EOFToken.prototype.tokenType = "EOF";
EOFToken.prototype.toSource = function() { return ""; }

function DelimToken(code) {
  this.value = stringFromCode(code);
  return this;
}
DelimToken.prototype = Object.create(CSSParserToken.prototype);
DelimToken.prototype.tokenType = "DELIM";
DelimToken.prototype.toString = function() { return "DELIM("+this.value+")"; }
DelimToken.prototype.toJSON = function() {
  var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
  json.value = this.value;
  return json;
}
DelimToken.prototype.toSource = function() {
  if(this.value == "\\")
    return "\\\n";
  else
    return this.value;
}

function StringValuedToken() { throw "Abstract Base Class"; }
StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
StringValuedToken.prototype.ASCIIMatch = function(str) {
  return this.value.toLowerCase() == str.toLowerCase();
}
StringValuedToken.prototype.toJSON = function() {
  var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
  json.value = this.value;
  return json;
}

function IdentToken(val) {
  this.value = val;
}
IdentToken.prototype = Object.create(StringValuedToken.prototype);
IdentToken.prototype.tokenType = "IDENT";
IdentToken.prototype.toString = function() { return "IDENT("+this.value+")"; }
IdentToken.prototype.toSource = function() {
  return escapeIdent(this.value);
}

function FunctionToken(val) {
  this.value = val;
  this.mirror = ")";
}
FunctionToken.prototype = Object.create(StringValuedToken.prototype);
FunctionToken.prototype.tokenType = "FUNCTION";
FunctionToken.prototype.toString = function() { return "FUNCTION("+this.value+")"; }
FunctionToken.prototype.toSource = function() {
  return escapeIdent(this.value) + "(";
}

function AtKeywordToken(val) {
  this.value = val;
}
AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
AtKeywordToken.prototype.toString = function() { return "AT("+this.value+")"; }
AtKeywordToken.prototype.toSource = function() {
  return "@" + escapeIdent(this.value);
}

function HashToken(val) {
  this.value = val;
  this.type = "unrestricted";
}
HashToken.prototype = Object.create(StringValuedToken.prototype);
HashToken.prototype.tokenType = "HASH";
HashToken.prototype.toString = function() { return "HASH("+this.value+")"; }
HashToken.prototype.toJSON = function() {
  var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
  json.value = this.value;
  json.type = this.type;
  return json;
}
HashToken.prototype.toSource = function() {
  if(this.type == "id") {
    return "#" + escapeIdent(this.value);
  } else {
    return "#" + escapeHash(this.value);
  }
}

function StringToken(val) {
  this.value = val;
}
StringToken.prototype = Object.create(StringValuedToken.prototype);
StringToken.prototype.tokenType = "STRING";
StringToken.prototype.toString = function() {
  return '"' + escapeString(this.value) + '"';
}

function URLToken(val) {
  this.value = val;
}
URLToken.prototype = Object.create(StringValuedToken.prototype);
URLToken.prototype.tokenType = "URL";
URLToken.prototype.toString = function() { return "URL("+this.value+")"; }
URLToken.prototype.toSource = function() {
  return 'url("' + escapeString(this.value) + '")';
}

function NumberToken() {
  this.value = null;
  this.type = "integer";
  this.repr = "";
}
NumberToken.prototype = Object.create(CSSParserToken.prototype);
NumberToken.prototype.tokenType = "NUMBER";
NumberToken.prototype.toString = function() {
  if(this.type == "integer")
    return "INT("+this.value+")";
  return "NUMBER("+this.value+")";
}
NumberToken.prototype.toJSON = function() {
  var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
  json.value = this.value;
  json.type = this.type;
  json.repr = this.repr;
  return json;
}
NumberToken.prototype.toSource = function() { return this.repr; };

function PercentageToken() {
  this.value = null;
  this.repr = "";
}
PercentageToken.prototype = Object.create(CSSParserToken.prototype);
PercentageToken.prototype.tokenType = "PERCENTAGE";
PercentageToken.prototype.toString = function() { return "PERCENTAGE("+this.value+")"; }
PercentageToken.prototype.toJSON = function() {
  var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
  json.value = this.value;
  json.repr = this.repr;
  return json;
}
PercentageToken.prototype.toSource = function() { return this.repr + "%"; }

function DimensionToken() {
  this.value = null;
  this.type = "integer";
  this.repr = "";
  this.unit = "";
}
DimensionToken.prototype = Object.create(CSSParserToken.prototype);
DimensionToken.prototype.tokenType = "DIMENSION";
DimensionToken.prototype.toString = function() { return "DIM("+this.value+","+this.unit+")"; }
DimensionToken.prototype.toJSON = function() {
  var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
  json.value = this.value;
  json.type = this.type;
  json.repr = this.repr;
  json.unit = this.unit;
  return json;
}
DimensionToken.prototype.toSource = function() {
  var source = this.repr;
  var unit = escapeIdent(this.unit);
  if(unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 0x30, 0x39))) {
    // Unit is ambiguous with scinot
    // Remove the leading "e", replace with escape.
    unit = "\\65 " + unit.slice(1, unit.length);
  }
  return source+unit;
}

function escapeIdent(string) {
  string = ''+string;
  var result = '';
  var firstcode = string.charCodeAt(0);
  for(var i = 0; i < string.length; i++) {
    var code = string.charCodeAt(i);
    if(code == 0x0) {
      throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
    }

    if(
      between(code, 0x1, 0x1f) || code == 0x7f ||
      (i == 0 && between(code, 0x30, 0x39)) ||
      (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)
    ) {
      result += '\\' + code.toString(16) + ' ';
    } else if(
      code >= 0x80 ||
      code == 0x2d ||
      code == 0x5f ||
      between(code, 0x30, 0x39) ||
      between(code, 0x41, 0x5a) ||
      between(code, 0x61, 0x7a)
    ) {
      result += string[i];
    } else {
      result += '\\' + string[i];
    }
  }
  return result;
}

function escapeHash(string) {
  // Escapes the contents of "unrestricted"-type hash tokens.
  // Won't preserve the ID-ness of "id"-type hash tokens;
  // use escapeIdent() for that.
  string = ''+string;
  var result = '';
  var firstcode = string.charCodeAt(0);
  for(var i = 0; i < string.length; i++) {
    var code = string.charCodeAt(i);
    if(code == 0x0) {
      throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
    }

    if(
      code >= 0x80 ||
      code == 0x2d ||
      code == 0x5f ||
      between(code, 0x30, 0x39) ||
      between(code, 0x41, 0x5a) ||
      between(code, 0x61, 0x7a)
    ) {
      result += string[i];
    } else {
      result += '\\' + code.toString(16) + ' ';
    }
  }
  return result;
}

function escapeString(string) {
  string = ''+string;
  var result = '';
  for(var i = 0; i < string.length; i++) {
    var code = string.charCodeAt(i);

    if(code == 0x0) {
      throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
    }

    if(between(code, 0x1, 0x1f) || code == 0x7f) {
      result += '\\' + code.toString(16) + ' ';
    } else if(code == 0x22 || code == 0x5c) {
      result += '\\' + string[i];
    } else {
      result += string[i];
    }
  }
  return result;
}

// Exportation.
exports.tokenize = tokenize;
exports.IdentToken = IdentToken;
exports.FunctionToken = FunctionToken;
exports.AtKeywordToken = AtKeywordToken;
exports.HashToken = HashToken;
exports.StringToken = StringToken;
exports.BadStringToken = BadStringToken;
exports.URLToken = URLToken;
exports.BadURLToken = BadURLToken;
exports.DelimToken = DelimToken;
exports.NumberToken = NumberToken;
exports.PercentageToken = PercentageToken;
exports.DimensionToken = DimensionToken;
exports.IncludeMatchToken = IncludeMatchToken;
exports.DashMatchToken = DashMatchToken;
exports.PrefixMatchToken = PrefixMatchToken;
exports.SuffixMatchToken = SuffixMatchToken;
exports.SubstringMatchToken = SubstringMatchToken;
exports.ColumnToken = ColumnToken;
exports.WhitespaceToken = WhitespaceToken;
exports.CDOToken = CDOToken;
exports.CDCToken = CDCToken;
exports.ColonToken = ColonToken;
exports.SemicolonToken = SemicolonToken;
exports.CommaToken = CommaToken;
exports.OpenParenToken = OpenParenToken;
exports.CloseParenToken = CloseParenToken;
exports.OpenSquareToken = OpenSquareToken;
exports.CloseSquareToken = CloseSquareToken;
exports.OpenCurlyToken = OpenCurlyToken;
exports.CloseCurlyToken = CloseCurlyToken;
exports.EOFToken = EOFToken;
exports.CSSParserToken = CSSParserToken;
exports.GroupingToken = GroupingToken;



/***/ }),

/***/ 377:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "InvalidSelectorError", ({
  enumerable: true,
  get: function () {
    return _cssParser.InvalidSelectorError;
  }
}));
exports.allEngineNames = allEngineNames;
exports.customCSSNames = void 0;
Object.defineProperty(exports, "isInvalidSelectorError", ({
  enumerable: true,
  get: function () {
    return _cssParser.isInvalidSelectorError;
  }
}));
exports.parseAttributeSelector = parseAttributeSelector;
exports.parseSelector = parseSelector;
exports.splitSelectorByFrame = splitSelectorByFrame;
exports.stringifySelector = stringifySelector;

var _cssParser = __nccwpck_require__(3706);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kNestedSelectorNames = new Set(['has', 'left-of', 'right-of', 'above', 'below', 'near']);
const kNestedSelectorNamesWithDistance = new Set(['left-of', 'right-of', 'above', 'below', 'near']);
const customCSSNames = new Set(['not', 'is', 'where', 'has', 'scope', 'light', 'visible', 'text', 'text-matches', 'text-is', 'has-text', 'above', 'below', 'right-of', 'left-of', 'near', 'nth-match']);
exports.customCSSNames = customCSSNames;

function parseSelector(selector) {
  const result = parseSelectorString(selector);
  const parts = result.parts.map(part => {
    if (part.name === 'css' || part.name === 'css:light') {
      if (part.name === 'css:light') part.body = ':light(' + part.body + ')';
      const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);
      return {
        name: 'css',
        body: parsedCSS.selector,
        source: part.body
      };
    }

    if (kNestedSelectorNames.has(part.name)) {
      let innerSelector;
      let distance;

      try {
        const unescaped = JSON.parse('[' + part.body + ']');
        if (!Array.isArray(unescaped) || unescaped.length < 1 || unescaped.length > 2 || typeof unescaped[0] !== 'string') throw new Error(`Malformed selector: ${part.name}=` + part.body);
        innerSelector = unescaped[0];

        if (unescaped.length === 2) {
          if (typeof unescaped[1] !== 'number' || !kNestedSelectorNamesWithDistance.has(part.name)) throw new Error(`Malformed selector: ${part.name}=` + part.body);
          distance = unescaped[1];
        }
      } catch (e) {
        throw new Error(`Malformed selector: ${part.name}=` + part.body);
      }

      const result = {
        name: part.name,
        source: part.body,
        body: {
          parsed: parseSelector(innerSelector),
          distance
        }
      };
      if (result.body.parsed.parts.some(part => part.name === 'control' && part.body === 'enter-frame')) throw new Error(`Frames are not allowed inside "${part.name}" selectors`);
      return result;
    }

    return { ...part,
      source: part.body
    };
  });
  if (kNestedSelectorNames.has(parts[0].name)) throw new Error(`"${parts[0].name}" selector cannot be first`);
  return {
    capture: result.capture,
    parts
  };
}

function splitSelectorByFrame(selectorText) {
  const selector = parseSelector(selectorText);
  const result = [];
  let chunk = {
    parts: []
  };
  let chunkStartIndex = 0;

  for (let i = 0; i < selector.parts.length; ++i) {
    const part = selector.parts[i];

    if (part.name === 'control' && part.body === 'enter-frame') {
      if (!chunk.parts.length) throw new _cssParser.InvalidSelectorError('Selector cannot start with entering frame, select the iframe first');
      result.push(chunk);
      chunk = {
        parts: []
      };
      chunkStartIndex = i + 1;
      continue;
    }

    if (selector.capture === i) chunk.capture = i - chunkStartIndex;
    chunk.parts.push(part);
  }

  if (!chunk.parts.length) throw new _cssParser.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
  result.push(chunk);
  if (typeof selector.capture === 'number' && typeof result[result.length - 1].capture !== 'number') throw new _cssParser.InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
  return result;
}

function stringifySelector(selector) {
  if (typeof selector === 'string') return selector;
  return selector.parts.map((p, i) => {
    const prefix = p.name === 'css' ? '' : p.name + '=';
    return `${i === selector.capture ? '*' : ''}${prefix}${p.source}`;
  }).join(' >> ');
}

function allEngineNames(selector) {
  const result = new Set();

  const visit = selector => {
    for (const part of selector.parts) {
      result.add(part.name);
      if (kNestedSelectorNames.has(part.name)) visit(part.body.parsed);
    }
  };

  visit(selector);
  return result;
}

function parseSelectorString(selector) {
  let index = 0;
  let quote;
  let start = 0;
  const result = {
    parts: []
  };

  const append = () => {
    const part = selector.substring(start, index).trim();
    const eqIndex = part.indexOf('=');
    let name;
    let body;

    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
      name = part.substring(0, eqIndex).trim();
      body = part.substring(eqIndex + 1);
    } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
      name = 'text';
      body = part;
    } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
      name = 'text';
      body = part;
    } else if (/^\(*\/\//.test(part) || part.startsWith('..')) {
      // If selector starts with '//' or '//' prefixed with multiple opening
      // parenthesis, consider xpath. @see https://github.com/microsoft/playwright/issues/817
      // If selector starts with '..', consider xpath as well.
      name = 'xpath';
      body = part;
    } else {
      name = 'css';
      body = part;
    }

    let capture = false;

    if (name[0] === '*') {
      capture = true;
      name = name.substring(1);
    }

    result.parts.push({
      name,
      body
    });

    if (capture) {
      if (result.capture !== undefined) throw new _cssParser.InvalidSelectorError(`Only one of the selectors can capture using * modifier`);
      result.capture = result.parts.length - 1;
    }
  };

  if (!selector.includes('>>')) {
    index = selector.length;
    append();
    return result;
  }

  const shouldIgnoreTextSelectorQuote = () => {
    const prefix = selector.substring(start, index);
    const match = prefix.match(/^\s*text\s*=(.*)$/); // Must be a text selector with some text before the quote.

    return !!match && !!match[1];
  };

  while (index < selector.length) {
    const c = selector[index];

    if (c === '\\' && index + 1 < selector.length) {
      index += 2;
    } else if (c === quote) {
      quote = undefined;
      index++;
    } else if (!quote && (c === '"' || c === '\'' || c === '`') && !shouldIgnoreTextSelectorQuote()) {
      quote = c;
      index++;
    } else if (!quote && c === '>' && selector[index + 1] === '>') {
      append();
      index += 2;
      start = index;
    } else {
      index++;
    }
  }

  append();
  return result;
}

function parseAttributeSelector(selector, allowUnquotedStrings) {
  let wp = 0;
  let EOL = selector.length === 0;

  const next = () => selector[wp] || '';

  const eat1 = () => {
    const result = next();
    ++wp;
    EOL = wp >= selector.length;
    return result;
  };

  const syntaxError = stage => {
    if (EOL) throw new Error(`Unexpected end of selector while parsing selector \`${selector}\``);
    throw new Error(`Error while parsing selector \`${selector}\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? ' during ' + stage : ''));
  };

  function skipSpaces() {
    while (!EOL && /\s/.test(next())) eat1();
  }

  function isCSSNameChar(char) {
    // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    return char >= '\u0080' // non-ascii
    || char >= '\u0030' && char <= '\u0039' // digit
    || char >= '\u0041' && char <= '\u005a' // uppercase letter
    || char >= '\u0061' && char <= '\u007a' // lowercase letter
    || char >= '\u0030' && char <= '\u0039' // digit
    || char === '\u005f' // "_"
    || char === '\u002d'; // "-"
  }

  function readIdentifier() {
    let result = '';
    skipSpaces();

    while (!EOL && isCSSNameChar(next())) result += eat1();

    return result;
  }

  function readQuotedString(quote) {
    let result = eat1();
    if (result !== quote) syntaxError('parsing quoted string');

    while (!EOL && next() !== quote) {
      if (next() === '\\') eat1();
      result += eat1();
    }

    if (next() !== quote) syntaxError('parsing quoted string');
    result += eat1();
    return result;
  }

  function readRegularExpression() {
    if (eat1() !== '/') syntaxError('parsing regular expression');
    let source = '';
    let inClass = false; // https://262.ecma-international.org/11.0/#sec-literals-regular-expression-literals

    while (!EOL) {
      if (next() === '\\') {
        source += eat1();
        if (EOL) syntaxError('parsing regular expressiion');
      } else if (inClass && next() === ']') {
        inClass = false;
      } else if (!inClass && next() === '[') {
        inClass = true;
      } else if (!inClass && next() === '/') {
        break;
      }

      source += eat1();
    }

    if (eat1() !== '/') syntaxError('parsing regular expression');
    let flags = ''; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions

    while (!EOL && next().match(/[dgimsuy]/)) flags += eat1();

    try {
      return new RegExp(source, flags);
    } catch (e) {
      throw new Error(`Error while parsing selector \`${selector}\`: ${e.message}`);
    }
  }

  function readAttributeToken() {
    let token = '';
    skipSpaces();
    if (next() === `'` || next() === `"`) token = readQuotedString(next()).slice(1, -1);else token = readIdentifier();
    if (!token) syntaxError('parsing property path');
    return token;
  }

  function readOperator() {
    skipSpaces();
    let op = '';
    if (!EOL) op += eat1();
    if (!EOL && op !== '=') op += eat1();
    if (!['=', '*=', '^=', '$=', '|=', '~='].includes(op)) syntaxError('parsing operator');
    return op;
  }

  function readAttribute() {
    // skip leading [
    eat1(); // read attribute name:
    // foo.bar
    // 'foo'  . "ba zz"

    const jsonPath = [];
    jsonPath.push(readAttributeToken());
    skipSpaces();

    while (next() === '.') {
      eat1();
      jsonPath.push(readAttributeToken());
      skipSpaces();
    } // check property is truthy: [enabled]


    if (next() === ']') {
      eat1();
      return {
        name: jsonPath.join('.'),
        jsonPath,
        op: '<truthy>',
        value: null,
        caseSensitive: false
      };
    }

    const operator = readOperator();
    let value = undefined;
    let caseSensitive = true;
    skipSpaces();

    if (next() === '/') {
      if (operator !== '=') throw new Error(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with regular expression`);
      value = readRegularExpression();
    } else if (next() === `'` || next() === `"`) {
      value = readQuotedString(next()).slice(1, -1);
      skipSpaces();

      if (next() === 'i' || next() === 'I') {
        caseSensitive = false;
        eat1();
      } else if (next() === 's' || next() === 'S') {
        caseSensitive = true;
        eat1();
      }
    } else {
      value = '';

      while (!EOL && (isCSSNameChar(next()) || next() === '+' || next() === '.')) value += eat1();

      if (value === 'true') {
        value = true;
      } else if (value === 'false') {
        value = false;
      } else {
        if (!allowUnquotedStrings) {
          value = +value;
          if (Number.isNaN(value)) syntaxError('parsing attribute value');
        }
      }
    }

    skipSpaces();
    if (next() !== ']') syntaxError('parsing attribute value');
    eat1();
    if (operator !== '=' && typeof value !== 'string') throw new Error(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);
    return {
      name: jsonPath.join('.'),
      jsonPath,
      op: operator,
      value,
      caseSensitive
    };
  }

  const result = {
    name: '',
    attributes: []
  };
  result.name = readIdentifier();
  skipSpaces();

  while (next() === '[') {
    result.attributes.push(readAttribute());
    skipSpaces();
  }

  if (!EOL) syntaxError(undefined);
  if (!result.name && !result.attributes.length) throw new Error(`Error while parsing selector \`${selector}\` - selector cannot be empty`);
  return result;
}

/***/ }),

/***/ 9012:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.serializeAsCallArgument = exports.parseEvaluationResultValue = void 0;
exports.source = source;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function source() {
  function isRegExp(obj) {
    return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
  }

  function isDate(obj) {
    return obj instanceof Date || Object.prototype.toString.call(obj) === '[object Date]';
  }

  function isURL(obj) {
    return obj instanceof URL || Object.prototype.toString.call(obj) === '[object URL]';
  }

  function isError(obj) {
    try {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === 'Error';
    } catch (error) {
      return false;
    }
  }

  function parseEvaluationResultValue(value, handles = [], refs = new Map()) {
    if (Object.is(value, undefined)) return undefined;

    if (typeof value === 'object' && value) {
      if ('ref' in value) return refs.get(value.ref);

      if ('v' in value) {
        if (value.v === 'undefined') return undefined;
        if (value.v === 'null') return null;
        if (value.v === 'NaN') return NaN;
        if (value.v === 'Infinity') return Infinity;
        if (value.v === '-Infinity') return -Infinity;
        if (value.v === '-0') return -0;
        return undefined;
      }

      if ('d' in value) return new Date(value.d);
      if ('u' in value) return new URL(value.u);
      if ('r' in value) return new RegExp(value.r.p, value.r.f);

      if ('a' in value) {
        const result = [];
        refs.set(value.id, result);

        for (const a of value.a) result.push(parseEvaluationResultValue(a, handles, refs));

        return result;
      }

      if ('o' in value) {
        const result = {};
        refs.set(value.id, result);

        for (const {
          k,
          v
        } of value.o) result[k] = parseEvaluationResultValue(v, handles, refs);

        return result;
      }

      if ('h' in value) return handles[value.h];
    }

    return value;
  }

  function serializeAsCallArgument(value, handleSerializer) {
    return serialize(value, handleSerializer, {
      visited: new Map(),
      lastId: 0
    });
  }

  function serialize(value, handleSerializer, visitorInfo) {
    if (value && typeof value === 'object') {
      if (globalThis.Window && value instanceof globalThis.Window) return 'ref: <Window>';
      if (globalThis.Document && value instanceof globalThis.Document) return 'ref: <Document>';
      if (globalThis.Node && value instanceof globalThis.Node) return 'ref: <Node>';
    }

    return innerSerialize(value, handleSerializer, visitorInfo);
  }

  function innerSerialize(value, handleSerializer, visitorInfo) {
    const result = handleSerializer(value);
    if ('fallThrough' in result) value = result.fallThrough;else return result;
    if (typeof value === 'symbol') return {
      v: 'undefined'
    };
    if (Object.is(value, undefined)) return {
      v: 'undefined'
    };
    if (Object.is(value, null)) return {
      v: 'null'
    };
    if (Object.is(value, NaN)) return {
      v: 'NaN'
    };
    if (Object.is(value, Infinity)) return {
      v: 'Infinity'
    };
    if (Object.is(value, -Infinity)) return {
      v: '-Infinity'
    };
    if (Object.is(value, -0)) return {
      v: '-0'
    };
    if (typeof value === 'boolean') return value;
    if (typeof value === 'number') return value;
    if (typeof value === 'string') return value;

    if (isError(value)) {
      const error = value;

      if ('captureStackTrace' in globalThis.Error) {
        // v8
        return error.stack || '';
      }

      return `${error.name}: ${error.message}\n${error.stack}`;
    }

    if (isDate(value)) return {
      d: value.toJSON()
    };
    if (isURL(value)) return {
      u: value.toJSON()
    };
    if (isRegExp(value)) return {
      r: {
        p: value.source,
        f: value.flags
      }
    };
    const id = visitorInfo.visited.get(value);
    if (id) return {
      ref: id
    };

    if (Array.isArray(value)) {
      const a = [];
      const id = ++visitorInfo.lastId;
      visitorInfo.visited.set(value, id);

      for (let i = 0; i < value.length; ++i) a.push(serialize(value[i], handleSerializer, visitorInfo));

      return {
        a,
        id
      };
    }

    if (typeof value === 'object') {
      const o = [];
      const id = ++visitorInfo.lastId;
      visitorInfo.visited.set(value, id);

      for (const name of Object.keys(value)) {
        let item;

        try {
          item = value[name];
        } catch (e) {
          continue; // native bindings will throw sometimes
        }

        if (name === 'toJSON' && typeof item === 'function') o.push({
          k: name,
          v: {
            o: [],
            id: 0
          }
        });else o.push({
          k: name,
          v: serialize(item, handleSerializer, visitorInfo)
        });
      } // If Object.keys().length === 0 we fall back to toJSON if it exists


      if (o.length === 0 && value.toJSON && typeof value.toJSON === 'function') return innerSerialize(value.toJSON(), handleSerializer, visitorInfo);
      return {
        o,
        id
      };
    }
  }

  return {
    parseEvaluationResultValue,
    serializeAsCallArgument
  };
}

const result = source();
const parseEvaluationResultValue = result.parseEvaluationResultValue;
exports.parseEvaluationResultValue = parseEvaluationResultValue;
const serializeAsCallArgument = result.serializeAsCallArgument;
exports.serializeAsCallArgument = serializeAsCallArgument;

/***/ }),

/***/ 804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JavaScriptErrorInEvaluate = exports.JSHandle = exports.ExecutionContext = void 0;
exports.evaluate = evaluate;
exports.evaluateExpression = evaluateExpression;
exports.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;
exports.isJavaScriptErrorInEvaluate = isJavaScriptErrorInEvaluate;
exports.normalizeEvaluationExpression = normalizeEvaluationExpression;
exports.parseUnserializableValue = parseUnserializableValue;

var utilityScriptSource = _interopRequireWildcard(__nccwpck_require__(7186));

var _utilityScriptSerializers = __nccwpck_require__(9012);

var _instrumentation = __nccwpck_require__(6686);

var _manualPromise = __nccwpck_require__(6729);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExecutionContext extends _instrumentation.SdkObject {
  constructor(parent, delegate) {
    super(parent, 'execution-context');
    this._delegate = void 0;
    this._utilityScriptPromise = void 0;
    this._destroyedPromise = new _manualPromise.ManualPromise();
    this._delegate = delegate;
  }

  contextDestroyed(error) {
    this._destroyedPromise.resolve(error);
  }

  _raceAgainstContextDestroyed(promise) {
    return Promise.race([this._destroyedPromise.then(e => {
      throw e;
    }), promise]);
  }

  rawEvaluateJSON(expression) {
    return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateJSON(expression));
  }

  rawEvaluateHandle(expression) {
    return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(expression));
  }

  rawCallFunctionNoReply(func, ...args) {
    this._delegate.rawCallFunctionNoReply(func, ...args);
  }

  evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
    return this._raceAgainstContextDestroyed(this._delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds));
  }

  getProperties(context, objectId) {
    return this._raceAgainstContextDestroyed(this._delegate.getProperties(context, objectId));
  }

  createHandle(remoteObject) {
    return this._delegate.createHandle(this, remoteObject);
  }

  releaseHandle(objectId) {
    return this._delegate.releaseHandle(objectId);
  }

  async waitForSignalsCreatedBy(action) {
    return action();
  }

  adoptIfNeeded(handle) {
    return null;
  }

  utilityScript() {
    if (!this._utilityScriptPromise) {
      const source = `
      (() => {
        const module = {};
        ${utilityScriptSource.source}
        return new module.exports();
      })();`;
      this._utilityScriptPromise = this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(source).then(objectId => new JSHandle(this, 'object', undefined, objectId)));
    }

    return this._utilityScriptPromise;
  }

  async doSlowMo() {// overridden in FrameExecutionContext
  }

}

exports.ExecutionContext = ExecutionContext;

class JSHandle extends _instrumentation.SdkObject {
  constructor(context, type, preview, objectId, value) {
    super(context, 'handle');
    this._context = void 0;
    this._disposed = false;
    this._objectId = void 0;
    this._value = void 0;
    this._objectType = void 0;
    this._preview = void 0;
    this._previewCallback = void 0;
    this._context = context;
    this._objectId = objectId;
    this._value = value;
    this._objectType = type;
    this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
  }

  callFunctionNoReply(func, arg) {
    this._context.rawCallFunctionNoReply(func, this, arg);
  }

  async evaluate(pageFunction, arg) {
    return evaluate(this._context, true
    /* returnByValue */
    , pageFunction, this, arg);
  }

  async evaluateHandle(pageFunction, arg) {
    return evaluate(this._context, false
    /* returnByValue */
    , pageFunction, this, arg);
  }

  async evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {
    const value = await evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);
    await this._context.doSlowMo();
    return value;
  }

  async getProperty(propertyName) {
    const objectHandle = await this.evaluateHandle((object, propertyName) => {
      const result = {
        __proto__: null
      };
      result[propertyName] = object[propertyName];
      return result;
    }, propertyName);
    const properties = await objectHandle.getProperties();
    const result = properties.get(propertyName);
    objectHandle.dispose();
    return result;
  }

  async getProperties() {
    if (!this._objectId) return new Map();
    return this._context.getProperties(this._context, this._objectId);
  }

  rawValue() {
    return this._value;
  }

  async jsonValue() {
    if (!this._objectId) return this._value;
    const utilityScript = await this._context.utilityScript();
    const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
    return this._context.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
  }

  asElement() {
    return null;
  }

  dispose() {
    if (this._disposed) return;
    this._disposed = true;
    if (this._objectId) this._context.releaseHandle(this._objectId).catch(e => {});
  }

  toString() {
    return this._preview;
  }

  _setPreviewCallback(callback) {
    this._previewCallback = callback;
  }

  preview() {
    return this._preview;
  }

  _setPreview(preview) {
    this._preview = preview;
    if (this._previewCallback) this._previewCallback(preview);
  }

}

exports.JSHandle = JSHandle;

async function evaluate(context, returnByValue, pageFunction, ...args) {
  return evaluateExpression(context, returnByValue, String(pageFunction), typeof pageFunction === 'function', ...args);
}

async function evaluateExpression(context, returnByValue, expression, isFunction, ...args) {
  const utilityScript = await context.utilityScript();
  expression = normalizeEvaluationExpression(expression, isFunction);
  const handles = [];
  const toDispose = [];

  const pushHandle = handle => {
    handles.push(handle);
    return handles.length - 1;
  };

  args = args.map(arg => (0, _utilityScriptSerializers.serializeAsCallArgument)(arg, handle => {
    if (handle instanceof JSHandle) {
      if (!handle._objectId) return {
        fallThrough: handle._value
      };
      if (handle._disposed) throw new Error('JSHandle is disposed!');
      const adopted = context.adoptIfNeeded(handle);
      if (adopted === null) return {
        h: pushHandle(Promise.resolve(handle))
      };
      toDispose.push(adopted);
      return {
        h: pushHandle(adopted)
      };
    }

    return {
      fallThrough: handle
    };
  }));
  const utilityScriptObjectIds = [];

  for (const handle of await Promise.all(handles)) {
    if (handle._context !== context) throw new Error('JSHandles can be evaluated only in the context they were created!');
    utilityScriptObjectIds.push(handle._objectId);
  } // See UtilityScript for arguments.


  const utilityScriptValues = [isFunction, returnByValue, expression, args.length, ...args];
  const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;

  try {
    return await context.evaluateWithArguments(script, returnByValue, utilityScript, utilityScriptValues, utilityScriptObjectIds);
  } finally {
    toDispose.map(handlePromise => handlePromise.then(handle => handle.dispose()));
  }
}

async function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {
  return await context.waitForSignalsCreatedBy(() => evaluateExpression(context, returnByValue, expression, isFunction, ...args));
}

function parseUnserializableValue(unserializableValue) {
  if (unserializableValue === 'NaN') return NaN;
  if (unserializableValue === 'Infinity') return Infinity;
  if (unserializableValue === '-Infinity') return -Infinity;
  if (unserializableValue === '-0') return -0;
}

function normalizeEvaluationExpression(expression, isFunction) {
  expression = expression.trim();

  if (isFunction) {
    try {
      new Function('(' + expression + ')');
    } catch (e1) {
      // This means we might have a function shorthand. Try another
      // time prefixing 'function '.
      if (expression.startsWith('async ')) expression = 'async function ' + expression.substring('async '.length);else expression = 'function ' + expression;

      try {
        new Function('(' + expression + ')');
      } catch (e2) {
        // We tried hard to serialize, but there's a weird beast here.
        throw new Error('Passed function is not well-serializable!');
      }
    }
  }

  if (/^(async)?\s*function(\s|\()/.test(expression)) expression = '(' + expression + ')';
  return expression;
} // Error inside the expression evaluation as opposed to a protocol error.


class JavaScriptErrorInEvaluate extends Error {}

exports.JavaScriptErrorInEvaluate = JavaScriptErrorInEvaluate;

function isJavaScriptErrorInEvaluate(error) {
  return error instanceof JavaScriptErrorInEvaluate;
}

/***/ }),

/***/ 2310:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.macEditingCommands = void 0;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const macEditingCommands = {
  'Backspace': 'deleteBackward:',
  'Enter': 'insertNewline:',
  'NumpadEnter': 'insertNewline:',
  'Escape': 'cancelOperation:',
  'ArrowUp': 'moveUp:',
  'ArrowDown': 'moveDown:',
  'ArrowLeft': 'moveLeft:',
  'ArrowRight': 'moveRight:',
  'F5': 'complete:',
  'Delete': 'deleteForward:',
  'Home': 'scrollToBeginningOfDocument:',
  'End': 'scrollToEndOfDocument:',
  'PageUp': 'scrollPageUp:',
  'PageDown': 'scrollPageDown:',
  'Shift+Backspace': 'deleteBackward:',
  'Shift+Enter': 'insertNewline:',
  'Shift+NumpadEnter': 'insertNewline:',
  'Shift+Escape': 'cancelOperation:',
  'Shift+ArrowUp': 'moveUpAndModifySelection:',
  'Shift+ArrowDown': 'moveDownAndModifySelection:',
  'Shift+ArrowLeft': 'moveLeftAndModifySelection:',
  'Shift+ArrowRight': 'moveRightAndModifySelection:',
  'Shift+F5': 'complete:',
  'Shift+Delete': 'deleteForward:',
  'Shift+Home': 'moveToBeginningOfDocumentAndModifySelection:',
  'Shift+End': 'moveToEndOfDocumentAndModifySelection:',
  'Shift+PageUp': 'pageUpAndModifySelection:',
  'Shift+PageDown': 'pageDownAndModifySelection:',
  'Shift+Numpad5': 'delete:',
  'Control+Tab': 'selectNextKeyView:',
  'Control+Enter': 'insertLineBreak:',
  'Control+NumpadEnter': 'insertLineBreak:',
  'Control+Quote': 'insertSingleQuoteIgnoringSubstitution:',
  'Control+KeyA': 'moveToBeginningOfParagraph:',
  'Control+KeyB': 'moveBackward:',
  'Control+KeyD': 'deleteForward:',
  'Control+KeyE': 'moveToEndOfParagraph:',
  'Control+KeyF': 'moveForward:',
  'Control+KeyH': 'deleteBackward:',
  'Control+KeyK': 'deleteToEndOfParagraph:',
  'Control+KeyL': 'centerSelectionInVisibleArea:',
  'Control+KeyN': 'moveDown:',
  'Control+KeyO': ['insertNewlineIgnoringFieldEditor:', 'moveBackward:'],
  'Control+KeyP': 'moveUp:',
  'Control+KeyT': 'transpose:',
  'Control+KeyV': 'pageDown:',
  'Control+KeyY': 'yank:',
  'Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',
  'Control+ArrowUp': 'scrollPageUp:',
  'Control+ArrowDown': 'scrollPageDown:',
  'Control+ArrowLeft': 'moveToLeftEndOfLine:',
  'Control+ArrowRight': 'moveToRightEndOfLine:',
  'Shift+Control+Enter': 'insertLineBreak:',
  'Shift+Control+NumpadEnter': 'insertLineBreak:',
  'Shift+Control+Tab': 'selectPreviousKeyView:',
  'Shift+Control+Quote': 'insertDoubleQuoteIgnoringSubstitution:',
  'Shift+Control+KeyA': 'moveToBeginningOfParagraphAndModifySelection:',
  'Shift+Control+KeyB': 'moveBackwardAndModifySelection:',
  'Shift+Control+KeyE': 'moveToEndOfParagraphAndModifySelection:',
  'Shift+Control+KeyF': 'moveForwardAndModifySelection:',
  'Shift+Control+KeyN': 'moveDownAndModifySelection:',
  'Shift+Control+KeyP': 'moveUpAndModifySelection:',
  'Shift+Control+KeyV': 'pageDownAndModifySelection:',
  'Shift+Control+Backspace': 'deleteBackwardByDecomposingPreviousCharacter:',
  'Shift+Control+ArrowUp': 'scrollPageUp:',
  'Shift+Control+ArrowDown': 'scrollPageDown:',
  'Shift+Control+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',
  'Shift+Control+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',
  'Alt+Backspace': 'deleteWordBackward:',
  'Alt+Enter': 'insertNewlineIgnoringFieldEditor:',
  'Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',
  'Alt+Escape': 'complete:',
  'Alt+ArrowUp': ['moveBackward:', 'moveToBeginningOfParagraph:'],
  'Alt+ArrowDown': ['moveForward:', 'moveToEndOfParagraph:'],
  'Alt+ArrowLeft': 'moveWordLeft:',
  'Alt+ArrowRight': 'moveWordRight:',
  'Alt+Delete': 'deleteWordForward:',
  'Alt+PageUp': 'pageUp:',
  'Alt+PageDown': 'pageDown:',
  'Shift+Alt+Backspace': 'deleteWordBackward:',
  'Shift+Alt+Enter': 'insertNewlineIgnoringFieldEditor:',
  'Shift+Alt+NumpadEnter': 'insertNewlineIgnoringFieldEditor:',
  'Shift+Alt+Escape': 'complete:',
  'Shift+Alt+ArrowUp': 'moveParagraphBackwardAndModifySelection:',
  'Shift+Alt+ArrowDown': 'moveParagraphForwardAndModifySelection:',
  'Shift+Alt+ArrowLeft': 'moveWordLeftAndModifySelection:',
  'Shift+Alt+ArrowRight': 'moveWordRightAndModifySelection:',
  'Shift+Alt+Delete': 'deleteWordForward:',
  'Shift+Alt+PageUp': 'pageUp:',
  'Shift+Alt+PageDown': 'pageDown:',
  'Control+Alt+KeyB': 'moveWordBackward:',
  'Control+Alt+KeyF': 'moveWordForward:',
  'Control+Alt+Backspace': 'deleteWordBackward:',
  'Shift+Control+Alt+KeyB': 'moveWordBackwardAndModifySelection:',
  'Shift+Control+Alt+KeyF': 'moveWordForwardAndModifySelection:',
  'Shift+Control+Alt+Backspace': 'deleteWordBackward:',
  'Meta+NumpadSubtract': 'cancel:',
  'Meta+Backspace': 'deleteToBeginningOfLine:',
  'Meta+ArrowUp': 'moveToBeginningOfDocument:',
  'Meta+ArrowDown': 'moveToEndOfDocument:',
  'Meta+ArrowLeft': 'moveToLeftEndOfLine:',
  'Meta+ArrowRight': 'moveToRightEndOfLine:',
  'Shift+Meta+NumpadSubtract': 'cancel:',
  'Shift+Meta+Backspace': 'deleteToBeginningOfLine:',
  'Shift+Meta+ArrowUp': 'moveToBeginningOfDocumentAndModifySelection:',
  'Shift+Meta+ArrowDown': 'moveToEndOfDocumentAndModifySelection:',
  'Shift+Meta+ArrowLeft': 'moveToLeftEndOfLineAndModifySelection:',
  'Shift+Meta+ArrowRight': 'moveToRightEndOfLineAndModifySelection:',
  'Meta+KeyA': 'selectAll:',
  'Meta+KeyC': 'copy:',
  'Meta+KeyV': 'paste:',
  'Meta+KeyZ': 'undo:',
  'Shift+Meta+KeyZ': 'redo:'
};
exports.macEditingCommands = macEditingCommands;

/***/ }),

/***/ 3824:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocket = exports.STATUS_TEXTS = exports.Route = exports.Response = exports.Request = void 0;
exports.filterCookies = filterCookies;
exports.mergeHeaders = mergeHeaders;
exports.parsedURL = parsedURL;
exports.rewriteCookies = rewriteCookies;
exports.singleHeader = singleHeader;
exports.stripFragmentFromUrl = stripFragmentFromUrl;

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

var _instrumentation = __nccwpck_require__(6686);

var _fetch = __nccwpck_require__(2857);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function filterCookies(cookies, urls) {
  const parsedURLs = urls.map(s => new URL(s)); // Chromiums's cookies are missing sameSite when it is 'None'

  return cookies.filter(c => {
    if (!parsedURLs.length) return true;

    for (const parsedURL of parsedURLs) {
      let domain = c.domain;
      if (!domain.startsWith('.')) domain = '.' + domain;
      if (!('.' + parsedURL.hostname).endsWith(domain)) continue;
      if (!parsedURL.pathname.startsWith(c.path)) continue;
      if (parsedURL.protocol !== 'https:' && parsedURL.hostname !== 'localhost' && c.secure) continue;
      return true;
    }

    return false;
  });
} // Rollover to 5-digit year:
// 253402300799 == Fri, 31 Dec 9999 23:59:59 +0000 (UTC)
// 253402300800 == Sat,  1 Jan 1000 00:00:00 +0000 (UTC)


const kMaxCookieExpiresDateInSeconds = 253402300799;

function rewriteCookies(cookies) {
  return cookies.map(c => {
    (0, _utils.assert)(c.url || c.domain && c.path, 'Cookie should have a url or a domain/path pair');
    (0, _utils.assert)(!(c.url && c.domain), 'Cookie should have either url or domain');
    (0, _utils.assert)(!(c.url && c.path), 'Cookie should have either url or path');
    (0, _utils.assert)(!(c.expires && c.expires < 0 && c.expires !== -1), 'Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed');
    (0, _utils.assert)(!(c.expires && c.expires > 0 && c.expires > kMaxCookieExpiresDateInSeconds), 'Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed');
    const copy = { ...c
    };

    if (copy.url) {
      (0, _utils.assert)(copy.url !== 'about:blank', `Blank page can not have cookie "${c.name}"`);
      (0, _utils.assert)(!copy.url.startsWith('data:'), `Data URL page can not have cookie "${c.name}"`);
      const url = new URL(copy.url);
      copy.domain = url.hostname;
      copy.path = url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
      copy.secure = url.protocol === 'https:';
    }

    return copy;
  });
}

function parsedURL(url) {
  try {
    return new URL(url);
  } catch (e) {
    return null;
  }
}

function stripFragmentFromUrl(url) {
  if (!url.includes('#')) return url;
  return url.substring(0, url.indexOf('#'));
}

class Request extends _instrumentation.SdkObject {
  constructor(context, frame, serviceWorker, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
    super(frame || context, 'request');
    this._response = null;
    this._redirectedFrom = void 0;
    this._redirectedTo = null;
    this._documentId = void 0;
    this._isFavicon = void 0;
    this._failureText = null;
    this._url = void 0;
    this._resourceType = void 0;
    this._method = void 0;
    this._postData = void 0;
    this._headers = void 0;
    this._headersMap = new Map();
    this._frame = null;
    this._serviceWorker = null;
    this._context = void 0;
    this._rawRequestHeadersPromise = new _manualPromise.ManualPromise();
    this._waitForResponsePromise = new _manualPromise.ManualPromise();
    this._responseEndTiming = -1;
    (0, _utils.assert)(!url.startsWith('data:'), 'Data urls should not fire requests');
    this._context = context;
    this._frame = frame;
    this._serviceWorker = serviceWorker;
    this._redirectedFrom = redirectedFrom;
    if (redirectedFrom) redirectedFrom._redirectedTo = this;
    this._documentId = documentId;
    this._url = stripFragmentFromUrl(url);
    this._resourceType = resourceType;
    this._method = method;
    this._postData = postData;
    this._headers = headers;

    for (const {
      name,
      value
    } of this._headers) this._headersMap.set(name.toLowerCase(), value);

    this._isFavicon = url.endsWith('/favicon.ico') || !!(redirectedFrom !== null && redirectedFrom !== void 0 && redirectedFrom._isFavicon);
  }

  _setFailureText(failureText) {
    this._failureText = failureText;

    this._waitForResponsePromise.resolve(null);
  }

  url() {
    return this._url;
  }

  resourceType() {
    return this._resourceType;
  }

  method() {
    return this._method;
  }

  postDataBuffer() {
    return this._postData;
  }

  headers() {
    return this._headers;
  }

  headerValue(name) {
    return this._headersMap.get(name);
  } // "null" means no raw headers available - we'll use provisional headers as raw headers.


  setRawRequestHeaders(headers) {
    if (!this._rawRequestHeadersPromise.isDone()) this._rawRequestHeadersPromise.resolve(headers || this._headers);
  }

  async rawRequestHeaders() {
    return this._rawRequestHeadersPromise;
  }

  response() {
    return this._waitForResponsePromise;
  }

  _existingResponse() {
    return this._response;
  }

  _setResponse(response) {
    this._response = response;

    this._waitForResponsePromise.resolve(response);
  }

  _finalRequest() {
    return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
  }

  frame() {
    return this._frame;
  }

  serviceWorker() {
    return this._serviceWorker;
  }

  isNavigationRequest() {
    return !!this._documentId;
  }

  redirectedFrom() {
    return this._redirectedFrom;
  }

  failure() {
    if (this._failureText === null) return null;
    return {
      errorText: this._failureText
    };
  }

  bodySize() {
    var _this$postDataBuffer;

    return ((_this$postDataBuffer = this.postDataBuffer()) === null || _this$postDataBuffer === void 0 ? void 0 : _this$postDataBuffer.length) || 0;
  }

  async requestHeadersSize() {
    let headersSize = 4; // 4 = 2 spaces + 2 line breaks (GET /path \r\n)

    headersSize += this.method().length;
    headersSize += new URL(this.url()).pathname.length;
    headersSize += 8; // httpVersion

    const headers = await this.rawRequestHeaders();

    for (const header of headers) headersSize += header.name.length + header.value.length + 4; // 4 = ': ' + '\r\n'


    return headersSize;
  }

}

exports.Request = Request;

class Route extends _instrumentation.SdkObject {
  constructor(request, delegate) {
    super(request._frame || request._context, 'route');
    this._request = void 0;
    this._delegate = void 0;
    this._handled = false;
    this._request = request;
    this._delegate = delegate;

    this._request._context.addRouteInFlight(this);
  }

  request() {
    return this._request;
  }

  async abort(errorCode = 'failed') {
    this._startHandling();

    await this._delegate.abort(errorCode);

    this._endHandling();
  }

  async redirectNavigationRequest(url) {
    this._startHandling();

    (0, _utils.assert)(this._request.isNavigationRequest());

    this._request.frame().redirectNavigation(url, this._request._documentId, this._request.headerValue('referer'));
  }

  async fulfill(overrides) {
    this._startHandling();

    let body = overrides.body;
    let isBase64 = overrides.isBase64 || false;

    if (body === undefined) {
      if (overrides.fetchResponseUid) {
        const buffer = this._request._context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || _fetch.APIRequestContext.findResponseBody(overrides.fetchResponseUid);

        (0, _utils.assert)(buffer, 'Fetch response has been disposed');
        body = buffer.toString('base64');
        isBase64 = true;
      } else {
        body = '';
        isBase64 = false;
      }
    }

    const headers = [...(overrides.headers || [])];

    this._maybeAddCorsHeaders(headers);

    await this._delegate.fulfill({
      status: overrides.status || 200,
      headers,
      body,
      isBase64
    });

    this._endHandling();
  } // See https://github.com/microsoft/playwright/issues/12929


  _maybeAddCorsHeaders(headers) {
    const origin = this._request.headerValue('origin');

    if (!origin) return;
    const requestUrl = new URL(this._request.url());
    if (!requestUrl.protocol.startsWith('http')) return;
    if (requestUrl.origin === origin.trim()) return;
    const corsHeader = headers.find(({
      name
    }) => name === 'access-control-allow-origin');
    if (corsHeader) return;
    headers.push({
      name: 'access-control-allow-origin',
      value: origin
    });
    headers.push({
      name: 'access-control-allow-credentials',
      value: 'true'
    });
    headers.push({
      name: 'vary',
      value: 'Origin'
    });
  }

  async continue(overrides = {}) {
    this._startHandling();

    if (overrides.url) {
      const newUrl = new URL(overrides.url);
      const oldUrl = new URL(this._request.url());
      if (oldUrl.protocol !== newUrl.protocol) throw new Error('New URL must have same protocol as overridden URL');
    }

    await this._delegate.continue(this._request, overrides);

    this._endHandling();
  }

  _startHandling() {
    (0, _utils.assert)(!this._handled, 'Route is already handled!');
    this._handled = true;
  }

  _endHandling() {
    this._request._context.removeRouteInFlight(this);
  }

}

exports.Route = Route;

class Response extends _instrumentation.SdkObject {
  constructor(request, status, statusText, headers, timing, getResponseBodyCallback, fromServiceWorker, httpVersion) {
    super(request.frame() || request._context, 'response');
    this._request = void 0;
    this._contentPromise = null;
    this._finishedPromise = new _manualPromise.ManualPromise();
    this._status = void 0;
    this._statusText = void 0;
    this._url = void 0;
    this._headers = void 0;
    this._headersMap = new Map();
    this._getResponseBodyCallback = void 0;
    this._timing = void 0;
    this._serverAddrPromise = new _manualPromise.ManualPromise();
    this._securityDetailsPromise = new _manualPromise.ManualPromise();
    this._rawResponseHeadersPromise = new _manualPromise.ManualPromise();
    this._httpVersion = void 0;
    this._fromServiceWorker = void 0;
    this._encodedBodySizePromise = new _manualPromise.ManualPromise();
    this._transferSizePromise = new _manualPromise.ManualPromise();
    this._responseHeadersSizePromise = new _manualPromise.ManualPromise();
    this._request = request;
    this._timing = timing;
    this._status = status;
    this._statusText = statusText;
    this._url = request.url();
    this._headers = headers;

    for (const {
      name,
      value
    } of this._headers) this._headersMap.set(name.toLowerCase(), value);

    this._getResponseBodyCallback = getResponseBodyCallback;

    this._request._setResponse(this);

    this._httpVersion = httpVersion;
    this._fromServiceWorker = fromServiceWorker;
  }

  _serverAddrFinished(addr) {
    this._serverAddrPromise.resolve(addr);
  }

  _securityDetailsFinished(securityDetails) {
    this._securityDetailsPromise.resolve(securityDetails);
  }

  _requestFinished(responseEndTiming) {
    this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);

    this._finishedPromise.resolve();
  }

  _setHttpVersion(httpVersion) {
    this._httpVersion = httpVersion;
  }

  url() {
    return this._url;
  }

  status() {
    return this._status;
  }

  statusText() {
    return this._statusText;
  }

  headers() {
    return this._headers;
  }

  headerValue(name) {
    return this._headersMap.get(name);
  }

  async rawResponseHeaders() {
    return this._rawResponseHeadersPromise;
  } // "null" means no raw headers available - we'll use provisional headers as raw headers.


  setRawResponseHeaders(headers) {
    if (!this._rawResponseHeadersPromise.isDone()) this._rawResponseHeadersPromise.resolve(headers || this._headers);
  }

  setTransferSize(size) {
    this._transferSizePromise.resolve(size);
  }

  setEncodedBodySize(size) {
    this._encodedBodySizePromise.resolve(size);
  }

  setResponseHeadersSize(size) {
    this._responseHeadersSizePromise.resolve(size);
  }

  timing() {
    return this._timing;
  }

  async serverAddr() {
    return (await this._serverAddrPromise) || null;
  }

  async securityDetails() {
    return (await this._securityDetailsPromise) || null;
  }

  body() {
    if (!this._contentPromise) {
      this._contentPromise = this._finishedPromise.then(async () => {
        if (this._status >= 300 && this._status <= 399) throw new Error('Response body is unavailable for redirect responses');
        return this._getResponseBodyCallback();
      });
    }

    return this._contentPromise;
  }

  request() {
    return this._request;
  }

  frame() {
    return this._request.frame();
  }

  httpVersion() {
    if (!this._httpVersion) return 'HTTP/1.1';
    if (this._httpVersion === 'http/1.1') return 'HTTP/1.1';
    if (this._httpVersion === 'h2') return 'HTTP/2.0';
    return this._httpVersion;
  }

  fromServiceWorker() {
    return this._fromServiceWorker;
  }

  async responseHeadersSize() {
    const availableSize = await this._responseHeadersSizePromise;
    if (availableSize !== null) return availableSize; // Fallback to calculating it manually.

    let headersSize = 4; // 4 = 2 spaces + 2 line breaks (HTTP/1.1 200 Ok\r\n)

    headersSize += 8; // httpVersion;

    headersSize += 3; // statusCode;

    headersSize += this.statusText().length;
    const headers = await this._rawResponseHeadersPromise;

    for (const header of headers) headersSize += header.name.length + header.value.length + 4; // 4 = ': ' + '\r\n'


    headersSize += 2; // '\r\n'

    return headersSize;
  }

  async sizes() {
    const requestHeadersSize = await this._request.requestHeadersSize();
    const responseHeadersSize = await this.responseHeadersSize();
    let encodedBodySize = await this._encodedBodySizePromise;

    if (encodedBodySize === null) {
      var _headers$find;

      // Fallback to calculating it manually.
      const headers = await this._rawResponseHeadersPromise;
      const contentLength = (_headers$find = headers.find(h => h.name.toLowerCase() === 'content-length')) === null || _headers$find === void 0 ? void 0 : _headers$find.value;
      encodedBodySize = contentLength ? +contentLength : 0;
    }

    let transferSize = await this._transferSizePromise;

    if (transferSize === null) {
      // Fallback to calculating it manually.
      transferSize = responseHeadersSize + encodedBodySize;
    }

    return {
      requestBodySize: this._request.bodySize(),
      requestHeadersSize,
      responseBodySize: encodedBodySize,
      responseHeadersSize,
      transferSize
    };
  }

}

exports.Response = Response;

class WebSocket extends _instrumentation.SdkObject {
  constructor(parent, url) {
    super(parent, 'ws');
    this._url = void 0;
    this._notified = false;
    this._url = url;
  }

  markAsNotified() {
    // Sometimes we get "onWebSocketRequest" twice, at least in Chromium.
    // Perhaps websocket is restarted because of chrome.webRequest extensions api?
    // Or maybe the handshake response was a redirect?
    if (this._notified) return false;
    this._notified = true;
    return true;
  }

  url() {
    return this._url;
  }

  frameSent(opcode, data) {
    this.emit(WebSocket.Events.FrameSent, {
      opcode,
      data
    });
  }

  frameReceived(opcode, data) {
    this.emit(WebSocket.Events.FrameReceived, {
      opcode,
      data
    });
  }

  error(errorMessage) {
    this.emit(WebSocket.Events.SocketError, errorMessage);
  }

  closed() {
    this.emit(WebSocket.Events.Close);
  }

}

exports.WebSocket = WebSocket;
WebSocket.Events = {
  Close: 'close',
  SocketError: 'socketerror',
  FrameReceived: 'framereceived',
  FrameSent: 'framesent'
};
// List taken from https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml with extra 306 and 418 codes.
const STATUS_TEXTS = {
  '100': 'Continue',
  '101': 'Switching Protocols',
  '102': 'Processing',
  '103': 'Early Hints',
  '200': 'OK',
  '201': 'Created',
  '202': 'Accepted',
  '203': 'Non-Authoritative Information',
  '204': 'No Content',
  '205': 'Reset Content',
  '206': 'Partial Content',
  '207': 'Multi-Status',
  '208': 'Already Reported',
  '226': 'IM Used',
  '300': 'Multiple Choices',
  '301': 'Moved Permanently',
  '302': 'Found',
  '303': 'See Other',
  '304': 'Not Modified',
  '305': 'Use Proxy',
  '306': 'Switch Proxy',
  '307': 'Temporary Redirect',
  '308': 'Permanent Redirect',
  '400': 'Bad Request',
  '401': 'Unauthorized',
  '402': 'Payment Required',
  '403': 'Forbidden',
  '404': 'Not Found',
  '405': 'Method Not Allowed',
  '406': 'Not Acceptable',
  '407': 'Proxy Authentication Required',
  '408': 'Request Timeout',
  '409': 'Conflict',
  '410': 'Gone',
  '411': 'Length Required',
  '412': 'Precondition Failed',
  '413': 'Payload Too Large',
  '414': 'URI Too Long',
  '415': 'Unsupported Media Type',
  '416': 'Range Not Satisfiable',
  '417': 'Expectation Failed',
  '418': 'I\'m a teapot',
  '421': 'Misdirected Request',
  '422': 'Unprocessable Entity',
  '423': 'Locked',
  '424': 'Failed Dependency',
  '425': 'Too Early',
  '426': 'Upgrade Required',
  '428': 'Precondition Required',
  '429': 'Too Many Requests',
  '431': 'Request Header Fields Too Large',
  '451': 'Unavailable For Legal Reasons',
  '500': 'Internal Server Error',
  '501': 'Not Implemented',
  '502': 'Bad Gateway',
  '503': 'Service Unavailable',
  '504': 'Gateway Timeout',
  '505': 'HTTP Version Not Supported',
  '506': 'Variant Also Negotiates',
  '507': 'Insufficient Storage',
  '508': 'Loop Detected',
  '510': 'Not Extended',
  '511': 'Network Authentication Required'
};
exports.STATUS_TEXTS = STATUS_TEXTS;

function singleHeader(name, value) {
  return [{
    name,
    value
  }];
}

function mergeHeaders(headers) {
  const lowerCaseToValue = new Map();
  const lowerCaseToOriginalCase = new Map();

  for (const h of headers) {
    if (!h) continue;

    for (const {
      name,
      value
    } of h) {
      const lower = name.toLowerCase();
      lowerCaseToOriginalCase.set(lower, name);
      lowerCaseToValue.set(lower, value);
    }
  }

  const result = [];

  for (const [lower, value] of lowerCaseToValue) result.push({
    name: lowerCaseToOriginalCase.get(lower),
    value
  });

  return result;
}

/***/ }),

/***/ 3555:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Worker = exports.PageBinding = exports.Page = void 0;

var frames = _interopRequireWildcard(__nccwpck_require__(8895));

var input = _interopRequireWildcard(__nccwpck_require__(2654));

var js = _interopRequireWildcard(__nccwpck_require__(804));

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _screenshotter = __nccwpck_require__(4613);

var _timeoutSettings = __nccwpck_require__(9053);

var _browserContext = __nccwpck_require__(5985);

var _console = __nccwpck_require__(8477);

var accessibility = _interopRequireWildcard(__nccwpck_require__(5900));

var _fileChooser = __nccwpck_require__(2337);

var _progress = __nccwpck_require__(2836);

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

var _debugLogger = __nccwpck_require__(2003);

var _comparators = __nccwpck_require__(9509);

var _instrumentation = __nccwpck_require__(6686);

var _selectorParser = __nccwpck_require__(377);

var _utilityScriptSerializers = __nccwpck_require__(9012);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Page extends _instrumentation.SdkObject {
  constructor(delegate, browserContext) {
    super(browserContext, 'page');
    this._closedState = 'open';
    this._closedPromise = new _manualPromise.ManualPromise();
    this._disconnected = false;
    this._initialized = false;
    this._disconnectedPromise = new _manualPromise.ManualPromise();
    this._crashedPromise = new _manualPromise.ManualPromise();
    this._browserContext = void 0;
    this.keyboard = void 0;
    this.mouse = void 0;
    this.touchscreen = void 0;
    this._timeoutSettings = void 0;
    this._delegate = void 0;
    this._emulatedSize = void 0;
    this._extraHTTPHeaders = void 0;
    this._emulatedMedia = {};
    this._interceptFileChooser = false;
    this._pageBindings = new Map();
    this.initScripts = [];
    this._screenshotter = void 0;
    this._frameManager = void 0;
    this.accessibility = void 0;
    this._workers = new Map();
    this.pdf = void 0;
    this.coverage = void 0;
    this._clientRequestInterceptor = void 0;
    this._serverRequestInterceptor = void 0;
    this._ownedContext = void 0;
    this.selectors = void 0;
    this._pageIsError = void 0;
    this._video = null;
    this._opener = void 0;
    this._frameThrottler = new FrameThrottler(10, 200);
    this._isServerSideOnly = false;
    this.attribution.page = this;
    this._delegate = delegate;
    this._browserContext = browserContext;
    this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
    this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
    this.mouse = new input.Mouse(delegate.rawMouse, this);
    this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
    this._timeoutSettings = new _timeoutSettings.TimeoutSettings(browserContext._timeoutSettings);
    this._screenshotter = new _screenshotter.Screenshotter(this);
    this._frameManager = new frames.FrameManager(this);
    if (delegate.pdf) this.pdf = delegate.pdf.bind(delegate);
    this.coverage = delegate.coverage ? delegate.coverage() : null;
    this.selectors = browserContext.selectors();
    this.instrumentation.onPageOpen(this);
  }

  async initOpener(opener) {
    if (!opener) return;
    const openerPage = await opener.pageOrError();
    if (openerPage instanceof Page && !openerPage.isClosed()) this._opener = openerPage;
  }

  reportAsNew(error = undefined, contextEvent = _browserContext.BrowserContext.Events.Page) {
    if (error) {
      // Initialization error could have happened because of
      // context/browser closure. Just ignore the page.
      if (this._browserContext.isClosingOrClosed()) return;

      this._setIsError(error);
    }

    this._initialized = true;
    this.emitOnContext(contextEvent, this); // I may happen that page initialization finishes after Close event has already been sent,
    // in that case we fire another Close event to ensure that each reported Page will have
    // corresponding Close event after it is reported on the context.

    if (this.isClosed()) this.emit(Page.Events.Close);
  }

  initializedOrUndefined() {
    return this._initialized ? this : undefined;
  }

  emitOnContext(event, ...args) {
    if (this._isServerSideOnly) return;

    this._browserContext.emit(event, ...args);
  }

  async resetForReuse(metadata) {
    this.setDefaultNavigationTimeout(undefined);
    this.setDefaultTimeout(undefined);
    await this._removeExposedBindings();
    await this._removeInitScripts();
    await this.setClientRequestInterceptor(undefined);
    await this._setServerRequestInterceptor(undefined);
    await this.setFileChooserIntercepted(false); // Re-navigate once init scripts are gone.

    await this.mainFrame().goto(metadata, 'about:blank');
    this._emulatedSize = undefined;
    this._emulatedMedia = {};
    this._extraHTTPHeaders = undefined;
    this._interceptFileChooser = false;
    await Promise.all([this._delegate.updateEmulatedViewportSize(true), this._delegate.updateEmulateMedia(), this._delegate.updateFileChooserInterception()]);
  }

  async _doSlowMo() {
    const slowMo = this._browserContext._browser.options.slowMo;
    if (!slowMo) return;
    await new Promise(x => setTimeout(x, slowMo));
  }

  _didClose() {
    this.instrumentation.onPageClose(this);

    this._frameManager.dispose();

    this._frameThrottler.setEnabled(false);

    (0, _utils.assert)(this._closedState !== 'closed', 'Page closed twice');
    this._closedState = 'closed';
    this.emit(Page.Events.Close);

    this._closedPromise.resolve();
  }

  _didCrash() {
    this.instrumentation.onPageClose(this);

    this._frameManager.dispose();

    this._frameThrottler.setEnabled(false);

    this.emit(Page.Events.Crash);

    this._crashedPromise.resolve(new Error('Page crashed'));
  }

  _didDisconnect() {
    this.instrumentation.onPageClose(this);

    this._frameManager.dispose();

    this._frameThrottler.setEnabled(false);

    (0, _utils.assert)(!this._disconnected, 'Page disconnected twice');
    this._disconnected = true;

    this._disconnectedPromise.resolve(new Error('Page closed'));
  }

  async _onFileChooserOpened(handle) {
    let multiple;

    try {
      multiple = await handle.evaluate(element => !!element.multiple);
    } catch (e) {
      // Frame/context may be gone during async processing. Do not throw.
      return;
    }

    if (!this.listenerCount(Page.Events.FileChooser)) {
      handle.dispose();
      return;
    }

    const fileChooser = new _fileChooser.FileChooser(this, handle, multiple);
    this.emit(Page.Events.FileChooser, fileChooser);
  }

  context() {
    return this._browserContext;
  }

  opener() {
    return this._opener;
  }

  mainFrame() {
    return this._frameManager.mainFrame();
  }

  frames() {
    return this._frameManager.frames();
  }

  setDefaultNavigationTimeout(timeout) {
    this._timeoutSettings.setDefaultNavigationTimeout(timeout);
  }

  setDefaultTimeout(timeout) {
    this._timeoutSettings.setDefaultTimeout(timeout);
  }

  async exposeBinding(name, needsHandle, playwrightBinding) {
    if (this._pageBindings.has(name)) throw new Error(`Function "${name}" has been already registered`);
    if (this._browserContext._pageBindings.has(name)) throw new Error(`Function "${name}" has been already registered in the browser context`);
    const binding = new PageBinding(name, playwrightBinding, needsHandle);

    this._pageBindings.set(name, binding);

    await this._delegate.exposeBinding(binding);
  }

  async _removeExposedBindings() {
    for (const key of this._pageBindings.keys()) {
      if (!key.startsWith('__pw')) this._pageBindings.delete(key);
    }

    await this._delegate.removeExposedBindings();
  }

  setExtraHTTPHeaders(headers) {
    this._extraHTTPHeaders = headers;
    return this._delegate.updateExtraHTTPHeaders();
  }

  extraHTTPHeaders() {
    return this._extraHTTPHeaders;
  }

  async _onBindingCalled(payload, context) {
    if (this._disconnected || this._closedState === 'closed') return;
    await PageBinding.dispatch(this, payload, context);
  }

  _addConsoleMessage(type, args, location, text) {
    const message = new _console.ConsoleMessage(this, type, text, args, location);

    const intercepted = this._frameManager.interceptConsoleMessage(message);

    if (intercepted || !this.listenerCount(Page.Events.Console)) args.forEach(arg => arg.dispose());else this.emit(Page.Events.Console, message);
  }

  async reload(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this.mainFrame().raceNavigationAction(progress, options, async () => {
      // Note: waitForNavigation may fail before we get response to reload(),
      // so we should await it immediately.
      const [response] = await Promise.all([this.mainFrame()._waitForNavigation(progress, options), this._delegate.reload()]);
      await this._doSlowMo();
      return response;
    }), this._timeoutSettings.navigationTimeout(options));
  }

  async goBack(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this.mainFrame().raceNavigationAction(progress, options, async () => {
      // Note: waitForNavigation may fail before we get response to goBack,
      // so we should catch it immediately.
      let error;

      const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch(e => {
        error = e;
        return null;
      });

      const result = await this._delegate.goBack();
      if (!result) return null;
      const response = await waitPromise;
      if (error) throw error;
      await this._doSlowMo();
      return response;
    }), this._timeoutSettings.navigationTimeout(options));
  }

  async goForward(metadata, options) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this.mainFrame().raceNavigationAction(progress, options, async () => {
      // Note: waitForNavigation may fail before we get response to goForward,
      // so we should catch it immediately.
      let error;

      const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch(e => {
        error = e;
        return null;
      });

      const result = await this._delegate.goForward();
      if (!result) return null;
      const response = await waitPromise;
      if (error) throw error;
      await this._doSlowMo();
      return response;
    }), this._timeoutSettings.navigationTimeout(options));
  }

  async emulateMedia(options) {
    if (options.media !== undefined) this._emulatedMedia.media = options.media;
    if (options.colorScheme !== undefined) this._emulatedMedia.colorScheme = options.colorScheme;
    if (options.reducedMotion !== undefined) this._emulatedMedia.reducedMotion = options.reducedMotion;
    if (options.forcedColors !== undefined) this._emulatedMedia.forcedColors = options.forcedColors;
    await this._delegate.updateEmulateMedia();
    await this._doSlowMo();
  }

  emulatedMedia() {
    var _contextOptions$color, _contextOptions$reduc, _contextOptions$force;

    const contextOptions = this._browserContext._options;
    return {
      media: this._emulatedMedia.media || null,
      colorScheme: this._emulatedMedia.colorScheme !== undefined ? this._emulatedMedia.colorScheme : (_contextOptions$color = contextOptions.colorScheme) !== null && _contextOptions$color !== void 0 ? _contextOptions$color : 'light',
      reducedMotion: this._emulatedMedia.reducedMotion !== undefined ? this._emulatedMedia.reducedMotion : (_contextOptions$reduc = contextOptions.reducedMotion) !== null && _contextOptions$reduc !== void 0 ? _contextOptions$reduc : 'no-preference',
      forcedColors: this._emulatedMedia.forcedColors !== undefined ? this._emulatedMedia.forcedColors : (_contextOptions$force = contextOptions.forcedColors) !== null && _contextOptions$force !== void 0 ? _contextOptions$force : 'none'
    };
  }

  async setViewportSize(viewportSize) {
    this._emulatedSize = {
      viewport: { ...viewportSize
      },
      screen: { ...viewportSize
      }
    };
    await this._delegate.updateEmulatedViewportSize();
    await this._doSlowMo();
  }

  viewportSize() {
    var _this$emulatedSize;

    return ((_this$emulatedSize = this.emulatedSize()) === null || _this$emulatedSize === void 0 ? void 0 : _this$emulatedSize.viewport) || null;
  }

  emulatedSize() {
    if (this._emulatedSize) return this._emulatedSize;
    const contextOptions = this._browserContext._options;
    return contextOptions.viewport ? {
      viewport: contextOptions.viewport,
      screen: contextOptions.screen || contextOptions.viewport
    } : null;
  }

  async bringToFront() {
    await this._delegate.bringToFront();
  }

  async addInitScript(source) {
    this.initScripts.push(source);
    await this._delegate.addInitScript(source);
  }

  async _removeInitScripts() {
    this.initScripts.splice(0, this.initScripts.length);
    await this._delegate.removeInitScripts();
  }

  needsRequestInterception() {
    return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
  }

  async setClientRequestInterceptor(handler) {
    this._clientRequestInterceptor = handler;
    await this._delegate.updateRequestInterception();
  }

  async _setServerRequestInterceptor(handler) {
    this._serverRequestInterceptor = handler;
    await this._delegate.updateRequestInterception();
  }

  async expectScreenshot(metadata, options = {}) {
    const locator = options.locator;
    const rafrafScreenshot = locator ? async (progress, timeout) => {
      return await locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress, locator.selector, timeout, options.screenshotOptions || {});
    } : async (progress, timeout) => {
      await this.mainFrame().rafrafTimeout(timeout);
      return await this._screenshotter.screenshotPage(progress, options.screenshotOptions || {});
    };
    const comparator = (0, _comparators.getComparator)('image/png');
    const controller = new _progress.ProgressController(metadata, this);
    if (!options.expected && options.isNot) return {
      errorMessage: '"not" matcher requires expected result'
    };

    try {
      const format = (0, _screenshotter.validateScreenshotOptions)(options.screenshotOptions || {});
      if (format !== 'png') throw new Error('Only PNG screenshots are supported');
    } catch (error) {
      return {
        errorMessage: error.message
      };
    }

    let intermediateResult = undefined;

    const areEqualScreenshots = (actual, expected, previous) => {
      const comparatorResult = actual && expected ? comparator(actual, expected, options.comparatorOptions) : undefined;
      if (comparatorResult !== undefined && !!comparatorResult === !!options.isNot) return true;
      if (comparatorResult) intermediateResult = {
        errorMessage: comparatorResult.errorMessage,
        diff: comparatorResult.diff,
        actual,
        previous
      };
      return false;
    };

    const callTimeout = this._timeoutSettings.timeout(options);

    return controller.run(async progress => {
      let actual;
      let previous;
      const pollIntervals = [0, 100, 250, 500];
      progress.log(`${metadata.apiName}${callTimeout ? ` with timeout ${callTimeout}ms` : ''}`);
      if (options.expected) progress.log(`  verifying given screenshot expectation`);else progress.log(`  generating new stable screenshot expectation`);
      let isFirstIteration = true;

      while (true) {
        var _pollIntervals$shift;

        progress.throwIfAborted();
        if (this.isClosed()) throw new Error('The page has closed');
        const screenshotTimeout = (_pollIntervals$shift = pollIntervals.shift()) !== null && _pollIntervals$shift !== void 0 ? _pollIntervals$shift : 1000;
        if (screenshotTimeout) progress.log(`waiting ${screenshotTimeout}ms before taking screenshot`);
        previous = actual;
        actual = await rafrafScreenshot(progress, screenshotTimeout).catch(e => {
          progress.log(`failed to take screenshot - ` + e.message);
          return undefined;
        });
        if (!actual) continue; // Compare against expectation for the first iteration.

        const expectation = options.expected && isFirstIteration ? options.expected : previous;
        if (areEqualScreenshots(actual, expectation, previous)) break;
        if (intermediateResult) progress.log(intermediateResult.errorMessage);
        isFirstIteration = false;
      }

      if (!isFirstIteration) progress.log(`captured a stable screenshot`);
      if (!options.expected) return {
        actual
      };

      if (isFirstIteration) {
        progress.log(`screenshot matched expectation`);
        return {};
      }

      if (areEqualScreenshots(actual, options.expected, previous)) {
        progress.log(`screenshot matched expectation`);
        return {};
      }

      throw new Error(intermediateResult.errorMessage);
    }, callTimeout).catch(e => {
      // Q: Why not throw upon isSessionClosedError(e) as in other places?
      // A: We want user to receive a friendly diff between actual and expected/previous.
      if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e)) throw e;
      return {
        log: e.message ? [...metadata.log, e.message] : metadata.log,
        ...intermediateResult,
        errorMessage: e.message
      };
    });
  }

  async screenshot(metadata, options = {}) {
    const controller = new _progress.ProgressController(metadata, this);
    return controller.run(progress => this._screenshotter.screenshotPage(progress, options), this._timeoutSettings.timeout(options));
  }

  async close(metadata, options) {
    if (this._closedState === 'closed') return;
    const runBeforeUnload = !!options && !!options.runBeforeUnload;

    if (this._closedState !== 'closing') {
      this._closedState = 'closing';
      (0, _utils.assert)(!this._disconnected, 'Target closed'); // This might throw if the browser context containing the page closes
      // while we are trying to close the page.

      await this._delegate.closePage(runBeforeUnload).catch(e => _debugLogger.debugLogger.log('error', e));
    }

    if (!runBeforeUnload) await this._closedPromise;
    if (this._ownedContext) await this._ownedContext.close(metadata);
  }

  _setIsError(error) {
    this._pageIsError = error;

    this._frameManager.createDummyMainFrameIfNeeded();
  }

  isClosed() {
    return this._closedState === 'closed';
  }

  _addWorker(workerId, worker) {
    this._workers.set(workerId, worker);

    this.emit(Page.Events.Worker, worker);
  }

  _removeWorker(workerId) {
    const worker = this._workers.get(workerId);

    if (!worker) return;
    worker.didClose();

    this._workers.delete(workerId);
  }

  _clearWorkers() {
    for (const [workerId, worker] of this._workers) {
      worker.didClose();

      this._workers.delete(workerId);
    }
  }

  async setFileChooserIntercepted(enabled) {
    this._interceptFileChooser = enabled;
    await this._delegate.updateFileChooserInterception();
  }

  fileChooserIntercepted() {
    return this._interceptFileChooser;
  }

  frameNavigatedToNewDocument(frame) {
    this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
    const url = frame.url();
    if (!url.startsWith('http')) return;
    const purl = network.parsedURL(url);
    if (purl) this._browserContext.addVisitedOrigin(purl.origin);
  }

  allBindings() {
    return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
  }

  getBinding(name) {
    return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
  }

  setScreencastOptions(options) {
    this._delegate.setScreencastOptions(options).catch(e => _debugLogger.debugLogger.log('error', e));

    this._frameThrottler.setEnabled(!!options);
  }

  throttleScreencastFrameAck(ack) {
    // Don't ack immediately, tracing has smart throttling logic that is implemented here.
    this._frameThrottler.ack(ack);
  }

  temporarlyDisableTracingScreencastThrottling() {
    this._frameThrottler.recharge();
  }

  firePageError(error) {
    this.emit(Page.Events.PageError, error);
  }

  parseSelector(selector, options) {
    const strict = typeof (options === null || options === void 0 ? void 0 : options.strict) === 'boolean' ? options.strict : !!this.context()._options.strictSelectors;
    return this.selectors.parseSelector(selector, strict);
  }

  async hideHighlight() {
    await Promise.all(this.frames().map(frame => frame.hideHighlight().catch(() => {})));
  }

  markAsServerSideOnly() {
    this._isServerSideOnly = true;
  }

}

exports.Page = Page;
Page.Events = {
  Close: 'close',
  Crash: 'crash',
  Console: 'console',
  Dialog: 'dialog',
  Download: 'download',
  FileChooser: 'filechooser',
  // Can't use just 'error' due to node.js special treatment of error events.
  // @see https://nodejs.org/api/events.html#events_error_events
  PageError: 'pageerror',
  FrameAttached: 'frameattached',
  FrameDetached: 'framedetached',
  InternalFrameNavigatedToNewDocument: 'internalframenavigatedtonewdocument',
  ScreencastFrame: 'screencastframe',
  Video: 'video',
  WebSocket: 'websocket',
  Worker: 'worker'
};

class Worker extends _instrumentation.SdkObject {
  constructor(parent, url) {
    super(parent, 'worker');
    this._url = void 0;
    this._executionContextPromise = void 0;
    this._executionContextCallback = void 0;
    this._existingExecutionContext = null;
    this._url = url;

    this._executionContextCallback = () => {};

    this._executionContextPromise = new Promise(x => this._executionContextCallback = x);
  }

  _createExecutionContext(delegate) {
    this._existingExecutionContext = new js.ExecutionContext(this, delegate);

    this._executionContextCallback(this._existingExecutionContext);
  }

  url() {
    return this._url;
  }

  didClose() {
    if (this._existingExecutionContext) this._existingExecutionContext.contextDestroyed(new Error('Worker was closed'));
    this.emit(Worker.Events.Close, this);
  }

  async evaluateExpression(expression, isFunction, arg) {
    return js.evaluateExpression(await this._executionContextPromise, true
    /* returnByValue */
    , expression, isFunction, arg);
  }

  async evaluateExpressionHandle(expression, isFunction, arg) {
    return js.evaluateExpression(await this._executionContextPromise, false
    /* returnByValue */
    , expression, isFunction, arg);
  }

}

exports.Worker = Worker;
Worker.Events = {
  Close: 'close'
};

class PageBinding {
  constructor(name, playwrightFunction, needsHandle) {
    this.name = void 0;
    this.playwrightFunction = void 0;
    this.source = void 0;
    this.needsHandle = void 0;
    this.name = name;
    this.playwrightFunction = playwrightFunction;
    this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle}, (${_utilityScriptSerializers.source})())`;
    this.needsHandle = needsHandle;
  }

  static async dispatch(page, payload, context) {
    const {
      name,
      seq,
      serializedArgs
    } = JSON.parse(payload);

    try {
      (0, _utils.assert)(context.world);
      const binding = page.getBinding(name);
      let result;

      if (binding.needsHandle) {
        const handle = await context.evaluateHandle(takeHandle, {
          name,
          seq
        }).catch(e => null);
        result = await binding.playwrightFunction({
          frame: context.frame,
          page,
          context: page._browserContext
        }, handle);
      } else {
        const args = serializedArgs.map(a => (0, _utilityScriptSerializers.parseEvaluationResultValue)(a));
        result = await binding.playwrightFunction({
          frame: context.frame,
          page,
          context: page._browserContext
        }, ...args);
      }

      context.evaluate(deliverResult, {
        name,
        seq,
        result
      }).catch(e => _debugLogger.debugLogger.log('error', e));
    } catch (error) {
      if ((0, _utils.isError)(error)) context.evaluate(deliverError, {
        name,
        seq,
        message: error.message,
        stack: error.stack
      }).catch(e => _debugLogger.debugLogger.log('error', e));else context.evaluate(deliverErrorValue, {
        name,
        seq,
        error
      }).catch(e => _debugLogger.debugLogger.log('error', e));
    }

    function takeHandle(arg) {
      const handle = globalThis[arg.name]['handles'].get(arg.seq);
      globalThis[arg.name]['handles'].delete(arg.seq);
      return handle;
    }

    function deliverResult(arg) {
      globalThis[arg.name]['callbacks'].get(arg.seq).resolve(arg.result);
      globalThis[arg.name]['callbacks'].delete(arg.seq);
    }

    function deliverError(arg) {
      const error = new Error(arg.message);
      error.stack = arg.stack;
      globalThis[arg.name]['callbacks'].get(arg.seq).reject(error);
      globalThis[arg.name]['callbacks'].delete(arg.seq);
    }

    function deliverErrorValue(arg) {
      globalThis[arg.name]['callbacks'].get(arg.seq).reject(arg.error);
      globalThis[arg.name]['callbacks'].delete(arg.seq);
    }
  }

}

exports.PageBinding = PageBinding;

function addPageBinding(bindingName, needsHandle, utilityScriptSerializers) {
  const binding = globalThis[bindingName];
  if (binding.__installed) return;

  globalThis[bindingName] = (...args) => {
    const me = globalThis[bindingName];
    if (needsHandle && args.slice(1).some(arg => arg !== undefined)) throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
    let callbacks = me['callbacks'];

    if (!callbacks) {
      callbacks = new Map();
      me['callbacks'] = callbacks;
    }

    const seq = (me['lastSeq'] || 0) + 1;
    me['lastSeq'] = seq;
    let handles = me['handles'];

    if (!handles) {
      handles = new Map();
      me['handles'] = handles;
    }

    const promise = new Promise((resolve, reject) => callbacks.set(seq, {
      resolve,
      reject
    }));
    let payload;

    if (needsHandle) {
      handles.set(seq, args[0]);
      payload = {
        name: bindingName,
        seq
      };
    } else {
      const serializedArgs = args.map(a => utilityScriptSerializers.serializeAsCallArgument(a, v => {
        return {
          fallThrough: v
        };
      }));
      payload = {
        name: bindingName,
        seq,
        serializedArgs
      };
    }

    binding(JSON.stringify(payload));
    return promise;
  };

  globalThis[bindingName].__installed = true;
}

class FrameThrottler {
  constructor(nonThrottledFrames, interval) {
    this._acks = [];
    this._interval = void 0;
    this._nonThrottledFrames = void 0;
    this._budget = void 0;
    this._intervalId = void 0;
    this._nonThrottledFrames = nonThrottledFrames;
    this._budget = nonThrottledFrames;
    this._interval = interval;
  }

  setEnabled(enabled) {
    if (enabled) {
      if (this._intervalId) clearInterval(this._intervalId);
      this._intervalId = setInterval(() => this._tick(), this._interval);
    } else if (this._intervalId) {
      clearInterval(this._intervalId);
      this._intervalId = undefined;
    }
  }

  recharge() {
    // Send all acks, reset budget.
    for (const ack of this._acks) ack();

    this._acks = [];
    this._budget = this._nonThrottledFrames;
  }

  ack(ack) {
    // Either not engaged or video is also recording, don't throttle.
    if (!this._intervalId) {
      ack();
      return;
    } // Do we have enough budget to respond w/o throttling?


    if (--this._budget > 0) {
      ack();
      return;
    } // Schedule.


    this._acks.push(ack);
  }

  _tick() {
    var _this$_acks$shift;

    (_this$_acks$shift = this._acks.shift()) === null || _this$_acks$shift === void 0 ? void 0 : _this$_acks$shift();
  }

}

/***/ }),

/***/ 5241:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PipeTransport = void 0;

var _utils = __nccwpck_require__(3557);

var _debugLogger = __nccwpck_require__(2003);

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PipeTransport {
  constructor(pipeWrite, pipeRead) {
    this._pipeRead = void 0;
    this._pipeWrite = void 0;
    this._pendingMessage = '';
    this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
    this._closed = false;
    this._onclose = void 0;
    this.onmessage = void 0;
    this._pipeRead = pipeRead;
    this._pipeWrite = pipeWrite;
    pipeRead.on('data', buffer => this._dispatch(buffer));
    pipeRead.on('close', () => {
      this._closed = true;
      if (this._onclose) this._onclose.call(null);
    });
    pipeRead.on('error', e => _debugLogger.debugLogger.log('error', e));
    pipeWrite.on('error', e => _debugLogger.debugLogger.log('error', e));
    this.onmessage = undefined;
  }

  get onclose() {
    return this._onclose;
  }

  set onclose(onclose) {
    this._onclose = onclose;
    if (onclose && !this._pipeRead.readable) onclose();
  }

  send(message) {
    if (this._closed) throw new Error('Pipe has been closed');

    this._pipeWrite.write(JSON.stringify(message));

    this._pipeWrite.write('\0');
  }

  close() {
    throw new Error('unimplemented');
  }

  _dispatch(buffer) {
    let end = buffer.indexOf('\0');

    if (end === -1) {
      this._pendingMessage += buffer.toString();
      return;
    }

    const message = this._pendingMessage + buffer.toString(undefined, 0, end);

    this._waitForNextTask(() => {
      if (this.onmessage) this.onmessage.call(null, JSON.parse(message));
    });

    let start = end + 1;
    end = buffer.indexOf('\0', start);

    while (end !== -1) {
      const message = buffer.toString(undefined, start, end);

      this._waitForNextTask(() => {
        if (this.onmessage) this.onmessage.call(null, JSON.parse(message));
      });

      start = end + 1;
      end = buffer.indexOf('\0', start);
    }

    this._pendingMessage = buffer.toString(undefined, start);
  }

}

exports.PipeTransport = PipeTransport;

/***/ }),

/***/ 4506:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Playwright = void 0;
exports.createPlaywright = createPlaywright;

var _android = __nccwpck_require__(6781);

var _backendAdb = __nccwpck_require__(389);

var _chromium = __nccwpck_require__(2302);

var _electron = __nccwpck_require__(9229);

var _firefox = __nccwpck_require__(2792);

var _selectors = __nccwpck_require__(5875);

var _webkit = __nccwpck_require__(2967);

var _instrumentation = __nccwpck_require__(6686);

var _debugLogger = __nccwpck_require__(2003);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Playwright extends _instrumentation.SdkObject {
  constructor(sdkLanguage, isInternalPlaywright) {
    super({
      attribution: {
        isInternalPlaywright
      },
      instrumentation: (0, _instrumentation.createInstrumentation)()
    }, undefined, 'Playwright');
    this.selectors = void 0;
    this.chromium = void 0;
    this.android = void 0;
    this.electron = void 0;
    this.firefox = void 0;
    this.webkit = void 0;
    this.options = void 0;
    this._allPages = new Set();
    this._allBrowsers = new Set();
    this.instrumentation.addListener({
      onBrowserOpen: browser => this._allBrowsers.add(browser),
      onBrowserClose: browser => this._allBrowsers.delete(browser),
      onPageOpen: page => this._allPages.add(page),
      onPageClose: page => this._allPages.delete(page),
      onCallLog: (sdkObject, metadata, logName, message) => {
        _debugLogger.debugLogger.log(logName, message);
      }
    }, null);
    this.options = {
      rootSdkObject: this,
      selectors: new _selectors.Selectors(),
      sdkLanguage: sdkLanguage
    };
    this.chromium = new _chromium.Chromium(this.options);
    this.firefox = new _firefox.Firefox(this.options);
    this.webkit = new _webkit.WebKit(this.options);
    this.electron = new _electron.Electron(this.options);
    this.android = new _android.Android(new _backendAdb.AdbBackend(), this.options);
    this.selectors = this.options.selectors;
  }

  async hideHighlight() {
    await Promise.all([...this._allPages].map(p => p.hideHighlight().catch(() => {})));
  }

  allBrowsers() {
    return [...this._allBrowsers];
  }

  allPages() {
    return [...this._allPages];
  }

}

exports.Playwright = Playwright;

function createPlaywright(sdkLanguage, isInternalPlaywright = false) {
  return new Playwright(sdkLanguage, isInternalPlaywright);
}

/***/ }),

/***/ 2836:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProgressController = void 0;

var _errors = __nccwpck_require__(542);

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProgressController {
  // Cleanups to be run only in the case of abort.
  constructor(metadata, sdkObject) {
    this._forceAbortPromise = new _manualPromise.ManualPromise();
    this._cleanups = [];
    this._logName = 'api';
    this._state = 'before';
    this._deadline = 0;
    this._timeout = 0;
    this._lastIntermediateResult = void 0;
    this.metadata = void 0;
    this.instrumentation = void 0;
    this.sdkObject = void 0;
    this.metadata = metadata;
    this.sdkObject = sdkObject;
    this.instrumentation = sdkObject.instrumentation;

    this._forceAbortPromise.catch(e => null); // Prevent unhandled promise rejection.

  }

  setLogName(logName) {
    this._logName = logName;
  }

  lastIntermediateResult() {
    return this._lastIntermediateResult;
  }

  async run(task, timeout) {
    if (timeout) {
      this._timeout = timeout;
      this._deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
    }

    (0, _utils.assert)(this._state === 'before');
    this._state = 'running';
    const progress = {
      log: message => {
        progress.logEntry({
          message
        });
      },
      logEntry: entry => {
        if ('message' in entry) {
          const message = entry.message;
          if (this._state === 'running') this.metadata.log.push(message); // Note: we might be sending logs after progress has finished, for example browser logs.

          this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
        }

        if ('intermediateResult' in entry) this._lastIntermediateResult = entry.intermediateResult;
      },
      timeUntilDeadline: () => this._deadline ? this._deadline - (0, _utils.monotonicTime)() : 2147483647,
      // 2^31-1 safe setTimeout in Node.
      isRunning: () => this._state === 'running',
      cleanupWhenAborted: cleanup => {
        if (this._state === 'running') this._cleanups.push(cleanup);else runCleanup(cleanup);
      },
      throwIfAborted: () => {
        if (this._state === 'aborted') throw new AbortedError();
      },
      beforeInputAction: async element => {
        await this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
      },
      metadata: this.metadata
    };
    const timeoutError = new _errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
    const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());

    try {
      const promise = task(progress);
      const result = await Promise.race([promise, this._forceAbortPromise]);
      this._state = 'finished';
      return result;
    } catch (e) {
      this._state = 'aborted';
      await Promise.all(this._cleanups.splice(0).map(runCleanup));
      throw e;
    } finally {
      clearTimeout(timer);
    }
  }

}

exports.ProgressController = ProgressController;

async function runCleanup(cleanup) {
  try {
    await cleanup();
  } catch (e) {}
}

class AbortedError extends Error {}

/***/ }),

/***/ 7314:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ProtocolError = void 0;
exports.isSessionClosedError = isSessionClosedError;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProtocolError extends Error {
  constructor(sessionClosed, message) {
    super(message);
    this.sessionClosed = void 0;
    this.sessionClosed = sessionClosed || false;
  }

}

exports.ProtocolError = ProtocolError;

function isSessionClosedError(e) {
  return e instanceof ProtocolError && e.sessionClosed;
}

/***/ }),

/***/ 8584:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Recorder = void 0;

var fs = _interopRequireWildcard(__nccwpck_require__(7147));

var _codeGenerator = __nccwpck_require__(9672);

var _utils = __nccwpck_require__(5704);

var _page = __nccwpck_require__(3555);

var _frames = __nccwpck_require__(8895);

var _browserContext = __nccwpck_require__(5985);

var _java = __nccwpck_require__(9359);

var _javascript = __nccwpck_require__(5954);

var _csharp = __nccwpck_require__(6514);

var _python = __nccwpck_require__(3082);

var recorderSource = _interopRequireWildcard(__nccwpck_require__(6048));

var consoleApiSource = _interopRequireWildcard(__nccwpck_require__(4989));

var _recorderApp = __nccwpck_require__(7351);

var _utils2 = __nccwpck_require__(3557);

var _recorderUtils = __nccwpck_require__(9311);

var _debugger = __nccwpck_require__(7370);

var _events = __nccwpck_require__(2361);

var _timeoutRunner = __nccwpck_require__(803);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const recorderSymbol = Symbol('recorderSymbol');

class Recorder {
  static showInspector(context) {
    Recorder.show(context, {}).catch(() => {});
  }

  static show(context, params = {}, recorderAppFactory = Recorder.defaultRecorderAppFactory) {
    let recorderPromise = context[recorderSymbol];

    if (!recorderPromise) {
      const recorder = new Recorder(context, params, recorderAppFactory);
      recorderPromise = recorder.install().then(() => recorder);
      context[recorderSymbol] = recorderPromise;
    }

    return recorderPromise;
  }

  constructor(context, params, recorderAppFactory) {
    this._context = void 0;
    this._mode = void 0;
    this._highlightedSelector = '';
    this._recorderApp = null;
    this._currentCallsMetadata = new Map();
    this._recorderSources = [];
    this._userSources = new Map();
    this._debugger = void 0;
    this._contextRecorder = void 0;
    this._handleSIGINT = void 0;
    this._recorderAppFactory = void 0;
    this._omitCallTracking = false;
    this._mode = params.mode || 'none';
    this._recorderAppFactory = recorderAppFactory;
    this._contextRecorder = new ContextRecorder(context, params);
    this._context = context;
    this._omitCallTracking = !!params.omitCallTracking;
    this._debugger = _debugger.Debugger.lookup(context);
    this._handleSIGINT = params.handleSIGINT;
    context.instrumentation.addListener(this, context);
  }

  static async defaultRecorderAppFactory(recorder) {
    if (process.env.PW_CODEGEN_NO_INSPECTOR) return new _recorderApp.EmptyRecorderApp();
    return await _recorderApp.RecorderApp.open(recorder, recorder._context, recorder._handleSIGINT);
  }

  async install() {
    const recorderApp = await this._recorderAppFactory(this);
    this._recorderApp = recorderApp;
    recorderApp.once('close', () => {
      this._debugger.resume(false);

      this._recorderApp = null;
    });
    recorderApp.on('event', data => {
      if (data.event === 'setMode') {
        this.setMode(data.params.mode);
        return;
      }

      if (data.event === 'selectorUpdated') {
        this.setHighlightedSelector(data.params.selector);
        return;
      }

      if (data.event === 'step') {
        this._debugger.resume(true);

        return;
      }

      if (data.event === 'resume') {
        this._debugger.resume(false);

        return;
      }

      if (data.event === 'pause') {
        this._debugger.pauseOnNextStatement();

        return;
      }

      if (data.event === 'clear') {
        this._contextRecorder.clearScript();

        return;
      }
    });
    await Promise.all([recorderApp.setMode(this._mode), recorderApp.setPaused(this._debugger.isPaused()), this._pushAllSources()]);

    this._context.once(_browserContext.BrowserContext.Events.Close, () => {
      this._contextRecorder.dispose();

      this._context.instrumentation.removeListener(this);

      recorderApp.close().catch(() => {});
    });

    this._contextRecorder.on(ContextRecorder.Events.Change, data => {
      var _this$_recorderApp;

      this._recorderSources = data.sources;

      this._pushAllSources();

      (_this$_recorderApp = this._recorderApp) === null || _this$_recorderApp === void 0 ? void 0 : _this$_recorderApp.setFileIfNeeded(data.primaryFileName);
    });

    await this._context.exposeBinding('__pw_recorderState', false, source => {
      let actionSelector = this._highlightedSelector;
      let actionPoint;

      for (const [metadata, sdkObject] of this._currentCallsMetadata) {
        if (source.page === sdkObject.attribution.page) {
          actionPoint = metadata.point || actionPoint;
          actionSelector = actionSelector || metadata.params.selector;
        }
      }

      const uiState = {
        mode: this._mode,
        actionPoint,
        actionSelector
      };
      return uiState;
    });
    await this._context.exposeBinding('__pw_recorderSetSelector', false, async (_, selector) => {
      var _this$_recorderApp2;

      await ((_this$_recorderApp2 = this._recorderApp) === null || _this$_recorderApp2 === void 0 ? void 0 : _this$_recorderApp2.setSelector(selector, true));
    });
    await this._context.exposeBinding('__pw_resume', false, () => {
      this._debugger.resume(false);
    });
    await this._context.extendInjectedScript(consoleApiSource.source);
    await this._contextRecorder.install();
    if (this._debugger.isPaused()) this._pausedStateChanged();

    this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());

    this._context.recorderAppForTest = recorderApp;
  }

  _pausedStateChanged() {
    var _this$_recorderApp3;

    // If we are called upon page.pause, we don't have metadatas, populate them.
    for (const {
      metadata,
      sdkObject
    } of this._debugger.pausedDetails()) {
      if (!this._currentCallsMetadata.has(metadata)) this.onBeforeCall(sdkObject, metadata);
    }

    (_this$_recorderApp3 = this._recorderApp) === null || _this$_recorderApp3 === void 0 ? void 0 : _this$_recorderApp3.setPaused(this._debugger.isPaused());

    this._updateUserSources();

    this.updateCallLog([...this._currentCallsMetadata.keys()]);
  }

  setMode(mode) {
    var _this$_recorderApp4;

    if (this._mode === mode) return;
    this._highlightedSelector = '';
    this._mode = mode;
    (_this$_recorderApp4 = this._recorderApp) === null || _this$_recorderApp4 === void 0 ? void 0 : _this$_recorderApp4.setMode(this._mode);

    this._contextRecorder.setEnabled(this._mode === 'recording');

    this._debugger.setMuted(this._mode === 'recording');

    if (this._mode !== 'none' && this._context.pages().length === 1) this._context.pages()[0].bringToFront().catch(() => {});

    this._refreshOverlay();
  }

  setHighlightedSelector(selector) {
    this._highlightedSelector = selector;

    this._refreshOverlay();
  }

  setOutput(language, outputFile) {
    this._contextRecorder.setOutput(language, outputFile);
  }

  _refreshOverlay() {
    for (const page of this._context.pages()) page.mainFrame().evaluateExpression('window.__pw_refreshOverlay()', false, undefined, 'main').catch(() => {});
  }

  async onBeforeCall(sdkObject, metadata) {
    if (this._omitCallTracking || this._mode === 'recording') return;

    this._currentCallsMetadata.set(metadata, sdkObject);

    this._updateUserSources();

    this.updateCallLog([metadata]);

    if (metadata.params && metadata.params.selector) {
      var _this$_recorderApp5;

      this._highlightedSelector = metadata.params.selector;
      (_this$_recorderApp5 = this._recorderApp) === null || _this$_recorderApp5 === void 0 ? void 0 : _this$_recorderApp5.setSelector(this._highlightedSelector).catch(() => {});
    }
  }

  async onAfterCall(sdkObject, metadata) {
    if (this._omitCallTracking || this._mode === 'recording') return;
    if (!metadata.error) this._currentCallsMetadata.delete(metadata);

    this._updateUserSources();

    this.updateCallLog([metadata]);
  }

  _updateUserSources() {
    var _this$_recorderApp6;

    // Remove old decorations.
    for (const source of this._userSources.values()) {
      source.highlight = [];
      source.revealLine = undefined;
    } // Apply new decorations.


    let fileToSelect = undefined;

    for (const metadata of this._currentCallsMetadata.keys()) {
      if (!metadata.stack || !metadata.stack[0]) continue;
      const {
        file,
        line
      } = metadata.stack[0];

      let source = this._userSources.get(file);

      if (!source) {
        source = {
          isRecorded: false,
          file,
          text: this._readSource(file),
          highlight: [],
          language: languageForFile(file)
        };

        this._userSources.set(file, source);
      }

      if (line) {
        const paused = this._debugger.isPaused(metadata);

        source.highlight.push({
          line,
          type: metadata.error ? 'error' : paused ? 'paused' : 'running'
        });
        source.revealLine = line;
        fileToSelect = source.file;
      }
    }

    this._pushAllSources();

    if (fileToSelect) (_this$_recorderApp6 = this._recorderApp) === null || _this$_recorderApp6 === void 0 ? void 0 : _this$_recorderApp6.setFileIfNeeded(fileToSelect);
  }

  _pushAllSources() {
    var _this$_recorderApp7;

    (_this$_recorderApp7 = this._recorderApp) === null || _this$_recorderApp7 === void 0 ? void 0 : _this$_recorderApp7.setSources([...this._recorderSources, ...this._userSources.values()]);
  }

  async onBeforeInputAction(sdkObject, metadata) {}

  async onCallLog(sdkObject, metadata, logName, message) {
    this.updateCallLog([metadata]);
  }

  updateCallLog(metadatas) {
    var _this$_recorderApp8;

    if (this._mode === 'recording') return;
    const logs = [];

    for (const metadata of metadatas) {
      if (!metadata.method || metadata.internal) continue;
      let status = 'done';
      if (this._currentCallsMetadata.has(metadata)) status = 'in-progress';
      if (this._debugger.isPaused(metadata)) status = 'paused';
      logs.push((0, _recorderUtils.metadataToCallLog)(metadata, status));
    }

    (_this$_recorderApp8 = this._recorderApp) === null || _this$_recorderApp8 === void 0 ? void 0 : _this$_recorderApp8.updateCallLogs(logs);
  }

  _readSource(fileName) {
    try {
      return fs.readFileSync(fileName, 'utf-8');
    } catch (e) {
      return '// No source available';
    }
  }

}

exports.Recorder = Recorder;

class ContextRecorder extends _events.EventEmitter {
  constructor(context, params) {
    super();
    this._generator = void 0;
    this._pageAliases = new Map();
    this._lastPopupOrdinal = 0;
    this._lastDialogOrdinal = 0;
    this._lastDownloadOrdinal = 0;
    this._timers = new Set();
    this._context = void 0;
    this._params = void 0;
    this._recorderSources = void 0;
    this._throttledOutputFile = null;
    this._orderedLanguages = [];
    this._context = context;
    this._params = params;
    this._recorderSources = [];
    const language = params.language || context._browser.options.sdkLanguage;
    this.setOutput(language, params.outputFile);
    const generator = new _codeGenerator.CodeGenerator(context._browser.options.name, params.mode === 'recording', params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
    generator.on('change', () => {
      this._recorderSources = [];

      for (const languageGenerator of this._orderedLanguages) {
        var _this$_throttledOutpu;

        const source = {
          isRecorded: true,
          file: languageGenerator.fileName,
          text: generator.generateText(languageGenerator),
          language: languageGenerator.highlighter,
          highlight: []
        };
        source.revealLine = source.text.split('\n').length - 1;

        this._recorderSources.push(source);

        if (languageGenerator === this._orderedLanguages[0]) (_this$_throttledOutpu = this._throttledOutputFile) === null || _this$_throttledOutpu === void 0 ? void 0 : _this$_throttledOutpu.setContent(source.text);
      }

      this.emit(ContextRecorder.Events.Change, {
        sources: this._recorderSources,
        primaryFileName: this._orderedLanguages[0].fileName
      });
    });
    context.on(_browserContext.BrowserContext.Events.BeforeClose, () => {
      var _this$_throttledOutpu2;

      (_this$_throttledOutpu2 = this._throttledOutputFile) === null || _this$_throttledOutpu2 === void 0 ? void 0 : _this$_throttledOutpu2.flush();
    });
    process.on('exit', () => {
      var _this$_throttledOutpu3;

      (_this$_throttledOutpu3 = this._throttledOutputFile) === null || _this$_throttledOutpu3 === void 0 ? void 0 : _this$_throttledOutpu3.flush();
    });
    this._generator = generator;
  }

  setOutput(language, outputFile) {
    var _this$_generator;

    const languages = new Set([new _java.JavaLanguageGenerator(), new _javascript.JavaScriptLanguageGenerator(false), new _javascript.JavaScriptLanguageGenerator(true), new _python.PythonLanguageGenerator(false, false), new _python.PythonLanguageGenerator(true, false), new _python.PythonLanguageGenerator(false, true), new _csharp.CSharpLanguageGenerator()]);
    const primaryLanguage = [...languages].find(l => l.id === language);
    if (!primaryLanguage) throw new Error(`\n===============================\nUnsupported language: '${language}'\n===============================\n`);
    languages.delete(primaryLanguage);
    this._orderedLanguages = [primaryLanguage, ...languages];
    this._throttledOutputFile = outputFile ? new ThrottledFile(outputFile) : null;
    (_this$_generator = this._generator) === null || _this$_generator === void 0 ? void 0 : _this$_generator.restart();
  }

  async install() {
    this._context.on(_browserContext.BrowserContext.Events.Page, page => this._onPage(page));

    for (const page of this._context.pages()) this._onPage(page); // Input actions that potentially lead to navigation are intercepted on the page and are
    // performed by the Playwright.


    await this._context.exposeBinding('__pw_recorderPerformAction', false, (source, action) => this._performAction(source.frame, action)); // Other non-essential actions are simply being recorded.

    await this._context.exposeBinding('__pw_recorderRecordAction', false, (source, action) => this._recordAction(source.frame, action));
    await this._context.extendInjectedScript(recorderSource.source);
  }

  setEnabled(enabled) {
    this._generator.setEnabled(enabled);
  }

  dispose() {
    for (const timer of this._timers) clearTimeout(timer);

    this._timers.clear();
  }

  async _onPage(page) {
    // First page is called page, others are called popup1, popup2, etc.
    const frame = page.mainFrame();
    page.on('close', () => {
      this._generator.addAction({
        frame: this._describeMainFrame(page),
        committed: true,
        action: {
          name: 'closePage',
          signals: []
        }
      });

      this._pageAliases.delete(page);
    });
    frame.on(_frames.Frame.Events.InternalNavigation, event => {
      if (event.isPublic) this._onFrameNavigated(frame, page);
    });
    page.on(_page.Page.Events.Download, () => this._onDownload(page));
    page.on(_page.Page.Events.Dialog, () => this._onDialog(page));
    const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : '';
    const pageAlias = 'page' + suffix;

    this._pageAliases.set(page, pageAlias);

    if (page.opener()) {
      this._onPopup(page.opener(), page);
    } else {
      this._generator.addAction({
        frame: this._describeMainFrame(page),
        committed: true,
        action: {
          name: 'openPage',
          url: page.mainFrame().url(),
          signals: []
        }
      });
    }
  }

  clearScript() {
    this._generator.restart();

    if (this._params.mode === 'recording') {
      for (const page of this._context.pages()) this._onFrameNavigated(page.mainFrame(), page);
    }
  }

  _describeMainFrame(page) {
    return {
      pageAlias: this._pageAliases.get(page),
      isMainFrame: true,
      url: page.mainFrame().url()
    };
  }

  async _describeFrame(frame) {
    const page = frame._page;

    const pageAlias = this._pageAliases.get(page);

    const chain = [];

    for (let ancestor = frame; ancestor; ancestor = ancestor.parentFrame()) chain.push(ancestor);

    chain.reverse();
    if (chain.length === 1) return this._describeMainFrame(page);
    const hasUniqueName = page.frames().filter(f => f.name() === frame.name()).length === 1;
    const fallback = {
      pageAlias,
      isMainFrame: false,
      url: frame.url(),
      name: frame.name() && hasUniqueName ? frame.name() : undefined
    };
    if (chain.length > 3) return fallback;
    const selectorPromises = [];

    for (let i = 0; i < chain.length - 1; i++) selectorPromises.push(this._findFrameSelector(chain[i + 1], chain[i]));

    const result = await (0, _timeoutRunner.raceAgainstTimeout)(() => Promise.all(selectorPromises), 2000);

    if (!result.timedOut && result.result.every(selector => !!selector)) {
      return { ...fallback,
        selectorsChain: result.result
      };
    }

    return fallback;
  }

  async _findFrameSelector(frame, parent) {
    try {
      const frameElement = await frame.frameElement();
      if (!frameElement) return;
      const utility = await parent._utilityContext();
      const injected = await utility.injectedScript();
      const selector = await injected.evaluate((injected, element) => injected.generateSelector(element), frameElement);
      return selector;
    } catch (e) {}
  }

  async _performAction(frame, action) {
    // Commit last action so that no further signals are added to it.
    this._generator.commitLastAction();

    const frameDescription = await this._describeFrame(frame);
    const actionInContext = {
      frame: frameDescription,
      action
    };

    const perform = async (action, params, cb) => {
      const callMetadata = {
        id: `call@${(0, _utils2.createGuid)()}`,
        apiName: 'frame.' + action,
        objectId: frame.guid,
        pageId: frame._page.guid,
        frameId: frame.guid,
        wallTime: Date.now(),
        startTime: (0, _utils2.monotonicTime)(),
        endTime: 0,
        type: 'Frame',
        method: action,
        params,
        log: [],
        snapshots: []
      };

      this._generator.willPerformAction(actionInContext);

      try {
        await frame.instrumentation.onBeforeCall(frame, callMetadata);
        await cb(callMetadata);
      } catch (e) {
        callMetadata.endTime = (0, _utils2.monotonicTime)();
        await frame.instrumentation.onAfterCall(frame, callMetadata);

        this._generator.performedActionFailed(actionInContext);

        return;
      }

      callMetadata.endTime = (0, _utils2.monotonicTime)();
      await frame.instrumentation.onAfterCall(frame, callMetadata);
      const timer = setTimeout(() => {
        // Commit the action after 5 seconds so that no further signals are added to it.
        actionInContext.committed = true;

        this._timers.delete(timer);
      }, 5000);

      this._generator.didPerformAction(actionInContext);

      this._timers.add(timer);
    };

    const kActionTimeout = 5000;

    if (action.name === 'click') {
      const {
        options
      } = (0, _utils.toClickOptions)(action);
      await perform('click', {
        selector: action.selector
      }, callMetadata => frame.click(callMetadata, action.selector, { ...options,
        timeout: kActionTimeout,
        strict: true
      }));
    }

    if (action.name === 'press') {
      const modifiers = (0, _utils.toModifiers)(action.modifiers);
      const shortcut = [...modifiers, action.key].join('+');
      await perform('press', {
        selector: action.selector,
        key: shortcut
      }, callMetadata => frame.press(callMetadata, action.selector, shortcut, {
        timeout: kActionTimeout,
        strict: true
      }));
    }

    if (action.name === 'check') await perform('check', {
      selector: action.selector
    }, callMetadata => frame.check(callMetadata, action.selector, {
      timeout: kActionTimeout,
      strict: true
    }));
    if (action.name === 'uncheck') await perform('uncheck', {
      selector: action.selector
    }, callMetadata => frame.uncheck(callMetadata, action.selector, {
      timeout: kActionTimeout,
      strict: true
    }));

    if (action.name === 'select') {
      const values = action.options.map(value => ({
        value
      }));
      await perform('selectOption', {
        selector: action.selector,
        values
      }, callMetadata => frame.selectOption(callMetadata, action.selector, [], values, {
        timeout: kActionTimeout,
        strict: true
      }));
    }
  }

  async _recordAction(frame, action) {
    // Commit last action so that no further signals are added to it.
    this._generator.commitLastAction();

    const frameDescription = await this._describeFrame(frame);
    const actionInContext = {
      frame: frameDescription,
      action
    };

    this._generator.addAction(actionInContext);
  }

  _onFrameNavigated(frame, page) {
    const pageAlias = this._pageAliases.get(page);

    this._generator.signal(pageAlias, frame, {
      name: 'navigation',
      url: frame.url()
    });
  }

  _onPopup(page, popup) {
    const pageAlias = this._pageAliases.get(page);

    const popupAlias = this._pageAliases.get(popup);

    this._generator.signal(pageAlias, page.mainFrame(), {
      name: 'popup',
      popupAlias
    });
  }

  _onDownload(page) {
    const pageAlias = this._pageAliases.get(page);

    this._generator.signal(pageAlias, page.mainFrame(), {
      name: 'download',
      downloadAlias: String(++this._lastDownloadOrdinal)
    });
  }

  _onDialog(page) {
    const pageAlias = this._pageAliases.get(page);

    this._generator.signal(pageAlias, page.mainFrame(), {
      name: 'dialog',
      dialogAlias: String(++this._lastDialogOrdinal)
    });
  }

}

ContextRecorder.Events = {
  Change: 'change'
};

function languageForFile(file) {
  if (file.endsWith('.py')) return 'python';
  if (file.endsWith('.java')) return 'java';
  if (file.endsWith('.cs')) return 'csharp';
  return 'javascript';
}

class ThrottledFile {
  constructor(file) {
    this._file = void 0;
    this._timer = void 0;
    this._text = void 0;
    this._file = file;
  }

  setContent(text) {
    this._text = text;
    if (!this._timer) this._timer = setTimeout(() => this.flush(), 250);
  }

  flush() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = undefined;
    }

    if (this._text) fs.writeFileSync(this._file, this._text);
    this._text = undefined;
  }

}

/***/ }),

/***/ 9672:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CodeGenerator = void 0;

var _events = __nccwpck_require__(2361);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CodeGenerator extends _events.EventEmitter {
  constructor(browserName, enabled, launchOptions, contextOptions, deviceName, saveStorage) {
    super(); // Make a copy of options to modify them later.

    this._currentAction = null;
    this._lastAction = null;
    this._actions = [];
    this._enabled = void 0;
    this._options = void 0;
    launchOptions = {
      headless: false,
      ...launchOptions
    };
    contextOptions = { ...contextOptions
    };
    this._enabled = enabled;
    this._options = {
      browserName,
      launchOptions,
      contextOptions,
      deviceName,
      saveStorage
    };
    this.restart();
  }

  restart() {
    this._currentAction = null;
    this._lastAction = null;
    this._actions = [];
    this.emit('change');
  }

  setEnabled(enabled) {
    this._enabled = enabled;
  }

  addAction(action) {
    if (!this._enabled) return;
    this.willPerformAction(action);
    this.didPerformAction(action);
  }

  willPerformAction(action) {
    if (!this._enabled) return;
    this._currentAction = action;
  }

  performedActionFailed(action) {
    if (!this._enabled) return;
    if (this._currentAction === action) this._currentAction = null;
  }

  didPerformAction(actionInContext) {
    if (!this._enabled) return;
    const action = actionInContext.action;
    let eraseLastAction = false;

    if (this._lastAction && this._lastAction.frame.pageAlias === actionInContext.frame.pageAlias) {
      const lastAction = this._lastAction.action; // We augment last action based on the type.

      if (this._lastAction && action.name === 'fill' && lastAction.name === 'fill') {
        if (action.selector === lastAction.selector) eraseLastAction = true;
      }

      if (lastAction && action.name === 'click' && lastAction.name === 'click') {
        if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount) eraseLastAction = true;
      }

      if (lastAction && action.name === 'navigate' && lastAction.name === 'navigate') {
        if (action.url === lastAction.url) {
          // Already at a target URL.
          this._currentAction = null;
          return;
        }
      } // Check and uncheck erase click.


      if (lastAction && (action.name === 'check' || action.name === 'uncheck') && lastAction.name === 'click') {
        if (action.selector === lastAction.selector) eraseLastAction = true;
      }
    }

    this._lastAction = actionInContext;
    this._currentAction = null;
    if (eraseLastAction) this._actions.pop();

    this._actions.push(actionInContext);

    this.emit('change');
  }

  commitLastAction() {
    if (!this._enabled) return;
    const action = this._lastAction;
    if (action) action.committed = true;
  }

  signal(pageAlias, frame, signal) {
    if (!this._enabled) return; // Signal either arrives while action is being performed or shortly after.

    if (this._currentAction) {
      this._currentAction.action.signals.push(signal);

      return;
    }

    if (this._lastAction && !this._lastAction.committed) {
      const signals = this._lastAction.action.signals;
      if (signal.name === 'navigation' && signals.length && signals[signals.length - 1].name === 'download') return;
      if (signal.name === 'download' && signals.length && signals[signals.length - 1].name === 'navigation') signals.length = signals.length - 1;

      this._lastAction.action.signals.push(signal);

      this.emit('change');
      return;
    }

    if (signal.name === 'navigation') {
      this.addAction({
        frame: {
          pageAlias,
          isMainFrame: frame._page.mainFrame() === frame,
          url: frame.url()
        },
        committed: true,
        action: {
          name: 'navigate',
          url: frame.url(),
          signals: []
        }
      });
    }
  }

  generateText(languageGenerator) {
    const text = [];
    text.push(languageGenerator.generateHeader(this._options));

    for (const action of this._actions) {
      const actionText = languageGenerator.generateAction(action);
      if (actionText) text.push(actionText);
    }

    text.push(languageGenerator.generateFooter(this._options.saveStorage));
    return text.join('\n');
  }

}

exports.CodeGenerator = CodeGenerator;

/***/ }),

/***/ 6514:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CSharpLanguageGenerator = void 0;

var _language = __nccwpck_require__(2067);

var _recorderActions = __nccwpck_require__(8077);

var _utils = __nccwpck_require__(5704);

var _stringUtils = __nccwpck_require__(7517);

var _deviceDescriptors = _interopRequireDefault(__nccwpck_require__(2327));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CSharpLanguageGenerator {
  constructor() {
    this.id = 'csharp';
    this.fileName = 'C#';
    this.highlighter = 'csharp';
  }

  generateAction(actionInContext) {
    const action = actionInContext.action;
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new CSharpFormatter(8);
    formatter.newLine();
    formatter.add('// ' + (0, _recorderActions.actionTitle)(action));

    if (action.name === 'openPage') {
      formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
      return formatter.format();
    }

    let subject;

    if (actionInContext.frame.isMainFrame) {
      subject = pageAlias;
    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {
      const locators = actionInContext.frame.selectorsChain.map(selector => '.' + asLocator(selector, 'FrameLocator'));
      subject = `${pageAlias}${locators.join('')}`;
    } else if (actionInContext.frame.name) {
      subject = `${pageAlias}.Frame(${quote(actionInContext.frame.name)})`;
    } else {
      subject = `${pageAlias}.FrameByUrl(${quote(actionInContext.frame.url)})`;
    }

    const signals = (0, _language.toSignalMap)(action);

    if (signals.dialog) {
      formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
    }

    const lines = [];

    const actionCall = this._generateActionCall(action, actionInContext.frame.isMainFrame);

    lines.push(`await ${subject}.${actionCall};`);

    if (signals.download) {
      lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>\n{`);
      lines.push(`});`);
    }

    if (signals.popup) {
      lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>\n{`);
      lines.push(`});`);
    }

    for (const line of lines) formatter.add(line);

    if (signals.assertNavigation) formatter.add(`await ${pageAlias}.WaitForURLAsync(${quote(signals.assertNavigation.url)});`);
    return formatter.format();
  }

  _generateActionCall(action, isPage) {
    switch (action.name) {
      case 'openPage':
        throw Error('Not reached');

      case 'closePage':
        return 'CloseAsync()';

      case 'click':
        {
          let method = 'Click';
          if (action.clickCount === 2) method = 'DblClick';
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const options = {};
          if (action.button !== 'left') options.button = action.button;
          if (modifiers.length) options.modifiers = modifiers;
          if (action.clickCount > 2) options.clickCount = action.clickCount;
          if (action.position) options.position = action.position;
          if (!Object.entries(options).length) return asLocator(action.selector) + `.${method}Async()`;
          const optionsString = formatObject(options, '    ', 'Locator' + method + 'Options');
          return asLocator(action.selector) + `.${method}Async(${optionsString})`;
        }

      case 'check':
        return asLocator(action.selector) + `.CheckAsync()`;

      case 'uncheck':
        return asLocator(action.selector) + `.UncheckAsync()`;

      case 'fill':
        return asLocator(action.selector) + `.FillAsync(${quote(action.text)})`;

      case 'setInputFiles':
        return asLocator(action.selector) + `.SetInputFilesAsync(${formatObject(action.files)})`;

      case 'press':
        {
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const shortcut = [...modifiers, action.key].join('+');
          return asLocator(action.selector) + `.PressAsync(${quote(shortcut)})`;
        }

      case 'navigate':
        return `GotoAsync(${quote(action.url)})`;

      case 'select':
        return asLocator(action.selector) + `.SelectOptionAsync(${formatObject(action.options)})`;
    }
  }

  generateHeader(options) {
    const formatter = new CSharpFormatter(0);
    formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      class Program
      {
          public static async Task Main()
          {
              using var playwright = await Playwright.CreateAsync();
              await using var browser = await playwright.${toPascal(options.browserName)}.LaunchAsync(${formatObject(options.launchOptions, '    ', 'BrowserTypeLaunchOptions')});
              var context = await browser.NewContextAsync(${formatContextOptions(options.contextOptions, options.deviceName)});`);
    return formatter.format();
  }

  generateFooter(saveStorage) {
    const storageStateLine = saveStorage ? `\n        await context.StorageStateAsync(new BrowserContextStorageStateOptions\n        {\n            Path = ${quote(saveStorage)}\n        });\n` : '';
    return `${storageStateLine}    }
}\n`;
  }

}

exports.CSharpLanguageGenerator = CSharpLanguageGenerator;

function formatObject(value, indent = '    ', name = '') {
  if (typeof value === 'string') {
    if (['permissions', 'colorScheme', 'modifiers', 'button', 'recordHarContent', 'recordHarMode', 'serviceWorkers'].includes(name)) return `${getClassName(name)}.${toPascal(value)}`;
    return quote(value);
  }

  if (Array.isArray(value)) return `new[] { ${value.map(o => formatObject(o, indent, name)).join(', ')} }`;

  if (typeof value === 'object') {
    const keys = Object.keys(value).filter(key => value[key] !== undefined).sort();
    if (!keys.length) return name ? `new ${getClassName(name)}` : '';
    const tokens = [];

    for (const key of keys) {
      const property = getPropertyName(key);
      tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
    }

    if (name) return `new ${getClassName(name)}\n{\n${indent}${tokens.join(`\n${indent}`)}\n${indent}}`;
    return `{\n${indent}${tokens.join(`\n${indent}`)}\n${indent}}`;
  }

  if (name === 'latitude' || name === 'longitude') return String(value) + 'm';
  return String(value);
}

function getClassName(value) {
  switch (value) {
    case 'viewport':
      return 'ViewportSize';

    case 'proxy':
      return 'ProxySettings';

    case 'permissions':
      return 'ContextPermission';

    case 'modifiers':
      return 'KeyboardModifier';

    case 'button':
      return 'MouseButton';

    case 'recordHarMode':
      return 'HarMode';

    case 'recordHarContent':
      return 'HarContentPolicy';

    case 'serviceWorkers':
      return 'ServiceWorkerPolicy';

    default:
      return toPascal(value);
  }
}

function getPropertyName(key) {
  switch (key) {
    case 'storageState':
      return 'StorageStatePath';

    case 'viewport':
      return 'ViewportSize';

    default:
      return toPascal(key);
  }
}

function toPascal(value) {
  return value[0].toUpperCase() + value.slice(1);
}

function convertContextOptions(options) {
  const result = { ...options
  };

  if (options.recordHar) {
    result['recordHarPath'] = options.recordHar.path;
    result['recordHarContent'] = options.recordHar.content;
    result['recordHarMode'] = options.recordHar.mode;
    result['recordHarOmitContent'] = options.recordHar.omitContent;
    result['recordHarUrlFilter'] = options.recordHar.urlFilter;
    delete result.recordHar;
  }

  return result;
}

function formatContextOptions(options, deviceName) {
  const device = deviceName && _deviceDescriptors.default[deviceName];

  if (!device) {
    if (!Object.entries(options).length) return '';
    return formatObject(convertContextOptions(options), '    ', 'BrowserNewContextOptions');
  }

  options = (0, _language.sanitizeDeviceOptions)(device, options);
  if (!Object.entries(options).length) return `playwright.Devices[${quote(deviceName)}]`;
  return formatObject(convertContextOptions(options), '    ', `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
}

class CSharpFormatter {
  constructor(offset = 0) {
    this._baseIndent = void 0;
    this._baseOffset = void 0;
    this._lines = [];
    this._baseIndent = ' '.repeat(4);
    this._baseOffset = ' '.repeat(offset);
  }

  prepend(text) {
    this._lines = text.trim().split('\n').map(line => line.trim()).concat(this._lines);
  }

  add(text) {
    this._lines.push(...text.trim().split('\n').map(line => line.trim()));
  }

  newLine() {
    this._lines.push('');
  }

  format() {
    let spaces = '';
    let previousLine = '';
    return this._lines.map(line => {
      if (line === '') return line;
      if (line.startsWith('}') || line.startsWith(']') || line.includes('});') || line === ');') spaces = spaces.substring(this._baseIndent.length);
      const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : '';
      previousLine = line;
      line = spaces + extraSpaces + line;
      if (line.endsWith('{') || line.endsWith('[') || line.endsWith('(')) spaces += this._baseIndent;
      if (line.endsWith('));')) spaces = spaces.substring(this._baseIndent.length);
      return this._baseOffset + line;
    }).join('\n');
  }

}

function quote(text) {
  return (0, _stringUtils.escapeWithQuotes)(text, '\"');
}

function asLocator(selector, locatorFn = 'Locator') {
  const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
  if (!match) return `${locatorFn}(${quote(selector)})`;
  if (+match[2] === 0) return `${locatorFn}(${quote(match[1])}).First`;
  return `${locatorFn}(${quote(match[1])}).Nth(${match[2]})`;
}

/***/ }),

/***/ 9359:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JavaLanguageGenerator = void 0;

var _language = __nccwpck_require__(2067);

var _recorderActions = __nccwpck_require__(8077);

var _utils = __nccwpck_require__(5704);

var _deviceDescriptors = _interopRequireDefault(__nccwpck_require__(2327));

var _javascript = __nccwpck_require__(5954);

var _stringUtils = __nccwpck_require__(7517);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JavaLanguageGenerator {
  constructor() {
    this.id = 'java';
    this.fileName = 'Java';
    this.highlighter = 'java';
  }

  generateAction(actionInContext) {
    const action = actionInContext.action;
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new _javascript.JavaScriptFormatter(6);
    formatter.newLine();
    formatter.add('// ' + (0, _recorderActions.actionTitle)(action));

    if (action.name === 'openPage') {
      formatter.add(`Page ${pageAlias} = context.newPage();`);
      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`${pageAlias}.navigate(${quote(action.url)});`);
      return formatter.format();
    }

    let subject;

    if (actionInContext.frame.isMainFrame) {
      subject = pageAlias;
    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {
      const locators = actionInContext.frame.selectorsChain.map(selector => '.' + asLocator(selector, 'frameLocator'));
      subject = `${pageAlias}${locators.join('')}`;
    } else if (actionInContext.frame.name) {
      subject = `${pageAlias}.frame(${quote(actionInContext.frame.name)})`;
    } else {
      subject = `${pageAlias}.frameByUrl(${quote(actionInContext.frame.url)})`;
    }

    const signals = (0, _language.toSignalMap)(action);

    if (signals.dialog) {
      formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
    }

    const actionCall = this._generateActionCall(action);

    let code = `${subject}.${actionCall};`;

    if (signals.popup) {
      code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
    }

    if (signals.download) {
      code = `Download download = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
    }

    formatter.add(code);
    if (signals.assertNavigation) formatter.add(`assertThat(${pageAlias}).hasURL(${quote(signals.assertNavigation.url)});`);
    return formatter.format();
  }

  _generateActionCall(action) {
    switch (action.name) {
      case 'openPage':
        throw Error('Not reached');

      case 'closePage':
        return 'close()';

      case 'click':
        {
          let method = 'click';
          if (action.clickCount === 2) method = 'dblclick';
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const options = {};
          if (action.button !== 'left') options.button = action.button;
          if (modifiers.length) options.modifiers = modifiers;
          if (action.clickCount > 2) options.clickCount = action.clickCount;
          if (action.position) options.position = action.position;
          const optionsText = formatClickOptions(options);
          return asLocator(action.selector) + `.${method}(${optionsText})`;
        }

      case 'check':
        return asLocator(action.selector) + `.check()`;

      case 'uncheck':
        return asLocator(action.selector) + `.uncheck()`;

      case 'fill':
        return asLocator(action.selector) + `.fill(${quote(action.text)})`;

      case 'setInputFiles':
        return asLocator(action.selector) + `.setInputFiles(${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;

      case 'press':
        {
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const shortcut = [...modifiers, action.key].join('+');
          return asLocator(action.selector) + `.press(${quote(shortcut)})`;
        }

      case 'navigate':
        return `navigate(${quote(action.url)})`;

      case 'select':
        return asLocator(action.selector) + `.selectOption(${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
    }
  }

  generateHeader(options) {
    const formatter = new _javascript.JavaScriptFormatter();
    formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;
    import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options.browserName}().launch(${formatLaunchOptions(options.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
    return formatter.format();
  }

  generateFooter(saveStorage) {
    const storageStateLine = saveStorage ? `\n      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));\n` : '';
    return `${storageStateLine}    }
  }
}`;
  }

}

exports.JavaLanguageGenerator = JavaLanguageGenerator;

function formatPath(files) {
  if (Array.isArray(files)) {
    if (files.length === 0) return 'new Path[0]';
    return `new Path[] {${files.map(s => 'Paths.get(' + quote(s) + ')').join(', ')}}`;
  }

  return `Paths.get(${quote(files)})`;
}

function formatSelectOption(options) {
  if (Array.isArray(options)) {
    if (options.length === 0) return 'new String[0]';
    return `new String[] {${options.map(s => quote(s)).join(', ')}}`;
  }

  return quote(options);
}

function formatLaunchOptions(options) {
  const lines = [];
  if (!Object.keys(options).filter(key => options[key] !== undefined).length) return '';
  lines.push('new BrowserType.LaunchOptions()');
  if (options.channel) lines.push(`  .setChannel(${quote(options.channel)})`);
  if (typeof options.headless === 'boolean') lines.push(`  .setHeadless(false)`);
  return lines.join('\n');
}

function formatContextOptions(contextOptions, deviceName) {
  var _options$recordHar, _options$recordHar2, _options$recordHar3, _options$recordHar4, _options$recordHar5, _options$recordHar6, _options$recordHar7;

  const lines = [];
  if (!Object.keys(contextOptions).length && !deviceName) return '';
  const device = deviceName ? _deviceDescriptors.default[deviceName] : {};
  const options = { ...device,
    ...contextOptions
  };
  lines.push('new Browser.NewContextOptions()');
  if (options.acceptDownloads) lines.push(`  .setAcceptDownloads(true)`);
  if (options.bypassCSP) lines.push(`  .setBypassCSP(true)`);
  if (options.colorScheme) lines.push(`  .setColorScheme(ColorScheme.${options.colorScheme.toUpperCase()})`);
  if (options.deviceScaleFactor) lines.push(`  .setDeviceScaleFactor(${options.deviceScaleFactor})`);
  if (options.geolocation) lines.push(`  .setGeolocation(${options.geolocation.latitude}, ${options.geolocation.longitude})`);
  if (options.hasTouch) lines.push(`  .setHasTouch(${options.hasTouch})`);
  if (options.isMobile) lines.push(`  .setIsMobile(${options.isMobile})`);
  if (options.locale) lines.push(`  .setLocale(${quote(options.locale)})`);
  if (options.proxy) lines.push(`  .setProxy(new Proxy(${quote(options.proxy.server)}))`);
  if ((_options$recordHar = options.recordHar) !== null && _options$recordHar !== void 0 && _options$recordHar.content) lines.push(`  .setRecordHarContent(HarContentPolicy.${(_options$recordHar2 = options.recordHar) === null || _options$recordHar2 === void 0 ? void 0 : _options$recordHar2.content.toUpperCase()})`);
  if ((_options$recordHar3 = options.recordHar) !== null && _options$recordHar3 !== void 0 && _options$recordHar3.mode) lines.push(`  .setRecordHarMode(HarMode.${(_options$recordHar4 = options.recordHar) === null || _options$recordHar4 === void 0 ? void 0 : _options$recordHar4.mode.toUpperCase()})`);
  if ((_options$recordHar5 = options.recordHar) !== null && _options$recordHar5 !== void 0 && _options$recordHar5.omitContent) lines.push(`  .setRecordHarOmitContent(true)`);
  if ((_options$recordHar6 = options.recordHar) !== null && _options$recordHar6 !== void 0 && _options$recordHar6.path) lines.push(`  .setRecordHarPath(Paths.get(${quote(options.recordHar.path)}))`);
  if ((_options$recordHar7 = options.recordHar) !== null && _options$recordHar7 !== void 0 && _options$recordHar7.urlFilter) lines.push(`  .setRecordHarUrlFilter(${quote(options.recordHar.urlFilter)})`);
  if (options.serviceWorkers) lines.push(`  .setServiceWorkers(ServiceWorkerPolicy.${options.serviceWorkers.toUpperCase()})`);
  if (options.storageState) lines.push(`  .setStorageStatePath(Paths.get(${quote(options.storageState)}))`);
  if (options.timezoneId) lines.push(`  .setTimezoneId(${quote(options.timezoneId)})`);
  if (options.userAgent) lines.push(`  .setUserAgent(${quote(options.userAgent)})`);
  if (options.viewport) lines.push(`  .setViewportSize(${options.viewport.width}, ${options.viewport.height})`);
  return lines.join('\n');
}

function formatClickOptions(options) {
  const lines = [];
  if (options.button) lines.push(`  .setButton(MouseButton.${options.button.toUpperCase()})`);
  if (options.modifiers) lines.push(`  .setModifiers(Arrays.asList(${options.modifiers.map(m => `KeyboardModifier.${m.toUpperCase()}`).join(', ')}))`);
  if (options.clickCount) lines.push(`  .setClickCount(${options.clickCount})`);
  if (options.position) lines.push(`  .setPosition(${options.position.x}, ${options.position.y})`);
  if (!lines.length) return '';
  lines.unshift(`new Locator.ClickOptions()`);
  return lines.join('\n');
}

function quote(text) {
  return (0, _stringUtils.escapeWithQuotes)(text, '\"');
}

function asLocator(selector, locatorFn = 'locator') {
  const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
  if (!match) return `${locatorFn}(${quote(selector)})`;
  if (+match[2] === 0) return `${locatorFn}(${quote(match[1])}).first()`;
  return `${locatorFn}(${quote(match[1])}).nth(${match[2]})`;
}

/***/ }),

/***/ 5954:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JavaScriptLanguageGenerator = exports.JavaScriptFormatter = void 0;

var _language = __nccwpck_require__(2067);

var _recorderActions = __nccwpck_require__(8077);

var _utils = __nccwpck_require__(5704);

var _deviceDescriptors = _interopRequireDefault(__nccwpck_require__(2327));

var _stringUtils = __nccwpck_require__(7517);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JavaScriptLanguageGenerator {
  constructor(isTest) {
    this.id = void 0;
    this.fileName = void 0;
    this.highlighter = 'javascript';
    this._isTest = void 0;
    this.id = isTest ? 'test' : 'javascript';
    this.fileName = isTest ? 'Playwright Test' : 'JavaScript';
    this._isTest = isTest;
  }

  generateAction(actionInContext) {
    const action = actionInContext.action;
    if (this._isTest && (action.name === 'openPage' || action.name === 'closePage')) return '';
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new JavaScriptFormatter(2);
    formatter.newLine();
    formatter.add('// ' + (0, _recorderActions.actionTitle)(action));

    if (action.name === 'openPage') {
      formatter.add(`const ${pageAlias} = await context.newPage();`);
      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
      return formatter.format();
    }

    let subject;

    if (actionInContext.frame.isMainFrame) {
      subject = pageAlias;
    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {
      const locators = actionInContext.frame.selectorsChain.map(selector => '.' + asLocator(selector, 'frameLocator'));
      subject = `${pageAlias}${locators.join('')}`;
    } else if (actionInContext.frame.name) {
      subject = `${pageAlias}.frame(${formatObject({
        name: actionInContext.frame.name
      })})`;
    } else {
      subject = `${pageAlias}.frame(${formatObject({
        url: actionInContext.frame.url
      })})`;
    }

    const signals = (0, _language.toSignalMap)(action);

    if (signals.dialog) {
      formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: $\{dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
    }

    const emitPromiseAll = signals.popup || signals.download;

    if (emitPromiseAll) {
      // Generate either await Promise.all([]) or
      // const [popup1] = await Promise.all([]).
      let leftHandSide = '';
      if (signals.popup) leftHandSide = `const [${signals.popup.popupAlias}] = `;else if (signals.download) leftHandSide = `const [download] = `;
      formatter.add(`${leftHandSide}await Promise.all([`);
    } // Popup signals.


    if (signals.popup) formatter.add(`${pageAlias}.waitForEvent('popup'),`); // Download signals.

    if (signals.download) formatter.add(`${pageAlias}.waitForEvent('download'),`);
    const prefix = signals.popup || signals.download ? '' : 'await ';

    const actionCall = this._generateActionCall(action);

    const suffix = emitPromiseAll ? '' : ';';
    formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);

    if (emitPromiseAll) {
      formatter.add(`]);`);
    } else if (signals.assertNavigation) {
      if (this._isTest) formatter.add(`await expect(${pageAlias}).toHaveURL(${quote(signals.assertNavigation.url)});`);else formatter.add(`await ${pageAlias}.waitForURL(${quote(signals.assertNavigation.url)});`);
    }

    return formatter.format();
  }

  _generateActionCall(action) {
    switch (action.name) {
      case 'openPage':
        throw Error('Not reached');

      case 'closePage':
        return 'close()';

      case 'click':
        {
          let method = 'click';
          if (action.clickCount === 2) method = 'dblclick';
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const options = {};
          if (action.button !== 'left') options.button = action.button;
          if (modifiers.length) options.modifiers = modifiers;
          if (action.clickCount > 2) options.clickCount = action.clickCount;
          if (action.position) options.position = action.position;
          const optionsString = formatOptions(options, false);
          return asLocator(action.selector) + `.${method}(${optionsString})`;
        }

      case 'check':
        return asLocator(action.selector) + `.check()`;

      case 'uncheck':
        return asLocator(action.selector) + `.uncheck()`;

      case 'fill':
        return asLocator(action.selector) + `.fill(${quote(action.text)})`;

      case 'setInputFiles':
        return asLocator(action.selector) + `.setInputFiles(${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;

      case 'press':
        {
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const shortcut = [...modifiers, action.key].join('+');
          return asLocator(action.selector) + `.press(${quote(shortcut)})`;
        }

      case 'navigate':
        return `goto(${quote(action.url)})`;

      case 'select':
        return asLocator(action.selector) + `.selectOption(${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
    }
  }

  generateHeader(options) {
    if (this._isTest) return this.generateTestHeader(options);
    return this.generateStandaloneHeader(options);
  }

  generateFooter(saveStorage) {
    if (this._isTest) return this.generateTestFooter(saveStorage);
    return this.generateStandaloneFooter(saveStorage);
  }

  generateTestHeader(options) {
    const formatter = new JavaScriptFormatter();
    const useText = formatContextOptions(options.contextOptions, options.deviceName);
    formatter.add(`
      import { test, expect${options.deviceName ? ', devices' : ''} } from '@playwright/test';
${useText ? '\ntest.use(' + useText + ');\n' : ''}
      test('test', async ({ page }) => {`);
    return formatter.format();
  }

  generateTestFooter(saveStorage) {
    return `\n});`;
  }

  generateStandaloneHeader(options) {
    const formatter = new JavaScriptFormatter();
    formatter.add(`
      const { ${options.browserName}${options.deviceName ? ', devices' : ''} } = require('playwright');

      (async () => {
        const browser = await ${options.browserName}.launch(${formatObjectOrVoid(options.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
    return formatter.format();
  }

  generateStandaloneFooter(saveStorage) {
    const storageStateLine = saveStorage ? `\n  await context.storageState({ path: ${quote(saveStorage)} });` : '';
    return `\n  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
  }

}

exports.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;

function asLocator(selector, locatorFn = 'locator') {
  const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
  if (!match) return `${locatorFn}(${quote(selector)})`;
  if (+match[2] === 0) return `${locatorFn}(${quote(match[1])}).first()`;
  return `${locatorFn}(${quote(match[1])}).nth(${match[2]})`;
}

function formatOptions(value, hasArguments) {
  const keys = Object.keys(value);
  if (!keys.length) return '';
  return (hasArguments ? ', ' : '') + formatObject(value);
}

function formatObject(value, indent = '  ') {
  if (typeof value === 'string') return quote(value);
  if (Array.isArray(value)) return `[${value.map(o => formatObject(o)).join(', ')}]`;

  if (typeof value === 'object') {
    const keys = Object.keys(value).filter(key => value[key] !== undefined).sort();
    if (!keys.length) return '{}';
    const tokens = [];

    for (const key of keys) tokens.push(`${key}: ${formatObject(value[key])}`);

    return `{\n${indent}${tokens.join(`,\n${indent}`)}\n}`;
  }

  return String(value);
}

function formatObjectOrVoid(value, indent = '  ') {
  const result = formatObject(value, indent);
  return result === '{}' ? '' : result;
}

function formatContextOptions(options, deviceName) {
  const device = deviceName && _deviceDescriptors.default[deviceName];
  if (!device) return formatObjectOrVoid(options); // Filter out all the properties from the device descriptor.

  let serializedObject = formatObjectOrVoid((0, _language.sanitizeDeviceOptions)(device, options)); // When there are no additional context options, we still want to spread the device inside.

  if (!serializedObject) serializedObject = '{\n}';
  const lines = serializedObject.split('\n');
  lines.splice(1, 0, `...devices[${quote(deviceName)}],`);
  return lines.join('\n');
}

class JavaScriptFormatter {
  constructor(offset = 0) {
    this._baseIndent = void 0;
    this._baseOffset = void 0;
    this._lines = [];
    this._baseIndent = ' '.repeat(2);
    this._baseOffset = ' '.repeat(offset);
  }

  prepend(text) {
    this._lines = text.trim().split('\n').map(line => line.trim()).concat(this._lines);
  }

  add(text) {
    this._lines.push(...text.trim().split('\n').map(line => line.trim()));
  }

  newLine() {
    this._lines.push('');
  }

  format() {
    let spaces = '';
    let previousLine = '';
    return this._lines.map(line => {
      if (line === '') return line;
      if (line.startsWith('}') || line.startsWith(']')) spaces = spaces.substring(this._baseIndent.length);
      const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : '';
      previousLine = line;
      const callCarryOver = line.startsWith('.set');
      line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : '') + line;
      if (line.endsWith('{') || line.endsWith('[')) spaces += this._baseIndent;
      return this._baseOffset + line;
    }).join('\n');
  }

}

exports.JavaScriptFormatter = JavaScriptFormatter;

function quote(text) {
  return (0, _stringUtils.escapeWithQuotes)(text, '\'');
}

/***/ }),

/***/ 2067:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.sanitizeDeviceOptions = sanitizeDeviceOptions;
exports.toSignalMap = toSignalMap;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function sanitizeDeviceOptions(device, options) {
  // Filter out all the properties from the device descriptor.
  const cleanedOptions = {};

  for (const property in options) {
    if (JSON.stringify(device[property]) !== JSON.stringify(options[property])) cleanedOptions[property] = options[property];
  }

  return cleanedOptions;
}

function toSignalMap(action) {
  let assertNavigation;
  let popup;
  let download;
  let dialog;

  for (const signal of action.signals) {
    if (signal.name === 'navigation') assertNavigation = signal;else if (signal.name === 'popup') popup = signal;else if (signal.name === 'download') download = signal;else if (signal.name === 'dialog') dialog = signal;
  }

  return {
    assertNavigation,
    popup,
    download,
    dialog
  };
}

/***/ }),

/***/ 3082:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PythonLanguageGenerator = void 0;

var _language = __nccwpck_require__(2067);

var _recorderActions = __nccwpck_require__(8077);

var _utils = __nccwpck_require__(5704);

var _stringUtils = __nccwpck_require__(7517);

var _deviceDescriptors = _interopRequireDefault(__nccwpck_require__(2327));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PythonLanguageGenerator {
  constructor(isAsync, isPyTest) {
    this.id = 'python';
    this.fileName = 'Python';
    this.highlighter = 'python';
    this._awaitPrefix = void 0;
    this._asyncPrefix = void 0;
    this._isAsync = void 0;
    this._isPyTest = void 0;
    this.id = isPyTest ? 'pytest' : isAsync ? 'python-async' : 'python';
    this.fileName = isPyTest ? 'Pytest' : isAsync ? 'Python Async' : 'Python';
    this._isAsync = isAsync;
    this._isPyTest = isPyTest;
    this._awaitPrefix = isAsync ? 'await ' : '';
    this._asyncPrefix = isAsync ? 'async ' : '';
  }

  generateAction(actionInContext) {
    const action = actionInContext.action;
    if (this._isPyTest && (action.name === 'openPage' || action.name === 'closePage')) return '';
    const pageAlias = actionInContext.frame.pageAlias;
    const formatter = new PythonFormatter(4);
    formatter.newLine();
    formatter.add('# ' + (0, _recorderActions.actionTitle)(action));

    if (action.name === 'openPage') {
      formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
      if (action.url && action.url !== 'about:blank' && action.url !== 'chrome://newtab/') formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
      return formatter.format();
    }

    let subject;

    if (actionInContext.frame.isMainFrame) {
      subject = pageAlias;
    } else if (actionInContext.frame.selectorsChain && action.name !== 'navigate') {
      const locators = actionInContext.frame.selectorsChain.map(selector => '.' + asLocator(selector, 'frame_locator'));
      subject = `${pageAlias}${locators.join('')}`;
    } else if (actionInContext.frame.name) {
      subject = `${pageAlias}.frame(${formatOptions({
        name: actionInContext.frame.name
      }, false)})`;
    } else {
      subject = `${pageAlias}.frame(${formatOptions({
        url: actionInContext.frame.url
      }, false)})`;
    }

    const signals = (0, _language.toSignalMap)(action);
    if (signals.dialog) formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);

    const actionCall = this._generateActionCall(action);

    let code = `${this._awaitPrefix}${subject}.${actionCall}`;

    if (signals.popup) {
      code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as popup_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}popup_info.value`;
    }

    if (signals.download) {
      code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download_info {
        ${code}
      }
      download = ${this._awaitPrefix}download_info.value`;
    }

    formatter.add(code);

    if (signals.assertNavigation) {
      if (this._isPyTest) formatter.add(`${this._awaitPrefix}expect(${pageAlias}).to_have_url(${quote(signals.assertNavigation.url)})`);else formatter.add(`${this._awaitPrefix}${pageAlias}.wait_for_url(${quote(signals.assertNavigation.url)})`);
    }

    return formatter.format();
  }

  _generateActionCall(action) {
    switch (action.name) {
      case 'openPage':
        throw Error('Not reached');

      case 'closePage':
        return 'close()';

      case 'click':
        {
          let method = 'click';
          if (action.clickCount === 2) method = 'dblclick';
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const options = {};
          if (action.button !== 'left') options.button = action.button;
          if (modifiers.length) options.modifiers = modifiers;
          if (action.clickCount > 2) options.clickCount = action.clickCount;
          if (action.position) options.position = action.position;
          const optionsString = formatOptions(options, false);
          return asLocator(action.selector) + `.${method}(${optionsString})`;
        }

      case 'check':
        return asLocator(action.selector) + `.check()`;

      case 'uncheck':
        return asLocator(action.selector) + `.uncheck()`;

      case 'fill':
        return asLocator(action.selector) + `.fill(${quote(action.text)})`;

      case 'setInputFiles':
        return asLocator(action.selector) + `.set_input_files(${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;

      case 'press':
        {
          const modifiers = (0, _utils.toModifiers)(action.modifiers);
          const shortcut = [...modifiers, action.key].join('+');
          return asLocator(action.selector) + `.press(${quote(shortcut)})`;
        }

      case 'navigate':
        return `goto(${quote(action.url)})`;

      case 'select':
        return asLocator(action.selector) + `.select_option(${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
    }
  }

  generateHeader(options) {
    const formatter = new PythonFormatter();

    if (this._isPyTest) {
      const contextOptions = formatContextOptions(options.contextOptions, options.deviceName, true
      /* asDict */
      );
      const fixture = contextOptions ? `

@pytest.fixture(scope="session")
def browser_context_args(browser_context_args, playwright) {
    return {${contextOptions}}
}
` : '';
      formatter.add(`${options.deviceName ? 'import pytest\n' : ''}
from playwright.sync_api import Page, expect
${fixture}

def test_example(page: Page) -> None {`);
    } else if (this._isAsync) {
      formatter.add(`
import asyncio

from playwright.async_api import Playwright, async_playwright, expect


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
    } else {
      formatter.add(`
from playwright.sync_api import Playwright, sync_playwright, expect


def run(playwright: Playwright) -> None {
    browser = playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
    }

    return formatter.format();
  }

  generateFooter(saveStorage) {
    if (this._isPyTest) {
      return '';
    } else if (this._isAsync) {
      const storageStateLine = saveStorage ? `\n    await context.storage_state(path=${quote(saveStorage)})` : '';
      return `\n    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
    } else {
      const storageStateLine = saveStorage ? `\n    context.storage_state(path=${quote(saveStorage)})` : '';
      return `\n    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
    }
  }

}

exports.PythonLanguageGenerator = PythonLanguageGenerator;

function formatValue(value) {
  if (value === false) return 'False';
  if (value === true) return 'True';
  if (value === undefined) return 'None';
  if (Array.isArray(value)) return `[${value.map(formatValue).join(', ')}]`;
  if (typeof value === 'string') return quote(value);
  if (typeof value === 'object') return JSON.stringify(value);
  return String(value);
}

function toSnakeCase(name) {
  const toSnakeCaseRegex = /((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))/g;
  return name.replace(toSnakeCaseRegex, `_$1`).toLowerCase();
}

function formatOptions(value, hasArguments, asDict) {
  const keys = Object.keys(value).filter(key => value[key] !== undefined).sort();
  if (!keys.length) return '';
  return (hasArguments ? ', ' : '') + keys.map(key => {
    if (asDict) return `"${toSnakeCase(key)}": ${formatValue(value[key])}`;
    return `${toSnakeCase(key)}=${formatValue(value[key])}`;
  }).join(', ');
}

function convertContextOptions(options) {
  const result = { ...options
  };

  if (options.recordHar) {
    result['record_har_path'] = options.recordHar.path;
    result['record_har_content'] = options.recordHar.content;
    result['record_har_mode'] = options.recordHar.mode;
    result['record_har_omit_content'] = options.recordHar.omitContent;
    result['record_har_url_filter'] = options.recordHar.urlFilter;
    delete result.recordHar;
  }

  return result;
}

function formatContextOptions(options, deviceName, asDict) {
  const device = deviceName && _deviceDescriptors.default[deviceName];
  if (!device) return formatOptions(convertContextOptions(options), false, asDict);
  return `**playwright.devices[${quote(deviceName)}]` + formatOptions(convertContextOptions((0, _language.sanitizeDeviceOptions)(device, options)), true, asDict);
}

class PythonFormatter {
  constructor(offset = 0) {
    this._baseIndent = void 0;
    this._baseOffset = void 0;
    this._lines = [];
    this._baseIndent = ' '.repeat(4);
    this._baseOffset = ' '.repeat(offset);
  }

  prepend(text) {
    this._lines = text.trim().split('\n').map(line => line.trim()).concat(this._lines);
  }

  add(text) {
    this._lines.push(...text.trim().split('\n').map(line => line.trim()));
  }

  newLine() {
    this._lines.push('');
  }

  format() {
    let spaces = '';
    const lines = [];

    this._lines.forEach(line => {
      if (line === '') return lines.push(line);

      if (line === '}') {
        spaces = spaces.substring(this._baseIndent.length);
        return;
      }

      line = spaces + line;

      if (line.endsWith('{')) {
        spaces += this._baseIndent;
        line = line.substring(0, line.length - 1).trimEnd() + ':';
      }

      return lines.push(this._baseOffset + line);
    });

    return lines.join('\n');
  }

}

function quote(text) {
  return (0, _stringUtils.escapeWithQuotes)(text, '\"');
}

function asLocator(selector, locatorFn = 'locator') {
  const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
  if (!match) return `${locatorFn}(${quote(selector)})`;
  if (+match[2] === 0) return `${locatorFn}(${quote(match[1])}).first`;
  return `${locatorFn}(${quote(match[1])}).nth(${match[2]})`;
}

/***/ }),

/***/ 8077:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.actionTitle = actionTitle;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Signals.
function actionTitle(action) {
  switch (action.name) {
    case 'openPage':
      return `Open new page`;

    case 'closePage':
      return `Close page`;

    case 'check':
      return `Check ${action.selector}`;

    case 'uncheck':
      return `Uncheck ${action.selector}`;

    case 'click':
      {
        if (action.clickCount === 1) return `Click ${action.selector}`;
        if (action.clickCount === 2) return `Double click ${action.selector}`;
        if (action.clickCount === 3) return `Triple click ${action.selector}`;
        return `${action.clickCount}× click`;
      }

    case 'fill':
      return `Fill ${action.selector}`;

    case 'setInputFiles':
      if (action.files.length === 0) return `Clear selected files`;else return `Upload ${action.files.join(', ')}`;

    case 'navigate':
      return `Go to ${action.url}`;

    case 'press':
      return `Press ${action.key}` + (action.modifiers ? ' with modifiers' : '');

    case 'select':
      return `Select ${action.options.join(', ')}`;
  }
}

/***/ }),

/***/ 7351:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RecorderApp = exports.EmptyRecorderApp = void 0;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _progress = __nccwpck_require__(2836);

var _events = __nccwpck_require__(2361);

var _instrumentation = __nccwpck_require__(6686);

var _utils = __nccwpck_require__(3557);

var _utilsBundle = __nccwpck_require__(1319);

var _crApp = __nccwpck_require__(3025);

var _registry = __nccwpck_require__(9048);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmptyRecorderApp extends _events.EventEmitter {
  async close() {}

  async setPaused(paused) {}

  async setMode(mode) {}

  async setFileIfNeeded(file) {}

  async setSelector(selector, focus) {}

  async updateCallLogs(callLogs) {}

  async setSources(sources) {}

}

exports.EmptyRecorderApp = EmptyRecorderApp;

class RecorderApp extends _events.EventEmitter {
  constructor(recorder, page, wsEndpoint) {
    super();
    this._page = void 0;
    this.wsEndpoint = void 0;
    this._recorder = void 0;
    this.setMaxListeners(0);
    this._recorder = recorder;
    this._page = page;
    this.wsEndpoint = wsEndpoint;
  }

  async close() {
    await this._page.context().close((0, _instrumentation.serverSideCallMetadata)());
  }

  async _init() {
    await (0, _crApp.installAppIcon)(this._page);
    await this._page._setServerRequestInterceptor(async route => {
      if (route.request().url().startsWith('https://playwright/')) {
        const uri = route.request().url().substring('https://playwright/'.length);

        const file = require.resolve('../../webpack/recorder/' + uri);

        const buffer = await _fs.default.promises.readFile(file);
        await route.fulfill({
          status: 200,
          headers: [{
            name: 'Content-Type',
            value: _utilsBundle.mime.getType(_path.default.extname(file)) || 'application/octet-stream'
          }],
          body: buffer.toString('base64'),
          isBase64: true
        });
        return;
      }

      await route.continue();
    });
    await this._page.exposeBinding('dispatch', false, (_, data) => this.emit('event', data));

    this._page.once('close', () => {
      this.emit('close');

      this._page.context().close((0, _instrumentation.serverSideCallMetadata)()).catch(() => {});
    });

    const mainFrame = this._page.mainFrame();

    await mainFrame.goto((0, _instrumentation.serverSideCallMetadata)(), 'https://playwright/index.html');
  }

  static async open(recorder, inspectedContext, handleSIGINT) {
    const sdkLanguage = inspectedContext._browser.options.sdkLanguage;
    const headed = !!inspectedContext._browser.options.headful;

    const recorderPlaywright = (__nccwpck_require__(4506).createPlaywright)('javascript', true);

    const args = ['--app=data:text/html,', '--window-size=600,600', '--window-position=1020,10', '--test-type='];
    if (process.env.PWTEST_RECORDER_PORT) args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
    const context = await recorderPlaywright.chromium.launchPersistentContext((0, _instrumentation.serverSideCallMetadata)(), '', {
      channel: (0, _registry.findChromiumChannel)(sdkLanguage),
      args,
      noDefaultViewport: true,
      ignoreDefaultArgs: ['--enable-automation'],
      headless: !!process.env.PWTEST_CLI_HEADLESS || (0, _utils.isUnderTest)() && !headed,
      useWebSocket: !!process.env.PWTEST_RECORDER_PORT,
      handleSIGINT
    });
    const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), context._browser);
    await controller.run(async progress => {
      await context._browser._defaultContext._loadDefaultContextAsIs(progress);
    });
    const [page] = context.pages();
    const result = new RecorderApp(recorder, page, context._browser.options.wsEndpoint);
    await result._init();
    return result;
  }

  async setMode(mode) {
    await this._page.mainFrame().evaluateExpression((mode => {
      window.playwrightSetMode(mode);
    }).toString(), true, mode, 'main').catch(() => {});
  }

  async setFileIfNeeded(file) {
    await this._page.mainFrame().evaluateExpression((file => {
      window.playwrightSetFileIfNeeded(file);
    }).toString(), true, file, 'main').catch(() => {});
  }

  async setPaused(paused) {
    await this._page.mainFrame().evaluateExpression((paused => {
      window.playwrightSetPaused(paused);
    }).toString(), true, paused, 'main').catch(() => {});
  }

  async setSources(sources) {
    await this._page.mainFrame().evaluateExpression((sources => {
      window.playwrightSetSources(sources);
    }).toString(), true, sources, 'main').catch(() => {}); // Testing harness for runCLI mode.

    {
      if ((process.env.PWTEST_CLI_IS_UNDER_TEST || process.env.PWTEST_CLI_EXIT) && sources.length) {
        process.stdout.write('\n-------------8<-------------\n');
        process.stdout.write(sources[0].text);
        process.stdout.write('\n-------------8<-------------\n');
      }
    }
  }

  async setSelector(selector, focus) {
    if (focus) {
      this._recorder.setMode('none');

      this._page.bringToFront();
    }

    await this._page.mainFrame().evaluateExpression((arg => {
      window.playwrightSetSelector(arg.selector, arg.focus);
    }).toString(), true, {
      selector,
      focus
    }, 'main').catch(() => {});
  }

  async updateCallLogs(callLogs) {
    await this._page.mainFrame().evaluateExpression((callLogs => {
      window.playwrightUpdateLogs(callLogs);
    }).toString(), true, callLogs, 'main').catch(() => {});
  }

}

exports.RecorderApp = RecorderApp;

/***/ }),

/***/ 9311:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.metadataToCallLog = metadataToCallLog;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function metadataToCallLog(metadata, status) {
  var _metadata$params, _metadata$params2;

  let title = metadata.apiName || metadata.method;
  if (metadata.method === 'waitForEventInfo') title += `(${metadata.params.info.event})`;
  title = title.replace('object.expect', 'expect');
  if (metadata.error) status = 'error';
  const params = {
    url: (_metadata$params = metadata.params) === null || _metadata$params === void 0 ? void 0 : _metadata$params.url,
    selector: (_metadata$params2 = metadata.params) === null || _metadata$params2 === void 0 ? void 0 : _metadata$params2.selector
  };
  let duration = metadata.endTime ? metadata.endTime - metadata.startTime : undefined;

  if (typeof duration === 'number' && metadata.pauseStartTime && metadata.pauseEndTime) {
    duration -= metadata.pauseEndTime - metadata.pauseStartTime;
    duration = Math.max(duration, 0);
  }

  const callLog = {
    id: metadata.id,
    messages: metadata.log,
    title,
    status,
    error: metadata.error,
    params,
    duration
  };
  return callLog;
}

/***/ }),

/***/ 5704:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.toClickOptions = toClickOptions;
exports.toModifiers = toModifiers;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function toClickOptions(action) {
  let method = 'click';
  if (action.clickCount === 2) method = 'dblclick';
  const modifiers = toModifiers(action.modifiers);
  const options = {};
  if (action.button !== 'left') options.button = action.button;
  if (modifiers.length) options.modifiers = modifiers;
  if (action.clickCount > 2) options.clickCount = action.clickCount;
  if (action.position) options.position = action.position;
  return {
    method,
    options
  };
}

function toModifiers(modifiers) {
  const result = [];
  if (modifiers & 1) result.push('Alt');
  if (modifiers & 2) result.push('Control');
  if (modifiers & 4) result.push('Meta');
  if (modifiers & 8) result.push('Shift');
  return result;
}

/***/ }),

/***/ 8285:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.downloadBrowserWithProgressBar = downloadBrowserWithProgressBar;
exports.logPolitely = logPolitely;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _userAgent = __nccwpck_require__(5110);

var _fileUtils = __nccwpck_require__(6034);

var _debugLogger = __nccwpck_require__(2003);

var _download = __nccwpck_require__(9739);

var _zipBundle = __nccwpck_require__(6383);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function downloadBrowserWithProgressBar(title, browserDirectory, executablePath, downloadURLs, downloadFileName) {
  if (await (0, _fileUtils.existsAsync)(browserDirectory)) {
    // Already downloaded.
    _debugLogger.debugLogger.log('install', `${title} is already downloaded.`);

    return false;
  }

  const zipPath = _path.default.join(_os.default.tmpdir(), downloadFileName);

  try {
    await (0, _download.download)(downloadURLs, zipPath, {
      progressBarName: title,
      log: _debugLogger.debugLogger.log.bind(_debugLogger.debugLogger, 'install'),
      userAgent: (0, _userAgent.getUserAgent)()
    });

    _debugLogger.debugLogger.log('install', `extracting archive`);

    _debugLogger.debugLogger.log('install', `-- zip: ${zipPath}`);

    _debugLogger.debugLogger.log('install', `-- location: ${browserDirectory}`);

    await (0, _zipBundle.extract)(zipPath, {
      dir: browserDirectory
    });

    _debugLogger.debugLogger.log('install', `fixing permissions at ${executablePath}`);

    await _fs.default.promises.chmod(executablePath, 0o755);
  } catch (e) {
    _debugLogger.debugLogger.log('install', `FAILED installation ${title} with error: ${e}`);

    process.exitCode = 1;
    throw e;
  } finally {
    if (await (0, _fileUtils.existsAsync)(zipPath)) await _fs.default.promises.unlink(zipPath);
  }

  logPolitely(`${title} downloaded to ${browserDirectory}`);
  return true;
}

function logPolitely(toBeLogged) {
  const logLevel = process.env.npm_config_loglevel;
  const logLevelDisplay = ['silent', 'error', 'warn'].indexOf(logLevel || '') > -1;
  if (!logLevelDisplay) console.log(toBeLogged); // eslint-disable-line no-console
}

/***/ }),

/***/ 9349:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.installDependenciesLinux = installDependenciesLinux;
exports.installDependenciesWindows = installDependenciesWindows;
exports.transformCommandsForRoot = transformCommandsForRoot;
exports.validateDependenciesLinux = validateDependenciesLinux;
exports.validateDependenciesWindows = validateDependenciesWindows;
exports.writeDockerVersion = writeDockerVersion;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var os = _interopRequireWildcard(__nccwpck_require__(2037));

var _child_process = _interopRequireDefault(__nccwpck_require__(2081));

var utils = _interopRequireWildcard(__nccwpck_require__(3557));

var _spawnAsync = __nccwpck_require__(4588);

var _hostPlatform = __nccwpck_require__(5228);

var _ = __nccwpck_require__(9048);

var _nativeDeps = __nccwpck_require__(4971);

var _userAgent = __nccwpck_require__(5110);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BIN_DIRECTORY = _path.default.join(__dirname, '..', '..', '..', 'bin');

const packageJSON = __nccwpck_require__(9415);

const dockerVersionFilePath = '/ms-playwright/.docker-info';

async function writeDockerVersion(dockerImageNameTemplate) {
  await _fs.default.promises.mkdir(_path.default.dirname(dockerVersionFilePath), {
    recursive: true
  });
  await _fs.default.promises.writeFile(dockerVersionFilePath, JSON.stringify({
    driverVersion: packageJSON.version,
    dockerImageName: dockerImageNameTemplate.replace('%version%', packageJSON.version)
  }, null, 2), 'utf8'); // Make sure version file is globally accessible.

  await _fs.default.promises.chmod(dockerVersionFilePath, 0o777);
}

async function readDockerVersion() {
  return await _fs.default.promises.readFile(dockerVersionFilePath, 'utf8').then(text => JSON.parse(text)).catch(e => null);
}

const checkExecutable = filePath => _fs.default.promises.access(filePath, _fs.default.constants.X_OK).then(() => true).catch(e => false);

function isSupportedWindowsVersion() {
  if (os.platform() !== 'win32' || os.arch() !== 'x64') return false;
  const [major, minor] = os.release().split('.').map(token => parseInt(token, 10)); // This is based on: https://stackoverflow.com/questions/42524606/how-to-get-windows-version-using-node-js/44916050#44916050
  // The table with versions is taken from: https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-osversioninfoexw#remarks
  // Windows 7 is not supported and is encoded as `6.1`.

  return major > 6 || major === 6 && minor > 1;
}

async function installDependenciesWindows(targets, dryRun) {
  if (targets.has('chromium')) {
    const command = 'powershell.exe';
    const args = ['-ExecutionPolicy', 'Bypass', '-File', _path.default.join(BIN_DIRECTORY, 'install_media_pack.ps1')];

    if (dryRun) {
      console.log(`${command} ${quoteProcessArgs(args).join(' ')}`); // eslint-disable-line no-console

      return;
    }

    const {
      code
    } = await (0, _spawnAsync.spawnAsync)(command, args, {
      cwd: BIN_DIRECTORY,
      stdio: 'inherit'
    });
    if (code !== 0) throw new Error('Failed to install windows dependencies!');
  }
}

async function installDependenciesLinux(targets, dryRun) {
  const libraries = [];
  let platform = _hostPlatform.hostPlatform;

  if (platform === 'generic-linux' || platform === 'generic-linux-arm64') {
    console.warn('BEWARE: your OS is not officially supported by Playwright; installing dependencies for Ubuntu as a fallback.'); // eslint-disable-line no-console

    platform = _hostPlatform.hostPlatform === 'generic-linux' ? 'ubuntu20.04' : 'ubuntu20.04-arm64';
  }

  for (const target of targets) {
    const info = _nativeDeps.deps[platform];

    if (!info) {
      console.warn('Cannot install dependencies for this linux distribution!'); // eslint-disable-line no-console

      return;
    }

    libraries.push(...info[target]);
  }

  const uniqueLibraries = Array.from(new Set(libraries));
  if (!dryRun) console.log(`Installing dependencies...`); // eslint-disable-line no-console

  const commands = [];
  commands.push('apt-get update');
  commands.push(['apt-get', 'install', '-y', '--no-install-recommends', ...uniqueLibraries].join(' '));
  const {
    command,
    args,
    elevatedPermissions
  } = await transformCommandsForRoot(commands);

  if (dryRun) {
    console.log(`${command} ${quoteProcessArgs(args).join(' ')}`); // eslint-disable-line no-console

    return;
  }

  if (elevatedPermissions) console.log('Switching to root user to install dependencies...'); // eslint-disable-line no-console

  const child = _child_process.default.spawn(command, args, {
    stdio: 'inherit'
  });

  await new Promise((resolve, reject) => {
    child.on('exit', code => code === 0 ? resolve() : reject(new Error(`Installation process exited with code: ${code}`)));
    child.on('error', reject);
  });
}

async function validateDependenciesWindows(windowsExeAndDllDirectories) {
  const directoryPaths = windowsExeAndDllDirectories;
  const lddPaths = [];

  for (const directoryPath of directoryPaths) lddPaths.push(...(await executablesOrSharedLibraries(directoryPath)));

  const allMissingDeps = await Promise.all(lddPaths.map(lddPath => missingFileDependenciesWindows(lddPath)));
  const missingDeps = new Set();

  for (const deps of allMissingDeps) {
    for (const dep of deps) missingDeps.add(dep);
  }

  if (!missingDeps.size) return;
  let isCrtMissing = false;
  let isMediaFoundationMissing = false;

  for (const dep of missingDeps) {
    if (dep.startsWith('api-ms-win-crt') || dep === 'vcruntime140.dll' || dep === 'vcruntime140_1.dll' || dep === 'msvcp140.dll') isCrtMissing = true;else if (dep === 'mf.dll' || dep === 'mfplat.dll' || dep === 'msmpeg2vdec.dll' || dep === 'evr.dll' || dep === 'avrt.dll') isMediaFoundationMissing = true;
  }

  const details = [];

  if (isCrtMissing) {
    details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
  }

  if (isMediaFoundationMissing) {
    details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
  }

  details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join('\n    ')}`, ``);
  const message = `Host system is missing dependencies!\n\n${details.join('\n')}`;

  if (isSupportedWindowsVersion()) {
    throw new Error(message);
  } else {
    // eslint-disable-next-line no-console
    console.warn(`WARNING: running on unsupported windows version!`); // eslint-disable-next-line no-console

    console.warn(message);
  }
}

async function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
  var _deps$hostPlatform;

  const directoryPaths = linuxLddDirectories;
  const lddPaths = [];

  for (const directoryPath of directoryPaths) lddPaths.push(...(await executablesOrSharedLibraries(directoryPath)));

  const missingDepsPerFile = await Promise.all(lddPaths.map(lddPath => missingFileDependencies(lddPath, directoryPaths)));
  const missingDeps = new Set();

  for (const deps of missingDepsPerFile) {
    for (const dep of deps) missingDeps.add(dep);
  }

  for (const dep of await missingDLOPENLibraries(dlOpenLibraries)) missingDeps.add(dep);

  if (!missingDeps.size) return;
  const allMissingDeps = new Set(missingDeps); // Check Ubuntu version.

  const missingPackages = new Set();
  const libraryToPackageNameMapping = _nativeDeps.deps[_hostPlatform.hostPlatform] ? { ...(((_deps$hostPlatform = _nativeDeps.deps[_hostPlatform.hostPlatform]) === null || _deps$hostPlatform === void 0 ? void 0 : _deps$hostPlatform.lib2package) || {}),
    ...MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU
  } : {}; // Translate missing dependencies to package names to install with apt.

  for (const missingDep of missingDeps) {
    const packageName = libraryToPackageNameMapping[missingDep];

    if (packageName) {
      missingPackages.add(packageName);
      missingDeps.delete(missingDep);
    }
  }

  const maybeSudo = process.getuid() !== 0 && os.platform() !== 'win32' ? 'sudo ' : '';
  const dockerInfo = await readDockerVersion();
  const errorLines = [`Host system is missing dependencies to run browsers.`]; // Ignore patch versions when comparing docker container version and Playwright version:
  // we **NEVER** roll browsers in patch releases, so native dependencies do not change.

  if (dockerInfo && !dockerInfo.driverVersion.startsWith((0, _userAgent.getPlaywrightVersion)(true
  /* majorMinorOnly */
  ) + '.')) {
    // We are running in a docker container with unmatching version.
    // In this case, we know how to install dependencies in it.
    const pwVersion = (0, _userAgent.getPlaywrightVersion)();
    const requiredDockerImage = dockerInfo.dockerImageName.replace(dockerInfo.driverVersion, pwVersion);
    errorLines.push(...[`This is most likely due to docker image version not matching Playwright version:`, `- Playwright: ${pwVersion}`, `-     Docker: ${dockerInfo.driverVersion}`, ``, `Either:`, `- (recommended) use docker image "${requiredDockerImage}"`, `- (alternative 1) run the following command inside docker to install missing dependencies:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, 'install-deps')}`, ``, `- (alternative 2) use apt inside docker:`, ``, `    ${maybeSudo}apt-get install ${[...missingPackages].join('\\\n        ')}`, ``, `<3 Playwright Team`]);
  } else if (missingPackages.size && !missingDeps.size) {
    // Only known dependencies are missing for browsers.
    // Suggest installation with a Playwright CLI.
    errorLines.push(...[`Please install them with the following command:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, 'install-deps')}`, ``, `Alternatively, use apt:`, `    ${maybeSudo}apt-get install ${[...missingPackages].join('\\\n        ')}`, ``, `<3 Playwright Team`]);
  } else {
    // Unhappy path: we either run on unknown distribution, or we failed to resolve all missing
    // libraries to package names.
    // Print missing libraries only:
    errorLines.push(...[`Missing libraries:`, ...[...allMissingDeps].map(dep => '    ' + dep)]);
  }

  throw new Error('\n' + utils.wrapInASCIIBox(errorLines.join('\n'), 1));
}

function isSharedLib(basename) {
  switch (os.platform()) {
    case 'linux':
      return basename.endsWith('.so') || basename.includes('.so.');

    case 'win32':
      return basename.endsWith('.dll');

    default:
      return false;
  }
}

async function executablesOrSharedLibraries(directoryPath) {
  if (!_fs.default.existsSync(directoryPath)) return [];
  const allPaths = (await _fs.default.promises.readdir(directoryPath)).map(file => _path.default.resolve(directoryPath, file));
  const allStats = await Promise.all(allPaths.map(aPath => _fs.default.promises.stat(aPath)));
  const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());
  const executablersOrLibraries = (await Promise.all(filePaths.map(async filePath => {
    const basename = _path.default.basename(filePath).toLowerCase();

    if (isSharedLib(basename)) return filePath;
    if (await checkExecutable(filePath)) return filePath;
    return false;
  }))).filter(Boolean);
  return executablersOrLibraries;
}

async function missingFileDependenciesWindows(filePath) {
  const executable = _path.default.join(__dirname, '..', '..', '..', 'bin', 'PrintDeps.exe');

  const dirname = _path.default.dirname(filePath);

  const {
    stdout,
    code
  } = await (0, _spawnAsync.spawnAsync)(executable, [filePath], {
    cwd: dirname,
    env: { ...process.env,
      LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
    }
  });
  if (code !== 0) return [];
  const missingDeps = stdout.split('\n').map(line => line.trim()).filter(line => line.endsWith('not found') && line.includes('=>')).map(line => line.split('=>')[0].trim().toLowerCase());
  return missingDeps;
}

async function missingFileDependencies(filePath, extraLDPaths) {
  const dirname = _path.default.dirname(filePath);

  let LD_LIBRARY_PATH = extraLDPaths.join(':');
  if (process.env.LD_LIBRARY_PATH) LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
  const {
    stdout,
    code
  } = await (0, _spawnAsync.spawnAsync)('ldd', [filePath], {
    cwd: dirname,
    env: { ...process.env,
      LD_LIBRARY_PATH
    }
  });
  if (code !== 0) return [];
  const missingDeps = stdout.split('\n').map(line => line.trim()).filter(line => line.endsWith('not found') && line.includes('=>')).map(line => line.split('=>')[0].trim());
  return missingDeps;
}

async function missingDLOPENLibraries(libraries) {
  if (!libraries.length) return []; // NOTE: Using full-qualified path to `ldconfig` since `/sbin` is not part of the
  // default PATH in CRON.
  // @see https://github.com/microsoft/playwright/issues/3397

  const {
    stdout,
    code,
    error
  } = await (0, _spawnAsync.spawnAsync)('/sbin/ldconfig', ['-p'], {});
  if (code !== 0 || error) return [];

  const isLibraryAvailable = library => stdout.toLowerCase().includes(library.toLowerCase());

  return libraries.filter(library => !isLibraryAvailable(library));
}

const MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
  // libgstlibav.so (the only actual library provided by gstreamer1.0-libav) is not
  // in the ldconfig cache, so we detect the actual library required for playing h.264
  // and if it's missing recommend installing missing gstreamer lib.
  // gstreamer1.0-libav -> libavcodec57 -> libx264-152
  'libx264.so': 'gstreamer1.0-libav'
};

function quoteProcessArgs(args) {
  return args.map(arg => {
    if (arg.includes(' ')) return `"${arg}"`;
    return arg;
  });
}

async function transformCommandsForRoot(commands) {
  const isRoot = process.getuid() === 0;
  if (isRoot) return {
    command: 'sh',
    args: ['-c', `${commands.join('&& ')}`],
    elevatedPermissions: false
  };
  const sudoExists = await (0, _spawnAsync.spawnAsync)('which', ['sudo']);
  if (sudoExists.code === 0) return {
    command: 'sudo',
    args: ['--', 'sh', '-c', `${commands.join('&& ')}`],
    elevatedPermissions: true
  };
  return {
    command: 'su',
    args: ['root', '-c', `${commands.join('&& ')}`],
    elevatedPermissions: true
  };
}

/***/ }),

/***/ 9739:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.download = download;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _utilsBundle = __nccwpck_require__(1319);

var _netUtils = __nccwpck_require__(989);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function downloadFile(url, destinationPath, options = {}) {
  const {
    progressCallback,
    log = () => {}
  } = options;
  log(`running download:`);
  log(`-- from url: ${url}`);
  log(`-- to location: ${destinationPath}`);

  let fulfill = ({
    error
  }) => {};

  let downloadedBytes = 0;
  let totalBytes = 0;
  const promise = new Promise(x => {
    fulfill = x;
  });
  (0, _netUtils.httpRequest)({
    url,
    headers: options.userAgent ? {
      'User-Agent': options.userAgent
    } : undefined
  }, response => {
    log(`-- response status code: ${response.statusCode}`);

    if (response.statusCode !== 200) {
      let content = '';

      const handleError = () => {
        const error = new Error(`Download failed: server returned code ${response.statusCode} body '${content}'. URL: ${url}`); // consume response data to free up memory

        response.resume();
        fulfill({
          error
        });
      };

      response.on('data', chunk => content += chunk).on('end', handleError).on('error', handleError);
      return;
    }

    const file = _fs.default.createWriteStream(destinationPath);

    file.on('finish', () => fulfill({
      error: null
    }));
    file.on('error', error => fulfill({
      error
    }));
    response.pipe(file);
    totalBytes = parseInt(response.headers['content-length'] || '0', 10);
    log(`-- total bytes: ${totalBytes}`);
    if (progressCallback) response.on('data', onData);
  }, error => fulfill({
    error
  }));
  return promise;

  function onData(chunk) {
    downloadedBytes += chunk.length;
    progressCallback(downloadedBytes, totalBytes);
  }
}

async function download(urls, destination, options = {}) {
  const {
    progressBarName = 'file',
    retryCount = 3,
    log = () => {},
    userAgent
  } = options;

  for (let attempt = 1; attempt <= retryCount; ++attempt) {
    log(`downloading ${progressBarName} - attempt #${attempt}`);
    if (!Array.isArray(urls)) urls = [urls];
    const url = urls[(attempt - 1) % urls.length];
    const {
      error
    } = await downloadFile(url, destination, {
      progressCallback: getDownloadProgress(progressBarName),
      log,
      userAgent
    });

    if (!error) {
      log(`SUCCESS downloading ${progressBarName}`);
      break;
    }

    const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || '';
    log(`attempt #${attempt} - ERROR: ${errorMessage}`);
    if (attempt >= retryCount) throw error;
  }
}

function getDownloadProgress(progressBarName) {
  if (process.stdout.isTTY) return _getAnimatedDownloadProgress(progressBarName);
  return _getBasicDownloadProgress(progressBarName);
}

function _getAnimatedDownloadProgress(progressBarName) {
  let progressBar;
  let lastDownloadedBytes = 0;
  return (downloadedBytes, totalBytes) => {
    if (!progressBar) {
      progressBar = new _utilsBundle.progress(`Downloading ${progressBarName} - ${toMegabytes(totalBytes)} [:bar] :percent :etas `, {
        complete: '=',
        incomplete: ' ',
        width: 20,
        total: totalBytes
      });
    }

    const delta = downloadedBytes - lastDownloadedBytes;
    lastDownloadedBytes = downloadedBytes;
    progressBar.tick(delta);
  };
}

function _getBasicDownloadProgress(progressBarName) {
  // eslint-disable-next-line no-console
  console.log(`Downloading ${progressBarName}...`);
  const totalRows = 10;
  const stepWidth = 8;
  let lastRow = -1;
  return (downloadedBytes, totalBytes) => {
    const percentage = downloadedBytes / totalBytes;
    const row = Math.floor(totalRows * percentage);

    if (row > lastRow) {
      lastRow = row;
      const percentageString = String(percentage * 100 | 0).padStart(3); // eslint-disable-next-line no-console

      console.log(`|${'■'.repeat(row * stepWidth)}${' '.repeat((totalRows - row) * stepWidth)}| ${percentageString}% of ${toMegabytes(totalBytes)}`);
    }
  };
}

function toMegabytes(bytes) {
  const mb = bytes / 1024 / 1024;
  return `${Math.round(mb * 10) / 10} Mb`;
}

/***/ }),

/***/ 9048:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Registry = void 0;
exports.buildPlaywrightCLICommand = buildPlaywrightCLICommand;
exports.findChromiumChannel = findChromiumChannel;
exports.installBrowsersForNpmInstall = installBrowsersForNpmInstall;
exports.installDefaultBrowsersForNpmInstall = installDefaultBrowsersForNpmInstall;
exports.registryDirectory = exports.registry = void 0;
Object.defineProperty(exports, "writeDockerVersion", ({
  enumerable: true,
  get: function () {
    return _dependencies.writeDockerVersion;
  }
}));

var os = _interopRequireWildcard(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var util = _interopRequireWildcard(__nccwpck_require__(3837));

var fs = _interopRequireWildcard(__nccwpck_require__(7147));

var _utilsBundle = __nccwpck_require__(1319);

var _linuxUtils = __nccwpck_require__(1665);

var _netUtils = __nccwpck_require__(989);

var _userAgent = __nccwpck_require__(5110);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _hostPlatform = __nccwpck_require__(5228);

var _spawnAsync = __nccwpck_require__(4588);

var _dependencies = __nccwpck_require__(9349);

var _browserFetcher = __nccwpck_require__(8285);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PACKAGE_PATH = _path.default.join(__dirname, '..', '..', '..');

const BIN_PATH = _path.default.join(__dirname, '..', '..', '..', 'bin');

const PLAYWRIGHT_CDN_MIRRORS = ['https://playwright.azureedge.net', 'https://playwright-akamai.azureedge.net', 'https://playwright-verizon.azureedge.net'];

if (process.env.PW_TEST_CDN_THAT_SHOULD_WORK) {
  for (let i = 0; i < PLAYWRIGHT_CDN_MIRRORS.length; i++) {
    const cdn = PLAYWRIGHT_CDN_MIRRORS[i];
    if (cdn !== process.env.PW_TEST_CDN_THAT_SHOULD_WORK) PLAYWRIGHT_CDN_MIRRORS[i] = cdn + '.does-not-resolve.playwright.dev';
  }
}

const EXECUTABLE_PATHS = {
  'chromium': {
    'linux': ['chrome-linux', 'chrome'],
    'mac': ['chrome-mac', 'Chromium.app', 'Contents', 'MacOS', 'Chromium'],
    'win': ['chrome-win', 'chrome.exe']
  },
  'firefox': {
    'linux': ['firefox', 'firefox'],
    'mac': ['firefox', 'Nightly.app', 'Contents', 'MacOS', 'firefox'],
    'win': ['firefox', 'firefox.exe']
  },
  'webkit': {
    'linux': ['pw_run.sh'],
    'mac': ['pw_run.sh'],
    'win': ['Playwright.exe']
  },
  'ffmpeg': {
    'linux': ['ffmpeg-linux'],
    'mac': ['ffmpeg-mac'],
    'win': ['ffmpeg-win64.exe']
  }
};
const DOWNLOAD_PATHS = {
  'chromium': {
    '<unknown>': undefined,
    'generic-linux': 'builds/chromium/%s/chromium-linux.zip',
    'generic-linux-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',
    'ubuntu18.04': 'builds/chromium/%s/chromium-linux.zip',
    'ubuntu20.04': 'builds/chromium/%s/chromium-linux.zip',
    'ubuntu22.04': 'builds/chromium/%s/chromium-linux.zip',
    'ubuntu18.04-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',
    'ubuntu20.04-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',
    'ubuntu22.04-arm64': 'builds/chromium/%s/chromium-linux-arm64.zip',
    'debian11': 'builds/chromium/%s/chromium-linux.zip',
    'mac10.13': 'builds/chromium/%s/chromium-mac.zip',
    'mac10.14': 'builds/chromium/%s/chromium-mac.zip',
    'mac10.15': 'builds/chromium/%s/chromium-mac.zip',
    'mac11': 'builds/chromium/%s/chromium-mac.zip',
    'mac11-arm64': 'builds/chromium/%s/chromium-mac-arm64.zip',
    'mac12': 'builds/chromium/%s/chromium-mac.zip',
    'mac12-arm64': 'builds/chromium/%s/chromium-mac-arm64.zip',
    'win64': 'builds/chromium/%s/chromium-win64.zip'
  },
  'chromium-tip-of-tree': {
    '<unknown>': undefined,
    'generic-linux': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',
    'generic-linux-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',
    'ubuntu18.04': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',
    'ubuntu20.04': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',
    'ubuntu22.04': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',
    'ubuntu18.04-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',
    'ubuntu20.04-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',
    'ubuntu22.04-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux-arm64.zip',
    'debian11': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-linux.zip',
    'mac10.13': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',
    'mac10.14': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',
    'mac10.15': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',
    'mac11': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',
    'mac11-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip',
    'mac12': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac.zip',
    'mac12-arm64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-mac-arm64.zip',
    'win64': 'builds/chromium-tip-of-tree/%s/chromium-tip-of-tree-win64.zip'
  },
  'chromium-with-symbols': {
    '<unknown>': undefined,
    'generic-linux': 'builds/chromium/%s/chromium-with-symbols-linux.zip',
    'generic-linux-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',
    'ubuntu18.04': 'builds/chromium/%s/chromium-with-symbols-linux.zip',
    'ubuntu20.04': 'builds/chromium/%s/chromium-with-symbols-linux.zip',
    'ubuntu22.04': 'builds/chromium/%s/chromium-with-symbols-linux.zip',
    'ubuntu18.04-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',
    'ubuntu20.04-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',
    'ubuntu22.04-arm64': 'builds/chromium/%s/chromium-with-symbols-linux-arm64.zip',
    'debian11': 'builds/chromium/%s/chromium-with-symbols-linux.zip',
    'mac10.13': 'builds/chromium/%s/chromium-with-symbols-mac.zip',
    'mac10.14': 'builds/chromium/%s/chromium-with-symbols-mac.zip',
    'mac10.15': 'builds/chromium/%s/chromium-with-symbols-mac.zip',
    'mac11': 'builds/chromium/%s/chromium-with-symbols-mac.zip',
    'mac11-arm64': 'builds/chromium/%s/chromium-with-symbols-mac-arm64.zip',
    'mac12': 'builds/chromium/%s/chromium-with-symbols-mac.zip',
    'mac12-arm64': 'builds/chromium/%s/chromium-with-symbols-mac-arm64.zip',
    'win64': 'builds/chromium/%s/chromium-with-symbols-win64.zip'
  },
  'firefox': {
    '<unknown>': undefined,
    'generic-linux': 'builds/firefox/%s/firefox-ubuntu-20.04.zip',
    'generic-linux-arm64': 'builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip',
    'ubuntu18.04': 'builds/firefox/%s/firefox-ubuntu-18.04.zip',
    'ubuntu20.04': 'builds/firefox/%s/firefox-ubuntu-20.04.zip',
    'ubuntu22.04': 'builds/firefox/%s/firefox-ubuntu-22.04.zip',
    'ubuntu18.04-arm64': undefined,
    'ubuntu20.04-arm64': 'builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip',
    'ubuntu22.04-arm64': 'builds/firefox/%s/firefox-ubuntu-22.04-arm64.zip',
    'debian11': 'builds/firefox/%s/firefox-debian-11.zip',
    'mac10.13': 'builds/firefox/%s/firefox-mac-11.zip',
    'mac10.14': 'builds/firefox/%s/firefox-mac-11.zip',
    'mac10.15': 'builds/firefox/%s/firefox-mac-11.zip',
    'mac11': 'builds/firefox/%s/firefox-mac-11.zip',
    'mac11-arm64': 'builds/firefox/%s/firefox-mac-11-arm64.zip',
    'mac12': 'builds/firefox/%s/firefox-mac-11.zip',
    'mac12-arm64': 'builds/firefox/%s/firefox-mac-11-arm64.zip',
    'win64': 'builds/firefox/%s/firefox-win64.zip'
  },
  'firefox-beta': {
    '<unknown>': undefined,
    'generic-linux': 'builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip',
    'generic-linux-arm64': undefined,
    'ubuntu18.04': 'builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip',
    'ubuntu20.04': 'builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip',
    'ubuntu22.04': 'builds/firefox-beta/%s/firefox-beta-ubuntu-22.04.zip',
    'ubuntu18.04-arm64': undefined,
    'ubuntu20.04-arm64': undefined,
    'ubuntu22.04-arm64': 'builds/firefox-beta/%s/firefox-beta-ubuntu-22.04-arm64.zip',
    'debian11': 'builds/firefox-beta/%s/firefox-beta-debian-11.zip',
    'mac10.13': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',
    'mac10.14': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',
    'mac10.15': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',
    'mac11': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',
    'mac11-arm64': 'builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip',
    'mac12': 'builds/firefox-beta/%s/firefox-beta-mac-11.zip',
    'mac12-arm64': 'builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip',
    'win64': 'builds/firefox-beta/%s/firefox-beta-win64.zip'
  },
  'webkit': {
    '<unknown>': undefined,
    'generic-linux': 'builds/webkit/%s/webkit-ubuntu-20.04.zip',
    'generic-linux-arm64': 'builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip',
    'ubuntu18.04': 'builds/webkit/%s/webkit-ubuntu-18.04.zip',
    'ubuntu20.04': 'builds/webkit/%s/webkit-ubuntu-20.04.zip',
    'ubuntu22.04': 'builds/webkit/%s/webkit-ubuntu-22.04.zip',
    'ubuntu18.04-arm64': undefined,
    'ubuntu20.04-arm64': 'builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip',
    'ubuntu22.04-arm64': 'builds/webkit/%s/webkit-ubuntu-22.04-arm64.zip',
    'debian11': 'builds/webkit/%s/webkit-debian-11.zip',
    'mac10.13': undefined,
    'mac10.14': 'builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip',
    'mac10.15': 'builds/webkit/%s/webkit-mac-10.15.zip',
    'mac11': 'builds/webkit/%s/webkit-mac-11.zip',
    'mac11-arm64': 'builds/webkit/%s/webkit-mac-11-arm64.zip',
    'mac12': 'builds/webkit/%s/webkit-mac-12.zip',
    'mac12-arm64': 'builds/webkit/%s/webkit-mac-12-arm64.zip',
    'win64': 'builds/webkit/%s/webkit-win64.zip'
  },
  'ffmpeg': {
    '<unknown>': undefined,
    'generic-linux': 'builds/ffmpeg/%s/ffmpeg-linux.zip',
    'generic-linux-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',
    'ubuntu18.04': 'builds/ffmpeg/%s/ffmpeg-linux.zip',
    'ubuntu20.04': 'builds/ffmpeg/%s/ffmpeg-linux.zip',
    'ubuntu22.04': 'builds/ffmpeg/%s/ffmpeg-linux.zip',
    'ubuntu18.04-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',
    'ubuntu20.04-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',
    'ubuntu22.04-arm64': 'builds/ffmpeg/%s/ffmpeg-linux-arm64.zip',
    'debian11': 'builds/ffmpeg/%s/ffmpeg-linux.zip',
    'mac10.13': 'builds/ffmpeg/%s/ffmpeg-mac.zip',
    'mac10.14': 'builds/ffmpeg/%s/ffmpeg-mac.zip',
    'mac10.15': 'builds/ffmpeg/%s/ffmpeg-mac.zip',
    'mac11': 'builds/ffmpeg/%s/ffmpeg-mac.zip',
    'mac11-arm64': 'builds/ffmpeg/%s/ffmpeg-mac-arm64.zip',
    'mac12': 'builds/ffmpeg/%s/ffmpeg-mac.zip',
    'mac12-arm64': 'builds/ffmpeg/%s/ffmpeg-mac-arm64.zip',
    'win64': 'builds/ffmpeg/%s/ffmpeg-win64.zip'
  }
};

const registryDirectory = (() => {
  let result;
  const envDefined = (0, _utils.getFromENV)('PLAYWRIGHT_BROWSERS_PATH');

  if (envDefined === '0') {
    result = _path.default.join(__dirname, '..', '..', '..', '.local-browsers');
  } else if (envDefined) {
    result = envDefined;
  } else {
    let cacheDirectory;
    if (process.platform === 'linux') cacheDirectory = process.env.XDG_CACHE_HOME || _path.default.join(os.homedir(), '.cache');else if (process.platform === 'darwin') cacheDirectory = _path.default.join(os.homedir(), 'Library', 'Caches');else if (process.platform === 'win32') cacheDirectory = process.env.LOCALAPPDATA || _path.default.join(os.homedir(), 'AppData', 'Local');else throw new Error('Unsupported platform: ' + process.platform);
    result = _path.default.join(cacheDirectory, 'ms-playwright');
  }

  if (!_path.default.isAbsolute(result)) {
    // It is important to resolve to the absolute path:
    //   - for unzipping to work correctly;
    //   - so that registry directory matches between installation and execution.
    // INIT_CWD points to the root of `npm/yarn install` and is probably what
    // the user meant when typing the relative path.
    result = _path.default.resolve((0, _utils.getFromENV)('INIT_CWD') || process.cwd(), result);
  }

  return result;
})();

exports.registryDirectory = registryDirectory;

function isBrowserDirectory(browserDirectory) {
  const baseName = _path.default.basename(browserDirectory);

  for (const browserName of allDownloadable) {
    if (baseName.startsWith(browserName + '-')) return true;
  }

  return false;
}

function readDescriptors(browsersJSON) {
  return browsersJSON['browsers'].map(obj => {
    const name = obj.name;
    const revisionOverride = (obj.revisionOverrides || {})[_hostPlatform.hostPlatform];
    const revision = revisionOverride || obj.revision;
    const browserDirectoryPrefix = revisionOverride ? `${name}_${_hostPlatform.hostPlatform}_special` : `${name}`;
    const descriptor = {
      name,
      revision,
      // We only put browser version for the supported operating systems.
      browserVersion: revisionOverride ? undefined : obj.browserVersion,
      installByDefault: !!obj.installByDefault,
      // Method `isBrowserDirectory` determines directory to be browser iff
      // it starts with some browser name followed by '-'. Some browser names
      // are prefixes of others, e.g. 'webkit' is a prefix of `webkit-technology-preview`.
      // To avoid older registries erroneously removing 'webkit-technology-preview', we have to
      // ensure that browser folders to never include dashes inside.
      dir: _path.default.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, '_') + '-' + revision)
    };
    return descriptor;
  });
}

const allDownloadable = ['chromium', 'firefox', 'webkit', 'ffmpeg', 'firefox-beta', 'chromium-with-symbols', 'chromium-tip-of-tree'];

class Registry {
  constructor(browsersJSON) {
    this._executables = void 0;
    const descriptors = readDescriptors(browsersJSON);

    const findExecutablePath = (dir, name) => {
      let tokens = undefined;
      if (process.platform === 'linux') tokens = EXECUTABLE_PATHS[name]['linux'];else if (process.platform === 'darwin') tokens = EXECUTABLE_PATHS[name]['mac'];else if (process.platform === 'win32') tokens = EXECUTABLE_PATHS[name]['win'];
      return tokens ? _path.default.join(dir, ...tokens) : undefined;
    };

    const executablePathOrDie = (name, e, installByDefault, sdkLanguage) => {
      if (!e) throw new Error(`${name} is not supported on ${_hostPlatform.hostPlatform}`);
      const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? '' : ' ' + name}`);

      if (!(0, _fileUtils.canAccessFile)(e)) {
        const prettyMessage = [`Looks like ${sdkLanguage === 'javascript' ? 'Playwright Test or ' : ''}Playwright was just installed or updated.`, `Please run the following command to download new browser${installByDefault ? 's' : ''}:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join('\n');
        throw new Error(`Executable doesn't exist at ${e}\n${(0, _utils.wrapInASCIIBox)(prettyMessage, 1)}`);
      }

      return e;
    };

    this._executables = [];
    const chromium = descriptors.find(d => d.name === 'chromium');
    const chromiumExecutable = findExecutablePath(chromium.dir, 'chromium');

    this._executables.push({
      type: 'browser',
      name: 'chromium',
      browserName: 'chromium',
      directory: chromium.dir,
      executablePath: () => chromiumExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('chromium', chromiumExecutable, chromium.installByDefault, sdkLanguage),
      installType: chromium.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'chromium', chromium.dir, ['chrome-linux'], [], ['chrome-win']),
      _install: () => this._downloadExecutable(chromium, chromiumExecutable, DOWNLOAD_PATHS['chromium'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST'),
      _dependencyGroup: 'chromium',
      _isHermeticInstallation: true
    });

    const chromiumWithSymbols = descriptors.find(d => d.name === 'chromium-with-symbols');
    const chromiumWithSymbolsExecutable = findExecutablePath(chromiumWithSymbols.dir, 'chromium');

    this._executables.push({
      type: 'tool',
      name: 'chromium-with-symbols',
      browserName: 'chromium',
      directory: chromiumWithSymbols.dir,
      executablePath: () => chromiumWithSymbolsExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('chromium-with-symbols', chromiumWithSymbolsExecutable, chromiumWithSymbols.installByDefault, sdkLanguage),
      installType: chromiumWithSymbols.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'chromium', chromiumWithSymbols.dir, ['chrome-linux'], [], ['chrome-win']),
      _install: () => this._downloadExecutable(chromiumWithSymbols, chromiumWithSymbolsExecutable, DOWNLOAD_PATHS['chromium-with-symbols'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST'),
      _dependencyGroup: 'chromium',
      _isHermeticInstallation: true
    });

    const chromiumTipOfTree = descriptors.find(d => d.name === 'chromium-tip-of-tree');
    const chromiumTipOfTreeExecutable = findExecutablePath(chromiumTipOfTree.dir, 'chromium');

    this._executables.push({
      type: 'tool',
      name: 'chromium-tip-of-tree',
      browserName: 'chromium',
      directory: chromiumTipOfTree.dir,
      executablePath: () => chromiumTipOfTreeExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('chromium-tip-of-tree', chromiumTipOfTreeExecutable, chromiumTipOfTree.installByDefault, sdkLanguage),
      installType: chromiumTipOfTree.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'chromium', chromiumTipOfTree.dir, ['chrome-linux'], [], ['chrome-win']),
      _install: () => this._downloadExecutable(chromiumTipOfTree, chromiumTipOfTreeExecutable, DOWNLOAD_PATHS['chromium-tip-of-tree'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST'),
      _dependencyGroup: 'chromium',
      _isHermeticInstallation: true
    });

    this._executables.push(this._createChromiumChannel('chrome', {
      'linux': '/opt/google/chrome/chrome',
      'darwin': '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',
      'win32': `\\Google\\Chrome\\Application\\chrome.exe`
    }, () => this._installChromiumChannel('chrome', {
      'linux': 'reinstall_chrome_stable_linux.sh',
      'darwin': 'reinstall_chrome_stable_mac.sh',
      'win32': 'reinstall_chrome_stable_win.ps1'
    })));

    this._executables.push(this._createChromiumChannel('chrome-beta', {
      'linux': '/opt/google/chrome-beta/chrome',
      'darwin': '/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta',
      'win32': `\\Google\\Chrome Beta\\Application\\chrome.exe`
    }, () => this._installChromiumChannel('chrome-beta', {
      'linux': 'reinstall_chrome_beta_linux.sh',
      'darwin': 'reinstall_chrome_beta_mac.sh',
      'win32': 'reinstall_chrome_beta_win.ps1'
    })));

    this._executables.push(this._createChromiumChannel('chrome-dev', {
      'linux': '/opt/google/chrome-unstable/chrome',
      'darwin': '/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev',
      'win32': `\\Google\\Chrome Dev\\Application\\chrome.exe`
    }));

    this._executables.push(this._createChromiumChannel('chrome-canary', {
      'linux': '',
      'darwin': '/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary',
      'win32': `\\Google\\Chrome SxS\\Application\\chrome.exe`
    }));

    this._executables.push(this._createChromiumChannel('msedge', {
      'linux': '/opt/microsoft/msedge/msedge',
      'darwin': '/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge',
      'win32': `\\Microsoft\\Edge\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel('msedge', {
      'linux': 'reinstall_msedge_stable_linux.sh',
      'darwin': 'reinstall_msedge_stable_mac.sh',
      'win32': 'reinstall_msedge_stable_win.ps1'
    })));

    this._executables.push(this._createChromiumChannel('msedge-beta', {
      'linux': '/opt/microsoft/msedge-beta/msedge',
      'darwin': '/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta',
      'win32': `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel('msedge-beta', {
      'darwin': 'reinstall_msedge_beta_mac.sh',
      'linux': 'reinstall_msedge_beta_linux.sh',
      'win32': 'reinstall_msedge_beta_win.ps1'
    })));

    this._executables.push(this._createChromiumChannel('msedge-dev', {
      'linux': '/opt/microsoft/msedge-dev/msedge',
      'darwin': '/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev',
      'win32': `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
    }, () => this._installMSEdgeChannel('msedge-dev', {
      'darwin': 'reinstall_msedge_dev_mac.sh',
      'linux': 'reinstall_msedge_dev_linux.sh',
      'win32': 'reinstall_msedge_dev_win.ps1'
    })));

    this._executables.push(this._createChromiumChannel('msedge-canary', {
      'linux': '',
      'darwin': '/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary',
      'win32': `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
    }));

    const firefox = descriptors.find(d => d.name === 'firefox');
    const firefoxExecutable = findExecutablePath(firefox.dir, 'firefox');

    this._executables.push({
      type: 'browser',
      name: 'firefox',
      browserName: 'firefox',
      directory: firefox.dir,
      executablePath: () => firefoxExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('firefox', firefoxExecutable, firefox.installByDefault, sdkLanguage),
      installType: firefox.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'firefox', firefox.dir, ['firefox'], [], ['firefox']),
      _install: () => this._downloadExecutable(firefox, firefoxExecutable, DOWNLOAD_PATHS['firefox'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST'),
      _dependencyGroup: 'firefox',
      _isHermeticInstallation: true
    });

    const firefoxBeta = descriptors.find(d => d.name === 'firefox-beta');
    const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, 'firefox');

    this._executables.push({
      type: 'tool',
      name: 'firefox-beta',
      browserName: 'firefox',
      directory: firefoxBeta.dir,
      executablePath: () => firefoxBetaExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('firefox-beta', firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage),
      installType: firefoxBeta.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'firefox', firefoxBeta.dir, ['firefox'], [], ['firefox']),
      _install: () => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable, DOWNLOAD_PATHS['firefox-beta'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST'),
      _dependencyGroup: 'firefox',
      _isHermeticInstallation: true
    });

    const webkit = descriptors.find(d => d.name === 'webkit');
    const webkitExecutable = findExecutablePath(webkit.dir, 'webkit');
    const webkitLinuxLddDirectories = [_path.default.join('minibrowser-gtk'), _path.default.join('minibrowser-gtk', 'bin'), _path.default.join('minibrowser-gtk', 'lib'), _path.default.join('minibrowser-gtk', 'sys', 'lib'), _path.default.join('minibrowser-wpe'), _path.default.join('minibrowser-wpe', 'bin'), _path.default.join('minibrowser-wpe', 'lib'), _path.default.join('minibrowser-wpe', 'sys', 'lib')];

    this._executables.push({
      type: 'browser',
      name: 'webkit',
      browserName: 'webkit',
      directory: webkit.dir,
      executablePath: () => webkitExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('webkit', webkitExecutable, webkit.installByDefault, sdkLanguage),
      installType: webkit.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: sdkLanguage => this._validateHostRequirements(sdkLanguage, 'webkit', webkit.dir, webkitLinuxLddDirectories, ['libGLESv2.so.2', 'libx264.so'], ['']),
      _install: () => this._downloadExecutable(webkit, webkitExecutable, DOWNLOAD_PATHS['webkit'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST'),
      _dependencyGroup: 'webkit',
      _isHermeticInstallation: true
    });

    const ffmpeg = descriptors.find(d => d.name === 'ffmpeg');
    const ffmpegExecutable = findExecutablePath(ffmpeg.dir, 'ffmpeg');

    this._executables.push({
      type: 'tool',
      name: 'ffmpeg',
      browserName: undefined,
      directory: ffmpeg.dir,
      executablePath: () => ffmpegExecutable,
      executablePathOrDie: sdkLanguage => executablePathOrDie('ffmpeg', ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage),
      installType: ffmpeg.installByDefault ? 'download-by-default' : 'download-on-demand',
      validateHostRequirements: () => Promise.resolve(),
      _install: () => this._downloadExecutable(ffmpeg, ffmpegExecutable, DOWNLOAD_PATHS['ffmpeg'][_hostPlatform.hostPlatform], 'PLAYWRIGHT_FFMPEG_DOWNLOAD_HOST'),
      _dependencyGroup: 'tools',
      _isHermeticInstallation: true
    });
  }

  _createChromiumChannel(name, lookAt, install) {
    const executablePath = (sdkLanguage, shouldThrow) => {
      const suffix = lookAt[process.platform];

      if (!suffix) {
        if (shouldThrow) throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
        return undefined;
      }

      const prefixes = process.platform === 'win32' ? [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env['PROGRAMFILES(X86)']].filter(Boolean) : [''];

      for (const prefix of prefixes) {
        const executablePath = _path.default.join(prefix, suffix);

        if ((0, _fileUtils.canAccessFile)(executablePath)) return executablePath;
      }

      if (!shouldThrow) return undefined;
      const location = prefixes.length ? ` at ${_path.default.join(prefixes[0], suffix)}` : ``; // TODO: language-specific error message

      const installation = install ? `\nRun "${buildPlaywrightCLICommand(sdkLanguage, 'install ' + name)}"` : '';
      throw new Error(`Chromium distribution '${name}' is not found${location}${installation}`);
    };

    return {
      type: 'channel',
      name,
      browserName: 'chromium',
      directory: undefined,
      executablePath: sdkLanguage => executablePath(sdkLanguage, false),
      executablePathOrDie: sdkLanguage => executablePath(sdkLanguage, true),
      installType: install ? 'install-script' : 'none',
      validateHostRequirements: () => Promise.resolve(),
      _isHermeticInstallation: false,
      _install: install
    };
  }

  executables() {
    return this._executables;
  }

  findExecutable(name) {
    return this._executables.find(b => b.name === name);
  }

  defaultExecutables() {
    return this._executables.filter(e => e.installType === 'download-by-default');
  }

  _addRequirementsAndDedupe(executables) {
    const set = new Set();

    for (const executable of executables) {
      set.add(executable);
      if (executable.browserName === 'chromium') set.add(this.findExecutable('ffmpeg'));
    }

    return Array.from(set);
  }

  async _validateHostRequirements(sdkLanguage, browserName, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
    if ((0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS')) {
      process.stdout.write('Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n');
      return;
    }

    const distributionInfo = await (0, _linuxUtils.getLinuxDistributionInfo)();
    if (browserName === 'firefox' && (distributionInfo === null || distributionInfo === void 0 ? void 0 : distributionInfo.id) === 'ubuntu' && (distributionInfo === null || distributionInfo === void 0 ? void 0 : distributionInfo.version) === '16.04') throw new Error(`Cannot launch Firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 18.04`);
    if (os.platform() === 'linux') return await (0, _dependencies.validateDependenciesLinux)(sdkLanguage, linuxLddDirectories.map(d => _path.default.join(browserDirectory, d)), dlOpenLibraries);
    if (os.platform() === 'win32' && os.arch() === 'x64') return await (0, _dependencies.validateDependenciesWindows)(windowsExeAndDllDirectories.map(d => _path.default.join(browserDirectory, d)));
  }

  async installDeps(executablesToInstallDeps, dryRun) {
    const executables = this._addRequirementsAndDedupe(executablesToInstallDeps);

    const targets = new Set();

    for (const executable of executables) {
      if (executable._dependencyGroup) targets.add(executable._dependencyGroup);
    }

    targets.add('tools');
    if (os.platform() === 'win32') return await (0, _dependencies.installDependenciesWindows)(targets, dryRun);
    if (os.platform() === 'linux') return await (0, _dependencies.installDependenciesLinux)(targets, dryRun);
  }

  async install(executablesToInstall, forceReinstall) {
    const executables = this._addRequirementsAndDedupe(executablesToInstall);

    await fs.promises.mkdir(registryDirectory, {
      recursive: true
    });

    const lockfilePath = _path.default.join(registryDirectory, '__dirlock');

    const linksDir = _path.default.join(registryDirectory, '.links');

    let releaseLock;

    try {
      releaseLock = await _utilsBundle.lockfile.lock(registryDirectory, {
        retries: {
          // Retry 20 times during 10 minutes with
          // exponential back-off.
          // See documentation at: https://www.npmjs.com/package/retry#retrytimeoutsoptions
          retries: 20,
          factor: 1.27579
        },
        onCompromised: err => {
          throw new Error(`${err.message} Path: ${lockfilePath}`);
        },
        lockfilePath
      }); // Create a link first, so that cache validation does not remove our own browsers.

      await fs.promises.mkdir(linksDir, {
        recursive: true
      });
      await fs.promises.writeFile(_path.default.join(linksDir, (0, _utils.calculateSha1)(PACKAGE_PATH)), PACKAGE_PATH); // Remove stale browsers.

      await this._validateInstallationCache(linksDir); // Install browsers for this package.

      for (const executable of executables) {
        if (!executable._install) throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
        const {
          langName
        } = (0, _userAgent.getClientLanguage)();

        if (!(0, _utils.getAsBooleanFromENV)('CI') && !executable._isHermeticInstallation && !forceReinstall && executable.executablePath(langName)) {
          const command = buildPlaywrightCLICommand(langName, 'install --force ' + executable.name);
          throw new Error('\n' + (0, _utils.wrapInASCIIBox)([`ATTENTION: "${executable.name}" is already installed on the system!`, ``, `"${executable.name}" installation is not hermetic; installing newer version`, `requires *removal* of a current installation first.`, ``, `To *uninstall* current version and re-install latest "${executable.name}":`, ``, `- Close all running instances of "${executable.name}", if any`, `- Use "--force" to install browser:`, ``, `    ${command}`, ``, `<3 Playwright Team`].join('\n'), 1));
        }

        await executable._install();
      }
    } catch (e) {
      if (e.code === 'ELOCKED') {
        const rmCommand = process.platform === 'win32' ? 'rm -R' : 'rm -rf';
        throw new Error('\n' + (0, _utils.wrapInASCIIBox)([`An active lockfile is found at:`, ``, `  ${lockfilePath}`, ``, `Either:`, `- wait a few minutes if other Playwright is installing browsers in parallel`, `- remove lock manually with:`, ``, `    ${rmCommand} ${lockfilePath}`, ``, `<3 Playwright Team`].join('\n'), 1));
      } else {
        throw e;
      }
    } finally {
      if (releaseLock) await releaseLock();
    }
  }

  async _downloadExecutable(descriptor, executablePath, downloadPathTemplate, downloadHostEnv) {
    if (!downloadPathTemplate || !executablePath) throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${_hostPlatform.hostPlatform}`);
    if (_hostPlatform.hostPlatform === 'generic-linux' || _hostPlatform.hostPlatform === 'generic-linux-arm64') (0, _browserFetcher.logPolitely)('BEWARE: your OS is not officially supported by Playwright; downloading fallback build.');
    const downloadPath = util.format(downloadPathTemplate, descriptor.revision);
    let downloadURLs = PLAYWRIGHT_CDN_MIRRORS.map(mirror => `${mirror}/${downloadPath}`);
    const customHostOverride = downloadHostEnv && (0, _utils.getFromENV)(downloadHostEnv) || (0, _utils.getFromENV)('PLAYWRIGHT_DOWNLOAD_HOST');
    if (customHostOverride) downloadURLs = [`${customHostOverride}/${downloadPath}`];
    const displayName = descriptor.name.split('-').map(word => {
      return word === 'ffmpeg' ? 'FFMPEG' : word.charAt(0).toUpperCase() + word.slice(1);
    }).join(' ');
    const title = descriptor.browserVersion ? `${displayName} ${descriptor.browserVersion} (playwright build v${descriptor.revision})` : `${displayName} playwright build v${descriptor.revision}`;
    const downloadFileName = `playwright-download-${descriptor.name}-${_hostPlatform.hostPlatform}-${descriptor.revision}.zip`;
    await (0, _browserFetcher.downloadBrowserWithProgressBar)(title, descriptor.dir, executablePath, downloadURLs, downloadFileName).catch(e => {
      throw new Error(`Failed to download ${title}, caused by\n${e.stack}`);
    });
    await fs.promises.writeFile(markerFilePath(descriptor.dir), '');
  }

  async _installMSEdgeChannel(channel, scripts) {
    const scriptArgs = [];

    if (process.platform !== 'linux') {
      const products = lowercaseAllKeys(JSON.parse(await (0, _netUtils.fetchData)({
        url: 'https://edgeupdates.microsoft.com/api/products'
      })));
      const productName = {
        'msedge': 'Stable',
        'msedge-beta': 'Beta',
        'msedge-dev': 'Dev'
      }[channel];
      const product = products.find(product => product.product === productName);
      const searchConfig = {
        darwin: {
          platform: 'MacOS',
          arch: 'universal',
          artifact: 'pkg'
        },
        win32: {
          platform: 'Windows',
          arch: 'x64',
          artifact: 'msi'
        }
      }[process.platform];
      const release = searchConfig ? product.releases.find(release => release.platform === searchConfig.platform && release.architecture === searchConfig.arch) : null;
      const artifact = release ? release.artifacts.find(artifact => artifact.artifactname === searchConfig.artifact) : null;
      if (artifact) scriptArgs.push(artifact.location
      /* url */
      );else throw new Error(`Cannot install ${channel} on ${process.platform}`);
    }

    await this._installChromiumChannel(channel, scripts, scriptArgs);
  }

  async _installChromiumChannel(channel, scripts, scriptArgs = []) {
    const scriptName = scripts[process.platform];
    if (!scriptName) throw new Error(`Cannot install ${channel} on ${process.platform}`);
    const cwd = BIN_PATH;
    const isPowerShell = scriptName.endsWith('.ps1');

    if (isPowerShell) {
      const args = ['-ExecutionPolicy', 'Bypass', '-File', _path.default.join(BIN_PATH, scriptName), ...scriptArgs];
      const {
        code
      } = await (0, _spawnAsync.spawnAsync)('powershell.exe', args, {
        cwd,
        stdio: 'inherit'
      });
      if (code !== 0) throw new Error(`Failed to install ${channel}`);
    } else {
      const {
        command,
        args,
        elevatedPermissions
      } = await (0, _dependencies.transformCommandsForRoot)([`bash "${_path.default.join(BIN_PATH, scriptName)}" ${scriptArgs.join('')}`]);
      if (elevatedPermissions) console.log('Switching to root user to install dependencies...'); // eslint-disable-line no-console

      const {
        code
      } = await (0, _spawnAsync.spawnAsync)(command, args, {
        cwd,
        stdio: 'inherit'
      });
      if (code !== 0) throw new Error(`Failed to install ${channel}`);
    }
  }

  async _validateInstallationCache(linksDir) {
    // 1. Collect used downloads and package descriptors.
    const usedBrowserPaths = new Set();

    for (const fileName of await fs.promises.readdir(linksDir)) {
      const linkPath = _path.default.join(linksDir, fileName);

      let linkTarget = '';

      try {
        linkTarget = (await fs.promises.readFile(linkPath)).toString();

        const browsersJSON = require(_path.default.join(linkTarget, 'browsers.json'));

        const descriptors = readDescriptors(browsersJSON);

        for (const browserName of allDownloadable) {
          // We retain browsers if they are found in the descriptor.
          // Note, however, that there are older versions out in the wild that rely on
          // the "download" field in the browser descriptor and use its value
          // to retain and download browsers.
          // As of v1.10, we decided to abandon "download" field.
          const descriptor = descriptors.find(d => d.name === browserName);
          if (!descriptor) continue;
          const usedBrowserPath = descriptor.dir;
          const browserRevision = parseInt(descriptor.revision, 10); // Old browser installations don't have marker file.

          const shouldHaveMarkerFile = browserName === 'chromium' && browserRevision >= 786218 || browserName === 'firefox' && browserRevision >= 1128 || browserName === 'webkit' && browserRevision >= 1307 || // All new applications have a marker file right away.
          browserName !== 'firefox' && browserName !== 'chromium' && browserName !== 'webkit';
          if (!shouldHaveMarkerFile || (await (0, _fileUtils.existsAsync)(markerFilePath(usedBrowserPath)))) usedBrowserPaths.add(usedBrowserPath);
        }
      } catch (e) {
        await fs.promises.unlink(linkPath).catch(e => {});
      }
    } // 2. Delete all unused browsers.


    if (!(0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_SKIP_BROWSER_GC')) {
      let downloadedBrowsers = (await fs.promises.readdir(registryDirectory)).map(file => _path.default.join(registryDirectory, file));
      downloadedBrowsers = downloadedBrowsers.filter(file => isBrowserDirectory(file));
      const directories = new Set(downloadedBrowsers);

      for (const browserDirectory of usedBrowserPaths) directories.delete(browserDirectory);

      for (const directory of directories) (0, _browserFetcher.logPolitely)('Removing unused browser at ' + directory);

      await (0, _fileUtils.removeFolders)([...directories]);
    }
  }

}

exports.Registry = Registry;

function markerFilePath(browserDirectory) {
  return _path.default.join(browserDirectory, 'INSTALLATION_COMPLETE');
}

function buildPlaywrightCLICommand(sdkLanguage, parameters) {
  switch (sdkLanguage) {
    case 'python':
      return `playwright ${parameters}`;

    case 'java':
      return `mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="${parameters}"`;

    case 'csharp':
      return `pwsh bin/Debug/netX/playwright.ps1 ${parameters}`;

    default:
      return `npx playwright ${parameters}`;
  }
}

async function installDefaultBrowsersForNpmInstall() {
  const defaultBrowserNames = registry.defaultExecutables().map(e => e.name);
  return installBrowsersForNpmInstall(defaultBrowserNames);
}

async function installBrowsersForNpmInstall(browsers) {
  // PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD should have a value of 0 or 1
  if ((0, _utils.getAsBooleanFromENV)('PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD')) {
    (0, _browserFetcher.logPolitely)('Skipping browsers download because `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` env variable is set');
    return false;
  }

  const executables = [];

  for (const browserName of browsers) {
    const executable = registry.findExecutable(browserName);
    if (!executable || executable.installType === 'none') throw new Error(`Cannot install ${browserName}`);
    executables.push(executable);
  }

  await registry.install(executables, false
  /* forceReinstall */
  );
}

function findChromiumChannel(sdkLanguage) {
  // Fall back to the stable channels of popular vendors to work out of the box.
  // Null means no installation and no channels found.
  let channel = null;

  for (const name of ['chromium', 'chrome', 'msedge']) {
    try {
      registry.findExecutable(name).executablePathOrDie(sdkLanguage);
      channel = name === 'chromium' ? undefined : name;
      break;
    } catch (e) {}
  }

  if (channel === null) {
    const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
    const prettyMessage = [`No chromium-based browser found on the system.`, `Please run the following command to download one:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join('\n');
    throw new Error('\n' + (0, _utils.wrapInASCIIBox)(prettyMessage, 1));
  }

  return channel;
}

function lowercaseAllKeys(json) {
  if (typeof json !== 'object' || !json) return json;
  if (Array.isArray(json)) return json.map(lowercaseAllKeys);
  const result = {};

  for (const [key, value] of Object.entries(json)) result[key.toLowerCase()] = lowercaseAllKeys(value);

  return result;
}

const registry = new Registry(__nccwpck_require__(1065));
exports.registry = registry;

/***/ }),

/***/ 4971:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.deps = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// - This file is used to execute 'npx playwright install-deps'
// - The reverse mappings "lib2package" are generated with the following script:
//     ./utils/linux-browser-dependencies/run.sh ubuntu:20.04
const deps = {
  'ubuntu18.04': {
    tools: ['xvfb', 'fonts-noto-color-emoji', 'ttf-unifont', 'libfontconfig', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'ttf-ubuntu-font-family'],
    chromium: ['fonts-liberation', 'libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libgbm1', 'libglib2.0-0', 'libgtk-3-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxrandr2', 'libxshmfence1'],
    firefox: ['ffmpeg', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libpangoft2-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrender1', 'libxt6', 'libxtst6'],
    webkit: ['gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libbrotli1', 'libcairo2', 'libegl1', 'libenchant1c2a', 'libepoxy0', 'libevdev2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libgl1', 'libgles2', 'libglib2.0-0', 'libgstreamer-gl1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libicu60', 'libjpeg-turbo8', 'libnotify4', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libsecret-1-0', 'libvpx5', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebp6', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1'],
    lib2package: {
      'libasound.so.2': 'libasound2',
      'libatk-1.0.so.0': 'libatk1.0-0',
      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
      'libatspi.so.0': 'libatspi2.0-0',
      'libbrotlidec.so.1': 'libbrotli1',
      'libcairo-gobject.so.2': 'libcairo-gobject2',
      'libcairo.so.2': 'libcairo2',
      'libcups.so.2': 'libcups2',
      'libdbus-1.so.3': 'libdbus-1-3',
      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
      'libdrm.so.2': 'libdrm2',
      'libEGL.so.1': 'libegl1',
      'libenchant.so.1': 'libenchant1c2a',
      'libepoxy.so.0': 'libepoxy0',
      'libevent-2.1.so.6': 'libevent-2.1-6',
      'libevdev.so.2': 'libevdev2',
      'libfontconfig.so.1': 'libfontconfig1',
      'libfreetype.so.6': 'libfreetype6',
      'libgbm.so.1': 'libgbm1',
      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf2.0-0',
      'libgdk-3.so.0': 'libgtk-3-0',
      'libgdk-x11-2.0.so.0': 'libgtk2.0-0',
      'libgio-2.0.so.0': 'libglib2.0-0',
      'libGL.so.1': 'libgl1',
      'libGLESv2.so.2': 'libgles2',
      'libglib-2.0.so.0': 'libglib2.0-0',
      'libgmodule-2.0.so.0': 'libglib2.0-0',
      'libgobject-2.0.so.0': 'libglib2.0-0',
      'libgstapp-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstaudio-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
      'libgstcodecparsers-1.0.so.0': 'gstreamer1.0-plugins-bad',
      'libgstfft-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
      'libgstpbutils-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
      'libgsttag-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstvideo-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgthread-2.0.so.0': 'libglib2.0-0',
      'libgtk-3.so.0': 'libgtk-3-0',
      'libgtk-x11-2.0.so.0': 'libgtk2.0-0',
      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
      'libharfbuzz.so.0': 'libharfbuzz0b',
      'libhyphen.so.0': 'libhyphen0',
      'libicudata.so.60': 'libicu60',
      'libicui18n.so.60': 'libicu60',
      'libicuuc.so.60': 'libicu60',
      'libjpeg.so.8': 'libjpeg-turbo8',
      'libnotify.so.4': 'libnotify4',
      'libnspr4.so': 'libnspr4',
      'libnss3.so': 'libnss3',
      'libnssutil3.so': 'libnss3',
      'libopenjp2.so.7': 'libopenjp2-7',
      'libopus.so.0': 'libopus0',
      'libpango-1.0.so.0': 'libpango-1.0-0',
      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
      'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',
      'libpng16.so.16': 'libpng16-16',
      'libsecret-1.so.0': 'libsecret-1-0',
      'libsmime3.so': 'libnss3',
      'libvpx.so.5': 'libvpx5',
      'libwayland-client.so.0': 'libwayland-client0',
      'libwayland-egl.so.1': 'libwayland-egl1',
      'libwayland-server.so.0': 'libwayland-server0',
      'libwebp.so.6': 'libwebp6',
      'libwebpdemux.so.2': 'libwebpdemux2',
      'libwoff2dec.so.1.0.2': 'libwoff1',
      'libX11-xcb.so.1': 'libx11-xcb1',
      'libX11.so.6': 'libx11-6',
      'libxcb-dri3.so.0': 'libxcb-dri3-0',
      'libxcb-shm.so.0': 'libxcb-shm0',
      'libxcb.so.1': 'libxcb1',
      'libXcomposite.so.1': 'libxcomposite1',
      'libXcursor.so.1': 'libxcursor1',
      'libXdamage.so.1': 'libxdamage1',
      'libXext.so.6': 'libxext6',
      'libXfixes.so.3': 'libxfixes3',
      'libXi.so.6': 'libxi6',
      'libxkbcommon.so.0': 'libxkbcommon0',
      'libxml2.so.2': 'libxml2',
      'libXrandr.so.2': 'libxrandr2',
      'libXrender.so.1': 'libxrender1',
      'libxslt.so.1': 'libxslt1.1',
      'libXt.so.6': 'libxt6',
      'libXtst.so.6': 'libxtst6'
    }
  },
  'ubuntu20.04': {
    tools: ['xvfb', 'fonts-noto-color-emoji', 'ttf-unifont', 'libfontconfig', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'ttf-ubuntu-font-family'],
    chromium: ['fonts-liberation', 'libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libgbm1', 'libglib2.0-0', 'libgtk-3-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxrandr2', 'libxshmfence1'],
    firefox: ['ffmpeg', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libpangoft2-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrender1', 'libxt6', 'libxtst6'],
    webkit: ['gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libcairo2', 'libegl1', 'libenchant1c2a', 'libepoxy0', 'libevdev2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf2.0-0', 'libgl1', 'libgles2', 'libglib2.0-0', 'libgstreamer-gl1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libicu66', 'libjpeg-turbo8', 'libnotify4', 'libopengl0', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libsecret-1-0', 'libsoup2.4-1', 'libvpx6', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebp6', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1', 'libatomic1'],
    lib2package: {
      'libasound.so.2': 'libasound2',
      'libatk-1.0.so.0': 'libatk1.0-0',
      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
      'libatspi.so.0': 'libatspi2.0-0',
      'libcairo-gobject.so.2': 'libcairo-gobject2',
      'libcairo.so.2': 'libcairo2',
      'libcups.so.2': 'libcups2',
      'libdbus-1.so.3': 'libdbus-1-3',
      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
      'libdrm.so.2': 'libdrm2',
      'libEGL.so.1': 'libegl1',
      'libenchant.so.1': 'libenchant1c2a',
      'libevdev.so.2': 'libevdev2',
      'libepoxy.so.0': 'libepoxy0',
      'libfontconfig.so.1': 'libfontconfig1',
      'libfreetype.so.6': 'libfreetype6',
      'libgbm.so.1': 'libgbm1',
      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf2.0-0',
      'libgdk-3.so.0': 'libgtk-3-0',
      'libgdk-x11-2.0.so.0': 'libgtk2.0-0',
      'libgio-2.0.so.0': 'libglib2.0-0',
      'libGL.so.1': 'libgl1',
      'libGLESv2.so.2': 'libgles2',
      'libglib-2.0.so.0': 'libglib2.0-0',
      'libgmodule-2.0.so.0': 'libglib2.0-0',
      'libgobject-2.0.so.0': 'libglib2.0-0',
      'libgstapp-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstaudio-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
      'libgstcodecparsers-1.0.so.0': 'gstreamer1.0-plugins-bad',
      'libgstfft-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
      'libgstpbutils-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
      'libgsttag-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgstvideo-1.0.so.0': 'gstreamer1.0-plugins-base',
      'libgthread-2.0.so.0': 'libglib2.0-0',
      'libgtk-3.so.0': 'libgtk-3-0',
      'libgtk-x11-2.0.so.0': 'libgtk2.0-0',
      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
      'libharfbuzz.so.0': 'libharfbuzz0b',
      'libhyphen.so.0': 'libhyphen0',
      'libicui18n.so.66': 'libicu66',
      'libicuuc.so.66': 'libicu66',
      'libjpeg.so.8': 'libjpeg-turbo8',
      'libnotify.so.4': 'libnotify4',
      'libnspr4.so': 'libnspr4',
      'libnss3.so': 'libnss3',
      'libnssutil3.so': 'libnss3',
      'libOpenGL.so.0': 'libopengl0',
      'libopenjp2.so.7': 'libopenjp2-7',
      'libopus.so.0': 'libopus0',
      'libpango-1.0.so.0': 'libpango-1.0-0',
      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
      'libpangoft2-1.0.so.0': 'libpangoft2-1.0-0',
      'libpng16.so.16': 'libpng16-16',
      'libsecret-1.so.0': 'libsecret-1-0',
      'libsmime3.so': 'libnss3',
      'libsoup-2.4.so.1': 'libsoup2.4-1',
      'libvpx.so.6': 'libvpx6',
      'libwayland-client.so.0': 'libwayland-client0',
      'libwayland-egl.so.1': 'libwayland-egl1',
      'libwayland-server.so.0': 'libwayland-server0',
      'libwebp.so.6': 'libwebp6',
      'libwebpdemux.so.2': 'libwebpdemux2',
      'libwoff2dec.so.1.0.2': 'libwoff1',
      'libX11-xcb.so.1': 'libx11-xcb1',
      'libX11.so.6': 'libx11-6',
      'libxcb-dri3.so.0': 'libxcb-dri3-0',
      'libxcb-shm.so.0': 'libxcb-shm0',
      'libxcb.so.1': 'libxcb1',
      'libXcomposite.so.1': 'libxcomposite1',
      'libXcursor.so.1': 'libxcursor1',
      'libXdamage.so.1': 'libxdamage1',
      'libXext.so.6': 'libxext6',
      'libXfixes.so.3': 'libxfixes3',
      'libXi.so.6': 'libxi6',
      'libxkbcommon.so.0': 'libxkbcommon0',
      'libxml2.so.2': 'libxml2',
      'libXrandr.so.2': 'libxrandr2',
      'libXrender.so.1': 'libxrender1',
      'libxslt.so.1': 'libxslt1.1',
      'libXt.so.6': 'libxt6',
      'libXtst.so.6': 'libxtst6',
      'libxshmfence.so.1': 'libxshmfence1',
      'libatomic.so.1': 'libatomic1'
    }
  },
  'ubuntu22.04': {
    tools: ['xvfb', 'fonts-noto-color-emoji', 'fonts-unifont', 'libfontconfig1', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'fonts-freefont-ttf'],
    chromium: ['libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libgbm1', 'libglib2.0-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libwayland-client0', 'libx11-6', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxkbcommon0', 'libxrandr2'],
    firefox: ['ffmpeg', 'libasound2', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf-2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrandr2', 'libxrender1', 'libxtst6'],
    webkit: ['libenchant-2-2', 'gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libicu70', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libcairo2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libepoxy0', 'libevdev2', 'libffi7', 'libfontconfig1', 'libfreetype6', 'libgbm1', 'libgdk-pixbuf-2.0-0', 'libgles2', 'libglib2.0-0', 'libglx0', 'libgstreamer-gl1.0-0', 'libgstreamer-plugins-base1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libgudev-1.0-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libjpeg-turbo8', 'liblcms2-2', 'libmanette-0.2-0', 'libnotify4', 'libopengl0', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libproxy1v5', 'libsecret-1-0', 'libsoup2.4-1', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1', 'libx264-163', 'libatomic1'],
    lib2package: {
      'libasound.so.2': 'libasound2',
      'libatk-1.0.so.0': 'libatk1.0-0',
      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
      'libatspi.so.0': 'libatspi2.0-0',
      'libcairo-gobject.so.2': 'libcairo-gobject2',
      'libcairo.so.2': 'libcairo2',
      'libcups.so.2': 'libcups2',
      'libdbus-1.so.3': 'libdbus-1-3',
      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
      'libdrm.so.2': 'libdrm2',
      'libEGL.so.1': 'libegl1',
      'libepoxy.so.0': 'libepoxy0',
      'libevdev.so.2': 'libevdev2',
      'libffi.so.7': 'libffi7',
      'libfontconfig.so.1': 'libfontconfig1',
      'libfreetype.so.6': 'libfreetype6',
      'libgbm.so.1': 'libgbm1',
      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf-2.0-0',
      'libgdk-3.so.0': 'libgtk-3-0',
      'libgio-2.0.so.0': 'libglib2.0-0',
      'libGLESv2.so.2': 'libgles2',
      'libglib-2.0.so.0': 'libglib2.0-0',
      'libGLX.so.0': 'libglx0',
      'libgmodule-2.0.so.0': 'libglib2.0-0',
      'libgobject-2.0.so.0': 'libglib2.0-0',
      'libgstallocators-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstapp-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstaudio-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
      'libgstfft-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
      'libgstpbutils-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
      'libgsttag-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstvideo-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgtk-3.so.0': 'libgtk-3-0',
      'libgudev-1.0.so.0': 'libgudev-1.0-0',
      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
      'libharfbuzz.so.0': 'libharfbuzz0b',
      'libhyphen.so.0': 'libhyphen0',
      'libjpeg.so.8': 'libjpeg-turbo8',
      'liblcms2.so.2': 'liblcms2-2',
      'libmanette-0.2.so.0': 'libmanette-0.2-0',
      'libnotify.so.4': 'libnotify4',
      'libnspr4.so': 'libnspr4',
      'libnss3.so': 'libnss3',
      'libnssutil3.so': 'libnss3',
      'libOpenGL.so.0': 'libopengl0',
      'libopenjp2.so.7': 'libopenjp2-7',
      'libopus.so.0': 'libopus0',
      'libpango-1.0.so.0': 'libpango-1.0-0',
      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
      'libpng16.so.16': 'libpng16-16',
      'libproxy.so.1': 'libproxy1v5',
      'libsecret-1.so.0': 'libsecret-1-0',
      'libsmime3.so': 'libnss3',
      'libsoup-2.4.so.1': 'libsoup2.4-1',
      'libwayland-client.so.0': 'libwayland-client0',
      'libwayland-egl.so.1': 'libwayland-egl1',
      'libwayland-server.so.0': 'libwayland-server0',
      'libwebpdemux.so.2': 'libwebpdemux2',
      'libwoff2dec.so.1.0.2': 'libwoff1',
      'libX11-xcb.so.1': 'libx11-xcb1',
      'libX11.so.6': 'libx11-6',
      'libxcb-shm.so.0': 'libxcb-shm0',
      'libxcb.so.1': 'libxcb1',
      'libXcomposite.so.1': 'libxcomposite1',
      'libXcursor.so.1': 'libxcursor1',
      'libXdamage.so.1': 'libxdamage1',
      'libXext.so.6': 'libxext6',
      'libXfixes.so.3': 'libxfixes3',
      'libXi.so.6': 'libxi6',
      'libxkbcommon.so.0': 'libxkbcommon0',
      'libxml2.so.2': 'libxml2',
      'libXrandr.so.2': 'libxrandr2',
      'libXrender.so.1': 'libxrender1',
      'libxslt.so.1': 'libxslt1.1',
      'libXtst.so.6': 'libxtst6',
      'libicui18n.so.60': 'libicu70',
      'libicuuc.so.66': 'libicu70',
      'libicui18n.so.66': 'libicu70',
      'libwebp.so.6': 'libwebp6',
      'libenchant-2.so.2': 'libenchant-2-2',
      'libx264.so': 'libx264-163',
      'libvpx.so.7': 'libvpx7',
      'libatomic.so.1': 'libatomic1'
    }
  },
  'debian11': {
    tools: ['xvfb', 'fonts-noto-color-emoji', 'fonts-unifont', 'libfontconfig1', 'libfreetype6', 'xfonts-cyrillic', 'xfonts-scalable', 'fonts-liberation', 'fonts-ipafont-gothic', 'fonts-wqy-zenhei', 'fonts-tlwg-loma-otf', 'fonts-freefont-ttf'],
    chromium: ['libasound2', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libatspi2.0-0', 'libcairo2', 'libcups2', 'libdbus-1-3', 'libdrm2', 'libgbm1', 'libglib2.0-0', 'libnspr4', 'libnss3', 'libpango-1.0-0', 'libwayland-client0', 'libx11-6', 'libxcb1', 'libxcomposite1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxkbcommon0', 'libxrandr2'],
    firefox: ['libasound2', 'libatk1.0-0', 'libcairo-gobject2', 'libcairo2', 'libdbus-1-3', 'libdbus-glib-1-2', 'libfontconfig1', 'libfreetype6', 'libgdk-pixbuf-2.0-0', 'libglib2.0-0', 'libgtk-3-0', 'libharfbuzz0b', 'libpango-1.0-0', 'libpangocairo-1.0-0', 'libx11-6', 'libx11-xcb1', 'libxcb-shm0', 'libxcb1', 'libxcomposite1', 'libxcursor1', 'libxdamage1', 'libxext6', 'libxfixes3', 'libxi6', 'libxrandr2', 'libxrender1', 'libxtst6'],
    webkit: ['gstreamer1.0-libav', 'gstreamer1.0-plugins-bad', 'gstreamer1.0-plugins-base', 'gstreamer1.0-plugins-good', 'libatk-bridge2.0-0', 'libatk1.0-0', 'libcairo2', 'libdbus-1-3', 'libdrm2', 'libegl1', 'libenchant-2-2', 'libepoxy0', 'libevdev2', 'libfontconfig1', 'libfreetype6', 'libgbm1', 'libgdk-pixbuf-2.0-0', 'libgles2', 'libglib2.0-0', 'libglx0', 'libgstreamer-gl1.0-0', 'libgstreamer-plugins-base1.0-0', 'libgstreamer1.0-0', 'libgtk-3-0', 'libgudev-1.0-0', 'libharfbuzz-icu0', 'libharfbuzz0b', 'libhyphen0', 'libicu67', 'libjpeg62-turbo', 'liblcms2-2', 'libmanette-0.2-0', 'libnotify4', 'libopengl0', 'libopenjp2-7', 'libopus0', 'libpango-1.0-0', 'libpng16-16', 'libproxy1v5', 'libsecret-1-0', 'libsoup2.4-1', 'libwayland-client0', 'libwayland-egl1', 'libwayland-server0', 'libwebp6', 'libwebpdemux2', 'libwoff1', 'libx11-6', 'libxcomposite1', 'libxdamage1', 'libxkbcommon0', 'libxml2', 'libxslt1.1', 'libatomic1'],
    lib2package: {
      'libasound.so.2': 'libasound2',
      'libatk-1.0.so.0': 'libatk1.0-0',
      'libatk-bridge-2.0.so.0': 'libatk-bridge2.0-0',
      'libatspi.so.0': 'libatspi2.0-0',
      'libcairo-gobject.so.2': 'libcairo-gobject2',
      'libcairo.so.2': 'libcairo2',
      'libcups.so.2': 'libcups2',
      'libdbus-1.so.3': 'libdbus-1-3',
      'libdbus-glib-1.so.2': 'libdbus-glib-1-2',
      'libdrm.so.2': 'libdrm2',
      'libEGL.so.1': 'libegl1',
      'libenchant-2.so.2': 'libenchant-2-2',
      'libepoxy.so.0': 'libepoxy0',
      'libevdev.so.2': 'libevdev2',
      'libfontconfig.so.1': 'libfontconfig1',
      'libfreetype.so.6': 'libfreetype6',
      'libgbm.so.1': 'libgbm1',
      'libgdk_pixbuf-2.0.so.0': 'libgdk-pixbuf-2.0-0',
      'libgdk-3.so.0': 'libgtk-3-0',
      'libgio-2.0.so.0': 'libglib2.0-0',
      'libGLESv2.so.2': 'libgles2',
      'libglib-2.0.so.0': 'libglib2.0-0',
      'libGLX.so.0': 'libglx0',
      'libgmodule-2.0.so.0': 'libglib2.0-0',
      'libgobject-2.0.so.0': 'libglib2.0-0',
      'libgstallocators-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstapp-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstaudio-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstbase-1.0.so.0': 'libgstreamer1.0-0',
      'libgstfft-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstgl-1.0.so.0': 'libgstreamer-gl1.0-0',
      'libgstpbutils-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstreamer-1.0.so.0': 'libgstreamer1.0-0',
      'libgsttag-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgstvideo-1.0.so.0': 'libgstreamer-plugins-base1.0-0',
      'libgtk-3.so.0': 'libgtk-3-0',
      'libgudev-1.0.so.0': 'libgudev-1.0-0',
      'libharfbuzz-icu.so.0': 'libharfbuzz-icu0',
      'libharfbuzz.so.0': 'libharfbuzz0b',
      'libhyphen.so.0': 'libhyphen0',
      'libicui18n.so.67': 'libicu67',
      'libicuuc.so.67': 'libicu67',
      'libjpeg.so.62': 'libjpeg62-turbo',
      'liblcms2.so.2': 'liblcms2-2',
      'libmanette-0.2.so.0': 'libmanette-0.2-0',
      'libnotify.so.4': 'libnotify4',
      'libnspr4.so': 'libnspr4',
      'libnss3.so': 'libnss3',
      'libnssutil3.so': 'libnss3',
      'libOpenGL.so.0': 'libopengl0',
      'libopenjp2.so.7': 'libopenjp2-7',
      'libopus.so.0': 'libopus0',
      'libpango-1.0.so.0': 'libpango-1.0-0',
      'libpangocairo-1.0.so.0': 'libpangocairo-1.0-0',
      'libpng16.so.16': 'libpng16-16',
      'libproxy.so.1': 'libproxy1v5',
      'libsecret-1.so.0': 'libsecret-1-0',
      'libsmime3.so': 'libnss3',
      'libsoup-2.4.so.1': 'libsoup2.4-1',
      'libwayland-client.so.0': 'libwayland-client0',
      'libwayland-egl.so.1': 'libwayland-egl1',
      'libwayland-server.so.0': 'libwayland-server0',
      'libwebp.so.6': 'libwebp6',
      'libwebpdemux.so.2': 'libwebpdemux2',
      'libwoff2dec.so.1.0.2': 'libwoff1',
      'libX11-xcb.so.1': 'libx11-xcb1',
      'libX11.so.6': 'libx11-6',
      'libxcb-shm.so.0': 'libxcb-shm0',
      'libxcb.so.1': 'libxcb1',
      'libXcomposite.so.1': 'libxcomposite1',
      'libXcursor.so.1': 'libxcursor1',
      'libXdamage.so.1': 'libxdamage1',
      'libXext.so.6': 'libxext6',
      'libXfixes.so.3': 'libxfixes3',
      'libXi.so.6': 'libxi6',
      'libxkbcommon.so.0': 'libxkbcommon0',
      'libxml2.so.2': 'libxml2',
      'libXrandr.so.2': 'libxrandr2',
      'libXrender.so.1': 'libxrender1',
      'libxslt.so.1': 'libxslt1.1',
      'libXtst.so.6': 'libxtst6',
      'libatomic.so.1': 'libatomic1'
    }
  }
};
exports.deps = deps;
deps['ubuntu20.04-arm64'] = {
  tools: [...deps['ubuntu20.04'].tools],
  chromium: [...deps['ubuntu20.04'].chromium],
  firefox: [...deps['ubuntu20.04'].firefox],
  webkit: [...deps['ubuntu20.04'].webkit, 'libevent-2.1-7'],
  lib2package: { ...deps['ubuntu20.04'].lib2package,
    'libevent-2.1.so.7': 'libevent-2.1.so.7'
  }
};
deps['ubuntu22.04-arm64'] = {
  tools: [...deps['ubuntu22.04'].tools],
  chromium: [...deps['ubuntu22.04'].chromium],
  firefox: [...deps['ubuntu22.04'].firefox],
  webkit: [...deps['ubuntu22.04'].webkit, 'libevent-2.1-7'],
  lib2package: { ...deps['ubuntu22.04'].lib2package,
    'libevent-2.1.so.7': 'libevent-2.1.so.7'
  }
};

/***/ }),

/***/ 4613:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Screenshotter = void 0;
exports.validateScreenshotOptions = validateScreenshotOptions;

var _helper = __nccwpck_require__(9175);

var _utils = __nccwpck_require__(3557);

var _multimap = __nccwpck_require__(2391);

/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Screenshotter {
  constructor(page) {
    this._queue = new TaskQueue();
    this._page = void 0;
    this._page = page;
    this._queue = new TaskQueue();
  }

  async _originalViewportSize(progress) {
    const originalViewportSize = this._page.viewportSize();

    let viewportSize = originalViewportSize;
    if (!viewportSize) viewportSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
      width: window.innerWidth,
      height: window.innerHeight
    }));
    return {
      viewportSize,
      originalViewportSize
    };
  }

  async _fullPageSize(progress) {
    const fullPageSize = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {
      if (!document.body || !document.documentElement) return null;
      return {
        width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
        height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
      };
    });
    return fullPageSize;
  }

  async screenshotPage(progress, options) {
    const format = validateScreenshotOptions(options);
    return this._queue.postTask(async () => {
      progress.log('taking page screenshot');
      const {
        viewportSize
      } = await this._originalViewportSize(progress);
      await this._preparePageForScreenshot(progress, options.caret !== 'initial', options.animations === 'disabled');
      progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.

      if (options.fullPage) {
        const fullPageSize = await this._fullPageSize(progress);
        let documentRect = {
          x: 0,
          y: 0,
          width: fullPageSize.width,
          height: fullPageSize.height
        };
        const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
        if (options.clip) documentRect = trimClipToSize(options.clip, documentRect);
        const buffer = await this._screenshot(progress, format, documentRect, undefined, fitsViewport, options);
        progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.

        await this._restorePageAfterScreenshot();
        return buffer;
      }

      const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : {
        x: 0,
        y: 0,
        ...viewportSize
      };
      const buffer = await this._screenshot(progress, format, undefined, viewportRect, true, options);
      progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.

      await this._restorePageAfterScreenshot();
      return buffer;
    });
  }

  async screenshotElement(progress, handle, options) {
    const format = validateScreenshotOptions(options);
    return this._queue.postTask(async () => {
      progress.log('taking element screenshot');
      const {
        viewportSize
      } = await this._originalViewportSize(progress);
      await this._preparePageForScreenshot(progress, options.caret !== 'initial', options.animations === 'disabled');
      progress.throwIfAborted(); // Do not do extra work.

      await handle._waitAndScrollIntoViewIfNeeded(progress, true
      /* waitForVisible */
      );
      progress.throwIfAborted(); // Do not do extra work.

      const boundingBox = await handle.boundingBox();
      (0, _utils.assert)(boundingBox, 'Node is either not visible or not an HTMLElement');
      (0, _utils.assert)(boundingBox.width !== 0, 'Node has 0 width.');
      (0, _utils.assert)(boundingBox.height !== 0, 'Node has 0 height.');
      const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
      progress.throwIfAborted(); // Avoid extra work.

      const scrollOffset = await this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
        x: window.scrollX,
        y: window.scrollY
      }));
      const documentRect = { ...boundingBox
      };
      documentRect.x += scrollOffset.x;
      documentRect.y += scrollOffset.y;
      const buffer = await this._screenshot(progress, format, _helper.helper.enclosingIntRect(documentRect), undefined, fitsViewport, options);
      progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.

      await this._restorePageAfterScreenshot();
      return buffer;
    });
  }

  async _preparePageForScreenshot(progress, hideCaret, disableAnimations) {
    if (!hideCaret && !disableAnimations) return;
    if (disableAnimations) progress.log('  disabled all CSS animations');
    await Promise.all(this._page.frames().map(async frame => {
      await frame.nonStallingEvaluateInExistingContext('(' + async function (hideCaret, disableAnimations) {
        const styleTag = document.createElement('style');

        if (hideCaret) {
          styleTag.textContent = `
            *:not(#playwright-aaaaaaaaaa.playwright-bbbbbbbbbbb.playwright-cccccccccc.playwright-dddddddddd.playwright-eeeeeeeee) {
              caret-color: transparent !important;
            }
          `;
          document.documentElement.append(styleTag);
        }

        const infiniteAnimationsToResume = new Set();
        const cleanupCallbacks = [];

        if (disableAnimations) {
          const collectRoots = (root, roots = []) => {
            roots.push(root);
            const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);

            do {
              const node = walker.currentNode;
              const shadowRoot = node instanceof Element ? node.shadowRoot : null;
              if (shadowRoot) collectRoots(shadowRoot, roots);
            } while (walker.nextNode());

            return roots;
          };

          const handleAnimations = root => {
            for (const animation of root.getAnimations()) {
              if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation)) continue;
              const endTime = animation.effect.getComputedTiming().endTime;

              if (Number.isFinite(endTime)) {
                try {
                  animation.finish();
                } catch (e) {// animation.finish() should not throw for
                  // finite animations, but we'd like to be on the
                  // safe side.
                }
              } else {
                try {
                  animation.cancel();
                  infiniteAnimationsToResume.add(animation);
                } catch (e) {// animation.cancel() should not throw for
                  // infinite animations, but we'd like to be on the
                  // safe side.
                }
              }
            }
          };

          for (const root of collectRoots(document)) {
            const handleRootAnimations = handleAnimations.bind(null, root);
            handleRootAnimations();
            root.addEventListener('transitionrun', handleRootAnimations);
            root.addEventListener('animationstart', handleRootAnimations);
            cleanupCallbacks.push(() => {
              root.removeEventListener('transitionrun', handleRootAnimations);
              root.removeEventListener('animationstart', handleRootAnimations);
            });
          }
        }

        window.__cleanupScreenshot = () => {
          styleTag.remove();

          for (const animation of infiniteAnimationsToResume) {
            try {
              animation.play();
            } catch (e) {// animation.play() should never throw, but
              // we'd like to be on the safe side.
            }
          }

          for (const cleanupCallback of cleanupCallbacks) cleanupCallback();

          delete window.__cleanupScreenshot;
        };
      }.toString() + `)(${hideCaret}, ${disableAnimations})`, false, 'utility').catch(() => {});
    }));
    progress.cleanupWhenAborted(() => this._restorePageAfterScreenshot());
  }

  async _restorePageAfterScreenshot() {
    await Promise.all(this._page.frames().map(async frame => {
      frame.nonStallingEvaluateInExistingContext('window.__cleanupScreenshot && window.__cleanupScreenshot()', false, 'utility').catch(() => {});
    }));
  }

  async _maskElements(progress, options) {
    const framesToParsedSelectors = new _multimap.MultiMap();

    const cleanup = async () => {
      await Promise.all([...framesToParsedSelectors.keys()].map(async frame => {
        await frame.hideHighlight();
      }));
    };

    if (!options.mask || !options.mask.length) return cleanup;
    await Promise.all((options.mask || []).map(async ({
      frame,
      selector
    }) => {
      const pair = await frame.resolveFrameForSelectorNoWait(selector);
      if (pair) framesToParsedSelectors.set(pair.frame, pair.info.parsed);
    }));
    progress.throwIfAborted(); // Avoid extra work.

    await Promise.all([...framesToParsedSelectors.keys()].map(async frame => {
      await frame.maskSelectors(framesToParsedSelectors.get(frame));
    }));
    progress.cleanupWhenAborted(cleanup);
    return cleanup;
  }

  async _screenshot(progress, format, documentRect, viewportRect, fitsViewport, options) {
    if (options.__testHookBeforeScreenshot) await options.__testHookBeforeScreenshot();
    progress.throwIfAborted(); // Screenshotting is expensive - avoid extra work.

    const shouldSetDefaultBackground = options.omitBackground && format === 'png';

    if (shouldSetDefaultBackground) {
      await this._page._delegate.setBackgroundColor({
        r: 0,
        g: 0,
        b: 0,
        a: 0
      });
      progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
    }

    progress.throwIfAborted(); // Avoid extra work.

    const cleanupHighlight = await this._maskElements(progress, options);
    progress.throwIfAborted(); // Avoid extra work.

    const buffer = await this._page._delegate.takeScreenshot(progress, format, documentRect, viewportRect, options.quality, fitsViewport, options.scale || 'device');
    progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.

    await cleanupHighlight();
    progress.throwIfAborted(); // Avoid restoring after failure - should be done by cleanup.

    if (shouldSetDefaultBackground) await this._page._delegate.setBackgroundColor();
    progress.throwIfAborted(); // Avoid side effects.

    if (options.__testHookAfterScreenshot) await options.__testHookAfterScreenshot();
    return buffer;
  }

}

exports.Screenshotter = Screenshotter;

class TaskQueue {
  constructor() {
    this._chain = void 0;
    this._chain = Promise.resolve();
  }

  postTask(task) {
    const result = this._chain.then(task);

    this._chain = result.catch(() => {});
    return result;
  }

}

function trimClipToSize(clip, size) {
  const p1 = {
    x: Math.max(0, Math.min(clip.x, size.width)),
    y: Math.max(0, Math.min(clip.y, size.height))
  };
  const p2 = {
    x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
    y: Math.max(0, Math.min(clip.y + clip.height, size.height))
  };
  const result = {
    x: p1.x,
    y: p1.y,
    width: p2.x - p1.x,
    height: p2.y - p1.y
  };
  (0, _utils.assert)(result.width && result.height, 'Clipped area is either empty or outside the resulting image');
  return result;
}

function validateScreenshotOptions(options) {
  let format = null; // options.type takes precedence over inferring the type from options.path
  // because it may be a 0-length file with no extension created beforehand (i.e. as a temp file).

  if (options.type) {
    (0, _utils.assert)(options.type === 'png' || options.type === 'jpeg', 'Unknown options.type value: ' + options.type);
    format = options.type;
  }

  if (!format) format = 'png';

  if (options.quality !== undefined) {
    (0, _utils.assert)(format === 'jpeg', 'options.quality is unsupported for the ' + format + ' screenshots');
    (0, _utils.assert)(typeof options.quality === 'number', 'Expected options.quality to be a number but found ' + typeof options.quality);
    (0, _utils.assert)(Number.isInteger(options.quality), 'Expected options.quality to be an integer');
    (0, _utils.assert)(options.quality >= 0 && options.quality <= 100, 'Expected options.quality to be between 0 and 100 (inclusive), got ' + options.quality);
  }

  if (options.clip) {
    (0, _utils.assert)(typeof options.clip.x === 'number', 'Expected options.clip.x to be a number but found ' + typeof options.clip.x);
    (0, _utils.assert)(typeof options.clip.y === 'number', 'Expected options.clip.y to be a number but found ' + typeof options.clip.y);
    (0, _utils.assert)(typeof options.clip.width === 'number', 'Expected options.clip.width to be a number but found ' + typeof options.clip.width);
    (0, _utils.assert)(typeof options.clip.height === 'number', 'Expected options.clip.height to be a number but found ' + typeof options.clip.height);
    (0, _utils.assert)(options.clip.width !== 0, 'Expected options.clip.width not to be 0.');
    (0, _utils.assert)(options.clip.height !== 0, 'Expected options.clip.height not to be 0.');
  }

  return format;
}

/***/ }),

/***/ 5875:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Selectors = void 0;

var _selectorParser = __nccwpck_require__(377);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Selectors {
  constructor() {
    this._builtinEngines = void 0;
    this._builtinEnginesInMainWorld = void 0;
    this._engines = void 0;
    this.guid = `selectors@${(0, _utils.createGuid)()}`;
    // Note: keep in sync with InjectedScript class.
    this._builtinEngines = new Set(['css', 'css:light', 'xpath', 'xpath:light', '_react', '_vue', 'text', 'text:light', 'id', 'id:light', 'data-testid', 'data-testid:light', 'data-test-id', 'data-test-id:light', 'data-test', 'data-test:light', 'nth', 'visible', 'control', 'has', 'role']);
    this._builtinEnginesInMainWorld = new Set(['_react', '_vue']);
    this._engines = new Map();
  }

  async register(name, source, contentScript = false) {
    if (!name.match(/^[a-zA-Z_0-9-]+$/)) throw new Error('Selector engine name may only contain [a-zA-Z0-9_] characters'); // Note: we keep 'zs' for future use.

    if (this._builtinEngines.has(name) || name === 'zs' || name === 'zs:light') throw new Error(`"${name}" is a predefined selector engine`);
    if (this._engines.has(name)) throw new Error(`"${name}" selector engine has been already registered`);

    this._engines.set(name, {
      source,
      contentScript
    });
  }

  unregisterAll() {
    this._engines.clear();
  }

  async query(frame, info, scope) {
    const context = await frame._context(info.world);
    const injectedScript = await context.injectedScript();
    const handle = await injectedScript.evaluateHandle((injected, {
      parsed,
      scope,
      strict
    }) => {
      return injected.querySelector(parsed, scope || document, strict);
    }, {
      parsed: info.parsed,
      scope,
      strict: info.strict
    });
    const elementHandle = handle.asElement();

    if (!elementHandle) {
      handle.dispose();
      return null;
    }

    const mainContext = await frame._mainContext();
    return this._adoptIfNeeded(elementHandle, mainContext);
  }

  async _queryArrayInMainWorld(frame, info, scope) {
    const context = await frame._mainContext();
    const injectedScript = await context.injectedScript();
    const arrayHandle = await injectedScript.evaluateHandle((injected, {
      parsed,
      scope
    }) => {
      return injected.querySelectorAll(parsed, scope || document);
    }, {
      parsed: info.parsed,
      scope
    });
    return arrayHandle;
  }

  async _queryCount(frame, info, scope) {
    const context = await frame._context(info.world);
    const injectedScript = await context.injectedScript();
    return await injectedScript.evaluate((injected, {
      parsed,
      scope
    }) => {
      return injected.querySelectorAll(parsed, scope || document).length;
    }, {
      parsed: info.parsed,
      scope
    });
  }

  async _queryAll(frame, selector, scope, adoptToMain) {
    const info = typeof selector === 'string' ? frame._page.parseSelector(selector) : selector;
    const context = await frame._context(info.world);
    const injectedScript = await context.injectedScript();
    const arrayHandle = await injectedScript.evaluateHandle((injected, {
      parsed,
      scope
    }) => {
      return injected.querySelectorAll(parsed, scope || document);
    }, {
      parsed: info.parsed,
      scope
    });
    const properties = await arrayHandle.getProperties();
    arrayHandle.dispose(); // Note: adopting elements one by one may be slow. If we encounter the issue here,
    // we might introduce 'useMainContext' option or similar to speed things up.

    const targetContext = adoptToMain ? await frame._mainContext() : context;
    const result = [];

    for (const property of properties.values()) {
      const elementHandle = property.asElement();
      if (elementHandle) result.push(this._adoptIfNeeded(elementHandle, targetContext));else property.dispose();
    }

    return Promise.all(result);
  }

  async _adoptIfNeeded(handle, context) {
    if (handle._context === context) return handle;

    const adopted = handle._page._delegate.adoptElementHandle(handle, context);

    handle.dispose();
    return adopted;
  }

  parseSelector(selector, strict) {
    const parsed = typeof selector === 'string' ? (0, _selectorParser.parseSelector)(selector) : selector;
    let needsMainWorld = false;

    for (const name of (0, _selectorParser.allEngineNames)(parsed)) {
      const custom = this._engines.get(name);

      if (!custom && !this._builtinEngines.has(name)) throw new _selectorParser.InvalidSelectorError(`Unknown engine "${name}" while parsing selector ${(0, _selectorParser.stringifySelector)(parsed)}`);
      if (custom && !custom.contentScript) needsMainWorld = true;
      if (this._builtinEnginesInMainWorld.has(name)) needsMainWorld = true;
    }

    return {
      parsed,
      world: needsMainWorld ? 'main' : 'utility',
      strict
    };
  }

}

exports.Selectors = Selectors;

/***/ }),

/***/ 9609:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VERSION = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Make sure you add _modernize_N_to_N1(event: any) to traceModel.ts.
const VERSION = 3;
exports.VERSION = VERSION;

/***/ }),

/***/ 899:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Snapshotter = void 0;

var _browserContext = __nccwpck_require__(5985);

var _page = __nccwpck_require__(3555);

var _eventsHelper = __nccwpck_require__(3841);

var _debugLogger = __nccwpck_require__(2003);

var _snapshotterInjected = __nccwpck_require__(6346);

var _utils = __nccwpck_require__(3557);

var _utilsBundle = __nccwpck_require__(1319);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Snapshotter {
  constructor(context, delegate) {
    this._context = void 0;
    this._delegate = void 0;
    this._eventListeners = [];
    this._snapshotStreamer = void 0;
    this._initialized = false;
    this._started = false;
    this._context = context;
    this._delegate = delegate;
    const guid = (0, _utils.createGuid)();
    this._snapshotStreamer = '__playwright_snapshot_streamer_' + guid;
  }

  started() {
    return this._started;
  }

  async start() {
    this._started = true;

    if (!this._initialized) {
      this._initialized = true;
      await this._initialize();
    }

    await this.reset();
  }

  async reset() {
    if (this._started) await this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
  }

  async stop() {
    this._started = false;
  }

  async _initialize() {
    for (const page of this._context.pages()) this._onPage(page);

    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._onPage.bind(this))];
    const initScript = `(${_snapshotterInjected.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
    await this._context.addInitScript(initScript);
    await this._runInAllFrames(initScript);
  }

  async _runInAllFrames(expression) {
    const frames = [];

    for (const page of this._context.pages()) frames.push(...page.frames());

    await Promise.all(frames.map(frame => {
      return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(e => _debugLogger.debugLogger.log('error', e));
    }));
  }

  dispose() {
    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
  }

  async captureSnapshot(page, snapshotName, element) {
    // Prepare expression synchronously.
    const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`; // In a best-effort manner, without waiting for it, mark target element.

    element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element, snapshotName) => {
      element.setAttribute('__playwright_target__', snapshotName);
    }, snapshotName); // In each frame, in a non-stalling manner, capture the snapshots.

    const snapshots = page.frames().map(async frame => {
      const data = await frame.nonStallingRawEvaluateInExistingMainContext(expression).catch(e => _debugLogger.debugLogger.log('error', e)); // Something went wrong -> bail out, our snapshots are best-efforty.

      if (!data || !this._started) return;
      const snapshot = {
        snapshotName,
        pageId: page.guid,
        frameId: frame.guid,
        frameUrl: data.url,
        doctype: data.doctype,
        html: data.html,
        viewport: data.viewport,
        timestamp: (0, _utils.monotonicTime)(),
        collectionTime: data.collectionTime,
        resourceOverrides: [],
        isMainFrame: page.mainFrame() === frame
      };

      for (const {
        url,
        content,
        contentType
      } of data.resourceOverrides) {
        if (typeof content === 'string') {
          const buffer = Buffer.from(content);
          const sha1 = (0, _utils.calculateSha1)(buffer) + '.' + (_utilsBundle.mime.getExtension(contentType) || 'dat');

          this._delegate.onSnapshotterBlob({
            sha1,
            buffer
          });

          snapshot.resourceOverrides.push({
            url,
            sha1
          });
        } else {
          snapshot.resourceOverrides.push({
            url,
            ref: content
          });
        }
      }

      this._delegate.onFrameSnapshot(snapshot);
    });
    await Promise.all(snapshots);
  }

  _onPage(page) {
    // Annotate frame hierarchy so that snapshots could include frame ids.
    for (const frame of page.frames()) this._annotateFrameHierarchy(frame);

    this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.FrameAttached, frame => this._annotateFrameHierarchy(frame)));
  }

  async _annotateFrameHierarchy(frame) {
    try {
      const frameElement = await frame.frameElement();
      const parent = frame.parentFrame();
      if (!parent) return;
      const context = await parent._mainContext();
      await (context === null || context === void 0 ? void 0 : context.evaluate(({
        snapshotStreamer,
        frameElement,
        frameId
      }) => {
        window[snapshotStreamer].markIframe(frameElement, frameId);
      }, {
        snapshotStreamer: this._snapshotStreamer,
        frameElement,
        frameId: frame.guid
      }));
      frameElement.dispose();
    } catch (e) {}
  }

}

exports.Snapshotter = Snapshotter;

/***/ }),

/***/ 6346:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.frameSnapshotStreamer = frameSnapshotStreamer;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function frameSnapshotStreamer(snapshotStreamer) {
  // Communication with Playwright.
  if (window[snapshotStreamer]) return; // Attributes present in the snapshot.

  const kShadowAttribute = '__playwright_shadow_root_';
  const kValueAttribute = '__playwright_value_';
  const kCheckedAttribute = '__playwright_checked_';
  const kSelectedAttribute = '__playwright_selected_';
  const kScrollTopAttribute = '__playwright_scroll_top_';
  const kScrollLeftAttribute = '__playwright_scroll_left_';
  const kStyleSheetAttribute = '__playwright_style_sheet_';
  const kTargetAttribute = '__playwright_target__'; // Symbols for our own info on Nodes/StyleSheets.

  const kSnapshotFrameId = Symbol('__playwright_snapshot_frameid_');
  const kCachedData = Symbol('__playwright_snapshot_cache_');
  const kEndOfList = Symbol('__playwright_end_of_list_');

  function resetCachedData(obj) {
    delete obj[kCachedData];
  }

  function ensureCachedData(obj) {
    if (!obj[kCachedData]) obj[kCachedData] = {};
    return obj[kCachedData];
  }

  function removeHash(url) {
    try {
      const u = new URL(url);
      u.hash = '';
      return u.toString();
    } catch (e) {
      return url;
    }
  }

  class Streamer {
    // To avoid invalidating due to our own reads.
    constructor() {
      this._removeNoScript = true;
      this._lastSnapshotNumber = 0;
      this._staleStyleSheets = new Set();
      this._readingStyleSheet = false;
      this._fakeBase = void 0;
      this._observer = void 0;

      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'insertRule', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'deleteRule', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'addRule', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'removeRule', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeGetter(window.CSSStyleSheet.prototype, 'rules', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeGetter(window.CSSStyleSheet.prototype, 'cssRules', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeMethod(window.CSSStyleSheet.prototype, 'replaceSync', sheet => this._invalidateStyleSheet(sheet));

      this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, 'replace', sheet => this._invalidateStyleSheet(sheet));

      this._fakeBase = document.createElement('base');
      this._observer = new MutationObserver(list => this._handleMutations(list));
      const observerConfig = {
        attributes: true,
        subtree: true
      };

      this._observer.observe(document, observerConfig);
    }

    _interceptNativeMethod(obj, method, cb) {
      const native = obj[method];
      if (!native) return;

      obj[method] = function (...args) {
        const result = native.call(this, ...args);
        cb(this, result);
        return result;
      };
    }

    _interceptNativeAsyncMethod(obj, method, cb) {
      const native = obj[method];
      if (!native) return;

      obj[method] = async function (...args) {
        const result = await native.call(this, ...args);
        cb(this, result);
        return result;
      };
    }

    _interceptNativeGetter(obj, prop, cb) {
      const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
      Object.defineProperty(obj, prop, { ...descriptor,
        get: function () {
          const result = descriptor.get.call(this);
          cb(this, result);
          return result;
        }
      });
    }

    _handleMutations(list) {
      for (const mutation of list) ensureCachedData(mutation.target).attributesCached = undefined;
    }

    _invalidateStyleSheet(sheet) {
      if (this._readingStyleSheet) return;

      this._staleStyleSheets.add(sheet);
    }

    _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
      const data = ensureCachedData(sheet);

      if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === undefined) {
        this._staleStyleSheets.delete(sheet);

        try {
          data.cssText = this._getSheetText(sheet);
        } catch (e) {
          // Sometimes we cannot access cross-origin stylesheets.
          data.cssText = '';
        }
      }

      return data.cssText;
    } // Returns either content, ref, or no override.


    _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
      const data = ensureCachedData(sheet);

      if (this._staleStyleSheets.has(sheet)) {
        this._staleStyleSheets.delete(sheet);

        try {
          data.cssText = this._getSheetText(sheet);
          data.cssRef = snapshotNumber;
          return data.cssText;
        } catch (e) {// Sometimes we cannot access cross-origin stylesheets.
        }
      }

      return data.cssRef === undefined ? undefined : snapshotNumber - data.cssRef;
    }

    markIframe(iframeElement, frameId) {
      iframeElement[kSnapshotFrameId] = frameId;
    }

    reset() {
      this._staleStyleSheets.clear();

      const visitNode = node => {
        resetCachedData(node);

        if (node.nodeType === Node.ELEMENT_NODE) {
          const element = node;
          if (element.shadowRoot) visitNode(element.shadowRoot);
        }

        for (let child = node.firstChild; child; child = child.nextSibling) visitNode(child);
      };

      visitNode(document.documentElement);
      visitNode(this._fakeBase);
    }

    __sanitizeMetaAttribute(name, value, httpEquiv) {
      if (name === 'charset') return 'utf-8';
      if (httpEquiv.toLowerCase() !== 'content-type' || name !== 'content') return value;
      const [type, ...params] = value.split(';');
      if (type !== 'text/html' || params.length <= 0) return value;
      const charsetParamIdx = params.findIndex(param => param.trim().startsWith('charset='));
      if (charsetParamIdx > -1) params[charsetParamIdx] = 'charset=utf-8';
      return `${type}; ${params.join('; ')}`;
    }

    _sanitizeUrl(url) {
      if (url.startsWith('javascript:') || url.startsWith('vbscript:')) return '';
      return url;
    }

    _sanitizeSrcSet(srcset) {
      return srcset.split(',').map(src => {
        src = src.trim();
        const spaceIndex = src.lastIndexOf(' ');
        if (spaceIndex === -1) return this._sanitizeUrl(src);
        return this._sanitizeUrl(src.substring(0, spaceIndex).trim()) + src.substring(spaceIndex);
      }).join(', ');
    }

    _resolveUrl(base, url) {
      if (url === '') return '';

      try {
        return new URL(url, base).href;
      } catch (e) {
        return url;
      }
    }

    _getSheetBase(sheet) {
      let rootSheet = sheet;

      while (rootSheet.parentStyleSheet) rootSheet = rootSheet.parentStyleSheet;

      if (rootSheet.ownerNode) return rootSheet.ownerNode.baseURI;
      return document.baseURI;
    }

    _getSheetText(sheet) {
      this._readingStyleSheet = true;

      try {
        const rules = [];

        for (const rule of sheet.cssRules) rules.push(rule.cssText);

        return rules.join('\n');
      } finally {
        this._readingStyleSheet = false;
      }
    }

    captureSnapshot() {
      const timestamp = performance.now();
      const snapshotNumber = ++this._lastSnapshotNumber;
      let nodeCounter = 0;
      let shadowDomNesting = 0;
      let headNesting = 0; // Ensure we are up to date.

      this._handleMutations(this._observer.takeRecords()); // Restore scroll positions for all ancestors of action target elements
      // that will show the highlight/red dot in the trace viewer.
      // Workaround for chromium regression:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=1324419
      // https://github.com/microsoft/playwright/issues/14037
      // TODO: remove after chromium is fixed?


      const elementsToRestoreScrollPosition = new Set();

      const findElementsToRestoreScrollPositionRecursively = element => {
        let shouldAdd = element.hasAttribute(kTargetAttribute);

        for (let child = element.firstElementChild; child; child = child.nextElementSibling) shouldAdd = shouldAdd || findElementsToRestoreScrollPositionRecursively(child);

        if (element.shadowRoot) {
          for (let child = element.shadowRoot.firstElementChild; child; child = child.nextElementSibling) shouldAdd = shouldAdd || findElementsToRestoreScrollPositionRecursively(child);
        }

        if (shouldAdd) elementsToRestoreScrollPosition.add(element);
        return shouldAdd;
      };

      if (document.documentElement) findElementsToRestoreScrollPositionRecursively(document.documentElement);

      const visitNode = node => {
        const nodeType = node.nodeType;
        const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? 'template' : node.nodeName;
        if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE) return;
        if (nodeName === 'SCRIPT') return; // Don't preload resources.

        if (nodeName === 'LINK' && nodeType === Node.ELEMENT_NODE) {
          var _getAttribute;

          const rel = (_getAttribute = node.getAttribute('rel')) === null || _getAttribute === void 0 ? void 0 : _getAttribute.toLowerCase();
          if (rel === 'preload' || rel === 'prefetch') return;
        }

        if (this._removeNoScript && nodeName === 'NOSCRIPT') return;
        if (nodeName === 'META' && node.httpEquiv.toLowerCase() === 'content-security-policy') return; // Skip iframes which are inside document's head as they are not visisble.
        // See https://github.com/microsoft/playwright/issues/12005.

        if ((nodeName === 'IFRAME' || nodeName === 'FRAME') && headNesting) return;
        const data = ensureCachedData(node);
        const values = [];
        let equals = !!data.cached;
        let extraNodes = 0;

        const expectValue = value => {
          equals = equals && data.cached[values.length] === value;
          values.push(value);
        };

        const checkAndReturn = n => {
          data.attributesCached = true;
          if (equals) return {
            equals: true,
            n: [[snapshotNumber - data.ref[0], data.ref[1]]]
          };
          nodeCounter += extraNodes;
          data.ref = [snapshotNumber, nodeCounter++];
          data.cached = values;
          return {
            equals: false,
            n
          };
        };

        if (nodeType === Node.TEXT_NODE) {
          const value = node.nodeValue || '';
          expectValue(value);
          return checkAndReturn(value);
        }

        if (nodeName === 'STYLE') {
          const sheet = node.sheet;
          let cssText;
          if (sheet) cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
          cssText = cssText || node.textContent || '';
          expectValue(cssText); // Compensate for the extra 'cssText' text node.

          extraNodes++;
          return checkAndReturn([nodeName, {}, cssText]);
        }

        const attrs = {};
        const result = [nodeName, attrs];

        const visitChild = child => {
          const snapshot = visitNode(child);

          if (snapshot) {
            result.push(snapshot.n);
            expectValue(child);
            equals = equals && snapshot.equals;
          }
        };

        const visitChildStyleSheet = child => {
          const snapshot = visitStyleSheet(child);

          if (snapshot) {
            result.push(snapshot.n);
            expectValue(child);
            equals = equals && snapshot.equals;
          }
        };

        if (nodeType === Node.DOCUMENT_FRAGMENT_NODE) attrs[kShadowAttribute] = 'open';

        if (nodeType === Node.ELEMENT_NODE) {
          const element = node;

          if (nodeName === 'INPUT' || nodeName === 'TEXTAREA') {
            const value = element.value;
            expectValue(kValueAttribute);
            expectValue(value);
            attrs[kValueAttribute] = value;
          }

          if (nodeName === 'INPUT' && ['checkbox', 'radio'].includes(element.type)) {
            const value = element.checked ? 'true' : 'false';
            expectValue(kCheckedAttribute);
            expectValue(value);
            attrs[kCheckedAttribute] = value;
          }

          if (nodeName === 'OPTION') {
            const value = element.selected ? 'true' : 'false';
            expectValue(kSelectedAttribute);
            expectValue(value);
            attrs[kSelectedAttribute] = value;
          }

          if (elementsToRestoreScrollPosition.has(element) && element.scrollTop) {
            expectValue(kScrollTopAttribute);
            expectValue(element.scrollTop);
            attrs[kScrollTopAttribute] = '' + element.scrollTop;
          }

          if (elementsToRestoreScrollPosition.has(element) && element.scrollLeft) {
            expectValue(kScrollLeftAttribute);
            expectValue(element.scrollLeft);
            attrs[kScrollLeftAttribute] = '' + element.scrollLeft;
          }

          if (element.shadowRoot) {
            ++shadowDomNesting;
            visitChild(element.shadowRoot);
            --shadowDomNesting;
          }
        }

        if (nodeName === 'HEAD') {
          ++headNesting; // Insert fake <base> first, to ensure all <link> elements use the proper base uri.

          this._fakeBase.setAttribute('href', document.baseURI);

          visitChild(this._fakeBase);
        }

        for (let child = node.firstChild; child; child = child.nextSibling) visitChild(child);

        if (nodeName === 'HEAD') --headNesting;
        expectValue(kEndOfList);
        let documentOrShadowRoot = null;
        if (node.ownerDocument.documentElement === node) documentOrShadowRoot = node.ownerDocument;else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) documentOrShadowRoot = node;

        if (documentOrShadowRoot) {
          for (const sheet of documentOrShadowRoot.adoptedStyleSheets || []) visitChildStyleSheet(sheet);

          expectValue(kEndOfList);
        } // Process iframe src attribute before bailing out since it depends on a symbol, not the DOM.


        if (nodeName === 'IFRAME' || nodeName === 'FRAME') {
          const element = node;
          const frameId = element[kSnapshotFrameId];
          const name = 'src';
          const value = frameId ? `/snapshot/${frameId}` : '';
          expectValue(name);
          expectValue(value);
          attrs[name] = value;
        } // We can skip attributes comparison because nothing else has changed,
        // and mutation observer didn't tell us about the attributes.


        if (equals && data.attributesCached && !shadowDomNesting) return checkAndReturn(result);

        if (nodeType === Node.ELEMENT_NODE) {
          const element = node;

          for (let i = 0; i < element.attributes.length; i++) {
            const name = element.attributes[i].name;
            if (nodeName === 'LINK' && name === 'integrity') continue;
            if (nodeName === 'IFRAME' && (name === 'src' || name === 'sandbox')) continue;
            if (nodeName === 'FRAME' && name === 'src') continue;
            let value = element.attributes[i].value;
            if (nodeName === 'META') value = this.__sanitizeMetaAttribute(name, value, node.httpEquiv);else if (name === 'src' && nodeName === 'IMG') value = this._sanitizeUrl(value);else if (name === 'srcset' && nodeName === 'IMG') value = this._sanitizeSrcSet(value);else if (name === 'srcset' && nodeName === 'SOURCE') value = this._sanitizeSrcSet(value);else if (name === 'href' && nodeName === 'LINK') value = this._sanitizeUrl(value);else if (name.startsWith('on')) value = '';
            expectValue(name);
            expectValue(value);
            attrs[name] = value;
          }

          expectValue(kEndOfList);
        }

        if (result.length === 2 && !Object.keys(attrs).length) result.pop(); // Remove empty attrs when there are no children.

        return checkAndReturn(result);
      };

      const visitStyleSheet = sheet => {
        const data = ensureCachedData(sheet);
        const oldCSSText = data.cssText;

        const cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet, true
        /* forceText */
        );

        if (cssText === oldCSSText) return {
          equals: true,
          n: [[snapshotNumber - data.ref[0], data.ref[1]]]
        };
        data.ref = [snapshotNumber, nodeCounter++];
        return {
          equals: false,
          n: ['template', {
            [kStyleSheetAttribute]: cssText
          }]
        };
      };

      let html;

      if (document.documentElement) {
        const {
          n
        } = visitNode(document.documentElement);
        html = n;
      } else {
        html = ['html'];
      }

      const result = {
        html,
        doctype: document.doctype ? document.doctype.name : undefined,
        resourceOverrides: [],
        viewport: {
          width: window.innerWidth,
          height: window.innerHeight
        },
        url: location.href,
        timestamp,
        collectionTime: 0
      };

      for (const sheet of this._staleStyleSheets) {
        if (sheet.href === null) continue;

        const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);

        if (content === undefined) {
          // Unable to capture stylesheet contents.
          continue;
        }

        const base = this._getSheetBase(sheet);

        const url = removeHash(this._resolveUrl(base, sheet.href));
        result.resourceOverrides.push({
          url,
          content,
          contentType: 'text/css'
        });
      }

      result.collectionTime = performance.now() - result.timestamp;
      return result;
    }

  }

  window[snapshotStreamer] = new Streamer();
}

/***/ }),

/***/ 865:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Tracing = void 0;
exports.shouldCaptureSnapshot = shouldCaptureSnapshot;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _channels = __nccwpck_require__(6272);

var _manualPromise = __nccwpck_require__(6729);

var _eventsHelper = __nccwpck_require__(3841);

var _utils = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

var _artifact = __nccwpck_require__(1796);

var _browserContext = __nccwpck_require__(5985);

var _dom = __nccwpck_require__(8139);

var _instrumentation = __nccwpck_require__(6686);

var _page = __nccwpck_require__(3555);

var _harTracer = __nccwpck_require__(4012);

var _traceEvents = __nccwpck_require__(9609);

var _snapshotter = __nccwpck_require__(899);

var _zipBundle = __nccwpck_require__(6383);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kScreencastOptions = {
  width: 800,
  height: 600,
  quality: 90
};

class Tracing extends _instrumentation.SdkObject {
  constructor(context, tracesDir) {
    super(context, 'tracing');
    this._writeChain = Promise.resolve();
    this._snapshotter = void 0;
    this._harTracer = void 0;
    this._screencastListeners = [];
    this._pendingCalls = new Map();
    this._context = void 0;
    this._state = void 0;
    this._isStopping = false;
    this._precreatedTracesDir = void 0;
    this._tracesTmpDir = void 0;
    this._allResources = new Set();
    this._contextCreatedEvent = void 0;
    this._context = context;
    this._precreatedTracesDir = tracesDir;
    this._harTracer = new _harTracer.HarTracer(context, null, this, {
      content: 'attach',
      includeTraceInfo: true,
      waitForContentOnStop: false,
      skipScripts: true
    });
    this._contextCreatedEvent = {
      version: _traceEvents.VERSION,
      type: 'context-options',
      browserName: '',
      options: {},
      platform: process.platform,
      wallTime: 0
    };

    if (context instanceof _browserContext.BrowserContext) {
      this._snapshotter = new _snapshotter.Snapshotter(context, this);
      (0, _utils.assert)(tracesDir, 'tracesDir must be specified for BrowserContext');
      this._contextCreatedEvent.browserName = context._browser.options.name;
      this._contextCreatedEvent.options = context._options;
    }
  }

  async start(options) {
    if (this._isStopping) throw new Error('Cannot start tracing while stopping');

    if (this._state) {
      const o = this._state.options;
      if (o.name !== options.name || !o.screenshots !== !options.screenshots || !o.snapshots !== !options.snapshots) throw new Error('Tracing has been already started with different options');
      return;
    } // TODO: passing the same name for two contexts makes them write into a single file
    // and conflict.


    const traceName = options.name || (0, _utils.createGuid)(); // Init the state synchrounously.

    this._state = {
      options,
      traceName,
      traceFile: '',
      networkFile: '',
      tracesDir: '',
      resourcesDir: '',
      filesCount: 0,
      traceSha1s: new Set(),
      networkSha1s: new Set(),
      sources: new Set(),
      recording: false
    };
    const state = this._state;
    state.tracesDir = await this._createTracesDirIfNeeded();
    state.resourcesDir = _path.default.join(state.tracesDir, 'resources');
    state.traceFile = _path.default.join(state.tracesDir, traceName + '.trace');
    state.networkFile = _path.default.join(state.tracesDir, traceName + '.network');
    this._writeChain = _fs.default.promises.mkdir(state.resourcesDir, {
      recursive: true
    }).then(() => _fs.default.promises.writeFile(state.networkFile, ''));
    if (options.snapshots) this._harTracer.start();
  }

  async startChunk(options = {}) {
    var _this$_snapshotter;

    if (this._state && this._state.recording) await this.stopChunk({
      mode: 'doNotSave'
    });
    if (!this._state) throw new Error('Must start tracing before starting a new chunk');
    if (this._isStopping) throw new Error('Cannot start a trace chunk while stopping');
    const state = this._state;
    const suffix = state.filesCount ? `-${state.filesCount}` : ``;
    state.filesCount++;
    state.traceFile = _path.default.join(state.tracesDir, `${state.traceName}${suffix}.trace`);
    state.recording = true;

    this._appendTraceOperation(async () => {
      await (0, _fileUtils.mkdirIfNeeded)(state.traceFile);
      await _fs.default.promises.appendFile(state.traceFile, JSON.stringify({ ...this._contextCreatedEvent,
        title: options.title,
        wallTime: Date.now()
      }) + '\n');
    });

    this._context.instrumentation.addListener(this, this._context);

    if (state.options.screenshots) this._startScreencast();
    if (state.options.snapshots) await ((_this$_snapshotter = this._snapshotter) === null || _this$_snapshotter === void 0 ? void 0 : _this$_snapshotter.start());
  }

  _startScreencast() {
    if (!(this._context instanceof _browserContext.BrowserContext)) return;

    for (const page of this._context.pages()) this._startScreencastInPage(page);

    this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._startScreencastInPage.bind(this)));
  }

  _stopScreencast() {
    _eventsHelper.eventsHelper.removeEventListeners(this._screencastListeners);

    if (!(this._context instanceof _browserContext.BrowserContext)) return;

    for (const page of this._context.pages()) page.setScreencastOptions(null);
  }

  async stop() {
    if (!this._state) return;
    if (this._isStopping) throw new Error(`Tracing is already stopping`);
    if (this._state.recording) throw new Error(`Must stop trace file before stopping tracing`);

    this._harTracer.stop();

    await this._writeChain;
    this._state = undefined;
  }

  async deleteTmpTracesDir() {
    if (this._tracesTmpDir) await (0, _fileUtils.removeFolders)([this._tracesTmpDir]);
  }

  async _createTracesDirIfNeeded() {
    if (this._precreatedTracesDir) return this._precreatedTracesDir;
    this._tracesTmpDir = await _fs.default.promises.mkdtemp(_path.default.join(_os.default.tmpdir(), 'playwright-tracing-'));
    return this._tracesTmpDir;
  }

  async flush() {
    var _this$_snapshotter2;

    (_this$_snapshotter2 = this._snapshotter) === null || _this$_snapshotter2 === void 0 ? void 0 : _this$_snapshotter2.dispose();
    await this._writeChain;
  }

  async dispose() {
    var _this$_snapshotter3;

    (_this$_snapshotter3 = this._snapshotter) === null || _this$_snapshotter3 === void 0 ? void 0 : _this$_snapshotter3.dispose();
  }

  async stopChunk(params) {
    var _this$_state, _this$_snapshotter4;

    if (this._isStopping) throw new Error(`Tracing is already stopping`);
    this._isStopping = true;

    if (!this._state || !this._state.recording) {
      this._isStopping = false;
      if (params.mode !== 'doNotSave') throw new Error(`Must start tracing before stopping`);
      return {
        artifact: null,
        sourceEntries: []
      };
    }

    const state = this._state;

    this._context.instrumentation.removeListener(this);

    if ((_this$_state = this._state) !== null && _this$_state !== void 0 && _this$_state.options.screenshots) this._stopScreencast();

    for (const {
      sdkObject,
      metadata,
      beforeSnapshot,
      actionSnapshot,
      afterSnapshot
    } of this._pendingCalls.values()) {
      await Promise.all([beforeSnapshot, actionSnapshot, afterSnapshot]);
      let callMetadata = metadata;

      if (!afterSnapshot) {
        // Note: we should not modify metadata here to avoid side-effects in any other place.
        callMetadata = { ...metadata,
          error: {
            error: {
              name: 'Error',
              message: 'Action was interrupted'
            }
          }
        };
      }

      await this.onAfterCall(sdkObject, callMetadata);
    }

    if (state.options.snapshots) await ((_this$_snapshotter4 = this._snapshotter) === null || _this$_snapshotter4 === void 0 ? void 0 : _this$_snapshotter4.stop()); // Chain the export operation against write operations,
    // so that neither trace files nor sha1s change during the export.

    return (await this._appendTraceOperation(async () => {
      if (params.mode === 'doNotSave') return {
        artifact: null,
        sourceEntries: undefined
      }; // Har files a live, make a snapshot before returning the resulting entries.

      const networkFile = _path.default.join(state.networkFile, '..', (0, _utils.createGuid)());

      await _fs.default.promises.copyFile(state.networkFile, networkFile);
      const entries = [];
      entries.push({
        name: 'trace.trace',
        value: state.traceFile
      });
      entries.push({
        name: 'trace.network',
        value: networkFile
      });

      for (const sha1 of new Set([...state.traceSha1s, ...state.networkSha1s])) entries.push({
        name: _path.default.join('resources', sha1),
        value: _path.default.join(state.resourcesDir, sha1)
      });

      let sourceEntries;

      if (state.sources.size) {
        sourceEntries = [];

        for (const value of state.sources) {
          const entry = {
            name: 'resources/src@' + (0, _utils.calculateSha1)(value) + '.txt',
            value
          };

          if (params.mode === 'compressTraceAndSources') {
            if (_fs.default.existsSync(entry.value)) entries.push(entry);
          } else {
            sourceEntries.push(entry);
          }
        }
      }

      const artifact = await this._exportZip(entries, state).catch(() => null);
      return {
        artifact,
        sourceEntries
      };
    }).finally(() => {
      // Only reset trace sha1s, network resources are preserved between chunks.
      state.traceSha1s = new Set();
      state.sources = new Set();
      this._isStopping = false;
      state.recording = false;
    })) || {
      artifact: null,
      sourceEntries: undefined
    };
  }

  async _exportZip(entries, state) {
    const zipFile = new _zipBundle.yazl.ZipFile();
    const result = new _manualPromise.ManualPromise();
    zipFile.on('error', error => result.reject(error));

    for (const entry of entries) zipFile.addFile(entry.value, entry.name);

    zipFile.end();
    const zipFileName = state.traceFile + '.zip';
    zipFile.outputStream.pipe(_fs.default.createWriteStream(zipFileName)).on('close', () => {
      const artifact = new _artifact.Artifact(this._context, zipFileName);
      artifact.reportFinished();
      result.resolve(artifact);
    });
    return result;
  }

  async _captureSnapshot(name, sdkObject, metadata, element) {
    if (!this._snapshotter) return;
    if (!sdkObject.attribution.page) return;
    if (!this._snapshotter.started()) return;
    if (!shouldCaptureSnapshot(metadata)) return;
    const snapshotName = `${name}@${metadata.id}`;
    metadata.snapshots.push({
      title: name,
      snapshotName
    }); // We have |element| for input actions (page.click and handle.click)
    // and |sdkObject| element for accessors like handle.textContent.

    if (!element && sdkObject instanceof _dom.ElementHandle) element = sdkObject;
    await this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element).catch(() => {});
  }

  async onBeforeCall(sdkObject, metadata) {
    var _sdkObject$attributio, _this$_state2;

    (_sdkObject$attributio = sdkObject.attribution.page) === null || _sdkObject$attributio === void 0 ? void 0 : _sdkObject$attributio.temporarlyDisableTracingScreencastThrottling(); // Set afterSnapshot name for all the actions that operate selectors.
    // Elements resolved from selectors will be marked on the snapshot.

    metadata.afterSnapshot = `after@${metadata.id}`;

    const beforeSnapshot = this._captureSnapshot('before', sdkObject, metadata);

    this._pendingCalls.set(metadata.id, {
      sdkObject,
      metadata,
      beforeSnapshot
    });

    if ((_this$_state2 = this._state) !== null && _this$_state2 !== void 0 && _this$_state2.options.sources) {
      for (const frame of metadata.stack || []) this._state.sources.add(frame.file);
    }

    await beforeSnapshot;
  }

  async onBeforeInputAction(sdkObject, metadata, element) {
    var _sdkObject$attributio2;

    (_sdkObject$attributio2 = sdkObject.attribution.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.temporarlyDisableTracingScreencastThrottling();

    const actionSnapshot = this._captureSnapshot('action', sdkObject, metadata, element);

    this._pendingCalls.get(metadata.id).actionSnapshot = actionSnapshot;
    await actionSnapshot;
  }

  async onAfterCall(sdkObject, metadata) {
    var _sdkObject$attributio3;

    (_sdkObject$attributio3 = sdkObject.attribution.page) === null || _sdkObject$attributio3 === void 0 ? void 0 : _sdkObject$attributio3.temporarlyDisableTracingScreencastThrottling();

    const pendingCall = this._pendingCalls.get(metadata.id);

    if (!pendingCall || pendingCall.afterSnapshot) return;

    if (!sdkObject.attribution.context) {
      this._pendingCalls.delete(metadata.id);

      return;
    }

    pendingCall.afterSnapshot = this._captureSnapshot('after', sdkObject, metadata);
    await pendingCall.afterSnapshot;
    const event = {
      type: 'action',
      metadata
    };

    this._appendTraceEvent(event);

    this._pendingCalls.delete(metadata.id);
  }

  onEvent(sdkObject, metadata) {
    if (!sdkObject.attribution.context) return;
    const event = {
      type: 'event',
      metadata
    };

    this._appendTraceEvent(event);
  }

  onEntryStarted(entry) {}

  onEntryFinished(entry) {
    const event = {
      type: 'resource-snapshot',
      snapshot: entry
    };

    this._appendTraceOperation(async () => {
      visitSha1s(event, this._state.networkSha1s);
      await _fs.default.promises.appendFile(this._state.networkFile, JSON.stringify(event) + '\n');
    });
  }

  onContentBlob(sha1, buffer) {
    this._appendResource(sha1, buffer);
  }

  onSnapshotterBlob(blob) {
    this._appendResource(blob.sha1, blob.buffer);
  }

  onFrameSnapshot(snapshot) {
    this._appendTraceEvent({
      type: 'frame-snapshot',
      snapshot
    });
  }

  _startScreencastInPage(page) {
    page.setScreencastOptions(kScreencastOptions);
    const prefix = page.guid;

    this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.ScreencastFrame, params => {
      const suffix = params.timestamp || Date.now();
      const sha1 = `${prefix}-${suffix}.jpeg`;
      const event = {
        type: 'screencast-frame',
        pageId: page.guid,
        sha1,
        width: params.width,
        height: params.height,
        timestamp: (0, _utils.monotonicTime)()
      }; // Make sure to write the screencast frame before adding a reference to it.

      this._appendResource(sha1, params.buffer);

      this._appendTraceEvent(event);
    }));
  }

  _appendTraceEvent(event) {
    this._appendTraceOperation(async () => {
      visitSha1s(event, this._state.traceSha1s);
      await _fs.default.promises.appendFile(this._state.traceFile, JSON.stringify(event) + '\n');
    });
  }

  _appendResource(sha1, buffer) {
    if (this._allResources.has(sha1)) return;

    this._allResources.add(sha1);

    const resourcePath = _path.default.join(this._state.resourcesDir, sha1);

    this._appendTraceOperation(async () => {
      try {
        // Perhaps we've already written this resource?
        await _fs.default.promises.access(resourcePath);
      } catch (e) {
        // If not, let's write! Note that async access is safe because we
        // never remove resources until the very end.
        await _fs.default.promises.writeFile(resourcePath, buffer).catch(() => {});
      }
    });
  }

  async _appendTraceOperation(cb) {
    // This method serializes all writes to the trace.
    let error;
    let result;
    this._writeChain = this._writeChain.then(async () => {
      // This check is here because closing the browser removes the tracesDir and tracing
      // dies trying to archive.
      if (this._context instanceof _browserContext.BrowserContext && !this._context._browser.isConnected()) return;

      try {
        result = await cb();
      } catch (e) {
        error = e;
      }
    });
    await this._writeChain;
    if (error) throw error;
    return result;
  }

}

exports.Tracing = Tracing;

function visitSha1s(object, sha1s) {
  if (Array.isArray(object)) {
    object.forEach(o => visitSha1s(o, sha1s));
    return;
  }

  if (typeof object === 'object') {
    for (const key in object) {
      if (key === 'sha1' || key === '_sha1' || key.endsWith('Sha1')) {
        const sha1 = object[key];
        if (sha1) sha1s.add(sha1);
      }

      visitSha1s(object[key], sha1s);
    }

    return;
  }
}

function shouldCaptureSnapshot(metadata) {
  return _channels.commandsWithTracingSnapshots.has(metadata.type + '.' + metadata.method);
}

/***/ }),

/***/ 1232:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocketTransport = void 0;

var _utilsBundle = __nccwpck_require__(1319);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WebSocketTransport {
  static async connect(progress, url, headers, followRedirects) {
    progress.log(`<ws connecting> ${url}`);
    const transport = new WebSocketTransport(progress, url, headers, followRedirects);
    let success = false;
    progress.cleanupWhenAborted(async () => {
      if (!success) await transport.closeAndWait().catch(e => null);
    });
    await new Promise((fulfill, reject) => {
      transport._ws.addEventListener('open', async () => {
        progress.log(`<ws connected> ${url}`);
        fulfill(transport);
      });

      transport._ws.addEventListener('error', event => {
        progress.log(`<ws connect error> ${url} ${event.message}`);
        reject(new Error('WebSocket error: ' + event.message));

        transport._ws.close();
      });
    });
    success = true;
    return transport;
  }

  constructor(progress, url, headers, followRedirects) {
    this._ws = void 0;
    this._progress = void 0;
    this.onmessage = void 0;
    this.onclose = void 0;
    this.wsEndpoint = void 0;
    this.wsEndpoint = url;
    this._ws = new _utilsBundle.ws(url, [], {
      perMessageDeflate: false,
      maxPayload: 256 * 1024 * 1024,
      // 256Mb,
      // Prevent internal http client error when passing negative timeout.
      handshakeTimeout: Math.max(progress.timeUntilDeadline(), 1),
      headers,
      followRedirects
    });
    this._progress = progress; // The 'ws' module in node sometimes sends us multiple messages in a single task.
    // In Web, all IO callbacks (e.g. WebSocket callbacks)
    // are dispatched into separate tasks, so there's no need
    // to do anything extra.

    const messageWrap = (0, _utils.makeWaitForNextTask)();

    this._ws.addEventListener('message', event => {
      messageWrap(() => {
        try {
          if (this.onmessage) this.onmessage.call(null, JSON.parse(event.data));
        } catch (e) {
          this._ws.close();
        }
      });
    });

    this._ws.addEventListener('close', event => {
      this._progress && this._progress.log(`<ws disconnected> ${url} code=${event.code} reason=${event.reason}`);
      if (this.onclose) this.onclose.call(null);
    }); // Prevent Error: read ECONNRESET.


    this._ws.addEventListener('error', error => this._progress && this._progress.log(`<ws error> ${error.type} ${error.message}`));
  }

  send(message) {
    this._ws.send(JSON.stringify(message));
  }

  close() {
    this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);

    this._ws.close();
  }

  async closeAndWait() {
    if (this._ws.readyState === _utilsBundle.ws.CLOSED) return;
    const promise = new Promise(f => this._ws.once('close', f));
    this.close();
    await promise; // Make sure to await the actual disconnect.
  }

}

exports.WebSocketTransport = WebSocketTransport;

/***/ }),

/***/ 6919:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.kLifecycleEvents = void 0;

/**
 * Copyright 2018 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const kLifecycleEvents = new Set(['load', 'domcontentloaded', 'networkidle', 'commit']);
exports.kLifecycleEvents = kLifecycleEvents;

/***/ }),

/***/ 574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.keypadLocation = exports.USKeyboardLayout = void 0;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const keypadLocation = 3;
exports.keypadLocation = keypadLocation;
const USKeyboardLayout = {
  // Functions row
  'Escape': {
    'keyCode': 27,
    'key': 'Escape'
  },
  'F1': {
    'keyCode': 112,
    'key': 'F1'
  },
  'F2': {
    'keyCode': 113,
    'key': 'F2'
  },
  'F3': {
    'keyCode': 114,
    'key': 'F3'
  },
  'F4': {
    'keyCode': 115,
    'key': 'F4'
  },
  'F5': {
    'keyCode': 116,
    'key': 'F5'
  },
  'F6': {
    'keyCode': 117,
    'key': 'F6'
  },
  'F7': {
    'keyCode': 118,
    'key': 'F7'
  },
  'F8': {
    'keyCode': 119,
    'key': 'F8'
  },
  'F9': {
    'keyCode': 120,
    'key': 'F9'
  },
  'F10': {
    'keyCode': 121,
    'key': 'F10'
  },
  'F11': {
    'keyCode': 122,
    'key': 'F11'
  },
  'F12': {
    'keyCode': 123,
    'key': 'F12'
  },
  // Numbers row
  'Backquote': {
    'keyCode': 192,
    'shiftKey': '~',
    'key': '`'
  },
  'Digit1': {
    'keyCode': 49,
    'shiftKey': '!',
    'key': '1'
  },
  'Digit2': {
    'keyCode': 50,
    'shiftKey': '@',
    'key': '2'
  },
  'Digit3': {
    'keyCode': 51,
    'shiftKey': '#',
    'key': '3'
  },
  'Digit4': {
    'keyCode': 52,
    'shiftKey': '$',
    'key': '4'
  },
  'Digit5': {
    'keyCode': 53,
    'shiftKey': '%',
    'key': '5'
  },
  'Digit6': {
    'keyCode': 54,
    'shiftKey': '^',
    'key': '6'
  },
  'Digit7': {
    'keyCode': 55,
    'shiftKey': '&',
    'key': '7'
  },
  'Digit8': {
    'keyCode': 56,
    'shiftKey': '*',
    'key': '8'
  },
  'Digit9': {
    'keyCode': 57,
    'shiftKey': '\(',
    'key': '9'
  },
  'Digit0': {
    'keyCode': 48,
    'shiftKey': ')',
    'key': '0'
  },
  'Minus': {
    'keyCode': 189,
    'shiftKey': '_',
    'key': '-'
  },
  'Equal': {
    'keyCode': 187,
    'shiftKey': '+',
    'key': '='
  },
  'Backslash': {
    'keyCode': 220,
    'shiftKey': '|',
    'key': '\\'
  },
  'Backspace': {
    'keyCode': 8,
    'key': 'Backspace'
  },
  // First row
  'Tab': {
    'keyCode': 9,
    'key': 'Tab'
  },
  'KeyQ': {
    'keyCode': 81,
    'shiftKey': 'Q',
    'key': 'q'
  },
  'KeyW': {
    'keyCode': 87,
    'shiftKey': 'W',
    'key': 'w'
  },
  'KeyE': {
    'keyCode': 69,
    'shiftKey': 'E',
    'key': 'e'
  },
  'KeyR': {
    'keyCode': 82,
    'shiftKey': 'R',
    'key': 'r'
  },
  'KeyT': {
    'keyCode': 84,
    'shiftKey': 'T',
    'key': 't'
  },
  'KeyY': {
    'keyCode': 89,
    'shiftKey': 'Y',
    'key': 'y'
  },
  'KeyU': {
    'keyCode': 85,
    'shiftKey': 'U',
    'key': 'u'
  },
  'KeyI': {
    'keyCode': 73,
    'shiftKey': 'I',
    'key': 'i'
  },
  'KeyO': {
    'keyCode': 79,
    'shiftKey': 'O',
    'key': 'o'
  },
  'KeyP': {
    'keyCode': 80,
    'shiftKey': 'P',
    'key': 'p'
  },
  'BracketLeft': {
    'keyCode': 219,
    'shiftKey': '{',
    'key': '['
  },
  'BracketRight': {
    'keyCode': 221,
    'shiftKey': '}',
    'key': ']'
  },
  // Second row
  'CapsLock': {
    'keyCode': 20,
    'key': 'CapsLock'
  },
  'KeyA': {
    'keyCode': 65,
    'shiftKey': 'A',
    'key': 'a'
  },
  'KeyS': {
    'keyCode': 83,
    'shiftKey': 'S',
    'key': 's'
  },
  'KeyD': {
    'keyCode': 68,
    'shiftKey': 'D',
    'key': 'd'
  },
  'KeyF': {
    'keyCode': 70,
    'shiftKey': 'F',
    'key': 'f'
  },
  'KeyG': {
    'keyCode': 71,
    'shiftKey': 'G',
    'key': 'g'
  },
  'KeyH': {
    'keyCode': 72,
    'shiftKey': 'H',
    'key': 'h'
  },
  'KeyJ': {
    'keyCode': 74,
    'shiftKey': 'J',
    'key': 'j'
  },
  'KeyK': {
    'keyCode': 75,
    'shiftKey': 'K',
    'key': 'k'
  },
  'KeyL': {
    'keyCode': 76,
    'shiftKey': 'L',
    'key': 'l'
  },
  'Semicolon': {
    'keyCode': 186,
    'shiftKey': ':',
    'key': ';'
  },
  'Quote': {
    'keyCode': 222,
    'shiftKey': '"',
    'key': '\''
  },
  'Enter': {
    'keyCode': 13,
    'key': 'Enter',
    'text': '\r'
  },
  // Third row
  'ShiftLeft': {
    'keyCode': 160,
    'keyCodeWithoutLocation': 16,
    'key': 'Shift',
    'location': 1
  },
  'KeyZ': {
    'keyCode': 90,
    'shiftKey': 'Z',
    'key': 'z'
  },
  'KeyX': {
    'keyCode': 88,
    'shiftKey': 'X',
    'key': 'x'
  },
  'KeyC': {
    'keyCode': 67,
    'shiftKey': 'C',
    'key': 'c'
  },
  'KeyV': {
    'keyCode': 86,
    'shiftKey': 'V',
    'key': 'v'
  },
  'KeyB': {
    'keyCode': 66,
    'shiftKey': 'B',
    'key': 'b'
  },
  'KeyN': {
    'keyCode': 78,
    'shiftKey': 'N',
    'key': 'n'
  },
  'KeyM': {
    'keyCode': 77,
    'shiftKey': 'M',
    'key': 'm'
  },
  'Comma': {
    'keyCode': 188,
    'shiftKey': '\<',
    'key': ','
  },
  'Period': {
    'keyCode': 190,
    'shiftKey': '>',
    'key': '.'
  },
  'Slash': {
    'keyCode': 191,
    'shiftKey': '?',
    'key': '/'
  },
  'ShiftRight': {
    'keyCode': 161,
    'keyCodeWithoutLocation': 16,
    'key': 'Shift',
    'location': 2
  },
  // Last row
  'ControlLeft': {
    'keyCode': 162,
    'keyCodeWithoutLocation': 17,
    'key': 'Control',
    'location': 1
  },
  'MetaLeft': {
    'keyCode': 91,
    'key': 'Meta',
    'location': 1
  },
  'AltLeft': {
    'keyCode': 164,
    'keyCodeWithoutLocation': 18,
    'key': 'Alt',
    'location': 1
  },
  'Space': {
    'keyCode': 32,
    'key': ' '
  },
  'AltRight': {
    'keyCode': 165,
    'keyCodeWithoutLocation': 18,
    'key': 'Alt',
    'location': 2
  },
  'AltGraph': {
    'keyCode': 225,
    'key': 'AltGraph'
  },
  'MetaRight': {
    'keyCode': 92,
    'key': 'Meta',
    'location': 2
  },
  'ContextMenu': {
    'keyCode': 93,
    'key': 'ContextMenu'
  },
  'ControlRight': {
    'keyCode': 163,
    'keyCodeWithoutLocation': 17,
    'key': 'Control',
    'location': 2
  },
  // Center block
  'PrintScreen': {
    'keyCode': 44,
    'key': 'PrintScreen'
  },
  'ScrollLock': {
    'keyCode': 145,
    'key': 'ScrollLock'
  },
  'Pause': {
    'keyCode': 19,
    'key': 'Pause'
  },
  'PageUp': {
    'keyCode': 33,
    'key': 'PageUp'
  },
  'PageDown': {
    'keyCode': 34,
    'key': 'PageDown'
  },
  'Insert': {
    'keyCode': 45,
    'key': 'Insert'
  },
  'Delete': {
    'keyCode': 46,
    'key': 'Delete'
  },
  'Home': {
    'keyCode': 36,
    'key': 'Home'
  },
  'End': {
    'keyCode': 35,
    'key': 'End'
  },
  'ArrowLeft': {
    'keyCode': 37,
    'key': 'ArrowLeft'
  },
  'ArrowUp': {
    'keyCode': 38,
    'key': 'ArrowUp'
  },
  'ArrowRight': {
    'keyCode': 39,
    'key': 'ArrowRight'
  },
  'ArrowDown': {
    'keyCode': 40,
    'key': 'ArrowDown'
  },
  // Numpad
  'NumLock': {
    'keyCode': 144,
    'key': 'NumLock'
  },
  'NumpadDivide': {
    'keyCode': 111,
    'key': '/',
    'location': 3
  },
  'NumpadMultiply': {
    'keyCode': 106,
    'key': '*',
    'location': 3
  },
  'NumpadSubtract': {
    'keyCode': 109,
    'key': '-',
    'location': 3
  },
  'Numpad7': {
    'keyCode': 36,
    'shiftKeyCode': 103,
    'key': 'Home',
    'shiftKey': '7',
    'location': 3
  },
  'Numpad8': {
    'keyCode': 38,
    'shiftKeyCode': 104,
    'key': 'ArrowUp',
    'shiftKey': '8',
    'location': 3
  },
  'Numpad9': {
    'keyCode': 33,
    'shiftKeyCode': 105,
    'key': 'PageUp',
    'shiftKey': '9',
    'location': 3
  },
  'Numpad4': {
    'keyCode': 37,
    'shiftKeyCode': 100,
    'key': 'ArrowLeft',
    'shiftKey': '4',
    'location': 3
  },
  'Numpad5': {
    'keyCode': 12,
    'shiftKeyCode': 101,
    'key': 'Clear',
    'shiftKey': '5',
    'location': 3
  },
  'Numpad6': {
    'keyCode': 39,
    'shiftKeyCode': 102,
    'key': 'ArrowRight',
    'shiftKey': '6',
    'location': 3
  },
  'NumpadAdd': {
    'keyCode': 107,
    'key': '+',
    'location': 3
  },
  'Numpad1': {
    'keyCode': 35,
    'shiftKeyCode': 97,
    'key': 'End',
    'shiftKey': '1',
    'location': 3
  },
  'Numpad2': {
    'keyCode': 40,
    'shiftKeyCode': 98,
    'key': 'ArrowDown',
    'shiftKey': '2',
    'location': 3
  },
  'Numpad3': {
    'keyCode': 34,
    'shiftKeyCode': 99,
    'key': 'PageDown',
    'shiftKey': '3',
    'location': 3
  },
  'Numpad0': {
    'keyCode': 45,
    'shiftKeyCode': 96,
    'key': 'Insert',
    'shiftKey': '0',
    'location': 3
  },
  'NumpadDecimal': {
    'keyCode': 46,
    'shiftKeyCode': 110,
    'key': '\u0000',
    'shiftKey': '.',
    'location': 3
  },
  'NumpadEnter': {
    'keyCode': 13,
    'key': 'Enter',
    'text': '\r',
    'location': 3
  }
};
exports.USKeyboardLayout = USKeyboardLayout;

/***/ }),

/***/ 2967:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebKit = void 0;

var _wkBrowser = __nccwpck_require__(2288);

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _wkConnection = __nccwpck_require__(281);

var _browserType = __nccwpck_require__(1192);

var _stackTrace = __nccwpck_require__(9030);

var _utils = __nccwpck_require__(3557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WebKit extends _browserType.BrowserType {
  constructor(playwrightOptions) {
    super('webkit', playwrightOptions);
  }

  _connectToTransport(transport, options) {
    return _wkBrowser.WKBrowser.connect(transport, options);
  }

  _amendEnvironment(env, userDataDir, executable, browserArguments) {
    return { ...env,
      CURL_COOKIE_JAR_PATH: _path.default.join(userDataDir, 'cookiejar.db')
    };
  }

  _rewriteStartupError(error) {
    if (error.message.includes('cannot open display')) return (0, _stackTrace.rewriteErrorMessage)(error, '\n' + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
    return error;
  }

  _attemptToGracefullyCloseBrowser(transport) {
    transport.send({
      method: 'Playwright.close',
      params: {},
      id: _wkConnection.kBrowserCloseMessageId
    });
  }

  _defaultArgs(options, isPersistent, userDataDir) {
    const {
      args = [],
      proxy,
      headless
    } = options;
    const userDataDirArg = args.find(arg => arg.startsWith('--user-data-dir'));
    if (userDataDirArg) throw new Error('Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument');
    if (args.find(arg => !arg.startsWith('-'))) throw new Error('Arguments can not specify page to be opened');
    const webkitArguments = ['--inspector-pipe'];
    if (process.platform === 'win32') webkitArguments.push('--disable-accelerated-compositing');
    if (headless) webkitArguments.push('--headless');
    if (isPersistent) webkitArguments.push(`--user-data-dir=${userDataDir}`);else webkitArguments.push(`--no-startup-window`);

    if (proxy) {
      if (process.platform === 'darwin') {
        webkitArguments.push(`--proxy=${proxy.server}`);
        if (proxy.bypass) webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
      } else if (process.platform === 'linux') {
        webkitArguments.push(`--proxy=${proxy.server}`);
        if (proxy.bypass) webkitArguments.push(...proxy.bypass.split(',').map(t => `--ignore-host=${t}`));
      } else if (process.platform === 'win32') {
        webkitArguments.push(`--curl-proxy=${proxy.server}`);
        if (proxy.bypass) webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
      }
    }

    webkitArguments.push(...args);
    if (isPersistent) webkitArguments.push('about:blank');
    return webkitArguments;
  }

}

exports.WebKit = WebKit;

/***/ }),

/***/ 8714:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getAccessibilityTree = getAccessibilityTree;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function getAccessibilityTree(session, needle) {
  const objectId = needle ? needle._objectId : undefined;
  const {
    axNode
  } = await session.send('Page.accessibilitySnapshot', {
    objectId
  });
  const tree = new WKAXNode(axNode);
  return {
    tree,
    needle: needle ? tree._findNeedle() : null
  };
}

const WKRoleToARIARole = new Map(Object.entries({
  'TextField': 'textbox'
})); // WebKit localizes role descriptions on mac, but the english versions only add noise.

const WKUnhelpfulRoleDescriptions = new Map(Object.entries({
  'WebArea': 'HTML content',
  'Summary': 'summary',
  'DescriptionList': 'description list',
  'ImageMap': 'image map',
  'ListMarker': 'list marker',
  'Video': 'video playback',
  'Mark': 'highlighted',
  'contentinfo': 'content information',
  'Details': 'details',
  'DescriptionListDetail': 'description',
  'DescriptionListTerm': 'term',
  'alertdialog': 'web alert dialog',
  'dialog': 'web dialog',
  'status': 'application status',
  'tabpanel': 'tab panel',
  'application': 'web application'
}));

class WKAXNode {
  constructor(payload) {
    this._payload = void 0;
    this._children = void 0;
    this._payload = payload;
    this._children = [];

    for (const payload of this._payload.children || []) this._children.push(new WKAXNode(payload));
  }

  children() {
    return this._children;
  }

  _findNeedle() {
    if (this._payload.found) return this;

    for (const child of this._children) {
      const found = child._findNeedle();

      if (found) return found;
    }

    return null;
  }

  isControl() {
    switch (this._payload.role) {
      case 'button':
      case 'checkbox':
      case 'ColorWell':
      case 'combobox':
      case 'DisclosureTriangle':
      case 'listbox':
      case 'menu':
      case 'menubar':
      case 'menuitem':
      case 'menuitemcheckbox':
      case 'menuitemradio':
      case 'radio':
      case 'scrollbar':
      case 'searchbox':
      case 'slider':
      case 'spinbutton':
      case 'switch':
      case 'tab':
      case 'textbox':
      case 'TextField':
      case 'tree':
        return true;

      default:
        return false;
    }
  }

  _isTextControl() {
    switch (this._payload.role) {
      case 'combobox':
      case 'searchfield':
      case 'textbox':
      case 'TextField':
        return true;
    }

    return false;
  }

  _name() {
    if (this._payload.role === 'text') return this._payload.value || '';
    return this._payload.name || '';
  }

  isInteresting(insideControl) {
    const {
      role,
      focusable
    } = this._payload;

    const name = this._name();

    if (role === 'ScrollArea') return false;
    if (role === 'WebArea') return true;
    if (focusable || role === 'MenuListOption') return true; // If it's not focusable but has a control role, then it's interesting.

    if (this.isControl()) return true; // A non focusable child of a control is not interesting

    if (insideControl) return false;
    return this.isLeafNode() && !!name;
  }

  _hasRendundantTextChild() {
    if (this._children.length !== 1) return false;
    const child = this._children[0];
    return child._payload.role === 'text' && this._payload.name === child._payload.value;
  }

  isLeafNode() {
    if (!this._children.length) return true; // WebKit on Linux ignores everything inside text controls, normalize this behavior

    if (this._isTextControl()) return true; // WebKit for mac has text nodes inside heading, li, menuitem, a, and p nodes

    if (this._hasRendundantTextChild()) return true;
    return false;
  }

  serialize() {
    const node = {
      role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
      name: this._name()
    };
    if ('description' in this._payload && this._payload.description !== node.name) node.description = this._payload.description;

    if ('roledescription' in this._payload) {
      const roledescription = this._payload.roledescription;
      if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription) node.roledescription = roledescription;
    }

    if ('value' in this._payload && this._payload.role !== 'text') {
      if (typeof this._payload.value === 'string') node.valueString = this._payload.value;else if (typeof this._payload.value === 'number') node.valueNumber = this._payload.value;
    }

    if ('checked' in this._payload) node.checked = this._payload.checked === 'true' ? 'checked' : this._payload.checked === 'false' ? 'unchecked' : 'mixed';
    if ('pressed' in this._payload) node.pressed = this._payload.pressed === 'true' ? 'pressed' : this._payload.pressed === 'false' ? 'released' : 'mixed';
    const userStringProperties = ['keyshortcuts', 'valuetext'];

    for (const userStringProperty of userStringProperties) {
      if (!(userStringProperty in this._payload)) continue;
      node[userStringProperty] = this._payload[userStringProperty];
    }

    const booleanProperties = ['disabled', 'expanded', 'focused', 'modal', 'multiline', 'multiselectable', 'readonly', 'required', 'selected'];

    for (const booleanProperty of booleanProperties) {
      // WebArea and ScorllArea treat focus differently than other nodes. They report whether their frame  has focus,
      // not whether focus is specifically on the root node.
      if (booleanProperty === 'focused' && (this._payload.role === 'WebArea' || this._payload.role === 'ScrollArea')) continue;
      const value = this._payload[booleanProperty];
      if (!value) continue;
      node[booleanProperty] = value;
    }

    const numericalProperties = ['level', 'valuemax', 'valuemin'];

    for (const numericalProperty of numericalProperties) {
      if (!(numericalProperty in this._payload)) continue;
      node[numericalProperty] = this._payload[numericalProperty];
    }

    const tokenProperties = ['autocomplete', 'haspopup', 'invalid'];

    for (const tokenProperty of tokenProperties) {
      const value = this._payload[tokenProperty];
      if (!value || value === 'false') continue;
      node[tokenProperty] = value;
    }

    const orientationIsApplicable = new Set(['ScrollArea', 'scrollbar', 'listbox', 'combobox', 'menu', 'tree', 'separator', 'slider', 'tablist', 'toolbar']);
    if (this._payload.orientation && orientationIsApplicable.has(this._payload.role)) node.orientation = this._payload.orientation;
    return node;
  }

}

/***/ }),

/***/ 2288:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKBrowserContext = exports.WKBrowser = void 0;

var _browser = __nccwpck_require__(6705);

var _browserContext = __nccwpck_require__(5985);

var _utils = __nccwpck_require__(3557);

var _eventsHelper = __nccwpck_require__(3841);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _wkConnection = __nccwpck_require__(281);

var _wkPage = __nccwpck_require__(582);

var _errors = __nccwpck_require__(542);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Safari/605.1.15';
const BROWSER_VERSION = '16.0';

class WKBrowser extends _browser.Browser {
  static async connect(transport, options) {
    const browser = new WKBrowser(transport, options);
    if (options.__testHookOnConnectToBrowser) await options.__testHookOnConnectToBrowser();
    const promises = [browser._browserSession.send('Playwright.enable')];

    if (options.persistent) {
      browser._defaultContext = new WKBrowserContext(browser, undefined, options.persistent);
      promises.push(browser._defaultContext._initialize());
    }

    await Promise.all(promises);
    return browser;
  }

  constructor(transport, options) {
    super(options);
    this._connection = void 0;
    this._browserSession = void 0;
    this._contexts = new Map();
    this._wkPages = new Map();
    this._eventListeners = void 0;
    this._connection = new _wkConnection.WKConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
    this._browserSession = this._connection.browserSession;
    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.pageProxyCreated', this._onPageProxyCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.pageProxyDestroyed', this._onPageProxyDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.provisionalLoadFailed', event => this._onProvisionalLoadFailed(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.windowOpen', event => this._onWindowOpen(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.downloadCreated', this._onDownloadCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.downloadFilenameSuggested', this._onDownloadFilenameSuggested.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.downloadFinished', this._onDownloadFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, 'Playwright.screencastFinished', this._onScreencastFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, _wkConnection.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))];
  }

  _onDisconnect() {
    for (const wkPage of this._wkPages.values()) wkPage.dispose(true);

    for (const video of this._idToVideo.values()) video.artifact.reportFinished(_errors.kBrowserClosedError);

    this._idToVideo.clear();

    this._didClose();
  }

  async doCreateNewContext(options) {
    const createOptions = options.proxy ? {
      proxyServer: options.proxy.server,
      proxyBypassList: options.proxy.bypass
    } : undefined;
    const {
      browserContextId
    } = await this._browserSession.send('Playwright.createContext', createOptions);
    options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
    const context = new WKBrowserContext(this, browserContextId, options);
    await context._initialize();

    this._contexts.set(browserContextId, context);

    return context;
  }

  contexts() {
    return Array.from(this._contexts.values());
  }

  version() {
    return BROWSER_VERSION;
  }

  userAgent() {
    return DEFAULT_USER_AGENT;
  }

  _onDownloadCreated(payload) {
    const page = this._wkPages.get(payload.pageProxyId);

    if (!page) return; // In some cases, e.g. blob url download, we receive only frameScheduledNavigation
    // but no signals that the navigation was canceled and replaced by download. Fix it
    // here by simulating cancelled provisional load which matches downloads from network.
    //
    // TODO: this is racy, because download might be unrelated any navigation, and we will
    // abort navgitation that is still running. We should be able to fix this by
    // instrumenting policy decision start/proceed/cancel.

    page._page._frameManager.frameAbortedNavigation(payload.frameId, 'Download is starting');

    let originPage = page._initializedPage; // If it's a new window download, report it on the opener page.

    if (!originPage) {
      // Resume the page creation with an error. The page will automatically close right
      // after the download begins.
      page._firstNonInitialNavigationCommittedReject(new Error('Starting new page download'));

      if (page._opener) originPage = page._opener._initializedPage;
    }

    if (!originPage) return;

    this._downloadCreated(originPage, payload.uuid, payload.url);
  }

  _onDownloadFilenameSuggested(payload) {
    this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
  }

  _onDownloadFinished(payload) {
    this._downloadFinished(payload.uuid, payload.error);
  }

  _onScreencastFinished(payload) {
    var _this$_takeVideo;

    (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
  }

  _onPageProxyCreated(event) {
    const pageProxyId = event.pageProxyId;
    let context = null;

    if (event.browserContextId) {
      // FIXME: we don't know about the default context id, so assume that all targets from
      // unknown contexts are created in the 'default' context which can in practice be represented
      // by multiple actual contexts in WebKit. Solving this properly will require adding context
      // lifecycle events.
      context = this._contexts.get(event.browserContextId) || null;
    }

    if (!context) context = this._defaultContext;
    if (!context) return;
    const pageProxySession = new _wkConnection.WKSession(this._connection, pageProxyId, `Target closed`, message => {
      this._connection.rawSend({ ...message,
        pageProxyId
      });
    });
    const opener = event.openerId ? this._wkPages.get(event.openerId) : undefined;
    const wkPage = new _wkPage.WKPage(context, pageProxySession, opener || null);

    this._wkPages.set(pageProxyId, wkPage);
  }

  _onPageProxyDestroyed(event) {
    const pageProxyId = event.pageProxyId;

    const wkPage = this._wkPages.get(pageProxyId);

    if (!wkPage) return;
    wkPage.didClose();
    wkPage.dispose(false);

    this._wkPages.delete(pageProxyId);
  }

  _onPageProxyMessageReceived(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);

    if (!wkPage) return;
    wkPage.dispatchMessageToSession(event.message);
  }

  _onProvisionalLoadFailed(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);

    if (!wkPage) return;
    wkPage.handleProvisionalLoadFailed(event);
  }

  _onWindowOpen(event) {
    const wkPage = this._wkPages.get(event.pageProxyId);

    if (!wkPage) return;
    wkPage.handleWindowOpen(event);
  }

  isConnected() {
    return !this._connection.isClosed();
  }

}

exports.WKBrowser = WKBrowser;

class WKBrowserContext extends _browserContext.BrowserContext {
  constructor(browser, browserContextId, options) {
    super(browser, options, browserContextId);

    this._authenticateProxyViaHeader();
  }

  async _initialize() {
    (0, _utils.assert)(!this._wkPages().length);
    const browserContextId = this._browserContextId;
    const promises = [super._initialize()];
    promises.push(this._browser._browserSession.send('Playwright.setDownloadBehavior', {
      behavior: this._options.acceptDownloads ? 'allow' : 'deny',
      downloadPath: this._browser.options.downloadsPath,
      browserContextId
    }));
    if (this._options.ignoreHTTPSErrors) promises.push(this._browser._browserSession.send('Playwright.setIgnoreCertificateErrors', {
      browserContextId,
      ignore: true
    }));
    if (this._options.locale) promises.push(this._browser._browserSession.send('Playwright.setLanguages', {
      browserContextId,
      languages: [this._options.locale]
    }));
    if (this._options.geolocation) promises.push(this.setGeolocation(this._options.geolocation));
    if (this._options.offline) promises.push(this.setOffline(this._options.offline));
    if (this._options.httpCredentials) promises.push(this.setHTTPCredentials(this._options.httpCredentials));
    await Promise.all(promises);
  }

  _wkPages() {
    return Array.from(this._browser._wkPages.values()).filter(wkPage => wkPage._browserContext === this);
  }

  pages() {
    return this._wkPages().map(wkPage => wkPage._initializedPage).filter(pageOrNull => !!pageOrNull);
  }

  async newPageDelegate() {
    (0, _browserContext.assertBrowserContextIsNotOwned)(this);
    const {
      pageProxyId
    } = await this._browser._browserSession.send('Playwright.createPage', {
      browserContextId: this._browserContextId
    });
    return this._browser._wkPages.get(pageProxyId);
  }

  async doGetCookies(urls) {
    const {
      cookies
    } = await this._browser._browserSession.send('Playwright.getAllCookies', {
      browserContextId: this._browserContextId
    });
    return network.filterCookies(cookies.map(c => {
      const copy = { ...c
      };
      copy.expires = c.expires === -1 ? -1 : c.expires / 1000;
      delete copy.session;
      return copy;
    }), urls);
  }

  async addCookies(cookies) {
    const cc = network.rewriteCookies(cookies).map(c => ({ ...c,
      session: c.expires === -1 || c.expires === undefined,
      expires: c.expires && c.expires !== -1 ? c.expires * 1000 : c.expires
    }));
    await this._browser._browserSession.send('Playwright.setCookies', {
      cookies: cc,
      browserContextId: this._browserContextId
    });
  }

  async clearCookies() {
    await this._browser._browserSession.send('Playwright.deleteAllCookies', {
      browserContextId: this._browserContextId
    });
  }

  async doGrantPermissions(origin, permissions) {
    await Promise.all(this.pages().map(page => page._delegate._grantPermissions(origin, permissions)));
  }

  async doClearPermissions() {
    await Promise.all(this.pages().map(page => page._delegate._clearPermissions()));
  }

  async setGeolocation(geolocation) {
    (0, _browserContext.verifyGeolocation)(geolocation);
    this._options.geolocation = geolocation;
    const payload = geolocation ? { ...geolocation,
      timestamp: Date.now()
    } : undefined;
    await this._browser._browserSession.send('Playwright.setGeolocationOverride', {
      browserContextId: this._browserContextId,
      geolocation: payload
    });
  }

  async setExtraHTTPHeaders(headers) {
    this._options.extraHTTPHeaders = headers;

    for (const page of this.pages()) await page._delegate.updateExtraHTTPHeaders();
  }

  async setUserAgent(userAgent) {
    this._options.userAgent = userAgent;

    for (const page of this.pages()) await page._delegate.updateUserAgent();
  }

  async setOffline(offline) {
    this._options.offline = offline;

    for (const page of this.pages()) await page._delegate.updateOffline();
  }

  async doSetHTTPCredentials(httpCredentials) {
    this._options.httpCredentials = httpCredentials;

    for (const page of this.pages()) await page._delegate.updateHttpCredentials();
  }

  async doAddInitScript(source) {
    for (const page of this.pages()) await page._delegate._updateBootstrapScript();
  }

  async doRemoveInitScripts() {
    for (const page of this.pages()) await page._delegate._updateBootstrapScript();
  }

  async doExposeBinding(binding) {
    for (const page of this.pages()) await page._delegate.exposeBinding(binding);
  }

  async doRemoveExposedBindings() {
    for (const page of this.pages()) await page._delegate.removeExposedBindings();
  }

  async doUpdateRequestInterception() {
    for (const page of this.pages()) await page._delegate.updateRequestInterception();
  }

  onClosePersistent() {}

  async doClose() {
    (0, _utils.assert)(this._browserContextId);
    await this._browser._browserSession.send('Playwright.deleteContext', {
      browserContextId: this._browserContextId
    });

    this._browser._contexts.delete(this._browserContextId);
  }

  async cancelDownload(uuid) {
    await this._browser._browserSession.send('Playwright.cancelDownload', {
      uuid
    });
  }

}

exports.WKBrowserContext = WKBrowserContext;

/***/ }),

/***/ 281:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKSession = exports.WKConnection = void 0;
exports.createProtocolError = createProtocolError;
exports.kPageProxyMessageReceived = exports.kBrowserCloseMessageId = void 0;

var _events = __nccwpck_require__(2361);

var _utils = __nccwpck_require__(3557);

var _stackTrace = __nccwpck_require__(9030);

var _debugLogger = __nccwpck_require__(2003);

var _helper = __nccwpck_require__(9175);

var _errors = __nccwpck_require__(542);

var _protocolError = __nccwpck_require__(7314);

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// WKPlaywright uses this special id to issue Browser.close command which we
// should ignore.
const kBrowserCloseMessageId = -9999; // We emulate kPageProxyMessageReceived message to unify it with Browser.pageProxyCreated
// and Browser.pageProxyDestroyed for easier management.

exports.kBrowserCloseMessageId = kBrowserCloseMessageId;
const kPageProxyMessageReceived = 'kPageProxyMessageReceived';
exports.kPageProxyMessageReceived = kPageProxyMessageReceived;

class WKConnection {
  constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
    this._transport = void 0;
    this._onDisconnect = void 0;
    this._protocolLogger = void 0;
    this._browserLogsCollector = void 0;
    this._lastId = 0;
    this._closed = false;
    this.browserSession = void 0;
    this._transport = transport;
    this._onDisconnect = onDisconnect;
    this._protocolLogger = protocolLogger;
    this._browserLogsCollector = browserLogsCollector;
    this.browserSession = new WKSession(this, '', _errors.kBrowserClosedError, message => {
      this.rawSend(message);
    });
    this._transport.onmessage = this._dispatchMessage.bind(this); // onclose should be set last, since it can be immediately called.

    this._transport.onclose = this._onClose.bind(this);
  }

  nextMessageId() {
    return ++this._lastId;
  }

  rawSend(message) {
    this._protocolLogger('send', message);

    this._transport.send(message);
  }

  _dispatchMessage(message) {
    this._protocolLogger('receive', message);

    if (message.id === kBrowserCloseMessageId) return;

    if (message.pageProxyId) {
      const payload = {
        message: message,
        pageProxyId: message.pageProxyId
      };
      this.browserSession.dispatchMessage({
        method: kPageProxyMessageReceived,
        params: payload
      });
      return;
    }

    this.browserSession.dispatchMessage(message);
  }

  _onClose() {
    this._closed = true;
    this._transport.onmessage = undefined;
    this._transport.onclose = undefined;
    this.browserSession.dispose(true);

    this._onDisconnect();
  }

  isClosed() {
    return this._closed;
  }

  close() {
    if (!this._closed) this._transport.close();
  }

}

exports.WKConnection = WKConnection;

class WKSession extends _events.EventEmitter {
  constructor(connection, sessionId, errorText, rawSend) {
    super();
    this.connection = void 0;
    this.errorText = void 0;
    this.sessionId = void 0;
    this._disposed = false;
    this._rawSend = void 0;
    this._callbacks = new Map();
    this._crashed = false;
    this.on = void 0;
    this.addListener = void 0;
    this.off = void 0;
    this.removeListener = void 0;
    this.once = void 0;
    this.setMaxListeners(0);
    this.connection = connection;
    this.sessionId = sessionId;
    this._rawSend = rawSend;
    this.errorText = errorText;
    this.on = super.on;
    this.off = super.removeListener;
    this.addListener = super.addListener;
    this.removeListener = super.removeListener;
    this.once = super.once;
  }

  async send(method, params) {
    if (this._crashed) throw new _protocolError.ProtocolError(true, 'Target crashed');
    if (this._disposed) throw new _protocolError.ProtocolError(true, `Target closed`);
    const id = this.connection.nextMessageId();
    const messageObj = {
      id,
      method,
      params
    };

    this._rawSend(messageObj);

    return new Promise((resolve, reject) => {
      this._callbacks.set(id, {
        resolve,
        reject,
        error: new _protocolError.ProtocolError(false),
        method
      });
    });
  }

  sendMayFail(method, params) {
    return this.send(method, params).catch(error => _debugLogger.debugLogger.log('error', error));
  }

  markAsCrashed() {
    this._crashed = true;
  }

  isDisposed() {
    return this._disposed;
  }

  dispose(disconnected) {
    if (disconnected) this.errorText = 'Browser closed.' + _helper.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());

    for (const callback of this._callbacks.values()) {
      callback.error.sessionClosed = true;
      callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, this.errorText));
    }

    this._callbacks.clear();

    this._disposed = true;
  }

  dispatchMessage(object) {
    if (object.id && this._callbacks.has(object.id)) {
      const callback = this._callbacks.get(object.id);

      this._callbacks.delete(object.id);

      if (object.error) callback.reject(createProtocolError(callback.error, callback.method, object.error));else callback.resolve(object.result);
    } else if (object.id && !object.error) {
      // Response might come after session has been disposed and rejected all callbacks.
      (0, _utils.assert)(this.isDisposed());
    } else {
      Promise.resolve().then(() => this.emit(object.method, object.params));
    }
  }

}

exports.WKSession = WKSession;

function createProtocolError(error, method, protocolError) {
  let message = `Protocol error (${method}): ${protocolError.message}`;
  if ('data' in protocolError) message += ` ${JSON.stringify(protocolError.data)}`;
  return (0, _stackTrace.rewriteErrorMessage)(error, message);
}

/***/ }),

/***/ 2559:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKExecutionContext = void 0;

var js = _interopRequireWildcard(__nccwpck_require__(804));

var _utilityScriptSerializers = __nccwpck_require__(9012);

var _protocolError = __nccwpck_require__(7314);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WKExecutionContext {
  constructor(session, contextId) {
    this._session = void 0;
    this._contextId = void 0;
    this._session = session;
    this._contextId = contextId;
  }

  async rawEvaluateJSON(expression) {
    try {
      const response = await this._session.send('Runtime.evaluate', {
        expression,
        contextId: this._contextId,
        returnByValue: true
      });
      if (response.wasThrown) throw new js.JavaScriptErrorInEvaluate(response.result.description);
      return response.result.value;
    } catch (error) {
      throw rewriteError(error);
    }
  }

  async rawEvaluateHandle(expression) {
    try {
      const response = await this._session.send('Runtime.evaluate', {
        expression,
        contextId: this._contextId,
        returnByValue: false
      });
      if (response.wasThrown) throw new js.JavaScriptErrorInEvaluate(response.result.description);
      return response.result.objectId;
    } catch (error) {
      throw rewriteError(error);
    }
  }

  rawCallFunctionNoReply(func, ...args) {
    this._session.send('Runtime.callFunctionOn', {
      functionDeclaration: func.toString(),
      objectId: args.find(a => a instanceof js.JSHandle)._objectId,
      arguments: args.map(a => a instanceof js.JSHandle ? {
        objectId: a._objectId
      } : {
        value: a
      }),
      returnByValue: true,
      emulateUserGesture: true
    }).catch(() => {});
  }

  async evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
    try {
      const response = await this._session.send('Runtime.callFunctionOn', {
        functionDeclaration: expression,
        objectId: utilityScript._objectId,
        arguments: [{
          objectId: utilityScript._objectId
        }, ...values.map(value => ({
          value
        })), ...objectIds.map(objectId => ({
          objectId
        }))],
        returnByValue,
        emulateUserGesture: true,
        awaitPromise: true
      });
      if (response.wasThrown) throw new js.JavaScriptErrorInEvaluate(response.result.description);
      if (returnByValue) return (0, _utilityScriptSerializers.parseEvaluationResultValue)(response.result.value);
      return utilityScript._context.createHandle(response.result);
    } catch (error) {
      throw rewriteError(error);
    }
  }

  async getProperties(context, objectId) {
    const response = await this._session.send('Runtime.getProperties', {
      objectId,
      ownProperties: true
    });
    const result = new Map();

    for (const property of response.properties) {
      if (!property.enumerable || !property.value) continue;
      result.set(property.name, context.createHandle(property.value));
    }

    return result;
  }

  createHandle(context, remoteObject) {
    const isPromise = remoteObject.className === 'Promise';
    return new js.JSHandle(context, isPromise ? 'promise' : remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
  }

  async releaseHandle(objectId) {
    await this._session.send('Runtime.releaseObject', {
      objectId
    });
  }

}

exports.WKExecutionContext = WKExecutionContext;

function potentiallyUnserializableValue(remoteObject) {
  const value = remoteObject.value;
  const isUnserializable = remoteObject.type === 'number' && ['NaN', '-Infinity', 'Infinity', '-0'].includes(remoteObject.description);
  return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
}

function rewriteError(error) {
  if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error)) return new Error('Execution context was destroyed, most likely because of a navigation.');
  return error;
}

function renderPreview(object) {
  if (object.type === 'undefined') return 'undefined';
  if ('value' in object) return String(object.value);

  if (object.description === 'Object' && object.preview) {
    const tokens = [];

    for (const {
      name,
      value
    } of object.preview.properties) tokens.push(`${name}: ${value}`);

    return `{${tokens.join(', ')}}`;
  }

  if (object.subtype === 'array' && object.preview) {
    const result = [];

    for (const {
      name,
      value
    } of object.preview.properties) result[+name] = value;

    return '[' + String(result) + ']';
  }

  return object.description;
}

/***/ }),

/***/ 2422:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RawTouchscreenImpl = exports.RawMouseImpl = exports.RawKeyboardImpl = void 0;

var input = _interopRequireWildcard(__nccwpck_require__(2654));

var _macEditingCommands = __nccwpck_require__(2310);

var _utils = __nccwpck_require__(3557);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function toModifiersMask(modifiers) {
  // From Source/WebKit/Shared/WebEvent.h
  let mask = 0;
  if (modifiers.has('Shift')) mask |= 1;
  if (modifiers.has('Control')) mask |= 2;
  if (modifiers.has('Alt')) mask |= 4;
  if (modifiers.has('Meta')) mask |= 8;
  return mask;
}

function toButtonsMask(buttons) {
  let mask = 0;
  if (buttons.has('left')) mask |= 1;
  if (buttons.has('right')) mask |= 2;
  if (buttons.has('middle')) mask |= 4;
  return mask;
}

class RawKeyboardImpl {
  constructor(session) {
    this._pageProxySession = void 0;
    this._session = void 0;
    this._pageProxySession = session;
  }

  setSession(session) {
    this._session = session;
  }

  async keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location, autoRepeat, text) {
    const parts = [];

    for (const modifier of ['Shift', 'Control', 'Alt', 'Meta']) {
      if (modifiers.has(modifier)) parts.push(modifier);
    }

    parts.push(code);
    const shortcut = parts.join('+');
    let commands = _macEditingCommands.macEditingCommands[shortcut];
    if ((0, _utils.isString)(commands)) commands = [commands];
    await this._pageProxySession.send('Input.dispatchKeyEvent', {
      type: 'keyDown',
      modifiers: toModifiersMask(modifiers),
      windowsVirtualKeyCode: keyCode,
      code,
      key,
      text,
      unmodifiedText: text,
      autoRepeat,
      macCommands: commands,
      isKeypad: location === input.keypadLocation
    });
  }

  async keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location) {
    await this._pageProxySession.send('Input.dispatchKeyEvent', {
      type: 'keyUp',
      modifiers: toModifiersMask(modifiers),
      key,
      windowsVirtualKeyCode: keyCode,
      code,
      isKeypad: location === input.keypadLocation
    });
  }

  async sendText(text) {
    await this._session.send('Page.insertText', {
      text
    });
  }

}

exports.RawKeyboardImpl = RawKeyboardImpl;

class RawMouseImpl {
  constructor(session) {
    this._pageProxySession = void 0;
    this._session = void 0;
    this._page = void 0;
    this._pageProxySession = session;
  }

  setSession(session) {
    this._session = session;
  }

  async move(x, y, button, buttons, modifiers, forClick) {
    await this._pageProxySession.send('Input.dispatchMouseEvent', {
      type: 'move',
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers)
    });
  }

  async down(x, y, button, buttons, modifiers, clickCount) {
    await this._pageProxySession.send('Input.dispatchMouseEvent', {
      type: 'down',
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      clickCount
    });
  }

  async up(x, y, button, buttons, modifiers, clickCount) {
    await this._pageProxySession.send('Input.dispatchMouseEvent', {
      type: 'up',
      button,
      buttons: toButtonsMask(buttons),
      x,
      y,
      modifiers: toModifiersMask(modifiers),
      clickCount
    });
  }

  async wheel(x, y, buttons, modifiers, deltaX, deltaY) {
    var _this$_page;

    if ((_this$_page = this._page) !== null && _this$_page !== void 0 && _this$_page._browserContext._options.isMobile) throw new Error('Mouse wheel is not supported in mobile WebKit');
    await this._session.send('Page.updateScrollingState'); // Wheel events hit the compositor first, so wait one frame for it to be synced.

    await this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, 'utility');
    await this._pageProxySession.send('Input.dispatchWheelEvent', {
      x,
      y,
      deltaX,
      deltaY,
      modifiers: toModifiersMask(modifiers)
    });
  }

  setPage(page) {
    this._page = page;
  }

}

exports.RawMouseImpl = RawMouseImpl;

class RawTouchscreenImpl {
  constructor(session) {
    this._pageProxySession = void 0;
    this._pageProxySession = session;
  }

  async tap(x, y, modifiers) {
    await this._pageProxySession.send('Input.dispatchTapEvent', {
      x,
      y,
      modifiers: toModifiersMask(modifiers)
    });
  }

}

exports.RawTouchscreenImpl = RawTouchscreenImpl;

/***/ }),

/***/ 113:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKRouteImpl = exports.WKInterceptableRequest = void 0;

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _utils = __nccwpck_require__(3557);

var _manualPromise = __nccwpck_require__(6729);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const errorReasons = {
  'aborted': 'Cancellation',
  'accessdenied': 'AccessControl',
  'addressunreachable': 'General',
  'blockedbyclient': 'Cancellation',
  'blockedbyresponse': 'General',
  'connectionaborted': 'General',
  'connectionclosed': 'General',
  'connectionfailed': 'General',
  'connectionrefused': 'General',
  'connectionreset': 'General',
  'internetdisconnected': 'General',
  'namenotresolved': 'General',
  'timedout': 'Timeout',
  'failed': 'General'
};

class WKInterceptableRequest {
  constructor(session, route, frame, event, redirectedFrom, documentId) {
    this._session = void 0;
    this.request = void 0;
    this._requestId = void 0;
    this._timestamp = void 0;
    this._wallTime = void 0;
    this._route = void 0;
    this._redirectedFrom = void 0;
    this._session = session;
    this._requestId = event.requestId;
    this._route = route;
    this._redirectedFrom = redirectedFrom;
    const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : 'other';
    let postDataBuffer = null;
    this._timestamp = event.timestamp;
    this._wallTime = event.walltime * 1000;
    if (event.request.postData) postDataBuffer = Buffer.from(event.request.postData, 'base64');
    this.request = new network.Request(frame._page._browserContext, frame, null, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, (0, _utils.headersObjectToArray)(event.request.headers));
  }

  _routeForRedirectChain() {
    let request = this;

    while (request._redirectedFrom) request = request._redirectedFrom;

    return request._route;
  }

  createResponse(responsePayload) {
    const getResponseBody = async () => {
      const response = await this._session.send('Network.getResponseBody', {
        requestId: this._requestId
      });
      return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');
    };

    const timingPayload = responsePayload.timing;
    const timing = {
      startTime: this._wallTime,
      domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
      domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
      connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
      secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
      connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
      requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
      responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
    };
    const setCookieSeparator = process.platform === 'darwin' ? ',' : '\n';
    const response = new network.Response(this.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers, ',', setCookieSeparator), timing, getResponseBody, responsePayload.source === 'service-worker'); // No raw response headers in WebKit, use "provisional" ones.

    response.setRawResponseHeaders(null); // Transfer size is not available in WebKit.

    response.setTransferSize(null);

    if (responsePayload.requestHeaders && Object.keys(responsePayload.requestHeaders).length) {
      const headers = { ...responsePayload.requestHeaders
      };
      if (!headers['host']) headers['Host'] = new URL(this.request.url()).host;
      this.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(headers));
    } else {
      // No raw headers avaialable, use provisional ones.
      this.request.setRawRequestHeaders(null);
    }

    return response;
  }

}

exports.WKInterceptableRequest = WKInterceptableRequest;

class WKRouteImpl {
  constructor(session, requestId) {
    this._session = void 0;
    this._requestId = void 0;
    this._requestInterceptedPromise = new _manualPromise.ManualPromise();
    this._session = session;
    this._requestId = requestId;
  }

  async abort(errorCode) {
    const errorType = errorReasons[errorCode];
    (0, _utils.assert)(errorType, 'Unknown error code: ' + errorCode);
    await this._requestInterceptedPromise; // In certain cases, protocol will return error if the request was already canceled
    // or the page was closed. We should tolerate these errors.

    await this._session.sendMayFail('Network.interceptRequestWithError', {
      requestId: this._requestId,
      errorType
    });
  }

  async fulfill(response) {
    if (300 <= response.status && response.status < 400) throw new Error('Cannot fulfill with redirect status: ' + response.status);
    await this._requestInterceptedPromise; // In certain cases, protocol will return error if the request was already canceled
    // or the page was closed. We should tolerate these errors.

    let mimeType = response.isBase64 ? 'application/octet-stream' : 'text/plain';
    const headers = (0, _utils.headersArrayToObject)(response.headers, true
    /* lowerCase */
    );
    const contentType = headers['content-type'];
    if (contentType) mimeType = contentType.split(';')[0].trim();
    await this._session.sendMayFail('Network.interceptRequestWithResponse', {
      requestId: this._requestId,
      status: response.status,
      statusText: network.STATUS_TEXTS[String(response.status)],
      mimeType,
      headers,
      base64Encoded: response.isBase64,
      content: response.body
    });
  }

  async continue(request, overrides) {
    await this._requestInterceptedPromise; // In certain cases, protocol will return error if the request was already canceled
    // or the page was closed. We should tolerate these errors.

    await this._session.sendMayFail('Network.interceptWithRequest', {
      requestId: this._requestId,
      url: overrides.url,
      method: overrides.method,
      headers: overrides.headers ? (0, _utils.headersArrayToObject)(overrides.headers, false
      /* lowerCase */
      ) : undefined,
      postData: overrides.postData ? Buffer.from(overrides.postData).toString('base64') : undefined
    });
  }

}

exports.WKRouteImpl = WKRouteImpl;

function wkMillisToRoundishMillis(value) {
  // WebKit uses -1000 for unavailable.
  if (value === -1000) return -1; // WebKit has a bug, instead of -1 it sends -1000 to be in ms.

  if (value <= 0) {
    // DNS can start before request start on Mac Network Stack
    return -1;
  }

  return (value * 1000 | 0) / 1000;
}

/***/ }),

/***/ 582:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKPage = void 0;

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _utilsBundle = __nccwpck_require__(1319);

var _stackTrace = __nccwpck_require__(9030);

var _utils = __nccwpck_require__(3557);

var _hostPlatform = __nccwpck_require__(5228);

var dialog = _interopRequireWildcard(__nccwpck_require__(1645));

var dom = _interopRequireWildcard(__nccwpck_require__(8139));

var _eventsHelper = __nccwpck_require__(3841);

var _helper = __nccwpck_require__(9175);

var network = _interopRequireWildcard(__nccwpck_require__(3824));

var _page = __nccwpck_require__(3555);

var _wkAccessibility = __nccwpck_require__(8714);

var _wkConnection = __nccwpck_require__(281);

var _wkExecutionContext = __nccwpck_require__(2559);

var _wkInput = __nccwpck_require__(2422);

var _wkInterceptableRequest = __nccwpck_require__(113);

var _wkProvisionalPage = __nccwpck_require__(1516);

var _wkWorkers = __nccwpck_require__(3471);

var _debugLogger = __nccwpck_require__(2003);

var _manualPromise = __nccwpck_require__(6729);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const UTILITY_WORLD_NAME = '__playwright_utility_world__';

class WKPage {
  // Holds window features for the next popup being opened via window.open,
  // until the popup page proxy arrives.
  constructor(browserContext, pageProxySession, opener) {
    this.rawMouse = void 0;
    this.rawKeyboard = void 0;
    this.rawTouchscreen = void 0;
    this._session = void 0;
    this._provisionalPage = null;
    this._page = void 0;
    this._pagePromise = new _manualPromise.ManualPromise();
    this._pageProxySession = void 0;
    this._opener = void 0;
    this._requestIdToRequest = new Map();
    this._workers = void 0;
    this._contextIdToContext = void 0;
    this._mainFrameContextId = void 0;
    this._sessionListeners = [];
    this._eventListeners = void 0;
    this._browserContext = void 0;
    this._initializedPage = null;
    this._firstNonInitialNavigationCommittedPromise = void 0;

    this._firstNonInitialNavigationCommittedFulfill = () => {};

    this._firstNonInitialNavigationCommittedReject = e => {};

    this._lastConsoleMessage = null;
    this._requestIdToResponseReceivedPayloadEvent = new Map();
    this._nextWindowOpenPopupFeatures = void 0;
    this._recordingVideoFile = null;
    this._screencastGeneration = 0;
    this._pageProxySession = pageProxySession;
    this._opener = opener;
    this.rawKeyboard = new _wkInput.RawKeyboardImpl(pageProxySession);
    this.rawMouse = new _wkInput.RawMouseImpl(pageProxySession);
    this.rawTouchscreen = new _wkInput.RawTouchscreenImpl(pageProxySession);
    this._contextIdToContext = new Map();
    this._page = new _page.Page(this, browserContext);
    this.rawMouse.setPage(this._page);
    this._workers = new _wkWorkers.WKWorkers(this._page);
    this._session = undefined;
    this._browserContext = browserContext;

    this._page.on(_page.Page.Events.FrameDetached, frame => this._removeContextsForFrame(frame, false));

    this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.targetCreated', this._onTargetCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.targetDestroyed', this._onTargetDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.dispatchMessageFromTarget', this._onDispatchMessageFromTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Target.didCommitProvisionalTarget', this._onDidCommitProvisionalTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Screencast.screencastFrame', this._onScreencastFrame.bind(this))];
    this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
      this._firstNonInitialNavigationCommittedFulfill = f;
      this._firstNonInitialNavigationCommittedReject = r;
    });

    if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
      const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);

      opener._nextWindowOpenPopupFeatures = undefined;
      if (viewportSize) this._page._emulatedSize = {
        viewport: viewportSize,
        screen: viewportSize
      };
    }
  }

  potentiallyUninitializedPage() {
    return this._page;
  }

  async _initializePageProxySession() {
    if (this._page._browserContext.isSettingStorageState()) return;
    const promises = [this._pageProxySession.send('Dialog.enable'), this._pageProxySession.send('Emulation.setActiveAndFocused', {
      active: true
    })];
    const contextOptions = this._browserContext._options;
    if (contextOptions.javaScriptEnabled === false) promises.push(this._pageProxySession.send('Emulation.setJavaScriptEnabled', {
      enabled: false
    }));
    promises.push(this._updateViewport());
    promises.push(this.updateHttpCredentials());

    if (this._browserContext._permissions.size) {
      for (const [key, value] of this._browserContext._permissions) promises.push(this._grantPermissions(key, value));
    }

    if (this._browserContext._options.recordVideo) {
      const outputFile = _path.default.join(this._browserContext._options.recordVideo.dir, (0, _utils.createGuid)() + '.webm');

      promises.push(this._browserContext._ensureVideosPath().then(() => {
        return this._startVideo({ // validateBrowserContextOptions ensures correct video size.
          ...this._browserContext._options.recordVideo.size,
          outputFile
        });
      }));
    }

    await Promise.all(promises);
  }

  _setSession(session) {
    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);

    this._session = session;
    this.rawKeyboard.setSession(session);
    this.rawMouse.setSession(session);

    this._addSessionListeners();

    this._workers.setSession(session);
  } // This method is called for provisional targets as well. The session passed as the parameter
  // may be different from the current session and may be destroyed without becoming current.


  async _initializeSession(session, provisional, resourceTreeHandler) {
    await this._initializeSessionMayThrow(session, resourceTreeHandler).catch(e => {
      // Provisional session can be disposed at any time, for example due to new navigation initiating
      // a new provisional page.
      if (provisional && session.isDisposed()) return; // Swallow initialization errors due to newer target swap in,
      // since we will reinitialize again.

      if (this._session === session) throw e;
    });
  }

  async _initializeSessionMayThrow(session, resourceTreeHandler) {
    const [, frameTree] = await Promise.all([// Page agent must be enabled before Runtime.
    session.send('Page.enable'), session.send('Page.getResourceTree')]);
    resourceTreeHandler(frameTree);
    const promises = [// Resource tree should be received before first execution context.
    session.send('Runtime.enable'), session.send('Page.createUserWorld', {
      name: UTILITY_WORLD_NAME
    }).catch(_ => {}), // Worlds are per-process
    session.send('Console.enable'), session.send('Network.enable'), this._workers.initializeSession(session)];

    if (this._page.needsRequestInterception()) {
      promises.push(session.send('Network.setInterceptionEnabled', {
        enabled: true
      }));
      promises.push(session.send('Network.addInterception', {
        url: '.*',
        stage: 'request',
        isRegex: true
      }));
    }

    if (this._page._browserContext.isSettingStorageState()) {
      await Promise.all(promises);
      return;
    }

    const contextOptions = this._browserContext._options;
    if (contextOptions.userAgent) promises.push(this.updateUserAgent());

    const emulatedMedia = this._page.emulatedMedia();

    if (emulatedMedia.media || emulatedMedia.colorScheme || emulatedMedia.reducedMotion) promises.push(WKPage._setEmulateMedia(session, emulatedMedia.media, emulatedMedia.colorScheme, emulatedMedia.reducedMotion));

    for (const binding of this._page.allBindings()) promises.push(session.send('Runtime.addBinding', {
      name: binding.name
    }));

    const bootstrapScript = this._calculateBootstrapScript();

    if (bootstrapScript.length) promises.push(session.send('Page.setBootstrapScript', {
      source: bootstrapScript
    }));

    this._page.frames().map(frame => frame.evaluateExpression(bootstrapScript, false, undefined).catch(e => {}));

    if (contextOptions.bypassCSP) promises.push(session.send('Page.setBypassCSP', {
      enabled: true
    }));

    const emulatedSize = this._page.emulatedSize();

    if (emulatedSize) {
      promises.push(session.send('Page.setScreenSizeOverride', {
        width: emulatedSize.screen.width,
        height: emulatedSize.screen.height
      }));
    }

    promises.push(this.updateEmulateMedia());
    promises.push(session.send('Network.setExtraHTTPHeaders', {
      headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false
      /* lowerCase */
      )
    }));
    if (contextOptions.offline) promises.push(session.send('Network.setEmulateOfflineState', {
      offline: true
    }));
    promises.push(session.send('Page.setTouchEmulationEnabled', {
      enabled: !!contextOptions.hasTouch
    }));

    if (contextOptions.timezoneId) {
      promises.push(session.send('Page.setTimeZone', {
        timeZone: contextOptions.timezoneId
      }).catch(e => {
        throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
      }));
    }

    if (this._page.fileChooserIntercepted()) promises.push(session.send('Page.setInterceptFileChooserDialog', {
      enabled: true
    }));
    promises.push(session.send('Page.overrideSetting', {
      setting: 'DeviceOrientationEventEnabled',
      value: contextOptions.isMobile
    }));
    promises.push(session.send('Page.overrideSetting', {
      setting: 'FullScreenEnabled',
      value: !contextOptions.isMobile
    }));
    promises.push(session.send('Page.overrideSetting', {
      setting: 'NotificationsEnabled',
      value: !contextOptions.isMobile
    }));
    promises.push(session.send('Page.overrideSetting', {
      setting: 'PointerLockEnabled',
      value: !contextOptions.isMobile
    }));
    promises.push(session.send('Page.overrideSetting', {
      setting: 'InputTypeMonthEnabled',
      value: contextOptions.isMobile
    }));
    promises.push(session.send('Page.overrideSetting', {
      setting: 'InputTypeWeekEnabled',
      value: contextOptions.isMobile
    }));
    await Promise.all(promises);
  }

  _onDidCommitProvisionalTarget(event) {
    const {
      oldTargetId,
      newTargetId
    } = event;
    (0, _utils.assert)(this._provisionalPage);
    (0, _utils.assert)(this._provisionalPage._session.sessionId === newTargetId, 'Unknown new target: ' + newTargetId);
    (0, _utils.assert)(this._session.sessionId === oldTargetId, 'Unknown old target: ' + oldTargetId);
    const newSession = this._provisionalPage._session;

    this._provisionalPage.commit();

    this._provisionalPage.dispose();

    this._provisionalPage = null;

    this._setSession(newSession);
  }

  _onTargetDestroyed(event) {
    const {
      targetId,
      crashed
    } = event;

    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
      this._provisionalPage._session.dispose(false);

      this._provisionalPage.dispose();

      this._provisionalPage = null;
    } else if (this._session.sessionId === targetId) {
      this._session.dispose(false);

      _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);

      if (crashed) {
        this._session.markAsCrashed();

        this._page._didCrash();
      }
    }
  }

  didClose() {
    this._page._didClose();
  }

  dispose(disconnected) {
    this._pageProxySession.dispose(disconnected);

    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);

    _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);

    if (this._session) this._session.dispose(disconnected);

    if (this._provisionalPage) {
      this._provisionalPage._session.dispose(disconnected);

      this._provisionalPage.dispose();

      this._provisionalPage = null;
    }

    this._page._didDisconnect();

    this._firstNonInitialNavigationCommittedReject(new Error('Page closed'));
  }

  dispatchMessageToSession(message) {
    this._pageProxySession.dispatchMessage(message);
  }

  handleProvisionalLoadFailed(event) {
    if (!this._initializedPage) {
      this._firstNonInitialNavigationCommittedReject(new Error('Initial load failed'));

      return;
    }

    if (!this._provisionalPage) return;
    let errorText = event.error;
    if (errorText.includes('cancelled')) errorText += '; maybe frame was detached?';

    this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
  }

  handleWindowOpen(event) {
    (0, _utils.debugAssert)(!this._nextWindowOpenPopupFeatures);
    this._nextWindowOpenPopupFeatures = event.windowFeatures;
  }

  async pageOrError() {
    return this._pagePromise;
  }

  async _onTargetCreated(event) {
    const {
      targetInfo
    } = event;
    const session = new _wkConnection.WKSession(this._pageProxySession.connection, targetInfo.targetId, `Target closed`, message => {
      this._pageProxySession.send('Target.sendMessageToTarget', {
        message: JSON.stringify(message),
        targetId: targetInfo.targetId
      }).catch(e => {
        session.dispatchMessage({
          id: message.id,
          error: {
            message: e.message
          }
        });
      });
    });
    (0, _utils.assert)(targetInfo.type === 'page', 'Only page targets are expected in WebKit, received: ' + targetInfo.type);

    if (!targetInfo.isProvisional) {
      (0, _utils.assert)(!this._initializedPage);
      let pageOrError;

      try {
        this._setSession(session);

        await Promise.all([this._initializePageProxySession(), this._initializeSession(session, false, ({
          frameTree
        }) => this._handleFrameTree(frameTree))]);
        pageOrError = this._page;
      } catch (e) {
        pageOrError = e;
      }

      if (targetInfo.isPaused) this._pageProxySession.sendMayFail('Target.resume', {
        targetId: targetInfo.targetId
      });

      if (pageOrError instanceof _page.Page && this._page.mainFrame().url() === '') {
        try {
          // Initial empty page has an empty url. We should wait until the first real url has been loaded,
          // even if that url is about:blank. This is especially important for popups, where we need the
          // actual url before interacting with it.
          await this._firstNonInitialNavigationCommittedPromise;
        } catch (e) {
          pageOrError = e;
        }
      } else {
        // Avoid rejection on disconnect.
        this._firstNonInitialNavigationCommittedPromise.catch(() => {});
      }

      await this._page.initOpener(this._opener); // Note: it is important to call |reportAsNew| before resolving pageOrError promise,
      // so that anyone who awaits pageOrError got a ready and reported page.

      this._initializedPage = pageOrError instanceof _page.Page ? pageOrError : null;

      this._page.reportAsNew(pageOrError instanceof _page.Page ? undefined : pageOrError);

      this._pagePromise.resolve(pageOrError);
    } else {
      (0, _utils.assert)(targetInfo.isProvisional);
      (0, _utils.assert)(!this._provisionalPage);
      this._provisionalPage = new _wkProvisionalPage.WKProvisionalPage(session, this);

      if (targetInfo.isPaused) {
        this._provisionalPage.initializationPromise.then(() => {
          this._pageProxySession.sendMayFail('Target.resume', {
            targetId: targetInfo.targetId
          });
        });
      }
    }
  }

  _onDispatchMessageFromTarget(event) {
    const {
      targetId,
      message
    } = event;
    if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) this._provisionalPage._session.dispatchMessage(JSON.parse(message));else if (this._session.sessionId === targetId) this._session.dispatchMessage(JSON.parse(message));else throw new Error('Unknown target: ' + targetId);
  }

  _addSessionListeners() {
    this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameNavigated', event => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.navigatedWithinDocument', event => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameAttached', event => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameDetached', event => this._onFrameDetached(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.willCheckNavigationPolicy', event => this._onWillCheckNavigationPolicy(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.didCheckNavigationPolicy', event => this._onDidCheckNavigationPolicy(event.frameId, event.cancel)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameScheduledNavigation', event => this._onFrameScheduledNavigation(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.frameStoppedLoading', event => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.loadEventFired', event => this._onLifecycleEvent(event.frameId, 'load')), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.domContentEventFired', event => this._onLifecycleEvent(event.frameId, 'domcontentloaded')), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.executionContextCreated', event => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Runtime.bindingCalled', event => this._onBindingCalled(event.contextId, event.argument)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Console.messageAdded', event => this._onConsoleMessage(event)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Console.messageRepeatCountUpdated', event => this._onConsoleRepeatCountUpdated(event)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, 'Dialog.javascriptDialogOpening', event => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Page.fileChooserOpened', event => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.requestWillBeSent', e => this._onRequestWillBeSent(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.requestIntercepted', e => this._onRequestIntercepted(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.responseReceived', e => this._onResponseReceived(e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.loadingFinished', e => this._onLoadingFinished(e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.loadingFailed', e => this._onLoadingFailed(e)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketCreated', e => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketWillSendHandshakeRequest', e => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketHandshakeResponseReceived', e => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketFrameSent', e => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketFrameReceived', e => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketClosed', e => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, 'Network.webSocketFrameError', e => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
  }

  async _updateState(method, params) {
    await this._forAllSessions(session => session.send(method, params).then());
  }

  async _forAllSessions(callback) {
    const sessions = [this._session]; // If the state changes during provisional load, push it to the provisional page
    // as well to always be in sync with the backend.

    if (this._provisionalPage) sessions.push(this._provisionalPage._session);
    await Promise.all(sessions.map(session => callback(session).catch(e => {})));
  }

  _onWillCheckNavigationPolicy(frameId) {
    // It may happen that new policy check occurs while there is an ongoing
    // provisional load, in this case it should be safe to ignore it as it will
    // either:
    // - end up canceled, e.g. ctrl+click opening link in new tab, having no effect
    //   on this page
    // - start new provisional load which we will miss in our signal trackers but
    //   we certainly won't hang waiting for it to finish and there is high chance
    //   that the current provisional page will commit navigation canceling the new
    //   one.
    if (this._provisionalPage) return;

    this._page._frameManager.frameRequestedNavigation(frameId);
  }

  _onDidCheckNavigationPolicy(frameId, cancel) {
    if (!cancel) return; // This is a cross-process navigation that is canceled in the original page and continues in
    // the provisional page. Bail out as we are tracking it.

    if (this._provisionalPage) return;

    this._page._frameManager.frameAbortedNavigation(frameId, 'Navigation canceled by policy check');
  }

  _onFrameScheduledNavigation(frameId) {
    this._page._frameManager.frameRequestedNavigation(frameId);
  }

  _onFrameStoppedLoading(frameId) {
    this._page._frameManager.frameStoppedLoading(frameId);
  }

  _onLifecycleEvent(frameId, event) {
    this._page._frameManager.frameLifecycleEvent(frameId, event);
  }

  _handleFrameTree(frameTree) {
    this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);

    this._onFrameNavigated(frameTree.frame, true);

    this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, 'domcontentloaded');

    this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, 'load');

    if (!frameTree.childFrames) return;

    for (const child of frameTree.childFrames) this._handleFrameTree(child);
  }

  _onFrameAttached(frameId, parentFrameId) {
    return this._page._frameManager.frameAttached(frameId, parentFrameId);
  }

  _onFrameNavigated(framePayload, initial) {
    const frame = this._page._frameManager.frame(framePayload.id);

    (0, _utils.assert)(frame);

    this._removeContextsForFrame(frame, true);

    if (!framePayload.parentId) this._workers.clear();

    this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || '', framePayload.loaderId, initial);

    if (!initial) this._firstNonInitialNavigationCommittedFulfill();
  }

  _onFrameNavigatedWithinDocument(frameId, url) {
    this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
  }

  _onFrameDetached(frameId) {
    this._page._frameManager.frameDetached(frameId);
  }

  _removeContextsForFrame(frame, notifyFrame) {
    for (const [contextId, context] of this._contextIdToContext) {
      if (context.frame === frame) {
        this._contextIdToContext.delete(contextId);

        if (notifyFrame) frame._contextDestroyed(context);
      }
    }
  }

  _onExecutionContextCreated(contextPayload) {
    if (this._contextIdToContext.has(contextPayload.id)) return;

    const frame = this._page._frameManager.frame(contextPayload.frameId);

    if (!frame) return;
    const delegate = new _wkExecutionContext.WKExecutionContext(this._session, contextPayload.id);
    let worldName = null;
    if (contextPayload.type === 'normal') worldName = 'main';else if (contextPayload.type === 'user' && contextPayload.name === UTILITY_WORLD_NAME) worldName = 'utility';
    const context = new dom.FrameExecutionContext(delegate, frame, worldName);
    context[contextDelegateSymbol] = delegate;
    if (worldName) frame._contextCreated(worldName, context);
    if (contextPayload.type === 'normal' && frame === this._page.mainFrame()) this._mainFrameContextId = contextPayload.id;

    this._contextIdToContext.set(contextPayload.id, context);
  }

  async _onBindingCalled(contextId, argument) {
    const pageOrError = await this.pageOrError();

    if (!(pageOrError instanceof Error)) {
      const context = this._contextIdToContext.get(contextId);

      if (context) await this._page._onBindingCalled(argument, context);
    }
  }

  async navigateFrame(frame, url, referrer) {
    if (this._pageProxySession.isDisposed()) throw new Error('Target closed');
    const pageProxyId = this._pageProxySession.sessionId;
    const result = await this._pageProxySession.connection.browserSession.send('Playwright.navigate', {
      url,
      pageProxyId,
      frameId: frame._id,
      referrer
    });
    return {
      newDocumentId: result.loaderId
    };
  }

  _onConsoleMessage(event) {
    // Note: do no introduce await in this function, otherwise we lose the ordering.
    // For example, frame.setContent relies on this.
    const {
      type,
      level,
      text,
      parameters,
      url,
      line: lineNumber,
      column: columnNumber,
      source
    } = event.message;

    if (level === 'error' && source === 'javascript') {
      const {
        name,
        message
      } = (0, _stackTrace.splitErrorMessage)(text);
      let stack;

      if (event.message.stackTrace) {
        stack = text + '\n' + event.message.stackTrace.callFrames.map(callFrame => {
          return `    at ${callFrame.functionName || 'unknown'} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
        }).join('\n');
      } else {
        stack = '';
      }

      const error = new Error(message);
      error.stack = stack;
      error.name = name;

      this._page.firePageError(error);

      return;
    }

    let derivedType = type || '';
    if (type === 'log') derivedType = level;else if (type === 'timing') derivedType = 'timeEnd';
    const handles = [];

    for (const p of parameters || []) {
      let context;

      if (p.objectId) {
        const objectId = JSON.parse(p.objectId);
        context = this._contextIdToContext.get(objectId.injectedScriptId);
      } else {
        context = this._contextIdToContext.get(this._mainFrameContextId);
      }

      if (!context) return;
      handles.push(context.createHandle(p));
    }

    this._lastConsoleMessage = {
      derivedType,
      text,
      handles,
      count: 0,
      location: {
        url: url || '',
        lineNumber: (lineNumber || 1) - 1,
        columnNumber: (columnNumber || 1) - 1
      }
    };

    this._onConsoleRepeatCountUpdated({
      count: 1
    });
  }

  _onConsoleRepeatCountUpdated(event) {
    if (this._lastConsoleMessage) {
      const {
        derivedType,
        text,
        handles,
        count,
        location
      } = this._lastConsoleMessage;

      for (let i = count; i < event.count; ++i) this._page._addConsoleMessage(derivedType, handles, location, handles.length ? undefined : text);

      this._lastConsoleMessage.count = event.count;
    }
  }

  _onDialog(event) {
    this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, async (accept, promptText) => {
      await this._pageProxySession.send('Dialog.handleJavaScriptDialog', {
        accept,
        promptText
      });
    }, event.defaultPrompt));
  }

  async _onFileChooserOpened(event) {
    let handle;

    try {
      const context = await this._page._frameManager.frame(event.frameId)._mainContext();
      handle = context.createHandle(event.element).asElement();
    } catch (e) {
      // During async processing, frame/context may go away. We should not throw.
      return;
    }

    await this._page._onFileChooserOpened(handle);
  }

  static async _setEmulateMedia(session, mediaType, colorScheme, reducedMotion) {
    const promises = [];
    promises.push(session.send('Page.setEmulatedMedia', {
      media: mediaType || ''
    }));
    let appearance = undefined;

    switch (colorScheme) {
      case 'light':
        appearance = 'Light';
        break;

      case 'dark':
        appearance = 'Dark';
        break;
    }

    promises.push(session.send('Page.setForcedAppearance', {
      appearance
    }));
    let reducedMotionWk = undefined;

    switch (reducedMotion) {
      case 'reduce':
        reducedMotionWk = 'Reduce';
        break;

      case 'no-preference':
        reducedMotionWk = 'NoPreference';
        break;
    }

    promises.push(session.send('Page.setForcedReducedMotion', {
      reducedMotion: reducedMotionWk
    }));
    await Promise.all(promises);
  }

  async updateExtraHTTPHeaders() {
    await this._updateState('Network.setExtraHTTPHeaders', {
      headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false
      /* lowerCase */
      )
    });
  }

  _calculateExtraHTTPHeaders() {
    const locale = this._browserContext._options.locale;
    const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._page.extraHTTPHeaders(), locale ? network.singleHeader('Accept-Language', locale) : undefined]);
    return headers;
  }

  async updateEmulateMedia() {
    const emulatedMedia = this._page.emulatedMedia();

    const colorScheme = emulatedMedia.colorScheme;
    const reducedMotion = emulatedMedia.reducedMotion;
    await this._forAllSessions(session => WKPage._setEmulateMedia(session, emulatedMedia.media, colorScheme, reducedMotion));
  }

  async updateEmulatedViewportSize() {
    await this._updateViewport();
  }

  async updateUserAgent() {
    const contextOptions = this._browserContext._options;

    this._updateState('Page.overrideUserAgent', {
      value: contextOptions.userAgent
    });
  }

  async bringToFront() {
    this._pageProxySession.send('Target.activate', {
      targetId: this._session.sessionId
    });
  }

  async _updateViewport() {
    const options = this._browserContext._options;

    const deviceSize = this._page.emulatedSize();

    if (deviceSize === null) return;
    const viewportSize = deviceSize.viewport;
    const screenSize = deviceSize.screen;
    const promises = [this._pageProxySession.send('Emulation.setDeviceMetricsOverride', {
      width: viewportSize.width,
      height: viewportSize.height,
      fixedLayout: !!options.isMobile,
      deviceScaleFactor: options.deviceScaleFactor || 1
    }), this._session.send('Page.setScreenSizeOverride', {
      width: screenSize.width,
      height: screenSize.height
    })];

    if (options.isMobile) {
      const angle = viewportSize.width > viewportSize.height ? 90 : 0;
      promises.push(this._session.send('Page.setOrientationOverride', {
        angle
      }));
    }

    await Promise.all(promises);
  }

  async updateRequestInterception() {
    const enabled = this._page.needsRequestInterception();

    await Promise.all([this._updateState('Network.setInterceptionEnabled', {
      enabled
    }), this._updateState('Network.addInterception', {
      url: '.*',
      stage: 'request',
      isRegex: true
    })]);
  }

  async updateOffline() {
    await this._updateState('Network.setEmulateOfflineState', {
      offline: !!this._browserContext._options.offline
    });
  }

  async updateHttpCredentials() {
    const credentials = this._browserContext._options.httpCredentials || {
      username: '',
      password: ''
    };
    await this._pageProxySession.send('Emulation.setAuthCredentials', {
      username: credentials.username,
      password: credentials.password
    });
  }

  async updateFileChooserInterception() {
    const enabled = this._page.fileChooserIntercepted();

    await this._session.send('Page.setInterceptFileChooserDialog', {
      enabled
    }).catch(() => {}); // target can be closed.
  }

  async reload() {
    await this._session.send('Page.reload');
  }

  goBack() {
    return this._session.send('Page.goBack').then(() => true).catch(error => {
      if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`)) return false;
      throw error;
    });
  }

  goForward() {
    return this._session.send('Page.goForward').then(() => true).catch(error => {
      if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`)) return false;
      throw error;
    });
  }

  async exposeBinding(binding) {
    this._session.send('Runtime.addBinding', {
      name: binding.name
    });

    await this._updateBootstrapScript();
    await Promise.all(this._page.frames().map(frame => frame.evaluateExpression(binding.source, false, {}).catch(e => {})));
  }

  async removeExposedBindings() {
    await this._updateBootstrapScript();
  }

  async addInitScript(script) {
    await this._updateBootstrapScript();
  }

  async removeInitScripts() {
    await this._updateBootstrapScript();
  }

  _calculateBootstrapScript() {
    const scripts = [];

    if (!this._page.context()._options.isMobile) {
      scripts.push('delete window.orientation');
      scripts.push('delete window.ondevicemotion');
      scripts.push('delete window.ondeviceorientation');
    }

    for (const binding of this._page.allBindings()) scripts.push(binding.source);

    scripts.push(...this._browserContext.initScripts);
    scripts.push(...this._page.initScripts);
    return scripts.join(';\n');
  }

  async _updateBootstrapScript() {
    await this._updateState('Page.setBootstrapScript', {
      source: this._calculateBootstrapScript()
    });
  }

  async closePage(runBeforeUnload) {
    await this._stopVideo();
    await this._pageProxySession.sendMayFail('Target.close', {
      targetId: this._session.sessionId,
      runBeforeUnload
    });
  }

  async setBackgroundColor(color) {
    await this._session.send('Page.setDefaultBackgroundColorOverride', {
      color
    });
  }

  _toolbarHeight() {
    var _this$_page$_browserC;

    if ((_this$_page$_browserC = this._page._browserContext._browser) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.options.headful) return _hostPlatform.hostPlatform === 'mac10.15' ? 55 : 59;
    return 0;
  }

  async _startVideo(options) {
    (0, _utils.assert)(!this._recordingVideoFile);
    const {
      screencastId
    } = await this._pageProxySession.send('Screencast.startVideo', {
      file: options.outputFile,
      width: options.width,
      height: options.height,
      toolbarHeight: this._toolbarHeight()
    });
    this._recordingVideoFile = options.outputFile;

    this._browserContext._browser._videoStarted(this._browserContext, screencastId, options.outputFile, this.pageOrError());
  }

  async _stopVideo() {
    if (!this._recordingVideoFile) return;
    await this._pageProxySession.sendMayFail('Screencast.stopVideo');
    this._recordingVideoFile = null;
  }

  async takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {
    const rect = documentRect || viewportRect;
    const result = await this._session.send('Page.snapshotRect', { ...rect,
      coordinateSystem: documentRect ? 'Page' : 'Viewport',
      omitDeviceScaleFactor: scale === 'css'
    });
    const prefix = 'data:image/png;base64,';
    let buffer = Buffer.from(result.dataURL.substr(prefix.length), 'base64');
    if (format === 'jpeg') buffer = _utilsBundle.jpegjs.encode(_utilsBundle.PNG.sync.read(buffer), quality).data;
    return buffer;
  }

  async getContentFrame(handle) {
    const nodeInfo = await this._session.send('DOM.describeNode', {
      objectId: handle._objectId
    });
    if (!nodeInfo.contentFrameId) return null;
    return this._page._frameManager.frame(nodeInfo.contentFrameId);
  }

  async getOwnerFrame(handle) {
    if (!handle._objectId) return null;
    const nodeInfo = await this._session.send('DOM.describeNode', {
      objectId: handle._objectId
    });
    return nodeInfo.ownerFrameId || null;
  }

  isElementHandle(remoteObject) {
    return remoteObject.subtype === 'node';
  }

  async getBoundingBox(handle) {
    const quads = await this.getContentQuads(handle);
    if (!quads || !quads.length) return null;
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;

    for (const quad of quads) {
      for (const point of quad) {
        minX = Math.min(minX, point.x);
        maxX = Math.max(maxX, point.x);
        minY = Math.min(minY, point.y);
        maxY = Math.max(maxY, point.y);
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  }

  async scrollRectIntoViewIfNeeded(handle, rect) {
    return await this._session.send('DOM.scrollIntoViewIfNeeded', {
      objectId: handle._objectId,
      rect
    }).then(() => 'done').catch(e => {
      if (e instanceof Error && e.message.includes('Node does not have a layout object')) return 'error:notvisible';
      if (e instanceof Error && e.message.includes('Node is detached from document')) return 'error:notconnected';
      throw e;
    });
  }

  async setScreencastOptions(options) {
    if (options) {
      const so = { ...options,
        toolbarHeight: this._toolbarHeight()
      };
      const {
        generation
      } = await this._pageProxySession.send('Screencast.startScreencast', so);
      this._screencastGeneration = generation;
    } else {
      await this._pageProxySession.send('Screencast.stopScreencast');
    }
  }

  _onScreencastFrame(event) {
    const generation = this._screencastGeneration;

    this._page.throttleScreencastFrameAck(() => {
      this._pageProxySession.send('Screencast.screencastFrameAck', {
        generation
      }).catch(e => _debugLogger.debugLogger.log('error', e));
    });

    const buffer = Buffer.from(event.data, 'base64');

    this._page.emit(_page.Page.Events.ScreencastFrame, {
      buffer,
      width: event.deviceWidth,
      height: event.deviceHeight
    });
  }

  rafCountForStablePosition() {
    return process.platform === 'win32' ? 5 : 1;
  }

  async getContentQuads(handle) {
    const result = await this._session.sendMayFail('DOM.getContentQuads', {
      objectId: handle._objectId
    });
    if (!result) return null;
    return result.quads.map(quad => [{
      x: quad[0],
      y: quad[1]
    }, {
      x: quad[2],
      y: quad[3]
    }, {
      x: quad[4],
      y: quad[5]
    }, {
      x: quad[6],
      y: quad[7]
    }]);
  }

  async setInputFiles(handle, files) {
    const objectId = handle._objectId;
    const protocolFiles = files.map(file => ({
      name: file.name,
      type: file.mimeType,
      data: file.buffer
    }));
    await this._session.send('DOM.setInputFiles', {
      objectId,
      files: protocolFiles
    });
  }

  async setInputFilePaths(handle, paths) {
    const pageProxyId = this._pageProxySession.sessionId;
    const objectId = handle._objectId;
    await Promise.all([this._pageProxySession.connection.browserSession.send('Playwright.grantFileReadAccess', {
      pageProxyId,
      paths
    }), this._session.send('DOM.setInputFiles', {
      objectId,
      paths
    })]);
  }

  async adoptElementHandle(handle, to) {
    const result = await this._session.sendMayFail('DOM.resolveNode', {
      objectId: handle._objectId,
      executionContextId: to[contextDelegateSymbol]._contextId
    });
    if (!result || result.object.subtype === 'null') throw new Error(dom.kUnableToAdoptErrorMessage);
    return to.createHandle(result.object);
  }

  async getAccessibilityTree(needle) {
    return (0, _wkAccessibility.getAccessibilityTree)(this._session, needle);
  }

  async inputActionEpilogue() {}

  async getFrameElement(frame) {
    const parent = frame.parentFrame();
    if (!parent) throw new Error('Frame has been detached.');

    const info = this._page.parseSelector('frame,iframe');

    const handles = await this._page.selectors._queryAll(parent, info);
    const items = await Promise.all(handles.map(async handle => {
      const frame = await handle.contentFrame().catch(e => null);
      return {
        handle,
        frame
      };
    }));
    const result = items.find(item => item.frame === frame);
    items.map(item => item === result ? Promise.resolve() : item.handle.dispose());
    if (!result) throw new Error('Frame has been detached.');
    return result.handle;
  }

  _onRequestWillBeSent(session, event) {
    if (event.request.url.startsWith('data:')) return;
    let redirectedFrom = null;

    if (event.redirectResponse) {
      const request = this._requestIdToRequest.get(event.requestId); // If we connect late to the target, we could have missed the requestWillBeSent event.


      if (request) {
        this._handleRequestRedirect(request, event.redirectResponse, event.timestamp);

        redirectedFrom = request;
      }
    }

    const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId); // sometimes we get stray network events for detached frames
    // TODO(einbinder) why?

    if (!frame) return; // TODO(einbinder) this will fail if we are an XHR document request

    const isNavigationRequest = event.type === 'Document';
    const documentId = isNavigationRequest ? event.loaderId : undefined;
    let route = null; // We do not support intercepting redirects.

    if (this._page.needsRequestInterception() && !redirectedFrom) route = new _wkInterceptableRequest.WKRouteImpl(session, event.requestId);
    const request = new _wkInterceptableRequest.WKInterceptableRequest(session, route, frame, event, redirectedFrom, documentId);

    this._requestIdToRequest.set(event.requestId, request);

    this._page._frameManager.requestStarted(request.request, route || undefined);
  }

  _handleRequestRedirect(request, responsePayload, timestamp) {
    const response = request.createResponse(responsePayload);

    response._securityDetailsFinished();

    response._serverAddrFinished();

    response.setResponseHeadersSize(null);
    response.setEncodedBodySize(null);

    response._requestFinished(responsePayload.timing ? _helper.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1);

    this._requestIdToRequest.delete(request._requestId);

    this._page._frameManager.requestReceivedResponse(response);

    this._page._frameManager.reportRequestFinished(request.request, response);
  }

  _onRequestIntercepted(session, event) {
    const request = this._requestIdToRequest.get(event.requestId);

    if (!request) {
      session.sendMayFail('Network.interceptRequestWithError', {
        errorType: 'Cancellation',
        requestId: event.requestId
      });
      return;
    } // There is no point in waiting for the raw headers in Network.responseReceived when intercepting.
    // Use provisional headers as raw headers, so that client can call allHeaders() from the route handler.


    request.request.setRawRequestHeaders(null);

    if (!request._route) {
      // Intercepted, although we do not intend to allow interception.
      // Just continue.
      session.sendMayFail('Network.interceptWithRequest', {
        requestId: request._requestId
      });
    } else {
      request._route._requestInterceptedPromise.resolve();
    }
  }

  _onResponseReceived(event) {
    const request = this._requestIdToRequest.get(event.requestId); // FileUpload sends a response without a matching request.


    if (!request) return;

    this._requestIdToResponseReceivedPayloadEvent.set(request._requestId, event);

    const response = request.createResponse(event.response);

    this._page._frameManager.requestReceivedResponse(response);

    if (response.status() === 204) {
      this._onLoadingFailed({
        requestId: event.requestId,
        errorText: 'Aborted: 204 No Content',
        timestamp: event.timestamp
      });
    }
  }

  _onLoadingFinished(event) {
    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.
    // @see https://crbug.com/750469


    if (!request) return; // Under certain conditions we never get the Network.responseReceived
    // event from protocol. @see https://crbug.com/883475

    const response = request.request._existingResponse();

    if (response) {
      var _event$metrics, _event$metrics2, _event$metrics2$secur, _responseReceivedPayl, _responseReceivedPayl2, _responseReceivedPayl3, _responseReceivedPayl4, _responseReceivedPayl5, _responseReceivedPayl6, _event$metrics3, _event$metrics$respon, _event$metrics4, _event$metrics$respon2, _event$metrics5;

      const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(request._requestId);

      response._serverAddrFinished(parseRemoteAddress(event === null || event === void 0 ? void 0 : (_event$metrics = event.metrics) === null || _event$metrics === void 0 ? void 0 : _event$metrics.remoteAddress));

      response._securityDetailsFinished({
        protocol: isLoadedSecurely(response.url(), response.timing()) ? (_event$metrics2 = event.metrics) === null || _event$metrics2 === void 0 ? void 0 : (_event$metrics2$secur = _event$metrics2.securityConnection) === null || _event$metrics2$secur === void 0 ? void 0 : _event$metrics2$secur.protocol : undefined,
        subjectName: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl = responseReceivedPayload.response.security) === null || _responseReceivedPayl === void 0 ? void 0 : (_responseReceivedPayl2 = _responseReceivedPayl.certificate) === null || _responseReceivedPayl2 === void 0 ? void 0 : _responseReceivedPayl2.subject,
        validFrom: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl3 = responseReceivedPayload.response.security) === null || _responseReceivedPayl3 === void 0 ? void 0 : (_responseReceivedPayl4 = _responseReceivedPayl3.certificate) === null || _responseReceivedPayl4 === void 0 ? void 0 : _responseReceivedPayl4.validFrom,
        validTo: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl5 = responseReceivedPayload.response.security) === null || _responseReceivedPayl5 === void 0 ? void 0 : (_responseReceivedPayl6 = _responseReceivedPayl5.certificate) === null || _responseReceivedPayl6 === void 0 ? void 0 : _responseReceivedPayl6.validUntil
      });

      if ((_event$metrics3 = event.metrics) !== null && _event$metrics3 !== void 0 && _event$metrics3.protocol) response._setHttpVersion(event.metrics.protocol);
      response.setEncodedBodySize((_event$metrics$respon = (_event$metrics4 = event.metrics) === null || _event$metrics4 === void 0 ? void 0 : _event$metrics4.responseBodyBytesReceived) !== null && _event$metrics$respon !== void 0 ? _event$metrics$respon : null);
      response.setResponseHeadersSize((_event$metrics$respon2 = (_event$metrics5 = event.metrics) === null || _event$metrics5 === void 0 ? void 0 : _event$metrics5.responseHeaderBytesReceived) !== null && _event$metrics$respon2 !== void 0 ? _event$metrics$respon2 : null);

      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
    } else {
      // Use provisional headers if we didn't have the response with raw headers.
      request.request.setRawRequestHeaders(null);
    }

    this._requestIdToResponseReceivedPayloadEvent.delete(request._requestId);

    this._requestIdToRequest.delete(request._requestId);

    this._page._frameManager.reportRequestFinished(request.request, response);
  }

  _onLoadingFailed(event) {
    const request = this._requestIdToRequest.get(event.requestId); // For certain requestIds we never receive requestWillBeSent event.
    // @see https://crbug.com/750469


    if (!request) return;

    const response = request.request._existingResponse();

    if (response) {
      response._serverAddrFinished();

      response._securityDetailsFinished();

      response.setResponseHeadersSize(null);
      response.setEncodedBodySize(null);

      response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
    } else {
      // Use provisional headers if we didn't have the response with raw headers.
      request.request.setRawRequestHeaders(null);
    }

    this._requestIdToRequest.delete(request._requestId);

    request.request._setFailureText(event.errorText);

    this._page._frameManager.requestFailed(request.request, event.errorText.includes('cancelled'));
  }

  async _grantPermissions(origin, permissions) {
    const webPermissionToProtocol = new Map([['geolocation', 'geolocation']]);
    const filtered = permissions.map(permission => {
      const protocolPermission = webPermissionToProtocol.get(permission);
      if (!protocolPermission) throw new Error('Unknown permission: ' + permission);
      return protocolPermission;
    });
    await this._pageProxySession.send('Emulation.grantPermissions', {
      origin,
      permissions: filtered
    });
  }

  async _clearPermissions() {
    await this._pageProxySession.send('Emulation.resetPermissions', {});
  }

}
/**
 * WebKit Remote Addresses look like:
 *
 * macOS:
 * ::1.8911
 * 2606:2800:220:1:248:1893:25c8:1946.443
 * 127.0.0.1:8000
 *
 * ubuntu:
 * ::1:8907
 * 127.0.0.1:8000
 *
 * NB: They look IPv4 and IPv6's with ports but use an alternative notation.
 */


exports.WKPage = WKPage;

function parseRemoteAddress(value) {
  if (!value) return;

  try {
    const colon = value.lastIndexOf(':');
    const dot = value.lastIndexOf('.');

    if (dot < 0) {
      // IPv6ish:port
      return {
        ipAddress: `[${value.slice(0, colon)}]`,
        port: +value.slice(colon + 1)
      };
    }

    if (colon > dot) {
      // IPv4:port
      const [address, port] = value.split(':');
      return {
        ipAddress: address,
        port: +port
      };
    } else {
      // IPv6ish.port
      const [address, port] = value.split('.');
      return {
        ipAddress: `[${address}]`,
        port: +port
      };
    }
  } catch (_) {}
}
/**
 * Adapted from Source/WebInspectorUI/UserInterface/Models/Resource.js in
 * WebKit codebase.
 */


function isLoadedSecurely(url, timing) {
  try {
    const u = new URL(url);
    if (u.protocol !== 'https:' && u.protocol !== 'wss:' && u.protocol !== 'sftp:') return false;
    if (timing.secureConnectionStart === -1 && timing.connectStart !== -1) return false;
    return true;
  } catch (_) {}
}

const contextDelegateSymbol = Symbol('delegate');

/***/ }),

/***/ 1516:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKProvisionalPage = void 0;

var _eventsHelper = __nccwpck_require__(3841);

var _utils = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WKProvisionalPage {
  constructor(session, page) {
    this._session = void 0;
    this._wkPage = void 0;
    this._sessionListeners = [];
    this._mainFrameId = null;
    this.initializationPromise = void 0;
    this._session = session;
    this._wkPage = page;

    const overrideFrameId = handler => {
      return payload => {
        // Pretend that the events happened in the same process.
        if (payload.frameId) payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
        handler(payload);
      };
    };

    const wkPage = this._wkPage;
    this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Network.requestWillBeSent', overrideFrameId(e => wkPage._onRequestWillBeSent(session, e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.requestIntercepted', overrideFrameId(e => wkPage._onRequestIntercepted(session, e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.responseReceived', overrideFrameId(e => wkPage._onResponseReceived(e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFinished', overrideFrameId(e => wkPage._onLoadingFinished(e))), _eventsHelper.eventsHelper.addEventListener(session, 'Network.loadingFailed', overrideFrameId(e => wkPage._onLoadingFailed(e)))];
    this.initializationPromise = this._wkPage._initializeSession(session, true, ({
      frameTree
    }) => this._handleFrameTree(frameTree));
  }

  dispose() {
    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
  }

  commit() {
    (0, _utils.assert)(this._mainFrameId);

    this._wkPage._onFrameAttached(this._mainFrameId, null);
  }

  _handleFrameTree(frameTree) {
    (0, _utils.assert)(!frameTree.frame.parentId);
    this._mainFrameId = frameTree.frame.id;
  }

}

exports.WKProvisionalPage = WKProvisionalPage;

/***/ }),

/***/ 3471:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WKWorkers = void 0;

var _eventsHelper = __nccwpck_require__(3841);

var _page = __nccwpck_require__(3555);

var _wkConnection = __nccwpck_require__(281);

var _wkExecutionContext = __nccwpck_require__(2559);

/**
 * Copyright 2019 Microsoft Corporation All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WKWorkers {
  constructor(page) {
    this._sessionListeners = [];
    this._page = void 0;
    this._workerSessions = new Map();
    this._page = page;
  }

  setSession(session) {
    _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);

    this.clear();
    this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, 'Worker.workerCreated', event => {
      const worker = new _page.Worker(this._page, event.url);
      const workerSession = new _wkConnection.WKSession(session.connection, event.workerId, 'Most likely the worker has been closed.', message => {
        session.send('Worker.sendMessageToWorker', {
          workerId: event.workerId,
          message: JSON.stringify(message)
        }).catch(e => {
          workerSession.dispatchMessage({
            id: message.id,
            error: {
              message: e.message
            }
          });
        });
      });

      this._workerSessions.set(event.workerId, workerSession);

      worker._createExecutionContext(new _wkExecutionContext.WKExecutionContext(workerSession, undefined));

      this._page._addWorker(event.workerId, worker);

      workerSession.on('Console.messageAdded', event => this._onConsoleMessage(worker, event));
      Promise.all([workerSession.send('Runtime.enable'), workerSession.send('Console.enable'), session.send('Worker.initialized', {
        workerId: event.workerId
      })]).catch(e => {
        // Worker can go as we are initializing it.
        this._page._removeWorker(event.workerId);
      });
    }), _eventsHelper.eventsHelper.addEventListener(session, 'Worker.dispatchMessageFromWorker', event => {
      const workerSession = this._workerSessions.get(event.workerId);

      if (!workerSession) return;
      workerSession.dispatchMessage(JSON.parse(event.message));
    }), _eventsHelper.eventsHelper.addEventListener(session, 'Worker.workerTerminated', event => {
      const workerSession = this._workerSessions.get(event.workerId);

      if (!workerSession) return;
      workerSession.dispose(false);

      this._workerSessions.delete(event.workerId);

      this._page._removeWorker(event.workerId);
    })];
  }

  clear() {
    this._page._clearWorkers();

    this._workerSessions.clear();
  }

  async initializeSession(session) {
    await session.send('Worker.enable');
  }

  async _onConsoleMessage(worker, event) {
    const {
      type,
      level,
      text,
      parameters,
      url,
      line: lineNumber,
      column: columnNumber
    } = event.message;
    let derivedType = type || '';
    if (type === 'log') derivedType = level;else if (type === 'timing') derivedType = 'timeEnd';
    const handles = (parameters || []).map(p => {
      return worker._existingExecutionContext.createHandle(p);
    });
    const location = {
      url: url || '',
      lineNumber: (lineNumber || 1) - 1,
      columnNumber: (columnNumber || 1) - 1
    };

    this._page._addConsoleMessage(derivedType, handles, location, handles.length ? undefined : text);
  }

}

exports.WKWorkers = WKWorkers;

/***/ }),

/***/ 2371:
/***/ ((module) => {

/**
 * Diff Match and Patch
 * Copyright 2018 The diff-match-patch Authors.
 * https://github.com/google/diff-match-patch
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
var diff_match_patch = function() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
};


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/**
 * Class representing one diff tuple.
 * Attempts to look like a two-element array (which is what this used to be).
 * @param {number} op Operation, one of: DIFF_DELETE, DIFF_INSERT, DIFF_EQUAL.
 * @param {string} text Text to be deleted, inserted, or retained.
 * @constructor
 */
diff_match_patch.Diff = function(op, text) {
  this[0] = op;
  this[1] = text;
};

diff_match_patch.Diff.prototype.length = 2;

/**
 * Emulate the output of a two-element array.
 * @return {string} Diff operation as a string.
 */
diff_match_patch.Diff.prototype.toString = function() {
  return this[0] + ',' + this[1];
};


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number=} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
  }
  if (commonsuffix) {
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
             new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
             new diff_match_patch.Diff(DIFF_INSERT,
                 longtext.substring(i + shorttext.length))];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [new diff_match_patch.Diff(DIFF_DELETE, text1),
            new diff_match_patch.Diff(DIFF_INSERT, text2)];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)],
                          diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var subDiff =
              this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = subDiff.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, subDiff[j]);
          }
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength == maxLines) {
          // Bail out at 65535 because
          // String.fromCharCode(65536) == String.fromCharCode(0)
          line = text.substring(lineStart);
          lineEnd = text.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  // Allocate 2/3rds of the space for text1, the rest for text2.
  var maxLines = 40000;
  var chars1 = diff_linesToCharsMunge_(text1);
  maxLines = 65535;
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var i = 0; i < diffs.length; i++) {
    var chars = diffs[i][1];
    var text = [];
    for (var j = 0; j < chars.length; j++) {
      text[j] = lineArray[chars.charCodeAt(j)];
    }
    diffs[i][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: https://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: https://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastEquality && (lastEquality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastEquality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL,
              deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastEquality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastEquality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastEquality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastEquality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  // Add a dummy entry at the end.
  diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ''));
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL,
                    text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0,
                new diff_match_patch.Diff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] =
              new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
        } else {
          diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  if (patch.start2 === null) {
    throw Error('patch not initialized');
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>=} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // https://github.com/google/diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] =
          new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indices are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};

module.exports = { diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL };


/***/ }),

/***/ 8950:
/***/ ((module) => {

"use strict";
/**
 * 
 * ISC License
 *
 * Copyright (c) 2019, Mapbox

 * Permission to use, copy, modify, and/or distribute this software for any purpose
 * with or without fee is hereby granted, provided that the above copyright notice
 * and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
 * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
 * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
 * THIS SOFTWARE.
 */



module.exports = pixelmatch;

const defaultOptions = {
    threshold: 0.1,         // matching threshold (0 to 1); smaller is more sensitive
    includeAA: false,       // whether to skip anti-aliasing detection
    alpha: 0.1,             // opacity of original image in diff output
    aaColor: [255, 255, 0], // color of anti-aliased pixels in diff output
    diffColor: [255, 0, 0], // color of different pixels in diff output
    diffColorAlt: null,     // whether to detect dark on light differences between img1 and img2 and set an alternative color to differentiate between the two
    diffMask: false         // draw the diff over a transparent background (a mask)
};

function pixelmatch(img1, img2, output, width, height, options) {

    if (!isPixelData(img1) || !isPixelData(img2) || (output && !isPixelData(output)))
        throw new Error('Image data: Uint8Array, Uint8ClampedArray or Buffer expected.');

    if (img1.length !== img2.length || (output && output.length !== img1.length))
        throw new Error('Image sizes do not match.');

    if (img1.length !== width * height * 4) throw new Error('Image data size does not match width/height.');

    options = Object.assign({}, defaultOptions, options);

    // check if images are identical
    const len = width * height;
    const a32 = new Uint32Array(img1.buffer, img1.byteOffset, len);
    const b32 = new Uint32Array(img2.buffer, img2.byteOffset, len);
    let identical = true;

    for (let i = 0; i < len; i++) {
        if (a32[i] !== b32[i]) { identical = false; break; }
    }
    if (identical) { // fast path if identical
        if (output && !options.diffMask) {
            for (let i = 0; i < len; i++) drawGrayPixel(img1, 4 * i, options.alpha, output);
        }
        return 0;
    }

    // maximum acceptable square distance between two colors;
    // 35215 is the maximum possible value for the YIQ difference metric
    const maxDelta = 35215 * options.threshold * options.threshold;
    let diff = 0;

    // compare each pixel of one image against the other one
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {

            const pos = (y * width + x) * 4;

            // squared YUV distance between colors at this pixel position, negative if the img2 pixel is darker
            const delta = colorDelta(img1, img2, pos, pos);

            // the color difference is above the threshold
            if (Math.abs(delta) > maxDelta) {
                // check it's a real rendering difference or just anti-aliasing
                if (!options.includeAA && (antialiased(img1, x, y, width, height, img2) ||
                                           antialiased(img2, x, y, width, height, img1))) {
                    // one of the pixels is anti-aliasing; draw as yellow and do not count as difference
                    // note that we do not include such pixels in a mask
                    if (output && !options.diffMask) drawPixel(output, pos, ...options.aaColor);

                } else {
                    // found substantial difference not caused by anti-aliasing; draw it as such
                    if (output) {
                        drawPixel(output, pos, ...(delta < 0 && options.diffColorAlt || options.diffColor));
                    }
                    diff++;
                }

            } else if (output) {
                // pixels are similar; draw background as grayscale image blended with white
                if (!options.diffMask) drawGrayPixel(img1, pos, options.alpha, output);
            }
        }
    }

    // return the number of different pixels
    return diff;
}

function isPixelData(arr) {
    // work around instanceof Uint8Array not working properly in some Jest environments
    return ArrayBuffer.isView(arr) && arr.constructor.BYTES_PER_ELEMENT === 1;
}

// check if a pixel is likely a part of anti-aliasing;
// based on "Anti-aliased Pixel and Intensity Slope Detector" paper by V. Vysniauskas, 2009

function antialiased(img, x1, y1, width, height, img2) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;
    let min = 0;
    let max = 0;
    let minX, minY, maxX, maxY;

    // go through 8 adjacent pixels
    for (let x = x0; x <= x2; x++) {
        for (let y = y0; y <= y2; y++) {
            if (x === x1 && y === y1) continue;

            // brightness delta between the center pixel and adjacent one
            const delta = colorDelta(img, img, pos, (y * width + x) * 4, true);

            // count the number of equal, darker and brighter adjacent pixels
            if (delta === 0) {
                zeroes++;
                // if found more than 2 equal siblings, it's definitely not anti-aliasing
                if (zeroes > 2) return false;

            // remember the darkest pixel
            } else if (delta < min) {
                min = delta;
                minX = x;
                minY = y;

            // remember the brightest pixel
            } else if (delta > max) {
                max = delta;
                maxX = x;
                maxY = y;
            }
        }
    }

    // if there are no both darker and brighter pixels among siblings, it's not anti-aliasing
    if (min === 0 || max === 0) return false;

    // if either the darkest or the brightest pixel has 3+ equal siblings in both images
    // (definitely not anti-aliased), this pixel is anti-aliased
    return (hasManySiblings(img, minX, minY, width, height) && hasManySiblings(img2, minX, minY, width, height)) ||
           (hasManySiblings(img, maxX, maxY, width, height) && hasManySiblings(img2, maxX, maxY, width, height));
}

// check if a pixel has 3+ adjacent pixels of the same color.
function hasManySiblings(img, x1, y1, width, height) {
    const x0 = Math.max(x1 - 1, 0);
    const y0 = Math.max(y1 - 1, 0);
    const x2 = Math.min(x1 + 1, width - 1);
    const y2 = Math.min(y1 + 1, height - 1);
    const pos = (y1 * width + x1) * 4;
    let zeroes = x1 === x0 || x1 === x2 || y1 === y0 || y1 === y2 ? 1 : 0;

    // go through 8 adjacent pixels
    for (let x = x0; x <= x2; x++) {
        for (let y = y0; y <= y2; y++) {
            if (x === x1 && y === y1) continue;

            const pos2 = (y * width + x) * 4;
            if (img[pos] === img[pos2] &&
                img[pos + 1] === img[pos2 + 1] &&
                img[pos + 2] === img[pos2 + 2] &&
                img[pos + 3] === img[pos2 + 3]) zeroes++;

            if (zeroes > 2) return true;
        }
    }

    return false;
}

// calculate color difference according to the paper "Measuring perceived color difference
// using YIQ NTSC transmission color space in mobile applications" by Y. Kotsarenko and F. Ramos

function colorDelta(img1, img2, k, m, yOnly) {
    let r1 = img1[k + 0];
    let g1 = img1[k + 1];
    let b1 = img1[k + 2];
    let a1 = img1[k + 3];

    let r2 = img2[m + 0];
    let g2 = img2[m + 1];
    let b2 = img2[m + 2];
    let a2 = img2[m + 3];

    if (a1 === a2 && r1 === r2 && g1 === g2 && b1 === b2) return 0;

    if (a1 < 255) {
        a1 /= 255;
        r1 = blend(r1, a1);
        g1 = blend(g1, a1);
        b1 = blend(b1, a1);
    }

    if (a2 < 255) {
        a2 /= 255;
        r2 = blend(r2, a2);
        g2 = blend(g2, a2);
        b2 = blend(b2, a2);
    }

    const y1 = rgb2y(r1, g1, b1);
    const y2 = rgb2y(r2, g2, b2);
    const y = y1 - y2;

    if (yOnly) return y; // brightness difference only

    const i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2);
    const q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);

    const delta = 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;

    // encode whether the pixel lightens or darkens in the sign
    return y1 > y2 ? -delta : delta;
}

function rgb2y(r, g, b) { return r * 0.29889531 + g * 0.58662247 + b * 0.11448223; }
function rgb2i(r, g, b) { return r * 0.59597799 - g * 0.27417610 - b * 0.32180189; }
function rgb2q(r, g, b) { return r * 0.21147017 - g * 0.52261711 + b * 0.31114694; }

// blend semi-transparent color with white
function blend(c, a) {
    return 255 + (c - 255) * a;
}

function drawPixel(output, pos, r, g, b) {
    output[pos + 0] = r;
    output[pos + 1] = g;
    output[pos + 2] = b;
    output[pos + 3] = 255;
}

function drawGrayPixel(img, i, alpha, output) {
    const r = img[i + 0];
    const g = img[i + 1];
    const b = img[i + 2];
    const val = blend(rgb2y(r, g, b), alpha * img[i + 3] / 255);
    drawPixel(output, i, val, val, val);
}


/***/ }),

/***/ 9509:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getComparator = getComparator;

var _utilsBundle = __nccwpck_require__(1319);

var _pixelmatch = _interopRequireDefault(__nccwpck_require__(8950));

var _diff_match_patch = __nccwpck_require__(2371);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getComparator(mimeType) {
  if (mimeType === 'image/png') return compareImages.bind(null, 'image/png');
  if (mimeType === 'image/jpeg') return compareImages.bind(null, 'image/jpeg');
  if (mimeType === 'text/plain') return compareText;
  return compareBuffersOrStrings;
}

const JPEG_JS_MAX_BUFFER_SIZE_IN_MB = 5 * 1024; // ~5 GB

function compareBuffersOrStrings(actualBuffer, expectedBuffer) {
  if (typeof actualBuffer === 'string') return compareText(actualBuffer, expectedBuffer);
  if (!actualBuffer || !(actualBuffer instanceof Buffer)) return {
    errorMessage: 'Actual result should be a Buffer or a string.'
  };
  if (Buffer.compare(actualBuffer, expectedBuffer)) return {
    errorMessage: 'Buffers differ'
  };
  return null;
}

function compareImages(mimeType, actualBuffer, expectedBuffer, options = {}) {
  var _options$threshold, _ref;

  if (!actualBuffer || !(actualBuffer instanceof Buffer)) return {
    errorMessage: 'Actual result should be a Buffer.'
  };
  const actual = mimeType === 'image/png' ? _utilsBundle.PNG.sync.read(actualBuffer) : _utilsBundle.jpegjs.decode(actualBuffer, {
    maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB
  });
  const expected = mimeType === 'image/png' ? _utilsBundle.PNG.sync.read(expectedBuffer) : _utilsBundle.jpegjs.decode(expectedBuffer, {
    maxMemoryUsageInMB: JPEG_JS_MAX_BUFFER_SIZE_IN_MB
  });

  if (expected.width !== actual.width || expected.height !== actual.height) {
    return {
      errorMessage: `Expected an image ${expected.width}px by ${expected.height}px, received ${actual.width}px by ${actual.height}px. `
    };
  }

  const diff = new _utilsBundle.PNG({
    width: expected.width,
    height: expected.height
  });
  const count = (0, _pixelmatch.default)(expected.data, actual.data, diff.data, expected.width, expected.height, {
    threshold: (_options$threshold = options.threshold) !== null && _options$threshold !== void 0 ? _options$threshold : 0.2
  });
  const maxDiffPixels1 = options.maxDiffPixels;
  const maxDiffPixels2 = options.maxDiffPixelRatio !== undefined ? expected.width * expected.height * options.maxDiffPixelRatio : undefined;
  let maxDiffPixels;
  if (maxDiffPixels1 !== undefined && maxDiffPixels2 !== undefined) maxDiffPixels = Math.min(maxDiffPixels1, maxDiffPixels2);else maxDiffPixels = (_ref = maxDiffPixels1 !== null && maxDiffPixels1 !== void 0 ? maxDiffPixels1 : maxDiffPixels2) !== null && _ref !== void 0 ? _ref : 0;
  const ratio = Math.ceil(count / (expected.width * expected.height) * 100) / 100;
  return count > maxDiffPixels ? {
    errorMessage: `${count} pixels (ratio ${ratio.toFixed(2)} of all image pixels) are different`,
    diff: _utilsBundle.PNG.sync.write(diff)
  } : null;
}

function compareText(actual, expectedBuffer) {
  if (typeof actual !== 'string') return {
    errorMessage: 'Actual result should be a string'
  };
  const expected = expectedBuffer.toString('utf-8');
  if (expected === actual) return null;
  const dmp = new _diff_match_patch.diff_match_patch();
  const d = dmp.diff_main(expected, actual);
  dmp.diff_cleanupSemantic(d);
  return {
    errorMessage: diff_prettyTerminal(d)
  };
}

function diff_prettyTerminal(diffs) {
  const html = [];

  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0]; // Operation (insert, delete, equal)

    const data = diffs[x][1]; // Text of change.

    const text = data;

    switch (op) {
      case _diff_match_patch.DIFF_INSERT:
        html[x] = _utilsBundle.colors.green(text);
        break;

      case _diff_match_patch.DIFF_DELETE:
        html[x] = _utilsBundle.colors.reset(_utilsBundle.colors.strikethrough(_utilsBundle.colors.red(text)));
        break;

      case _diff_match_patch.DIFF_EQUAL:
        html[x] = text;
        break;
    }
  }

  return html.join('');
}

/***/ }),

/***/ 3841:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.eventsHelper = void 0;

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EventsHelper {
  static addEventListener(emitter, eventName, handler) {
    emitter.on(eventName, handler);
    return {
      emitter,
      eventName,
      handler
    };
  }

  static removeEventListeners(listeners) {
    for (const listener of listeners) listener.emitter.removeListener(listener.eventName, listener.handler);

    listeners.splice(0, listeners.length);
  }

}

const eventsHelper = EventsHelper;
exports.eventsHelper = eventsHelper;

/***/ }),

/***/ 6034:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.canAccessFile = canAccessFile;
exports.existsAsync = void 0;
exports.mkdirIfNeeded = mkdirIfNeeded;
exports.removeFolders = removeFolders;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _utilsBundle = __nccwpck_require__(1319);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const existsAsync = path => new Promise(resolve => _fs.default.stat(path, err => resolve(!err)));

exports.existsAsync = existsAsync;

async function mkdirIfNeeded(filePath) {
  // This will harmlessly throw on windows if the dirname is the root directory.
  await _fs.default.promises.mkdir(_path.default.dirname(filePath), {
    recursive: true
  }).catch(() => {});
}

async function removeFolders(dirs) {
  return await Promise.all(dirs.map(dir => {
    return new Promise(fulfill => {
      (0, _utilsBundle.rimraf)(dir, {
        maxBusyTries: 10
      }, error => {
        fulfill(error !== null && error !== void 0 ? error : undefined);
      });
    });
  }));
}

function canAccessFile(file) {
  if (!file) return false;

  try {
    _fs.default.accessSync(file);

    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ 5228:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hostPlatform = void 0;

var _os = _interopRequireDefault(__nccwpck_require__(2037));

var _linuxUtils = __nccwpck_require__(1665);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hostPlatform = (() => {
  const platform = _os.default.platform();

  if (platform === 'darwin') {
    const ver = _os.default.release().split('.').map(a => parseInt(a, 10));

    let macVersion = '';

    if (ver[0] < 18) {
      // Everything before 10.14 is considered 10.13.
      macVersion = 'mac10.13';
    } else if (ver[0] === 18) {
      macVersion = 'mac10.14';
    } else if (ver[0] === 19) {
      macVersion = 'mac10.15';
    } else {
      // ver[0] >= 20
      const LAST_STABLE_MAC_MAJOR_VERSION = 12; // Best-effort support for MacOS beta versions.

      macVersion = 'mac' + Math.min(ver[0] - 9, LAST_STABLE_MAC_MAJOR_VERSION); // BigSur is the first version that might run on Apple Silicon.

      if (_os.default.cpus().some(cpu => cpu.model.includes('Apple'))) macVersion += '-arm64';
    }

    return macVersion;
  }

  if (platform === 'linux') {
    const archSuffix = _os.default.arch() === 'arm64' ? '-arm64' : '';
    const distroInfo = (0, _linuxUtils.getLinuxDistributionInfoSync)(); // Pop!_OS is ubuntu-based and has the same versions.

    if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'ubuntu' || (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'pop') {
      if (parseInt(distroInfo.version, 10) <= 19) return 'ubuntu18.04' + archSuffix;
      if (parseInt(distroInfo.version, 10) <= 21) return 'ubuntu20.04' + archSuffix;
      return 'ubuntu22.04' + archSuffix;
    }

    if ((distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.id) === 'debian' && (distroInfo === null || distroInfo === void 0 ? void 0 : distroInfo.version) === '11' && !archSuffix) return 'debian11';
    return 'generic-linux' + archSuffix;
  }

  if (platform === 'win32') return 'win64';
  return '<unknown>';
})();

exports.hostPlatform = hostPlatform;

/***/ }),

/***/ 3557:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.arrayToObject = arrayToObject;
exports.assert = assert;
exports.calculateSha1 = calculateSha1;
exports.constructURLBasedOnBaseURL = constructURLBasedOnBaseURL;
exports.createGuid = createGuid;
exports.debugAssert = debugAssert;
exports.debugMode = debugMode;
exports.deepCopy = deepCopy;
exports.getAsBooleanFromENV = getAsBooleanFromENV;
exports.getFromENV = getFromENV;
exports.headersArrayToObject = headersArrayToObject;
exports.headersObjectToArray = headersObjectToArray;
exports.isError = isError;
exports.isFilePayload = isFilePayload;
exports.isLikelyNpxGlobal = void 0;
exports.isObject = isObject;
exports.isRegExp = isRegExp;
exports.isString = isString;
exports.isUnderTest = isUnderTest;
exports.makeWaitForNextTask = makeWaitForNextTask;
exports.monotonicTime = monotonicTime;
exports.objectToArray = objectToArray;
exports.setUnderTest = setUnderTest;
exports.streamToString = streamToString;
exports.wrapInASCIIBox = wrapInASCIIBox;

var crypto = _interopRequireWildcard(__nccwpck_require__(6113));

var URL = _interopRequireWildcard(__nccwpck_require__(7310));

var _v = _interopRequireDefault(__nccwpck_require__(4655));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// See https://joel.tools/microtasks/
function makeWaitForNextTask() {
  // As of Mar 2021, Electron v12 doesn't create new task with `setImmediate` despite
  // using Node 14 internally, so we fallback to `setTimeout(0)` instead.
  // @see https://github.com/electron/electron/issues/28261
  if (process.versions.electron) return callback => setTimeout(callback, 0);
  if (parseInt(process.versions.node, 10) >= 11) return setImmediate; // Unlike Node 11, Node 10 and less have a bug with Task and MicroTask execution order:
  // - https://github.com/nodejs/node/issues/22257
  //
  // So we can't simply run setImmediate to dispatch code in a following task.
  // However, we can run setImmediate from-inside setImmediate to make sure we're getting
  // in the following task.

  let spinning = false;
  const callbacks = [];

  const loop = () => {
    const callback = callbacks.shift();

    if (!callback) {
      spinning = false;
      return;
    }

    setImmediate(loop); // Make sure to call callback() as the last thing since it's
    // untrusted code that might throw.

    callback();
  };

  return callback => {
    callbacks.push(callback);

    if (!spinning) {
      spinning = true;
      setImmediate(loop);
    }
  };
}

function assert(value, message) {
  if (!value) throw new Error(message || 'Assertion error');
}

function debugAssert(value, message) {
  if (isUnderTest() && !value) throw new Error(message);
}

function isString(obj) {
  return typeof obj === 'string' || obj instanceof String;
}

function isRegExp(obj) {
  return obj instanceof RegExp || Object.prototype.toString.call(obj) === '[object RegExp]';
}

function isObject(obj) {
  return typeof obj === 'object' && obj !== null;
}

function isError(obj) {
  return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === 'Error';
}

const debugEnv = getFromENV('PWDEBUG') || '';

function debugMode() {
  if (debugEnv === 'console') return 'console';
  if (debugEnv === '0' || debugEnv === 'false') return '';
  return debugEnv ? 'inspector' : '';
}

let _isUnderTest = false;

function setUnderTest() {
  _isUnderTest = true;
}

function isUnderTest() {
  return _isUnderTest;
}

function getFromENV(name) {
  let value = process.env[name];
  value = value === undefined ? process.env[`npm_config_${name.toLowerCase()}`] : value;
  value = value === undefined ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
  return value;
}

function getAsBooleanFromENV(name) {
  const value = getFromENV(name);
  return !!value && value !== 'false' && value !== '0';
}

function headersObjectToArray(headers, separator, setCookieSeparator) {
  if (!setCookieSeparator) setCookieSeparator = separator;
  const result = [];

  for (const name in headers) {
    const values = headers[name];
    if (values === undefined) continue;

    if (separator) {
      const sep = name.toLowerCase() === 'set-cookie' ? setCookieSeparator : separator;

      for (const value of values.split(sep)) result.push({
        name,
        value: value.trim()
      });
    } else {
      result.push({
        name,
        value: values
      });
    }
  }

  return result;
}

function headersArrayToObject(headers, lowerCase) {
  const result = {};

  for (const {
    name,
    value
  } of headers) result[lowerCase ? name.toLowerCase() : name] = value;

  return result;
}

function monotonicTime() {
  const [seconds, nanoseconds] = process.hrtime();
  return seconds * 1000 + (nanoseconds / 1000 | 0) / 1000;
}

function objectToArray(map) {
  if (!map) return undefined;
  const result = [];

  for (const [name, value] of Object.entries(map)) result.push({
    name,
    value: String(value)
  });

  return result;
}

function arrayToObject(array) {
  if (!array) return undefined;
  const result = {};

  for (const {
    name,
    value
  } of array) result[name] = value;

  return result;
}

function calculateSha1(buffer) {
  const hash = crypto.createHash('sha1');
  hash.update(buffer);
  return hash.digest('hex');
}

function createGuid() {
  return crypto.randomBytes(16).toString('hex');
}

function constructURLBasedOnBaseURL(baseURL, givenURL) {
  try {
    return new URL.URL(givenURL, baseURL).toString();
  } catch (e) {
    return givenURL;
  }
}

function wrapInASCIIBox(text, padding = 0) {
  const lines = text.split('\n');
  const maxLength = Math.max(...lines.map(line => line.length));
  return ['╔' + '═'.repeat(maxLength + padding * 2) + '╗', ...lines.map(line => '║' + ' '.repeat(padding) + line + ' '.repeat(maxLength - line.length + padding) + '║'), '╚' + '═'.repeat(maxLength + padding * 2) + '╝'].join('\n');
}

function isFilePayload(value) {
  return typeof value === 'object' && value['name'] && value['mimeType'] && value['buffer'];
}

function streamToString(stream) {
  return new Promise((resolve, reject) => {
    const chunks = [];
    stream.on('data', chunk => chunks.push(Buffer.from(chunk)));
    stream.on('error', reject);
    stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));
  });
}

const isLikelyNpxGlobal = () => process.argv.length >= 2 && process.argv[1].includes('_npx');

exports.isLikelyNpxGlobal = isLikelyNpxGlobal;

function deepCopy(obj) {
  return _v.default.deserialize(_v.default.serialize(obj));
}

/***/ }),

/***/ 7517:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.escapeWithQuotes = escapeWithQuotes;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function escapeWithQuotes(text, char = '\'') {
  const stringified = JSON.stringify(text);
  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
  if (char === '\'') return char + escapedText.replace(/[']/g, '\\\'') + char;
  if (char === '"') return char + escapedText.replace(/["]/g, '\\"') + char;
  if (char === '`') return char + escapedText.replace(/[`]/g, '`') + char;
  throw new Error('Invalid escape char');
}

/***/ }),

/***/ 1665:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getLinuxDistributionInfo = getLinuxDistributionInfo;
exports.getLinuxDistributionInfoSync = getLinuxDistributionInfoSync;

var _fs = _interopRequireDefault(__nccwpck_require__(7147));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let didFailToReadOSRelease = false;
let osRelease;

async function getLinuxDistributionInfo() {
  if (process.platform !== 'linux') return undefined;

  if (!osRelease && !didFailToReadOSRelease) {
    try {
      var _fields$get, _fields$get2;

      // List of /etc/os-release values for different distributions could be
      // found here: https://gist.github.com/aslushnikov/8ceddb8288e4cf9db3039c02e0f4fb75
      const osReleaseText = await _fs.default.promises.readFile('/etc/os-release', 'utf8');
      const fields = parseOSReleaseText(osReleaseText);
      osRelease = {
        id: (_fields$get = fields.get('id')) !== null && _fields$get !== void 0 ? _fields$get : '',
        version: (_fields$get2 = fields.get('version_id')) !== null && _fields$get2 !== void 0 ? _fields$get2 : ''
      };
    } catch (e) {
      didFailToReadOSRelease = true;
    }
  }

  return osRelease;
}

function getLinuxDistributionInfoSync() {
  if (process.platform !== 'linux') return undefined;

  if (!osRelease && !didFailToReadOSRelease) {
    try {
      var _fields$get3, _fields$get4;

      // List of /etc/os-release values for different distributions could be
      // found here: https://gist.github.com/aslushnikov/8ceddb8288e4cf9db3039c02e0f4fb75
      const osReleaseText = _fs.default.readFileSync('/etc/os-release', 'utf8');

      const fields = parseOSReleaseText(osReleaseText);
      osRelease = {
        id: (_fields$get3 = fields.get('id')) !== null && _fields$get3 !== void 0 ? _fields$get3 : '',
        version: (_fields$get4 = fields.get('version_id')) !== null && _fields$get4 !== void 0 ? _fields$get4 : ''
      };
    } catch (e) {
      didFailToReadOSRelease = true;
    }
  }

  return osRelease;
}

function parseOSReleaseText(osReleaseText) {
  const fields = new Map();

  for (const line of osReleaseText.split('\n')) {
    const tokens = line.split('=');
    const name = tokens.shift();
    let value = tokens.join('=').trim();
    if (value.startsWith('"') && value.endsWith('"')) value = value.substring(1, value.length - 1);
    if (!name) continue;
    fields.set(name.toLowerCase(), value);
  }

  return fields;
}

/***/ }),

/***/ 6729:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ManualPromise = void 0;

let _Symbol$species, _Symbol$toStringTag;

_Symbol$species = Symbol.species;
_Symbol$toStringTag = Symbol.toStringTag;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ManualPromise extends Promise {
  constructor() {
    let resolve;
    let reject;
    super((f, r) => {
      resolve = f;
      reject = r;
    });
    this._resolve = void 0;
    this._reject = void 0;
    this._isDone = void 0;
    this._isDone = false;
    this._resolve = resolve;
    this._reject = reject;
  }

  isDone() {
    return this._isDone;
  }

  resolve(t) {
    this._isDone = true;

    this._resolve(t);
  }

  reject(e) {
    this._isDone = true;

    this._reject(e);
  }

  static get [_Symbol$species]() {
    return Promise;
  }

  get [_Symbol$toStringTag]() {
    return 'ManualPromise';
  }

}

exports.ManualPromise = ManualPromise;

/***/ }),

/***/ 5746:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isTextualMimeType = isTextualMimeType;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isTextualMimeType(mimeType) {
  return !!mimeType.match(/^(text\/.*?|application\/(json|(x-)?javascript|xml.*?|ecmascript|graphql|x-www-form-urlencoded)|image\/svg(\+xml)?|application\/.*?(\+json|\+xml))(;\s*charset=.*)?$/);
}

/***/ }),

/***/ 2391:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MultiMap = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiMap {
  constructor() {
    this._map = void 0;
    this._map = new Map();
  }

  set(key, value) {
    let values = this._map.get(key);

    if (!values) {
      values = [];

      this._map.set(key, values);
    }

    values.push(value);
  }

  get(key) {
    return this._map.get(key) || [];
  }

  has(key) {
    return this._map.has(key);
  }

  delete(key, value) {
    const values = this._map.get(key);

    if (!values) return;
    if (values.includes(value)) this._map.set(key, values.filter(v => value !== v));
  }

  hasValue(key, value) {
    const values = this._map.get(key);

    if (!values) return false;
    return values.includes(value);
  }

  get size() {
    return this._map.size;
  }

  keys() {
    return this._map.keys();
  }

  values() {
    const result = [];

    for (const key of this.keys()) result.push(...this.get(key));

    return result;
  }

  clear() {
    this._map.clear();
  }

}

exports.MultiMap = MultiMap;

/***/ }),

/***/ 1441:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.envArrayToObject = envArrayToObject;
exports.gracefullyCloseAll = gracefullyCloseAll;
exports.gracefullyCloseSet = void 0;
exports.launchProcess = launchProcess;

var childProcess = _interopRequireWildcard(__nccwpck_require__(2081));

var readline = _interopRequireWildcard(__nccwpck_require__(4521));

var path = _interopRequireWildcard(__nccwpck_require__(1017));

var _eventsHelper = __nccwpck_require__(3841);

var _ = __nccwpck_require__(3557);

var _fileUtils = __nccwpck_require__(6034);

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Copyright 2017 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const gracefullyCloseSet = new Set();
exports.gracefullyCloseSet = gracefullyCloseSet;

async function gracefullyCloseAll() {
  await Promise.all(Array.from(gracefullyCloseSet).map(gracefullyClose => gracefullyClose().catch(e => {})));
} // We currently spawn a process per page when recording video in Chromium.
//  This triggers "too many listeners" on the process object once you have more than 10 pages open.


const maxListeners = process.getMaxListeners();
if (maxListeners !== 0) process.setMaxListeners(Math.max(maxListeners || 0, 100));

async function launchProcess(options) {
  const stdio = options.stdio === 'pipe' ? ['ignore', 'pipe', 'pipe', 'pipe', 'pipe'] : ['pipe', 'pipe', 'pipe'];
  options.log(`<launching> ${options.command} ${options.args ? options.args.join(' ') : ''}`);
  const spawnOptions = {
    // On non-windows platforms, `detached: true` makes child process a leader of a new
    // process group, making it possible to kill child process tree with `.kill(-pid)` command.
    // @see https://nodejs.org/api/child_process.html#child_process_options_detached
    detached: process.platform !== 'win32',
    env: options.env,
    cwd: options.cwd,
    shell: options.shell,
    stdio
  };
  const spawnedProcess = childProcess.spawn(options.command, options.args || [], spawnOptions);

  const cleanup = async () => {
    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);
    const errors = await (0, _fileUtils.removeFolders)(options.tempDirectories);

    for (let i = 0; i < options.tempDirectories.length; ++i) {
      if (errors[i]) options.log(`[pid=${spawnedProcess.pid || 'N/A'}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);
    }

    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);
  }; // Prevent Unhandled 'error' event.


  spawnedProcess.on('error', () => {});

  if (!spawnedProcess.pid) {
    let failed;
    const failedPromise = new Promise((f, r) => failed = f);
    spawnedProcess.once('error', error => {
      failed(new Error('Failed to launch: ' + error));
    });
    return cleanup().then(() => failedPromise).then(e => Promise.reject(e));
  }

  options.log(`<launched> pid=${spawnedProcess.pid}`);
  const stdout = readline.createInterface({
    input: spawnedProcess.stdout
  });
  stdout.on('line', data => {
    options.log(`[pid=${spawnedProcess.pid}][out] ` + data);
  });
  const stderr = readline.createInterface({
    input: spawnedProcess.stderr
  });
  stderr.on('line', data => {
    options.log(`[pid=${spawnedProcess.pid}][err] ` + data);
  });
  let processClosed = false;

  let fulfillCleanup = () => {};

  const waitForCleanup = new Promise(f => fulfillCleanup = f);
  spawnedProcess.once('exit', (exitCode, signal) => {
    options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
    processClosed = true;

    _eventsHelper.eventsHelper.removeEventListeners(listeners);

    gracefullyCloseSet.delete(gracefullyClose);
    options.onExit(exitCode, signal); // Cleanup as process exits.

    cleanup().then(fulfillCleanup);
  });
  const listeners = [_eventsHelper.eventsHelper.addEventListener(process, 'exit', killProcessAndCleanup)];

  if (options.handleSIGINT) {
    listeners.push(_eventsHelper.eventsHelper.addEventListener(process, 'SIGINT', () => {
      gracefullyClose().then(() => {
        // Give tests a chance to dispatch any async calls.
        if ((0, _.isUnderTest)()) setTimeout(() => process.exit(130), 0);else process.exit(130);
      });
    }));
  }

  if (options.handleSIGTERM) listeners.push(_eventsHelper.eventsHelper.addEventListener(process, 'SIGTERM', gracefullyClose));
  if (options.handleSIGHUP) listeners.push(_eventsHelper.eventsHelper.addEventListener(process, 'SIGHUP', gracefullyClose));
  gracefullyCloseSet.add(gracefullyClose);
  let gracefullyClosing = false;

  async function gracefullyClose() {
    gracefullyCloseSet.delete(gracefullyClose); // We keep listeners until we are done, to handle 'exit' and 'SIGINT' while
    // asynchronously closing to prevent zombie processes. This might introduce
    // reentrancy to this function, for example user sends SIGINT second time.
    // In this case, let's forcefully kill the process.

    if (gracefullyClosing) {
      options.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
      killProcess();
      await waitForCleanup; // Ensure the process is dead and we have cleaned up.

      return;
    }

    gracefullyClosing = true;
    options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
    await options.attemptToGracefullyClose().catch(() => killProcess());
    await waitForCleanup; // Ensure the process is dead and we have cleaned up.

    options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
  } // This method has to be sync to be used as 'exit' event handler.


  function killProcess() {
    options.log(`[pid=${spawnedProcess.pid}] <kill>`);

    _eventsHelper.eventsHelper.removeEventListeners(listeners);

    if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
      options.log(`[pid=${spawnedProcess.pid}] <will force kill>`); // Force kill the browser.

      try {
        if (process.platform === 'win32') {
          const taskkillProcess = childProcess.spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F`, {
            shell: true
          });
          const [stdout, stderr] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];
          if (stdout) options.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout}`);
          if (stderr) options.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr}`);
        } else {
          process.kill(-spawnedProcess.pid, 'SIGKILL');
        }
      } catch (e) {
        options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`); // the process might have already stopped
      }
    } else {
      options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
    }
  }

  function killProcessAndCleanup() {
    killProcess();
    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] starting temporary directories cleanup`);

    if (options.tempDirectories.length) {
      const cleanupProcess = childProcess.spawnSync(process.argv0, [path.join(__dirname, 'processLauncherCleanupEntrypoint.js'), ...options.tempDirectories]);
      const [stdout, stderr] = [cleanupProcess.stdout.toString(), cleanupProcess.stderr.toString()];
      if (stdout) options.log(`[pid=${spawnedProcess.pid || 'N/A'}] ${stdout}`);
      if (stderr) options.log(`[pid=${spawnedProcess.pid || 'N/A'}] ${stderr}`);
    }

    options.log(`[pid=${spawnedProcess.pid || 'N/A'}] finished temporary directories cleanup`);
  }

  function killAndWait() {
    killProcess();
    return waitForCleanup;
  }

  return {
    launchedProcess: spawnedProcess,
    gracefullyClose,
    kill: killAndWait
  };
}

function envArrayToObject(env) {
  const result = {};

  for (const {
    name,
    value
  } of env) result[name] = value;

  return result;
}

/***/ }),

/***/ 4588:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.spawnAsync = spawnAsync;

var _child_process = __nccwpck_require__(2081);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function spawnAsync(cmd, args, options = {}) {
  const process = (0, _child_process.spawn)(cmd, args, Object.assign({
    windowsHide: true
  }, options));
  return new Promise(resolve => {
    let stdout = '';
    let stderr = '';
    if (process.stdout) process.stdout.on('data', data => stdout += data);
    if (process.stderr) process.stderr.on('data', data => stderr += data);
    process.on('close', code => resolve({
      stdout,
      stderr,
      code
    }));
    process.on('error', error => resolve({
      stdout,
      stderr,
      code: 0,
      error
    }));
  });
}

/***/ }),

/***/ 9030:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.captureRawStack = captureRawStack;
exports.captureStackTrace = captureStackTrace;
exports.isInternalFileName = isInternalFileName;
exports.rewriteErrorMessage = rewriteErrorMessage;
exports.splitErrorMessage = splitErrorMessage;

var _path = _interopRequireDefault(__nccwpck_require__(1017));

var _utilsBundle = __nccwpck_require__(1319);

var _ = __nccwpck_require__(3557);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function rewriteErrorMessage(e, newMessage) {
  var _e$stack;

  const lines = (((_e$stack = e.stack) === null || _e$stack === void 0 ? void 0 : _e$stack.split('\n')) || []).filter(l => l.startsWith('    at '));
  e.message = newMessage;
  const errorTitle = `${e.name}: ${e.message}`;
  if (lines.length) e.stack = `${errorTitle}\n${lines.join('\n')}`;
  return e;
}

const CORE_DIR = _path.default.resolve(__dirname, '..', '..');

const CORE_LIB = _path.default.join(CORE_DIR, 'lib');

const CORE_SRC = _path.default.join(CORE_DIR, 'src');

const TEST_DIR_SRC = _path.default.resolve(CORE_DIR, '..', 'playwright-test');

const TEST_DIR_LIB = _path.default.resolve(CORE_DIR, '..', '@playwright', 'test');

const COVERAGE_PATH = _path.default.join(CORE_DIR, '..', '..', 'tests', 'config', 'coverage.js');

function captureRawStack() {
  const stackTraceLimit = Error.stackTraceLimit;
  Error.stackTraceLimit = 30;
  const error = new Error();
  const stack = error.stack;
  Error.stackTraceLimit = stackTraceLimit;
  return stack;
}

function isInternalFileName(file, functionName) {
  // Node 16+ has node:internal.
  if (file.startsWith('internal') || file.startsWith('node:')) return true; // EventEmitter.emit has 'events.js' file.

  if (file === 'events.js' && functionName !== null && functionName !== void 0 && functionName.endsWith('emit')) return true; // Node 12

  if (file === '_stream_readable.js' || file === '_stream_writable.js') return true;
  return false;
}

function captureStackTrace(rawStack) {
  const stack = rawStack || captureRawStack();
  const isTesting = (0, _.isUnderTest)();
  let parsedFrames = stack.split('\n').map(line => {
    const {
      frame,
      fileName
    } = (0, _utilsBundle.parseStackTraceLine)(line);
    if (!frame || !frame.file || !fileName) return null;
    if (!process.env.PWDEBUGIMPL && isInternalFileName(frame.file, frame.function)) return null;
    if (!process.env.PWDEBUGIMPL && isTesting && fileName.includes(COVERAGE_PATH)) return null;
    const inCore = fileName.startsWith(CORE_LIB) || fileName.startsWith(CORE_SRC);
    const parsed = {
      frame: {
        file: fileName,
        line: frame.line,
        column: frame.column,
        function: frame.function
      },
      frameText: line,
      inCore
    };
    return parsed;
  }).filter(Boolean);
  let apiName = '';
  const allFrames = parsedFrames; // Deepest transition between non-client code calling into client code
  // is the api entry.

  for (let i = 0; i < parsedFrames.length - 1; i++) {
    if (parsedFrames[i].inCore && !parsedFrames[i + 1].inCore) {
      const frame = parsedFrames[i].frame;
      apiName = normalizeAPIName(frame.function);
      if (!process.env.PWDEBUGIMPL) parsedFrames = parsedFrames.slice(i + 1);
      break;
    }
  }

  function normalizeAPIName(name) {
    if (!name) return '';
    const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);
    if (!match) return name;
    return match[1].toLowerCase() + match[2];
  } // Hide all test runner and library frames in the user stack (event handlers produce them).


  parsedFrames = parsedFrames.filter((f, i) => {
    if (process.env.PWDEBUGIMPL) return true;
    if (f.frame.file.startsWith(TEST_DIR_SRC) || f.frame.file.startsWith(TEST_DIR_LIB)) return false;
    if (f.frame.file.startsWith(CORE_DIR)) return false;
    return true;
  });
  return {
    allFrames: allFrames.map(p => p.frame),
    frames: parsedFrames.map(p => p.frame),
    frameTexts: parsedFrames.map(p => p.frameText),
    apiName
  };
}

function splitErrorMessage(message) {
  const separationIdx = message.indexOf(':');
  return {
    name: separationIdx !== -1 ? message.slice(0, separationIdx) : '',
    message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
  };
}

/***/ }),

/***/ 803:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TimeoutRunnerError = exports.TimeoutRunner = void 0;
exports.raceAgainstTimeout = raceAgainstTimeout;

var _manualPromise = __nccwpck_require__(6729);

var _ = __nccwpck_require__(3557);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TimeoutRunnerError extends Error {}

exports.TimeoutRunnerError = TimeoutRunnerError;

class TimeoutRunner {
  constructor(timeout) {
    this._running = void 0;
    this._timeout = void 0;
    this._elapsed = void 0;
    this._timeout = timeout;
    this._elapsed = 0;
  }

  async run(cb) {
    const running = this._running = {
      lastElapsedSync: (0, _.monotonicTime)(),
      timer: undefined,
      timeoutPromise: new _manualPromise.ManualPromise()
    };

    try {
      const resultPromise = Promise.race([cb(), running.timeoutPromise]);

      this._updateTimeout(running, this._timeout);

      return await resultPromise;
    } finally {
      this._updateTimeout(running, 0);

      if (this._running === running) this._running = undefined;
    }
  }

  interrupt() {
    if (this._running) this._updateTimeout(this._running, -1);
  }

  elapsed() {
    this._syncElapsedAndStart();

    return this._elapsed;
  }

  updateTimeout(timeout, elapsed) {
    this._timeout = timeout;

    if (elapsed !== undefined) {
      this._syncElapsedAndStart();

      this._elapsed = elapsed;
    }

    if (this._running) this._updateTimeout(this._running, timeout);
  }

  _syncElapsedAndStart() {
    if (this._running) {
      const now = (0, _.monotonicTime)();
      this._elapsed += now - this._running.lastElapsedSync;
      this._running.lastElapsedSync = now;
    }
  }

  _updateTimeout(running, timeout) {
    if (running.timer) {
      clearTimeout(running.timer);
      running.timer = undefined;
    }

    this._syncElapsedAndStart();

    if (timeout === 0) return;
    timeout = timeout - this._elapsed;
    if (timeout <= 0) running.timeoutPromise.reject(new TimeoutRunnerError());else running.timer = setTimeout(() => running.timeoutPromise.reject(new TimeoutRunnerError()), timeout);
  }

}

exports.TimeoutRunner = TimeoutRunner;

async function raceAgainstTimeout(cb, timeout) {
  const runner = new TimeoutRunner(timeout);

  try {
    return {
      result: await runner.run(cb),
      timedOut: false
    };
  } catch (e) {
    if (e instanceof TimeoutRunnerError) return {
      timedOut: true
    };
    throw e;
  }
}

/***/ }),

/***/ 6435:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ZipFile = void 0;

var _zipBundle = __nccwpck_require__(6383);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ZipFile {
  constructor(fileName) {
    this._fileName = void 0;
    this._zipFile = void 0;
    this._entries = new Map();
    this._openedPromise = void 0;
    this._fileName = fileName;
    this._openedPromise = this._open();
  }

  async _open() {
    await new Promise((fulfill, reject) => {
      _zipBundle.yauzl.open(this._fileName, {
        autoClose: false
      }, (e, z) => {
        if (e) {
          reject(e);
          return;
        }

        this._zipFile = z;

        this._zipFile.on('entry', entry => {
          this._entries.set(entry.fileName, entry);
        });

        this._zipFile.on('end', fulfill);
      });
    });
  }

  async entries() {
    await this._openedPromise;
    return [...this._entries.keys()];
  }

  async read(entryPath) {
    await this._openedPromise;

    const entry = this._entries.get(entryPath);

    if (!entry) throw new Error(`${entryPath} not found in file ${this._fileName}`);
    return new Promise((resolve, reject) => {
      this._zipFile.openReadStream(entry, (error, readStream) => {
        if (error || !readStream) {
          reject(error || 'Entry not found');
          return;
        }

        const buffers = [];
        readStream.on('data', data => buffers.push(data));
        readStream.on('end', () => resolve(Buffer.concat(buffers)));
      });
    });
  }

  close() {
    var _this$_zipFile;

    (_this$_zipFile = this._zipFile) === null || _this$_zipFile === void 0 ? void 0 : _this$_zipFile.close();
  }

}

exports.ZipFile = ZipFile;

/***/ }),

/***/ 4940:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.zones = void 0;

var _stackTrace = __nccwpck_require__(9030);

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ZoneManager {
  constructor() {
    this.lastZoneId = 0;
    this._zones = new Map();
  }

  async run(type, data, func) {
    const zone = new Zone(this, ++this.lastZoneId, type, data);

    this._zones.set(zone.id, zone);

    return zone.run(func);
  }

  zoneData(type, rawStack) {
    const stack = rawStack || (0, _stackTrace.captureRawStack)();

    for (const line of stack.split('\n')) {
      const index = line.indexOf('__PWZONE__[');

      if (index !== -1) {
        const zoneId = +line.substring(index + '__PWZONE__['.length, line.indexOf(']', index));

        const zone = this._zones.get(zoneId);

        if (zone && zone.type === type) return zone.data;
      }
    }

    return null;
  }

}

class Zone {
  constructor(manager, id, type, data) {
    this._manager = void 0;
    this.id = void 0;
    this.type = void 0;
    this.data = {};
    this._manager = manager;
    this.id = id;
    this.type = type;
    this.data = data;
  }

  async run(func) {
    Object.defineProperty(func, 'name', {
      value: `__PWZONE__[${this.id}]`
    });

    try {
      return await func();
    } finally {
      this._manager._zones.delete(this.id);
    }
  }

}

const zones = new ZoneManager();
exports.zones = zones;

/***/ }),

/***/ 1319:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ms = exports.minimatch = exports.mime = exports.lockfile = exports.jpegjs = exports.getProxyForUrl = exports.debug = exports.colors = exports.SocksProxyAgent = exports.PNG = exports.HttpsProxyAgent = void 0;
exports.parseStackTraceLine = parseStackTraceLine;
exports.wsServer = exports.wsSender = exports.wsReceiver = exports.ws = exports.rimraf = exports.progress = exports.program = void 0;

var _url = _interopRequireDefault(__nccwpck_require__(7310));

var _path = _interopRequireDefault(__nccwpck_require__(1017));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const colors = (__nccwpck_require__(9777).colors);

exports.colors = colors;

const debug = (__nccwpck_require__(9777).debug);

exports.debug = debug;

const getProxyForUrl = (__nccwpck_require__(9777).getProxyForUrl);

exports.getProxyForUrl = getProxyForUrl;

const HttpsProxyAgent = (__nccwpck_require__(9777).HttpsProxyAgent);

exports.HttpsProxyAgent = HttpsProxyAgent;

const jpegjs = (__nccwpck_require__(9777).jpegjs);

exports.jpegjs = jpegjs;

const lockfile = (__nccwpck_require__(9777).lockfile);

exports.lockfile = lockfile;

const mime = (__nccwpck_require__(9777).mime);

exports.mime = mime;

const minimatch = (__nccwpck_require__(9777).minimatch);

exports.minimatch = minimatch;

const ms = (__nccwpck_require__(9777).ms);

exports.ms = ms;

const PNG = (__nccwpck_require__(9777).PNG);

exports.PNG = PNG;

const program = (__nccwpck_require__(9777).program);

exports.program = program;

const progress = (__nccwpck_require__(9777).progress);

exports.progress = progress;

const rimraf = (__nccwpck_require__(9777).rimraf);

exports.rimraf = rimraf;

const SocksProxyAgent = (__nccwpck_require__(9777).SocksProxyAgent);

exports.SocksProxyAgent = SocksProxyAgent;

const ws = (__nccwpck_require__(9777).ws);

exports.ws = ws;

const wsServer = (__nccwpck_require__(9777).wsServer);

exports.wsServer = wsServer;

const wsReceiver = (__nccwpck_require__(9777).wsReceiver);

exports.wsReceiver = wsReceiver;

const wsSender = (__nccwpck_require__(9777).wsSender);

exports.wsSender = wsSender;

const StackUtils = (__nccwpck_require__(9777).StackUtils);

const stackUtils = new StackUtils();

function parseStackTraceLine(line) {
  const frame = stackUtils.parseLine(line);
  if (!frame) return {
    frame: null,
    fileName: null
  };
  let fileName = null;

  if (frame.file) {
    // ESM files return file:// URLs, see here: https://github.com/tapjs/stack-utils/issues/60
    fileName = frame.file.startsWith('file://') ? _url.default.fileURLToPath(frame.file) : _path.default.resolve(process.cwd(), frame.file);
  }

  return {
    frame,
    fileName
  };
}

/***/ }),

/***/ 9777:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
var Oh=Object.create;var pr=Object.defineProperty;var Ih=Object.getOwnPropertyDescriptor;var Th=Object.getOwnPropertyNames;var Ah=Object.getPrototypeOf,Rh=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),Bh=(t,e)=>{for(var i in e)pr(t,i,{get:e[i],enumerable:!0})},Lo=(t,e,i,r)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of Th(e))!Rh.call(t,n)&&n!==i&&pr(t,n,{get:()=>e[n],enumerable:!(r=Ih(e,n))||r.enumerable});return t};var Te=(t,e,i)=>(i=t!=null?Oh(Ah(t)):{},Lo(e||!t||!t.__esModule?pr(i,"default",{value:t,enumerable:!0}):i,t)),Lh=t=>Lo(pr({},"__esModule",{value:!0}),t);var Mo=x((Qv,Fo)=>{var Po={};Fo.exports=Po;var No={reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],gray:[90,39],grey:[90,39],brightRed:[91,39],brightGreen:[92,39],brightYellow:[93,39],brightBlue:[94,39],brightMagenta:[95,39],brightCyan:[96,39],brightWhite:[97,39],bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgGray:[100,49],bgGrey:[100,49],bgBrightRed:[101,49],bgBrightGreen:[102,49],bgBrightYellow:[103,49],bgBrightBlue:[104,49],bgBrightMagenta:[105,49],bgBrightCyan:[106,49],bgBrightWhite:[107,49],blackBG:[40,49],redBG:[41,49],greenBG:[42,49],yellowBG:[43,49],blueBG:[44,49],magentaBG:[45,49],cyanBG:[46,49],whiteBG:[47,49]};Object.keys(No).forEach(function(t){var e=No[t],i=Po[t]=[];i.open="\x1B["+e[0]+"m",i.close="\x1B["+e[1]+"m"})});var Do=x((Jv,Uo)=>{"use strict";Uo.exports=function(t,e){e=e||process.argv;var i=e.indexOf("--"),r=/^-{1,2}/.test(t)?"":"--",n=e.indexOf(r+t);return n!==-1&&(i===-1?!0:n<i)}});var qo=x((e_,jo)=>{"use strict";var Nh=__nccwpck_require__(2037),it=Do(),Ve=process.env,Xt=void 0;it("no-color")||it("no-colors")||it("color=false")?Xt=!1:(it("color")||it("colors")||it("color=true")||it("color=always"))&&(Xt=!0);"FORCE_COLOR"in Ve&&(Xt=Ve.FORCE_COLOR.length===0||parseInt(Ve.FORCE_COLOR,10)!==0);function Ph(t){return t===0?!1:{level:t,hasBasic:!0,has256:t>=2,has16m:t>=3}}function Fh(t){if(Xt===!1)return 0;if(it("color=16m")||it("color=full")||it("color=truecolor"))return 3;if(it("color=256"))return 2;if(t&&!t.isTTY&&Xt!==!0)return 0;var e=Xt?1:0;if(process.platform==="win32"){var i=Nh.release().split(".");return Number(process.versions.node.split(".")[0])>=8&&Number(i[0])>=10&&Number(i[2])>=10586?Number(i[2])>=14931?3:2:1}if("CI"in Ve)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some(function(n){return n in Ve})||Ve.CI_NAME==="codeship"?1:e;if("TEAMCITY_VERSION"in Ve)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(Ve.TEAMCITY_VERSION)?1:0;if("TERM_PROGRAM"in Ve){var r=parseInt((Ve.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(Ve.TERM_PROGRAM){case"iTerm.app":return r>=3?3:2;case"Hyper":return 3;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(Ve.TERM)?2:/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(Ve.TERM)||"COLORTERM"in Ve?1:(Ve.TERM==="dumb",e)}function en(t){var e=Fh(t);return Ph(e)}jo.exports={supportsColor:en,stdout:en(process.stdout),stderr:en(process.stderr)}});var Vo=x((t_,Ho)=>{Ho.exports=function(e,i){var r="";e=e||"Run the trap, drop the bass",e=e.split("");var n={a:["@","\u0104","\u023A","\u0245","\u0394","\u039B","\u0414"],b:["\xDF","\u0181","\u0243","\u026E","\u03B2","\u0E3F"],c:["\xA9","\u023B","\u03FE"],d:["\xD0","\u018A","\u0500","\u0501","\u0502","\u0503"],e:["\xCB","\u0115","\u018E","\u0258","\u03A3","\u03BE","\u04BC","\u0A6C"],f:["\u04FA"],g:["\u0262"],h:["\u0126","\u0195","\u04A2","\u04BA","\u04C7","\u050A"],i:["\u0F0F"],j:["\u0134"],k:["\u0138","\u04A0","\u04C3","\u051E"],l:["\u0139"],m:["\u028D","\u04CD","\u04CE","\u0520","\u0521","\u0D69"],n:["\xD1","\u014B","\u019D","\u0376","\u03A0","\u048A"],o:["\xD8","\xF5","\xF8","\u01FE","\u0298","\u047A","\u05DD","\u06DD","\u0E4F"],p:["\u01F7","\u048E"],q:["\u09CD"],r:["\xAE","\u01A6","\u0210","\u024C","\u0280","\u042F"],s:["\xA7","\u03DE","\u03DF","\u03E8"],t:["\u0141","\u0166","\u0373"],u:["\u01B1","\u054D"],v:["\u05D8"],w:["\u0428","\u0460","\u047C","\u0D70"],x:["\u04B2","\u04FE","\u04FC","\u04FD"],y:["\xA5","\u04B0","\u04CB"],z:["\u01B5","\u0240"]};return e.forEach(function(s){s=s.toLowerCase();var o=n[s]||[" "],a=Math.floor(Math.random()*o.length);typeof n[s]!="undefined"?r+=n[s][a]:r+=s}),r}});var Go=x((i_,$o)=>{$o.exports=function(e,i){e=e||"   he is here   ";var r={up:["\u030D","\u030E","\u0304","\u0305","\u033F","\u0311","\u0306","\u0310","\u0352","\u0357","\u0351","\u0307","\u0308","\u030A","\u0342","\u0313","\u0308","\u034A","\u034B","\u034C","\u0303","\u0302","\u030C","\u0350","\u0300","\u0301","\u030B","\u030F","\u0312","\u0313","\u0314","\u033D","\u0309","\u0363","\u0364","\u0365","\u0366","\u0367","\u0368","\u0369","\u036A","\u036B","\u036C","\u036D","\u036E","\u036F","\u033E","\u035B","\u0346","\u031A"],down:["\u0316","\u0317","\u0318","\u0319","\u031C","\u031D","\u031E","\u031F","\u0320","\u0324","\u0325","\u0326","\u0329","\u032A","\u032B","\u032C","\u032D","\u032E","\u032F","\u0330","\u0331","\u0332","\u0333","\u0339","\u033A","\u033B","\u033C","\u0345","\u0347","\u0348","\u0349","\u034D","\u034E","\u0353","\u0354","\u0355","\u0356","\u0359","\u035A","\u0323"],mid:["\u0315","\u031B","\u0300","\u0301","\u0358","\u0321","\u0322","\u0327","\u0328","\u0334","\u0335","\u0336","\u035C","\u035D","\u035E","\u035F","\u0360","\u0362","\u0338","\u0337","\u0361"," \u0489"]},n=[].concat(r.up,r.down,r.mid);function s(l){var c=Math.floor(Math.random()*l);return c}function o(l){var c=!1;return n.filter(function(u){c=u===l}),c}function a(l,c){var u="",f,h;c=c||{},c.up=typeof c.up!="undefined"?c.up:!0,c.mid=typeof c.mid!="undefined"?c.mid:!0,c.down=typeof c.down!="undefined"?c.down:!0,c.size=typeof c.size!="undefined"?c.size:"maxi",l=l.split("");for(h in l)if(!o(h)){switch(u=u+l[h],f={up:0,down:0,mid:0},c.size){case"mini":f.up=s(8),f.mid=s(2),f.down=s(8);break;case"maxi":f.up=s(16)+3,f.mid=s(4)+1,f.down=s(64)+3;break;default:f.up=s(8)+1,f.mid=s(6)/2,f.down=s(8)+1;break}var p=["up","mid","down"];for(var d in p)for(var m=p[d],g=0;g<=f[m];g++)c[m]&&(u=u+r[m][s(r[m].length)])}return u}return a(e,i)}});var Wo=x((r_,zo)=>{zo.exports=function(t){return function(e,i,r){if(e===" ")return e;switch(i%3){case 0:return t.red(e);case 1:return t.white(e);case 2:return t.blue(e)}}}});var Ko=x((n_,Yo)=>{Yo.exports=function(t){return function(e,i,r){return i%2===0?e:t.inverse(e)}}});var Xo=x((s_,Zo)=>{Zo.exports=function(t){var e=["red","yellow","green","blue","magenta"];return function(i,r,n){return i===" "?i:t[e[r++%e.length]](i)}}});var Jo=x((o_,Qo)=>{Qo.exports=function(t){var e=["underline","inverse","grey","yellow","red","green","blue","white","cyan","magenta","brightYellow","brightRed","brightGreen","brightBlue","brightWhite","brightCyan","brightMagenta"];return function(i,r,n){return i===" "?i:t[e[Math.round(Math.random()*(e.length-2))]](i)}}});var sa=x((l_,na)=>{var ae={};na.exports=ae;ae.themes={};var Mh=__nccwpck_require__(3837),Rt=ae.styles=Mo(),ta=Object.defineProperties,Uh=new RegExp(/[\r\n]+/g);ae.supportsColor=qo().supportsColor;typeof ae.enabled=="undefined"&&(ae.enabled=ae.supportsColor()!==!1);ae.enable=function(){ae.enabled=!0};ae.disable=function(){ae.enabled=!1};ae.stripColors=ae.strip=function(t){return(""+t).replace(/\x1B\[\d+m/g,"")};var a_=ae.stylize=function(e,i){if(!ae.enabled)return e+"";var r=Rt[i];return!r&&i in ae?ae[i](e):r.open+e+r.close},Dh=/[|\\{}()[\]^$+*?.]/g,jh=function(t){if(typeof t!="string")throw new TypeError("Expected a string");return t.replace(Dh,"\\$&")};function ia(t){var e=function i(){return Hh.apply(i,arguments)};return e._styles=t,e.__proto__=qh,e}var ra=function(){var t={};return Rt.grey=Rt.gray,Object.keys(Rt).forEach(function(e){Rt[e].closeRe=new RegExp(jh(Rt[e].close),"g"),t[e]={get:function(){return ia(this._styles.concat(e))}}}),t}(),qh=ta(function(){},ra);function Hh(){var t=Array.prototype.slice.call(arguments),e=t.map(function(o){return o!=null&&o.constructor===String?o:Mh.inspect(o)}).join(" ");if(!ae.enabled||!e)return e;for(var i=e.indexOf(`
`)!=-1,r=this._styles,n=r.length;n--;){var s=Rt[r[n]];e=s.open+e.replace(s.closeRe,s.open)+s.close,i&&(e=e.replace(Uh,function(o){return s.close+o+s.open}))}return e}ae.setTheme=function(t){if(typeof t=="string"){console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");return}for(var e in t)(function(i){ae[i]=function(r){if(typeof t[i]=="object"){var n=r;for(var s in t[i])n=ae[t[i][s]](n);return n}return ae[t[i]](r)}})(e)};function Vh(){var t={};return Object.keys(ra).forEach(function(e){t[e]={get:function(){return ia([e])}}}),t}var $h=function(e,i){var r=i.split("");return r=r.map(e),r.join("")};ae.trap=Vo();ae.zalgo=Go();ae.maps={};ae.maps.america=Wo()(ae);ae.maps.zebra=Ko()(ae);ae.maps.rainbow=Xo()(ae);ae.maps.random=Jo()(ae);for(ea in ae.maps)(function(t){ae[t]=function(e){return $h(ae.maps[t],e)}})(ea);var ea;ta(ae,Vh())});var aa=x((c_,oa)=>{var Gh=sa();oa.exports=Gh});var tn=x((u_,la)=>{var Qt=1e3,Jt=Qt*60,ei=Jt*60,Bt=ei*24,zh=Bt*7,Wh=Bt*365.25;la.exports=function(t,e){e=e||{};var i=typeof t;if(i==="string"&&t.length>0)return Yh(t);if(i==="number"&&isFinite(t))return e.long?Zh(t):Kh(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))};function Yh(t){if(t=String(t),!(t.length>100)){var e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(!!e){var i=parseFloat(e[1]),r=(e[2]||"ms").toLowerCase();switch(r){case"years":case"year":case"yrs":case"yr":case"y":return i*Wh;case"weeks":case"week":case"w":return i*zh;case"days":case"day":case"d":return i*Bt;case"hours":case"hour":case"hrs":case"hr":case"h":return i*ei;case"minutes":case"minute":case"mins":case"min":case"m":return i*Jt;case"seconds":case"second":case"secs":case"sec":case"s":return i*Qt;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return i;default:return}}}}function Kh(t){var e=Math.abs(t);return e>=Bt?Math.round(t/Bt)+"d":e>=ei?Math.round(t/ei)+"h":e>=Jt?Math.round(t/Jt)+"m":e>=Qt?Math.round(t/Qt)+"s":t+"ms"}function Zh(t){var e=Math.abs(t);return e>=Bt?dr(t,e,Bt,"day"):e>=ei?dr(t,e,ei,"hour"):e>=Jt?dr(t,e,Jt,"minute"):e>=Qt?dr(t,e,Qt,"second"):t+" ms"}function dr(t,e,i,r){var n=e>=i*1.5;return Math.round(t/i)+" "+r+(n?"s":"")}});var rn=x((f_,ca)=>{function Xh(t){i.debug=i,i.default=i,i.coerce=l,i.disable=s,i.enable=n,i.enabled=o,i.humanize=tn(),i.destroy=c,Object.keys(t).forEach(u=>{i[u]=t[u]}),i.names=[],i.skips=[],i.formatters={};function e(u){let f=0;for(let h=0;h<u.length;h++)f=(f<<5)-f+u.charCodeAt(h),f|=0;return i.colors[Math.abs(f)%i.colors.length]}i.selectColor=e;function i(u){let f,h=null,p,d;function m(...g){if(!m.enabled)return;let y=m,I=Number(new Date),w=I-(f||I);y.diff=w,y.prev=f,y.curr=I,f=I,g[0]=i.coerce(g[0]),typeof g[0]!="string"&&g.unshift("%O");let S=0;g[0]=g[0].replace(/%([a-zA-Z%])/g,($,C)=>{if($==="%%")return"%";S++;let U=i.formatters[C];if(typeof U=="function"){let E=g[S];$=U.call(y,E),g.splice(S,1),S--}return $}),i.formatArgs.call(y,g),(y.log||i.log).apply(y,g)}return m.namespace=u,m.useColors=i.useColors(),m.color=i.selectColor(u),m.extend=r,m.destroy=i.destroy,Object.defineProperty(m,"enabled",{enumerable:!0,configurable:!1,get:()=>h!==null?h:(p!==i.namespaces&&(p=i.namespaces,d=i.enabled(u)),d),set:g=>{h=g}}),typeof i.init=="function"&&i.init(m),m}function r(u,f){let h=i(this.namespace+(typeof f=="undefined"?":":f)+u);return h.log=this.log,h}function n(u){i.save(u),i.namespaces=u,i.names=[],i.skips=[];let f,h=(typeof u=="string"?u:"").split(/[\s,]+/),p=h.length;for(f=0;f<p;f++)!h[f]||(u=h[f].replace(/\*/g,".*?"),u[0]==="-"?i.skips.push(new RegExp("^"+u.slice(1)+"$")):i.names.push(new RegExp("^"+u+"$")))}function s(){let u=[...i.names.map(a),...i.skips.map(a).map(f=>"-"+f)].join(",");return i.enable(""),u}function o(u){if(u[u.length-1]==="*")return!0;let f,h;for(f=0,h=i.skips.length;f<h;f++)if(i.skips[f].test(u))return!1;for(f=0,h=i.names.length;f<h;f++)if(i.names[f].test(u))return!0;return!1}function a(u){return u.toString().substring(2,u.toString().length-2).replace(/\.\*\?$/,"*")}function l(u){return u instanceof Error?u.stack||u.message:u}function c(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return i.enable(i.load()),i}ca.exports=Xh});var ua=x((We,mr)=>{We.formatArgs=Jh;We.save=ep;We.load=tp;We.useColors=Qh;We.storage=ip();We.destroy=(()=>{let t=!1;return()=>{t||(t=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})();We.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Qh(){return typeof window!="undefined"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document!="undefined"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window!="undefined"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function Jh(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+mr.exports.humanize(this.diff),!this.useColors)return;let e="color: "+this.color;t.splice(1,0,e,"color: inherit");let i=0,r=0;t[0].replace(/%[a-zA-Z%]/g,n=>{n!=="%%"&&(i++,n==="%c"&&(r=i))}),t.splice(r,0,e)}We.log=console.debug||console.log||(()=>{});function ep(t){try{t?We.storage.setItem("debug",t):We.storage.removeItem("debug")}catch{}}function tp(){let t;try{t=We.storage.getItem("debug")}catch{}return!t&&typeof process!="undefined"&&"env"in process&&(t=process.env.DEBUG),t}function ip(){try{return localStorage}catch{}}mr.exports=rn()(We);var{formatters:rp}=mr.exports;rp.j=function(t){try{return JSON.stringify(t)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}});var ha=x((h_,fa)=>{"use strict";fa.exports=(t,e)=>{e=e||process.argv;let i=t.startsWith("-")?"":t.length===1?"-":"--",r=e.indexOf(i+t),n=e.indexOf("--");return r!==-1&&(n===-1?!0:r<n)}});var da=x((p_,pa)=>{"use strict";var np=__nccwpck_require__(2037),rt=ha(),je=process.env,ti;rt("no-color")||rt("no-colors")||rt("color=false")?ti=!1:(rt("color")||rt("colors")||rt("color=true")||rt("color=always"))&&(ti=!0);"FORCE_COLOR"in je&&(ti=je.FORCE_COLOR.length===0||parseInt(je.FORCE_COLOR,10)!==0);function sp(t){return t===0?!1:{level:t,hasBasic:!0,has256:t>=2,has16m:t>=3}}function op(t){if(ti===!1)return 0;if(rt("color=16m")||rt("color=full")||rt("color=truecolor"))return 3;if(rt("color=256"))return 2;if(t&&!t.isTTY&&ti!==!0)return 0;let e=ti?1:0;if(process.platform==="win32"){let i=np.release().split(".");return Number(process.versions.node.split(".")[0])>=8&&Number(i[0])>=10&&Number(i[2])>=10586?Number(i[2])>=14931?3:2:1}if("CI"in je)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some(i=>i in je)||je.CI_NAME==="codeship"?1:e;if("TEAMCITY_VERSION"in je)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(je.TEAMCITY_VERSION)?1:0;if(je.COLORTERM==="truecolor")return 3;if("TERM_PROGRAM"in je){let i=parseInt((je.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(je.TERM_PROGRAM){case"iTerm.app":return i>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(je.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(je.TERM)||"COLORTERM"in je?1:(je.TERM==="dumb",e)}function nn(t){let e=op(t);return sp(e)}pa.exports={supportsColor:nn,stdout:nn(process.stdout),stderr:nn(process.stderr)}});var ga=x((Me,vr)=>{var ap=__nccwpck_require__(6224),gr=__nccwpck_require__(3837);Me.init=dp;Me.log=fp;Me.formatArgs=cp;Me.save=hp;Me.load=pp;Me.useColors=lp;Me.destroy=gr.deprecate(()=>{},"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");Me.colors=[6,2,3,4,5,1];try{let t=da();t&&(t.stderr||t).level>=2&&(Me.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221])}catch{}Me.inspectOpts=Object.keys(process.env).filter(t=>/^debug_/i.test(t)).reduce((t,e)=>{let i=e.substring(6).toLowerCase().replace(/_([a-z])/g,(n,s)=>s.toUpperCase()),r=process.env[e];return/^(yes|on|true|enabled)$/i.test(r)?r=!0:/^(no|off|false|disabled)$/i.test(r)?r=!1:r==="null"?r=null:r=Number(r),t[i]=r,t},{});function lp(){return"colors"in Me.inspectOpts?Boolean(Me.inspectOpts.colors):ap.isatty(process.stderr.fd)}function cp(t){let{namespace:e,useColors:i}=this;if(i){let r=this.color,n="\x1B[3"+(r<8?r:"8;5;"+r),s=`  ${n};1m${e} \x1B[0m`;t[0]=s+t[0].split(`
`).join(`
`+s),t.push(n+"m+"+vr.exports.humanize(this.diff)+"\x1B[0m")}else t[0]=up()+e+" "+t[0]}function up(){return Me.inspectOpts.hideDate?"":new Date().toISOString()+" "}function fp(...t){return process.stderr.write(gr.format(...t)+`
`)}function hp(t){t?process.env.DEBUG=t:delete process.env.DEBUG}function pp(){return process.env.DEBUG}function dp(t){t.inspectOpts={};let e=Object.keys(Me.inspectOpts);for(let i=0;i<e.length;i++)t.inspectOpts[e[i]]=Me.inspectOpts[e[i]]}vr.exports=rn()(Me);var{formatters:ma}=vr.exports;ma.o=function(t){return this.inspectOpts.colors=this.useColors,gr.inspect(t,this.inspectOpts).split(`
`).map(e=>e.trim()).join(" ")};ma.O=function(t){return this.inspectOpts.colors=this.useColors,gr.inspect(t,this.inspectOpts)}});var ii=x((d_,sn)=>{typeof process=="undefined"||process.type==="renderer"||process.browser===!0||process.__nwjs?sn.exports=ua():sn.exports=ga()});var _a=x(va=>{"use strict";var mp=(__nccwpck_require__(7310).parse),gp={ftp:21,gopher:70,http:80,https:443,ws:80,wss:443},vp=String.prototype.endsWith||function(t){return t.length<=this.length&&this.indexOf(t,this.length-t.length)!==-1};function _p(t){var e=typeof t=="string"?mp(t):t||{},i=e.protocol,r=e.host,n=e.port;if(typeof r!="string"||!r||typeof i!="string"||(i=i.split(":",1)[0],r=r.replace(/:\d*$/,""),n=parseInt(n)||gp[i]||0,!xp(r,n)))return"";var s=ri("npm_config_"+i+"_proxy")||ri(i+"_proxy")||ri("npm_config_proxy")||ri("all_proxy");return s&&s.indexOf("://")===-1&&(s=i+"://"+s),s}function xp(t,e){var i=(ri("npm_config_no_proxy")||ri("no_proxy")).toLowerCase();return i?i==="*"?!1:i.split(/[,\s]/).every(function(r){if(!r)return!0;var n=r.match(/^(.+):(\d+)$/),s=n?n[1]:r,o=n?parseInt(n[2]):0;return o&&o!==e?!0:/^[.*]/.test(s)?(s.charAt(0)==="*"&&(s=s.slice(1)),!vp.call(t,s)):t!==s}):!0}function ri(t){return process.env[t.toLowerCase()]||process.env[t.toUpperCase()]||""}va.getProxyForUrl=_p});var xa=x(on=>{"use strict";Object.defineProperty(on,"__esModule",{value:!0});function yp(t){return function(e,i){return new Promise((r,n)=>{t.call(this,e,i,(s,o)=>{s?n(s):r(o)})})}}on.default=yp});var cn=x((ln,ba)=>{"use strict";var ya=ln&&ln.__importDefault||function(t){return t&&t.__esModule?t:{default:t}},bp=__nccwpck_require__(2361),wp=ya(ii()),Ep=ya(xa()),Ni=wp.default("agent-base");function Sp(t){return Boolean(t)&&typeof t.addRequest=="function"}function an(){let{stack:t}=new Error;return typeof t!="string"?!1:t.split(`
`).some(e=>e.indexOf("(https.js:")!==-1||e.indexOf("node:https:")!==-1)}function _r(t,e){return new _r.Agent(t,e)}(function(t){class e extends bp.EventEmitter{constructor(r,n){super();let s=n;typeof r=="function"?this.callback=r:r&&(s=r),this.timeout=null,s&&typeof s.timeout=="number"&&(this.timeout=s.timeout),this.maxFreeSockets=1,this.maxSockets=1,this.maxTotalSockets=1/0,this.sockets={},this.freeSockets={},this.requests={},this.options={}}get defaultPort(){return typeof this.explicitDefaultPort=="number"?this.explicitDefaultPort:an()?443:80}set defaultPort(r){this.explicitDefaultPort=r}get protocol(){return typeof this.explicitProtocol=="string"?this.explicitProtocol:an()?"https:":"http:"}set protocol(r){this.explicitProtocol=r}callback(r,n,s){throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`')}addRequest(r,n){let s=Object.assign({},n);typeof s.secureEndpoint!="boolean"&&(s.secureEndpoint=an()),s.host==null&&(s.host="localhost"),s.port==null&&(s.port=s.secureEndpoint?443:80),s.protocol==null&&(s.protocol=s.secureEndpoint?"https:":"http:"),s.host&&s.path&&delete s.path,delete s.agent,delete s.hostname,delete s._defaultAgent,delete s.defaultPort,delete s.createConnection,r._last=!0,r.shouldKeepAlive=!1;let o=!1,a=null,l=s.timeout||this.timeout,c=p=>{r._hadError||(r.emit("error",p),r._hadError=!0)},u=()=>{a=null,o=!0;let p=new Error(`A "socket" was not created for HTTP request before ${l}ms`);p.code="ETIMEOUT",c(p)},f=p=>{o||(a!==null&&(clearTimeout(a),a=null),c(p))},h=p=>{if(o)return;if(a!=null&&(clearTimeout(a),a=null),Sp(p)){Ni("Callback returned another Agent instance %o",p.constructor.name),p.addRequest(r,s);return}if(p){p.once("free",()=>{this.freeSocket(p,s)}),r.onSocket(p);return}let d=new Error(`no Duplex stream was returned to agent-base for \`${r.method} ${r.path}\``);c(d)};if(typeof this.callback!="function"){c(new Error("`callback` is not defined"));return}this.promisifiedCallback||(this.callback.length>=3?(Ni("Converting legacy callback function to promise"),this.promisifiedCallback=Ep.default(this.callback)):this.promisifiedCallback=this.callback),typeof l=="number"&&l>0&&(a=setTimeout(u,l)),"port"in s&&typeof s.port!="number"&&(s.port=Number(s.port));try{Ni("Resolving socket for %o request: %o",s.protocol,`${r.method} ${r.path}`),Promise.resolve(this.promisifiedCallback(r,s)).then(h,f)}catch(p){Promise.reject(p).catch(f)}}freeSocket(r,n){Ni("Freeing socket %o %o",r.constructor.name,n),r.destroy()}destroy(){Ni("Destroying agent %o",this.constructor.name)}}t.Agent=e,t.prototype=t.Agent.prototype})(_r||(_r={}));ba.exports=_r});var wa=x(Fi=>{"use strict";var kp=Fi&&Fi.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Fi,"__esModule",{value:!0});var Cp=kp(ii()),Pi=Cp.default("https-proxy-agent:parse-proxy-response");function Op(t){return new Promise((e,i)=>{let r=0,n=[];function s(){let f=t.read();f?u(f):t.once("readable",s)}function o(){t.removeListener("end",l),t.removeListener("error",c),t.removeListener("close",a),t.removeListener("readable",s)}function a(f){Pi("onclose had error %o",f)}function l(){Pi("onend")}function c(f){o(),Pi("onerror %o",f),i(f)}function u(f){n.push(f),r+=f.length;let h=Buffer.concat(n,r);if(h.indexOf(`\r
\r
`)===-1){Pi("have not received end of HTTP headers yet..."),s();return}let d=h.toString("ascii",0,h.indexOf(`\r
`)),m=+d.split(" ")[1];Pi("got proxy server response: %o",d),e({statusCode:m,buffered:h})}t.on("error",c),t.on("close",a),t.on("end",l),s()})}Fi.default=Op});var ka=x(Lt=>{"use strict";var Ip=Lt&&Lt.__awaiter||function(t,e,i,r){function n(s){return s instanceof i?s:new i(function(o){o(s)})}return new(i||(i=Promise))(function(s,o){function a(u){try{c(r.next(u))}catch(f){o(f)}}function l(u){try{c(r.throw(u))}catch(f){o(f)}}function c(u){u.done?s(u.value):n(u.value).then(a,l)}c((r=r.apply(t,e||[])).next())})},ni=Lt&&Lt.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(Lt,"__esModule",{value:!0});var Ea=ni(__nccwpck_require__(1808)),Sa=ni(__nccwpck_require__(4404)),Tp=ni(__nccwpck_require__(7310)),Ap=ni(__nccwpck_require__(9491)),Rp=ni(ii()),Bp=cn(),Lp=ni(wa()),Mi=Rp.default("https-proxy-agent:agent"),un=class extends Bp.Agent{constructor(e){let i;if(typeof e=="string"?i=Tp.default.parse(e):i=e,!i)throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");Mi("creating new HttpsProxyAgent instance: %o",i),super(i);let r=Object.assign({},i);this.secureProxy=i.secureProxy||Fp(r.protocol),r.host=r.hostname||r.host,typeof r.port=="string"&&(r.port=parseInt(r.port,10)),!r.port&&r.host&&(r.port=this.secureProxy?443:80),this.secureProxy&&!("ALPNProtocols"in r)&&(r.ALPNProtocols=["http 1.1"]),r.host&&r.path&&(delete r.path,delete r.pathname),this.proxy=r}callback(e,i){return Ip(this,void 0,void 0,function*(){let{proxy:r,secureProxy:n}=this,s;n?(Mi("Creating `tls.Socket`: %o",r),s=Sa.default.connect(r)):(Mi("Creating `net.Socket`: %o",r),s=Ea.default.connect(r));let o=Object.assign({},r.headers),l=`CONNECT ${`${i.host}:${i.port}`} HTTP/1.1\r
`;r.auth&&(o["Proxy-Authorization"]=`Basic ${Buffer.from(r.auth).toString("base64")}`);let{host:c,port:u,secureEndpoint:f}=i;Pp(u,f)||(c+=`:${u}`),o.Host=c,o.Connection="close";for(let g of Object.keys(o))l+=`${g}: ${o[g]}\r
`;let h=Lp.default(s);s.write(`${l}\r
`);let{statusCode:p,buffered:d}=yield h;if(p===200){if(e.once("socket",Np),i.secureEndpoint){let g=i.servername||i.host;if(!g)throw new Error('Could not determine "servername"');return Mi("Upgrading socket connection to TLS"),Sa.default.connect(Object.assign(Object.assign({},Mp(i,"host","hostname","path","port")),{socket:s,servername:g}))}return s}s.destroy();let m=new Ea.default.Socket;return m.readable=!0,e.once("socket",g=>{Mi("replaying proxy buffer for failed request"),Ap.default(g.listenerCount("data")>0),g.push(d),g.push(null)}),m})}};Lt.default=un;function Np(t){t.resume()}function Pp(t,e){return Boolean(!e&&t===80||e&&t===443)}function Fp(t){return typeof t=="string"?/^https:?$/i.test(t):!1}function Mp(t,...e){let i={},r;for(r in t)e.includes(r)||(i[r]=t[r]);return i}});var Oa=x((pn,Ca)=>{"use strict";var Up=pn&&pn.__importDefault||function(t){return t&&t.__esModule?t:{default:t}},fn=Up(ka());function hn(t){return new fn.default(t)}(function(t){t.HttpsProxyAgent=fn.default,t.prototype=fn.default.prototype})(hn||(hn={}));Ca.exports=hn});var Aa=x((x_,xr)=>{var Ta=Ta||function(t){return Buffer.from(t).toString("base64")};function Dp(t){var e=this,i=Math.round,r=Math.floor,n=new Array(64),s=new Array(64),o=new Array(64),a=new Array(64),l,c,u,f,h=new Array(65535),p=new Array(65535),d=new Array(64),m=new Array(64),g=[],y=0,I=7,w=new Array(64),S=new Array(64),b=new Array(64),$=new Array(256),C=new Array(2048),U,E=[0,1,5,6,14,15,27,28,2,4,7,13,16,26,29,42,3,8,12,17,25,30,41,43,9,11,18,24,31,40,44,53,10,19,23,32,39,45,52,54,20,22,33,38,46,51,55,60,21,34,37,47,50,56,59,61,35,36,48,49,57,58,62,63],T=[0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0],B=[0,1,2,3,4,5,6,7,8,9,10,11],G=[0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,125],L=[1,2,3,0,4,17,5,18,33,49,65,6,19,81,97,7,34,113,20,50,129,145,161,8,35,66,177,193,21,82,209,240,36,51,98,114,130,9,10,22,23,24,25,26,37,38,39,40,41,42,52,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,225,226,227,228,229,230,231,232,233,234,241,242,243,244,245,246,247,248,249,250],Q=[0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0],R=[0,1,2,3,4,5,6,7,8,9,10,11],F=[0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,119],j=[0,1,2,3,17,4,5,33,49,6,18,65,81,7,97,113,19,34,50,129,8,20,66,145,161,177,193,9,35,51,82,240,21,98,114,209,10,22,36,52,225,37,241,23,24,25,26,38,39,40,41,42,53,54,55,56,57,58,67,68,69,70,71,72,73,74,83,84,85,86,87,88,89,90,99,100,101,102,103,104,105,106,115,116,117,118,119,120,121,122,130,131,132,133,134,135,136,137,138,146,147,148,149,150,151,152,153,154,162,163,164,165,166,167,168,169,170,178,179,180,181,182,183,184,185,186,194,195,196,197,198,199,200,201,202,210,211,212,213,214,215,216,217,218,226,227,228,229,230,231,232,233,234,242,243,244,245,246,247,248,249,250];function z(v){for(var D=[16,11,10,16,24,40,51,61,12,12,14,19,26,58,60,55,14,13,16,24,40,57,69,56,14,17,22,29,51,87,80,62,18,22,37,56,68,109,103,77,24,35,55,64,81,104,113,92,49,64,78,87,103,121,120,101,72,92,95,98,112,100,103,99],W=0;W<64;W++){var V=r((D[W]*v+50)/100);V<1?V=1:V>255&&(V=255),n[E[W]]=V}for(var J=[17,18,24,47,99,99,99,99,18,21,26,66,99,99,99,99,24,26,56,99,99,99,99,99,47,66,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99,99],ee=0;ee<64;ee++){var he=r((J[ee]*v+50)/100);he<1?he=1:he>255&&(he=255),s[E[ee]]=he}for(var pe=[1,1.387039845,1.306562965,1.175875602,1,.785694958,.5411961,.275899379],Oe=0,be=0;be<8;be++)for(var O=0;O<8;O++)o[Oe]=1/(n[E[Oe]]*pe[be]*pe[O]*8),a[Oe]=1/(s[E[Oe]]*pe[be]*pe[O]*8),Oe++}function N(v,D){for(var W=0,V=0,J=new Array,ee=1;ee<=16;ee++){for(var he=1;he<=v[ee];he++)J[D[V]]=[],J[D[V]][0]=W,J[D[V]][1]=ee,V++,W++;W*=2}return J}function Se(){l=N(T,B),c=N(Q,R),u=N(G,L),f=N(F,j)}function ce(){for(var v=1,D=2,W=1;W<=15;W++){for(var V=v;V<D;V++)p[32767+V]=W,h[32767+V]=[],h[32767+V][1]=W,h[32767+V][0]=V;for(var J=-(D-1);J<=-v;J++)p[32767+J]=W,h[32767+J]=[],h[32767+J][1]=W,h[32767+J][0]=D-1+J;v<<=1,D<<=1}}function re(){for(var v=0;v<256;v++)C[v]=19595*v,C[v+256>>0]=38470*v,C[v+512>>0]=7471*v+32768,C[v+768>>0]=-11059*v,C[v+1024>>0]=-21709*v,C[v+1280>>0]=32768*v+8421375,C[v+1536>>0]=-27439*v,C[v+1792>>0]=-5329*v}function ne(v){for(var D=v[0],W=v[1]-1;W>=0;)D&1<<W&&(y|=1<<I),W--,I--,I<0&&(y==255?(_(255),_(0)):_(y),I=7,y=0)}function _(v){g.push(v)}function q(v){_(v>>8&255),_(v&255)}function ge(v,D){var W,V,J,ee,he,pe,Oe,be,O=0,M,Z=8,ke=64;for(M=0;M<Z;++M){W=v[O],V=v[O+1],J=v[O+2],ee=v[O+3],he=v[O+4],pe=v[O+5],Oe=v[O+6],be=v[O+7];var te=W+be,le=W-be,_e=V+Oe,Y=V-Oe,de=J+pe,Fe=J-pe,Ee=ee+he,Xe=ee-he,at=te+Ee,At=te-Ee,Kt=_e+de,Zt=_e-de;v[O]=at+Kt,v[O+4]=at-Kt;var Oi=(Zt+At)*.707106781;v[O+2]=At+Oi,v[O+6]=At-Oi,at=Xe+Fe,Kt=Fe+Y,Zt=Y+le;var Ii=(at-Zt)*.382683433,cr=.5411961*at+Ii,Ti=1.306562965*Zt+Ii,Ai=Kt*.707106781,Ri=le+Ai,Bi=le-Ai;v[O+5]=Bi+cr,v[O+3]=Bi-cr,v[O+1]=Ri+Ti,v[O+7]=Ri-Ti,O+=8}for(O=0,M=0;M<Z;++M){W=v[O],V=v[O+8],J=v[O+16],ee=v[O+24],he=v[O+32],pe=v[O+40],Oe=v[O+48],be=v[O+56];var yo=W+be,Qr=W-be,bo=V+Oe,wo=V-Oe,Eo=J+pe,So=J-pe,ko=ee+he,Ch=ee-he,Li=yo+ko,Jr=yo-ko,ur=bo+Eo,fr=bo-Eo;v[O]=Li+ur,v[O+32]=Li-ur;var Co=(fr+Jr)*.707106781;v[O+16]=Jr+Co,v[O+48]=Jr-Co,Li=Ch+So,ur=So+wo,fr=wo+Qr;var Oo=(Li-fr)*.382683433,Io=.5411961*Li+Oo,To=1.306562965*fr+Oo,Ao=ur*.707106781,Ro=Qr+Ao,Bo=Qr-Ao;v[O+40]=Bo+Io,v[O+24]=Bo-Io,v[O+8]=Ro+To,v[O+56]=Ro-To,O++}var hr;for(M=0;M<ke;++M)hr=v[M]*D[M],d[M]=hr>0?hr+.5|0:hr-.5|0;return d}function ve(){q(65504),q(16),_(74),_(70),_(73),_(70),_(0),_(1),_(1),_(0),q(1),q(1),_(0),_(0)}function ue(v){if(!!v){q(65505),v[0]===69&&v[1]===120&&v[2]===105&&v[3]===102?q(v.length+2):(q(v.length+5+2),_(69),_(120),_(105),_(102),_(0));for(var D=0;D<v.length;D++)_(v[D])}}function fe(v,D){q(65472),q(17),_(8),q(D),q(v),_(3),_(1),_(17),_(0),_(2),_(17),_(1),_(3),_(17),_(1)}function se(){q(65499),q(132),_(0);for(var v=0;v<64;v++)_(n[v]);_(1);for(var D=0;D<64;D++)_(s[D])}function P(){q(65476),q(418),_(0);for(var v=0;v<16;v++)_(T[v+1]);for(var D=0;D<=11;D++)_(B[D]);_(16);for(var W=0;W<16;W++)_(G[W+1]);for(var V=0;V<=161;V++)_(L[V]);_(1);for(var J=0;J<16;J++)_(Q[J+1]);for(var ee=0;ee<=11;ee++)_(R[ee]);_(17);for(var he=0;he<16;he++)_(F[he+1]);for(var pe=0;pe<=161;pe++)_(j[pe])}function A(v){typeof v=="undefined"||v.constructor!==Array||v.forEach(D=>{if(typeof D=="string"){q(65534);var W=D.length;q(W+2);var V;for(V=0;V<W;V++)_(D.charCodeAt(V))}})}function ye(){q(65498),q(12),_(3),_(1),_(0),_(2),_(17),_(3),_(17),_(0),_(63),_(0)}function K(v,D,W,V,J){for(var ee=J[0],he=J[240],pe,Oe=16,be=63,O=64,M=ge(v,D),Z=0;Z<O;++Z)m[E[Z]]=M[Z];var ke=m[0]-W;W=m[0],ke==0?ne(V[0]):(pe=32767+ke,ne(V[p[pe]]),ne(h[pe]));for(var te=63;te>0&&m[te]==0;te--);if(te==0)return ne(ee),W;for(var le=1,_e;le<=te;){for(var Y=le;m[le]==0&&le<=te;++le);var de=le-Y;if(de>=Oe){_e=de>>4;for(var Fe=1;Fe<=_e;++Fe)ne(he);de=de&15}pe=32767+m[le],ne(J[(de<<4)+p[pe]]),ne(h[pe]),le++}return te!=be&&ne(ee),W}function oe(){for(var v=String.fromCharCode,D=0;D<256;D++)$[D]=v(D)}this.encode=function(v,D){var W=new Date().getTime();D&&Ze(D),g=new Array,y=0,I=7,q(65496),ve(),A(v.comments),ue(v.exifBuffer),se(),fe(v.width,v.height),P(),ye();var V=0,J=0,ee=0;y=0,I=7,this.encode.displayName="_encode_";for(var he=v.data,pe=v.width,Oe=v.height,be=pe*4,O=pe*3,M,Z=0,ke,te,le,_e,Y,de,Fe,Ee;Z<Oe;){for(M=0;M<be;){for(_e=be*Z+M,Y=_e,de=-1,Fe=0,Ee=0;Ee<64;Ee++)Fe=Ee>>3,de=(Ee&7)*4,Y=_e+Fe*be+de,Z+Fe>=Oe&&(Y-=be*(Z+1+Fe-Oe)),M+de>=be&&(Y-=M+de-be+4),ke=he[Y++],te=he[Y++],le=he[Y++],w[Ee]=(C[ke]+C[te+256>>0]+C[le+512>>0]>>16)-128,S[Ee]=(C[ke+768>>0]+C[te+1024>>0]+C[le+1280>>0]>>16)-128,b[Ee]=(C[ke+1280>>0]+C[te+1536>>0]+C[le+1792>>0]>>16)-128;V=K(w,o,V,l,u),J=K(S,a,J,c,f),ee=K(b,a,ee,c,f),M+=32}Z+=8}if(I>=0){var Xe=[];Xe[1]=I+1,Xe[0]=(1<<I+1)-1,ne(Xe)}if(q(65497),typeof xr=="undefined")return new Uint8Array(g);return Buffer.from(g);var at,At};function Ze(v){if(v<=0&&(v=1),v>100&&(v=100),U!=v){var D=0;v<50?D=Math.floor(5e3/v):D=Math.floor(200-v*2),z(D),U=v}}function tt(){var v=new Date().getTime();t||(t=50),oe(),Se(),ce(),re(),Ze(t);var D=new Date().getTime()-v}tt()}typeof xr!="undefined"?xr.exports=Ia:typeof window!="undefined"&&(window["jpeg-js"]=window["jpeg-js"]||{},window["jpeg-js"].encode=Ia);function Ia(t,e){typeof e=="undefined"&&(e=50);var i=new Dp(e),r=i.encode(t,e);return{data:r,width:t.width,height:t.height}}});var Ba=x((y_,mn)=>{var dn=function(){"use strict";var e=new Int32Array([0,1,8,16,9,2,3,10,17,24,32,25,18,11,4,5,12,19,26,33,40,48,41,34,27,20,13,6,7,14,21,28,35,42,49,56,57,50,43,36,29,22,15,23,30,37,44,51,58,59,52,45,38,31,39,46,53,60,61,54,47,55,62,63]),i=4017,r=799,n=3406,s=2276,o=1567,a=3784,l=5793,c=2896;function u(){}function f(I,w){for(var S=0,b=[],$,C,U=16;U>0&&!I[U-1];)U--;b.push({children:[],index:0});var E=b[0],T;for($=0;$<U;$++){for(C=0;C<I[$];C++){for(E=b.pop(),E.children[E.index]=w[S];E.index>0;){if(b.length===0)throw new Error("Could not recreate Huffman Table");E=b.pop()}for(E.index++,b.push(E);b.length<=$;)b.push(T={children:[],index:0}),E.children[E.index]=T.children,E=T;S++}$+1<U&&(b.push(T={children:[],index:0}),E.children[E.index]=T.children,E=T)}return b[0].children}function h(I,w,S,b,$,C,U,E,T,B){var G=S.precision,L=S.samplesPerLine,Q=S.scanLines,R=S.mcusPerLine,F=S.progressive,j=S.maxH,z=S.maxV,N=w,Se=0,ce=0;function re(){if(ce>0)return ce--,Se>>ce&1;if(Se=I[w++],Se==255){var O=I[w++];if(O)throw new Error("unexpected marker: "+(Se<<8|O).toString(16))}return ce=7,Se>>>7}function ne(O){for(var M=O,Z;(Z=re())!==null;){if(M=M[Z],typeof M=="number")return M;if(typeof M!="object")throw new Error("invalid huffman sequence")}return null}function _(O){for(var M=0;O>0;){var Z=re();if(Z===null)return;M=M<<1|Z,O--}return M}function q(O){var M=_(O);return M>=1<<O-1?M:M+(-1<<O)+1}function ge(O,M){var Z=ne(O.huffmanTableDC),ke=Z===0?0:q(Z);M[0]=O.pred+=ke;for(var te=1;te<64;){var le=ne(O.huffmanTableAC),_e=le&15,Y=le>>4;if(_e===0){if(Y<15)break;te+=16;continue}te+=Y;var de=e[te];M[de]=q(_e),te++}}function ve(O,M){var Z=ne(O.huffmanTableDC),ke=Z===0?0:q(Z)<<T;M[0]=O.pred+=ke}function ue(O,M){M[0]|=re()<<T}var fe=0;function se(O,M){if(fe>0){fe--;return}for(var Z=C,ke=U;Z<=ke;){var te=ne(O.huffmanTableAC),le=te&15,_e=te>>4;if(le===0){if(_e<15){fe=_(_e)+(1<<_e)-1;break}Z+=16;continue}Z+=_e;var Y=e[Z];M[Y]=q(le)*(1<<T),Z++}}var P=0,A;function ye(O,M){for(var Z=C,ke=U,te=0;Z<=ke;){var le=e[Z],_e=M[le]<0?-1:1;switch(P){case 0:var Y=ne(O.huffmanTableAC),de=Y&15,te=Y>>4;if(de===0)te<15?(fe=_(te)+(1<<te),P=4):(te=16,P=1);else{if(de!==1)throw new Error("invalid ACn encoding");A=q(de),P=te?2:3}continue;case 1:case 2:M[le]?M[le]+=(re()<<T)*_e:(te--,te===0&&(P=P==2?3:0));break;case 3:M[le]?M[le]+=(re()<<T)*_e:(M[le]=A<<T,P=0);break;case 4:M[le]&&(M[le]+=(re()<<T)*_e);break}Z++}P===4&&(fe--,fe===0&&(P=0))}function K(O,M,Z,ke,te){var le=Z/R|0,_e=Z%R,Y=le*O.v+ke,de=_e*O.h+te;O.blocks[Y]===void 0&&B.tolerantDecoding||M(O,O.blocks[Y][de])}function oe(O,M,Z){var ke=Z/O.blocksPerLine|0,te=Z%O.blocksPerLine;O.blocks[ke]===void 0&&B.tolerantDecoding||M(O,O.blocks[ke][te])}var Ze=b.length,tt,v,D,W,V,J;F?C===0?J=E===0?ve:ue:J=E===0?se:ye:J=ge;var ee=0,he,pe;Ze==1?pe=b[0].blocksPerLine*b[0].blocksPerColumn:pe=R*S.mcusPerColumn,$||($=pe);for(var Oe,be;ee<pe;){for(v=0;v<Ze;v++)b[v].pred=0;if(fe=0,Ze==1)for(tt=b[0],V=0;V<$;V++)oe(tt,J,ee),ee++;else for(V=0;V<$;V++){for(v=0;v<Ze;v++)for(tt=b[v],Oe=tt.h,be=tt.v,D=0;D<be;D++)for(W=0;W<Oe;W++)K(tt,J,ee,D,W);if(ee++,ee===pe)break}if(ee===pe)do{if(I[w]===255&&I[w+1]!==0)break;w+=1}while(w<I.length-2);if(ce=0,he=I[w]<<8|I[w+1],he<65280)throw new Error("marker was not found");if(he>=65488&&he<=65495)w+=2;else break}return w-N}function p(I,w){var S=[],b=w.blocksPerLine,$=w.blocksPerColumn,C=b<<3,U=new Int32Array(64),E=new Uint8Array(64);function T(N,Se,ce){var re=w.quantizationTable,ne,_,q,ge,ve,ue,fe,se,P,A=ce,ye;for(ye=0;ye<64;ye++)A[ye]=N[ye]*re[ye];for(ye=0;ye<8;++ye){var K=8*ye;if(A[1+K]==0&&A[2+K]==0&&A[3+K]==0&&A[4+K]==0&&A[5+K]==0&&A[6+K]==0&&A[7+K]==0){P=l*A[0+K]+512>>10,A[0+K]=P,A[1+K]=P,A[2+K]=P,A[3+K]=P,A[4+K]=P,A[5+K]=P,A[6+K]=P,A[7+K]=P;continue}ne=l*A[0+K]+128>>8,_=l*A[4+K]+128>>8,q=A[2+K],ge=A[6+K],ve=c*(A[1+K]-A[7+K])+128>>8,se=c*(A[1+K]+A[7+K])+128>>8,ue=A[3+K]<<4,fe=A[5+K]<<4,P=ne-_+1>>1,ne=ne+_+1>>1,_=P,P=q*a+ge*o+128>>8,q=q*o-ge*a+128>>8,ge=P,P=ve-fe+1>>1,ve=ve+fe+1>>1,fe=P,P=se+ue+1>>1,ue=se-ue+1>>1,se=P,P=ne-ge+1>>1,ne=ne+ge+1>>1,ge=P,P=_-q+1>>1,_=_+q+1>>1,q=P,P=ve*s+se*n+2048>>12,ve=ve*n-se*s+2048>>12,se=P,P=ue*r+fe*i+2048>>12,ue=ue*i-fe*r+2048>>12,fe=P,A[0+K]=ne+se,A[7+K]=ne-se,A[1+K]=_+fe,A[6+K]=_-fe,A[2+K]=q+ue,A[5+K]=q-ue,A[3+K]=ge+ve,A[4+K]=ge-ve}for(ye=0;ye<8;++ye){var oe=ye;if(A[8+oe]==0&&A[16+oe]==0&&A[24+oe]==0&&A[32+oe]==0&&A[40+oe]==0&&A[48+oe]==0&&A[56+oe]==0){P=l*ce[ye+0]+8192>>14,A[0+oe]=P,A[8+oe]=P,A[16+oe]=P,A[24+oe]=P,A[32+oe]=P,A[40+oe]=P,A[48+oe]=P,A[56+oe]=P;continue}ne=l*A[0+oe]+2048>>12,_=l*A[32+oe]+2048>>12,q=A[16+oe],ge=A[48+oe],ve=c*(A[8+oe]-A[56+oe])+2048>>12,se=c*(A[8+oe]+A[56+oe])+2048>>12,ue=A[24+oe],fe=A[40+oe],P=ne-_+1>>1,ne=ne+_+1>>1,_=P,P=q*a+ge*o+2048>>12,q=q*o-ge*a+2048>>12,ge=P,P=ve-fe+1>>1,ve=ve+fe+1>>1,fe=P,P=se+ue+1>>1,ue=se-ue+1>>1,se=P,P=ne-ge+1>>1,ne=ne+ge+1>>1,ge=P,P=_-q+1>>1,_=_+q+1>>1,q=P,P=ve*s+se*n+2048>>12,ve=ve*n-se*s+2048>>12,se=P,P=ue*r+fe*i+2048>>12,ue=ue*i-fe*r+2048>>12,fe=P,A[0+oe]=ne+se,A[56+oe]=ne-se,A[8+oe]=_+fe,A[48+oe]=_-fe,A[16+oe]=q+ue,A[40+oe]=q-ue,A[24+oe]=ge+ve,A[32+oe]=ge-ve}for(ye=0;ye<64;++ye){var Ze=128+(A[ye]+8>>4);Se[ye]=Ze<0?0:Ze>255?255:Ze}}y(C*$*8);for(var B,G,L=0;L<$;L++){var Q=L<<3;for(B=0;B<8;B++)S.push(new Uint8Array(C));for(var R=0;R<b;R++){T(w.blocks[L][R],E,U);var F=0,j=R<<3;for(G=0;G<8;G++){var z=S[Q+G];for(B=0;B<8;B++)z[j+B]=E[F++]}}}return S}function d(I){return I<0?0:I>255?255:I}u.prototype={load:function(w){var S=new XMLHttpRequest;S.open("GET",w,!0),S.responseType="arraybuffer",S.onload=function(){var b=new Uint8Array(S.response||S.mozResponseArrayBuffer);this.parse(b),this.onload&&this.onload()}.bind(this),S.send(null)},parse:function(w){var S=this.opts.maxResolutionInMP*1e3*1e3,b=0,$=w.length;function C(){var Y=w[b]<<8|w[b+1];return b+=2,Y}function U(){var Y=C(),de=w.subarray(b,b+Y-2);return b+=de.length,de}function E(Y){var de=1,Fe=1,Ee,Xe;for(Xe in Y.components)Y.components.hasOwnProperty(Xe)&&(Ee=Y.components[Xe],de<Ee.h&&(de=Ee.h),Fe<Ee.v&&(Fe=Ee.v));var at=Math.ceil(Y.samplesPerLine/8/de),At=Math.ceil(Y.scanLines/8/Fe);for(Xe in Y.components)if(Y.components.hasOwnProperty(Xe)){Ee=Y.components[Xe];var Kt=Math.ceil(Math.ceil(Y.samplesPerLine/8)*Ee.h/de),Zt=Math.ceil(Math.ceil(Y.scanLines/8)*Ee.v/Fe),Oi=at*Ee.h,Ii=At*Ee.v,cr=Ii*Oi,Ti=[];y(cr*256);for(var Ai=0;Ai<Ii;Ai++){for(var Ri=[],Bi=0;Bi<Oi;Bi++)Ri.push(new Int32Array(64));Ti.push(Ri)}Ee.blocksPerLine=Kt,Ee.blocksPerColumn=Zt,Ee.blocks=Ti}Y.maxH=de,Y.maxV=Fe,Y.mcusPerLine=at,Y.mcusPerColumn=At}var T=null,B=null,G=null,L,Q,R=[],F=[],j=[],z=[],N=C(),Se=-1;if(this.comments=[],N!=65496)throw new Error("SOI not found");for(N=C();N!=65497;){var ce,re,ne;switch(N){case 65280:break;case 65504:case 65505:case 65506:case 65507:case 65508:case 65509:case 65510:case 65511:case 65512:case 65513:case 65514:case 65515:case 65516:case 65517:case 65518:case 65519:case 65534:var _=U();if(N===65534){var q=String.fromCharCode.apply(null,_);this.comments.push(q)}N===65504&&_[0]===74&&_[1]===70&&_[2]===73&&_[3]===70&&_[4]===0&&(T={version:{major:_[5],minor:_[6]},densityUnits:_[7],xDensity:_[8]<<8|_[9],yDensity:_[10]<<8|_[11],thumbWidth:_[12],thumbHeight:_[13],thumbData:_.subarray(14,14+3*_[12]*_[13])}),N===65505&&_[0]===69&&_[1]===120&&_[2]===105&&_[3]===102&&_[4]===0&&(this.exifBuffer=_.subarray(5,_.length)),N===65518&&_[0]===65&&_[1]===100&&_[2]===111&&_[3]===98&&_[4]===101&&_[5]===0&&(B={version:_[6],flags0:_[7]<<8|_[8],flags1:_[9]<<8|_[10],transformCode:_[11]});break;case 65499:for(var ge=C(),ve=ge+b-2;b<ve;){var ue=w[b++];y(256);var fe=new Int32Array(64);if(ue>>4===0)for(re=0;re<64;re++){var se=e[re];fe[se]=w[b++]}else if(ue>>4===1)for(re=0;re<64;re++){var se=e[re];fe[se]=C()}else throw new Error("DQT: invalid table spec");R[ue&15]=fe}break;case 65472:case 65473:case 65474:C(),L={},L.extended=N===65473,L.progressive=N===65474,L.precision=w[b++],L.scanLines=C(),L.samplesPerLine=C(),L.components={},L.componentsOrder=[];var P=L.scanLines*L.samplesPerLine;if(P>S){var A=Math.ceil((P-S)/1e6);throw new Error(`maxResolutionInMP limit exceeded by ${A}MP`)}var ye=w[b++],K,oe=0,Ze=0;for(ce=0;ce<ye;ce++){K=w[b];var tt=w[b+1]>>4,v=w[b+1]&15,D=w[b+2];if(tt<=0||v<=0)throw new Error("Invalid sampling factor, expected values above 0");L.componentsOrder.push(K),L.components[K]={h:tt,v,quantizationIdx:D},b+=3}E(L),F.push(L);break;case 65476:var W=C();for(ce=2;ce<W;){var V=w[b++],J=new Uint8Array(16),ee=0;for(re=0;re<16;re++,b++)ee+=J[re]=w[b];y(16+ee);var he=new Uint8Array(ee);for(re=0;re<ee;re++,b++)he[re]=w[b];ce+=17+ee,(V>>4===0?z:j)[V&15]=f(J,he)}break;case 65501:C(),Q=C();break;case 65500:C(),C();break;case 65498:var pe=C(),Oe=w[b++],be=[],O;for(ce=0;ce<Oe;ce++){O=L.components[w[b++]];var M=w[b++];O.huffmanTableDC=z[M>>4],O.huffmanTableAC=j[M&15],be.push(O)}var Z=w[b++],ke=w[b++],te=w[b++],le=h(w,b,L,be,Q,Z,ke,te>>4,te&15,this.opts);b+=le;break;case 65535:w[b]!==255&&b--;break;default:if(w[b-3]==255&&w[b-2]>=192&&w[b-2]<=254){b-=3;break}else if(N===224||N==225){if(Se!==-1)throw new Error(`first unknown JPEG marker at offset ${Se.toString(16)}, second unknown JPEG marker ${N.toString(16)} at offset ${(b-1).toString(16)}`);Se=b-1;let Y=C();if(w[b+Y-2]===255){b+=Y-2;break}}throw new Error("unknown JPEG marker "+N.toString(16))}N=C()}if(F.length!=1)throw new Error("only single frame JPEGs supported");for(var ce=0;ce<F.length;ce++){var _e=F[ce].components;for(var re in _e)_e[re].quantizationTable=R[_e[re].quantizationIdx],delete _e[re].quantizationIdx}this.width=L.samplesPerLine,this.height=L.scanLines,this.jfif=T,this.adobe=B,this.components=[];for(var ce=0;ce<L.componentsOrder.length;ce++){var O=L.components[L.componentsOrder[ce]];this.components.push({lines:p(L,O),scaleX:O.h/L.maxH,scaleY:O.v/L.maxV})}},getData:function(w,S){var b=this.width/w,$=this.height/S,C,U,E,T,B,G,L,Q,R,F,j=0,z,N,Se,ce,re,ne,_,q,ge,ve,ue,fe=w*S*this.components.length;y(fe);var se=new Uint8Array(fe);switch(this.components.length){case 1:for(C=this.components[0],F=0;F<S;F++)for(B=C.lines[0|F*C.scaleY*$],R=0;R<w;R++)z=B[0|R*C.scaleX*b],se[j++]=z;break;case 2:for(C=this.components[0],U=this.components[1],F=0;F<S;F++)for(B=C.lines[0|F*C.scaleY*$],G=U.lines[0|F*U.scaleY*$],R=0;R<w;R++)z=B[0|R*C.scaleX*b],se[j++]=z,z=G[0|R*U.scaleX*b],se[j++]=z;break;case 3:for(ue=!0,this.adobe&&this.adobe.transformCode?ue=!0:typeof this.opts.colorTransform!="undefined"&&(ue=!!this.opts.colorTransform),C=this.components[0],U=this.components[1],E=this.components[2],F=0;F<S;F++)for(B=C.lines[0|F*C.scaleY*$],G=U.lines[0|F*U.scaleY*$],L=E.lines[0|F*E.scaleY*$],R=0;R<w;R++)ue?(z=B[0|R*C.scaleX*b],N=G[0|R*U.scaleX*b],Se=L[0|R*E.scaleX*b],q=d(z+1.402*(Se-128)),ge=d(z-.3441363*(N-128)-.71413636*(Se-128)),ve=d(z+1.772*(N-128))):(q=B[0|R*C.scaleX*b],ge=G[0|R*U.scaleX*b],ve=L[0|R*E.scaleX*b]),se[j++]=q,se[j++]=ge,se[j++]=ve;break;case 4:if(!this.adobe)throw new Error("Unsupported color mode (4 components)");for(ue=!1,this.adobe&&this.adobe.transformCode?ue=!0:typeof this.opts.colorTransform!="undefined"&&(ue=!!this.opts.colorTransform),C=this.components[0],U=this.components[1],E=this.components[2],T=this.components[3],F=0;F<S;F++)for(B=C.lines[0|F*C.scaleY*$],G=U.lines[0|F*U.scaleY*$],L=E.lines[0|F*E.scaleY*$],Q=T.lines[0|F*T.scaleY*$],R=0;R<w;R++)ue?(z=B[0|R*C.scaleX*b],N=G[0|R*U.scaleX*b],Se=L[0|R*E.scaleX*b],ce=Q[0|R*T.scaleX*b],re=255-d(z+1.402*(Se-128)),ne=255-d(z-.3441363*(N-128)-.71413636*(Se-128)),_=255-d(z+1.772*(N-128))):(re=B[0|R*C.scaleX*b],ne=G[0|R*U.scaleX*b],_=L[0|R*E.scaleX*b],ce=Q[0|R*T.scaleX*b]),se[j++]=255-re,se[j++]=255-ne,se[j++]=255-_,se[j++]=255-ce;break;default:throw new Error("Unsupported color mode")}return se},copyToImageData:function(w,S){var b=w.width,$=w.height,C=w.data,U=this.getData(b,$),E=0,T=0,B,G,L,Q,R,F,j,z,N;switch(this.components.length){case 1:for(G=0;G<$;G++)for(B=0;B<b;B++)L=U[E++],C[T++]=L,C[T++]=L,C[T++]=L,S&&(C[T++]=255);break;case 3:for(G=0;G<$;G++)for(B=0;B<b;B++)j=U[E++],z=U[E++],N=U[E++],C[T++]=j,C[T++]=z,C[T++]=N,S&&(C[T++]=255);break;case 4:for(G=0;G<$;G++)for(B=0;B<b;B++)R=U[E++],F=U[E++],L=U[E++],Q=U[E++],j=255-d(R*(1-Q/255)+Q),z=255-d(F*(1-Q/255)+Q),N=255-d(L*(1-Q/255)+Q),C[T++]=j,C[T++]=z,C[T++]=N,S&&(C[T++]=255);break;default:throw new Error("Unsupported color mode")}}};var m=0,g=0;function y(I=0){var w=m+I;if(w>g){var S=Math.ceil((w-g)/1024/1024);throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${S}MB`)}m=w}return u.resetMaxMemoryUsage=function(I){m=0,g=I},u.getBytesAllocated=function(){return m},u.requestMemoryAllocation=y,u}();typeof mn!="undefined"?mn.exports=Ra:typeof window!="undefined"&&(window["jpeg-js"]=window["jpeg-js"]||{},window["jpeg-js"].decode=Ra);function Ra(t,e={}){var i={colorTransform:void 0,useTArray:!1,formatAsRGBA:!0,tolerantDecoding:!0,maxResolutionInMP:100,maxMemoryUsageInMB:512},r={...i,...e},n=new Uint8Array(t),s=new dn;s.opts=r,dn.resetMaxMemoryUsage(r.maxMemoryUsageInMB*1024*1024),s.parse(n);var o=r.formatAsRGBA?4:3,a=s.width*s.height*o;try{dn.requestMemoryAllocation(a);var l={width:s.width,height:s.height,exifBuffer:s.exifBuffer,data:r.useTArray?new Uint8Array(a):Buffer.alloc(a)};s.comments.length>0&&(l.comments=s.comments)}catch(c){throw c instanceof RangeError?new Error("Could not allocate enough memory for the image. Required: "+a):c instanceof ReferenceError&&c.message==="Buffer is not defined"?new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true"):c}return s.copyToImageData(l,r.formatAsRGBA),l}});var Na=x((b_,La)=>{var jp=Aa(),qp=Ba();La.exports={encode:jp,decode:qp}});var Fa=x((w_,Pa)=>{var vt=__nccwpck_require__(2057),Hp=process.cwd,yr=null,Vp=process.env.GRACEFUL_FS_PLATFORM||process.platform;process.cwd=function(){return yr||(yr=Hp.call(process)),yr};try{process.cwd()}catch{}typeof process.chdir=="function"&&(gn=process.chdir,process.chdir=function(t){yr=null,gn.call(process,t)},Object.setPrototypeOf&&Object.setPrototypeOf(process.chdir,gn));var gn;Pa.exports=$p;function $p(t){vt.hasOwnProperty("O_SYMLINK")&&process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)&&e(t),t.lutimes||i(t),t.chown=s(t.chown),t.fchown=s(t.fchown),t.lchown=s(t.lchown),t.chmod=r(t.chmod),t.fchmod=r(t.fchmod),t.lchmod=r(t.lchmod),t.chownSync=o(t.chownSync),t.fchownSync=o(t.fchownSync),t.lchownSync=o(t.lchownSync),t.chmodSync=n(t.chmodSync),t.fchmodSync=n(t.fchmodSync),t.lchmodSync=n(t.lchmodSync),t.stat=a(t.stat),t.fstat=a(t.fstat),t.lstat=a(t.lstat),t.statSync=l(t.statSync),t.fstatSync=l(t.fstatSync),t.lstatSync=l(t.lstatSync),t.chmod&&!t.lchmod&&(t.lchmod=function(u,f,h){h&&process.nextTick(h)},t.lchmodSync=function(){}),t.chown&&!t.lchown&&(t.lchown=function(u,f,h,p){p&&process.nextTick(p)},t.lchownSync=function(){}),Vp==="win32"&&(t.rename=typeof t.rename!="function"?t.rename:function(u){function f(h,p,d){var m=Date.now(),g=0;u(h,p,function y(I){if(I&&(I.code==="EACCES"||I.code==="EPERM")&&Date.now()-m<6e4){setTimeout(function(){t.stat(p,function(w,S){w&&w.code==="ENOENT"?u(h,p,y):d(I)})},g),g<100&&(g+=10);return}d&&d(I)})}return Object.setPrototypeOf&&Object.setPrototypeOf(f,u),f}(t.rename)),t.read=typeof t.read!="function"?t.read:function(u){function f(h,p,d,m,g,y){var I;if(y&&typeof y=="function"){var w=0;I=function(S,b,$){if(S&&S.code==="EAGAIN"&&w<10)return w++,u.call(t,h,p,d,m,g,I);y.apply(this,arguments)}}return u.call(t,h,p,d,m,g,I)}return Object.setPrototypeOf&&Object.setPrototypeOf(f,u),f}(t.read),t.readSync=typeof t.readSync!="function"?t.readSync:function(u){return function(f,h,p,d,m){for(var g=0;;)try{return u.call(t,f,h,p,d,m)}catch(y){if(y.code==="EAGAIN"&&g<10){g++;continue}throw y}}}(t.readSync);function e(u){u.lchmod=function(f,h,p){u.open(f,vt.O_WRONLY|vt.O_SYMLINK,h,function(d,m){if(d){p&&p(d);return}u.fchmod(m,h,function(g){u.close(m,function(y){p&&p(g||y)})})})},u.lchmodSync=function(f,h){var p=u.openSync(f,vt.O_WRONLY|vt.O_SYMLINK,h),d=!0,m;try{m=u.fchmodSync(p,h),d=!1}finally{if(d)try{u.closeSync(p)}catch{}else u.closeSync(p)}return m}}function i(u){vt.hasOwnProperty("O_SYMLINK")&&u.futimes?(u.lutimes=function(f,h,p,d){u.open(f,vt.O_SYMLINK,function(m,g){if(m){d&&d(m);return}u.futimes(g,h,p,function(y){u.close(g,function(I){d&&d(y||I)})})})},u.lutimesSync=function(f,h,p){var d=u.openSync(f,vt.O_SYMLINK),m,g=!0;try{m=u.futimesSync(d,h,p),g=!1}finally{if(g)try{u.closeSync(d)}catch{}else u.closeSync(d)}return m}):u.futimes&&(u.lutimes=function(f,h,p,d){d&&process.nextTick(d)},u.lutimesSync=function(){})}function r(u){return u&&function(f,h,p){return u.call(t,f,h,function(d){c(d)&&(d=null),p&&p.apply(this,arguments)})}}function n(u){return u&&function(f,h){try{return u.call(t,f,h)}catch(p){if(!c(p))throw p}}}function s(u){return u&&function(f,h,p,d){return u.call(t,f,h,p,function(m){c(m)&&(m=null),d&&d.apply(this,arguments)})}}function o(u){return u&&function(f,h,p){try{return u.call(t,f,h,p)}catch(d){if(!c(d))throw d}}}function a(u){return u&&function(f,h,p){typeof h=="function"&&(p=h,h=null);function d(m,g){g&&(g.uid<0&&(g.uid+=4294967296),g.gid<0&&(g.gid+=4294967296)),p&&p.apply(this,arguments)}return h?u.call(t,f,h,d):u.call(t,f,d)}}function l(u){return u&&function(f,h){var p=h?u.call(t,f,h):u.call(t,f);return p&&(p.uid<0&&(p.uid+=4294967296),p.gid<0&&(p.gid+=4294967296)),p}}function c(u){if(!u||u.code==="ENOSYS")return!0;var f=!process.getuid||process.getuid()!==0;return!!(f&&(u.code==="EINVAL"||u.code==="EPERM"))}}});var Da=x((E_,Ua)=>{var Ma=(__nccwpck_require__(2781).Stream);Ua.exports=Gp;function Gp(t){return{ReadStream:e,WriteStream:i};function e(r,n){if(!(this instanceof e))return new e(r,n);Ma.call(this);var s=this;this.path=r,this.fd=null,this.readable=!0,this.paused=!1,this.flags="r",this.mode=438,this.bufferSize=64*1024,n=n||{};for(var o=Object.keys(n),a=0,l=o.length;a<l;a++){var c=o[a];this[c]=n[c]}if(this.encoding&&this.setEncoding(this.encoding),this.start!==void 0){if(typeof this.start!="number")throw TypeError("start must be a Number");if(this.end===void 0)this.end=1/0;else if(typeof this.end!="number")throw TypeError("end must be a Number");if(this.start>this.end)throw new Error("start must be <= end");this.pos=this.start}if(this.fd!==null){process.nextTick(function(){s._read()});return}t.open(this.path,this.flags,this.mode,function(u,f){if(u){s.emit("error",u),s.readable=!1;return}s.fd=f,s.emit("open",f),s._read()})}function i(r,n){if(!(this instanceof i))return new i(r,n);Ma.call(this),this.path=r,this.fd=null,this.writable=!0,this.flags="w",this.encoding="binary",this.mode=438,this.bytesWritten=0,n=n||{};for(var s=Object.keys(n),o=0,a=s.length;o<a;o++){var l=s[o];this[l]=n[l]}if(this.start!==void 0){if(typeof this.start!="number")throw TypeError("start must be a Number");if(this.start<0)throw new Error("start must be >= zero");this.pos=this.start}this.busy=!1,this._queue=[],this.fd===null&&(this._open=t.open,this._queue.push([this._open,this.path,this.flags,this.mode,void 0]),this.flush())}}});var qa=x((S_,ja)=>{"use strict";ja.exports=Wp;var zp=Object.getPrototypeOf||function(t){return t.__proto__};function Wp(t){if(t===null||typeof t!="object")return t;if(t instanceof Object)var e={__proto__:zp(t)};else var e=Object.create(null);return Object.getOwnPropertyNames(t).forEach(function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(t,i))}),e}});var yn=x((k_,xn)=>{var Ie=__nccwpck_require__(7147),Yp=Fa(),Kp=Da(),Zp=qa(),br=__nccwpck_require__(3837),Ue,Er;typeof Symbol=="function"&&typeof Symbol.for=="function"?(Ue=Symbol.for("graceful-fs.queue"),Er=Symbol.for("graceful-fs.previous")):(Ue="___graceful-fs.queue",Er="___graceful-fs.previous");function Xp(){}function $a(t,e){Object.defineProperty(t,Ue,{get:function(){return e}})}var Nt=Xp;br.debuglog?Nt=br.debuglog("gfs4"):/\bgfs4\b/i.test(process.env.NODE_DEBUG||"")&&(Nt=function(){var t=br.format.apply(br,arguments);t="GFS4: "+t.split(/\n/).join(`
GFS4: `),console.error(t)});Ie[Ue]||(Ha=global[Ue]||[],$a(Ie,Ha),Ie.close=function(t){function e(i,r){return t.call(Ie,i,function(n){n||Va(),typeof r=="function"&&r.apply(this,arguments)})}return Object.defineProperty(e,Er,{value:t}),e}(Ie.close),Ie.closeSync=function(t){function e(i){t.apply(Ie,arguments),Va()}return Object.defineProperty(e,Er,{value:t}),e}(Ie.closeSync),/\bgfs4\b/i.test(process.env.NODE_DEBUG||"")&&process.on("exit",function(){Nt(Ie[Ue]),(__nccwpck_require__(9491).equal)(Ie[Ue].length,0)}));var Ha;global[Ue]||$a(global,Ie[Ue]);xn.exports=vn(Zp(Ie));process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH&&!Ie.__patched&&(xn.exports=vn(Ie),Ie.__patched=!0);function vn(t){Yp(t),t.gracefulify=vn,t.createReadStream=b,t.createWriteStream=$;var e=t.readFile;t.readFile=i;function i(E,T,B){return typeof T=="function"&&(B=T,T=null),G(E,T,B);function G(L,Q,R,F){return e(L,Q,function(j){j&&(j.code==="EMFILE"||j.code==="ENFILE")?si([G,[L,Q,R],j,F||Date.now(),Date.now()]):typeof R=="function"&&R.apply(this,arguments)})}}var r=t.writeFile;t.writeFile=n;function n(E,T,B,G){return typeof B=="function"&&(G=B,B=null),L(E,T,B,G);function L(Q,R,F,j,z){return r(Q,R,F,function(N){N&&(N.code==="EMFILE"||N.code==="ENFILE")?si([L,[Q,R,F,j],N,z||Date.now(),Date.now()]):typeof j=="function"&&j.apply(this,arguments)})}}var s=t.appendFile;s&&(t.appendFile=o);function o(E,T,B,G){return typeof B=="function"&&(G=B,B=null),L(E,T,B,G);function L(Q,R,F,j,z){return s(Q,R,F,function(N){N&&(N.code==="EMFILE"||N.code==="ENFILE")?si([L,[Q,R,F,j],N,z||Date.now(),Date.now()]):typeof j=="function"&&j.apply(this,arguments)})}}var a=t.copyFile;a&&(t.copyFile=l);function l(E,T,B,G){return typeof B=="function"&&(G=B,B=0),L(E,T,B,G);function L(Q,R,F,j,z){return a(Q,R,F,function(N){N&&(N.code==="EMFILE"||N.code==="ENFILE")?si([L,[Q,R,F,j],N,z||Date.now(),Date.now()]):typeof j=="function"&&j.apply(this,arguments)})}}var c=t.readdir;t.readdir=f;var u=/^v[0-5]\./;function f(E,T,B){typeof T=="function"&&(B=T,T=null);var G=u.test(process.version)?function(R,F,j,z){return c(R,L(R,F,j,z))}:function(R,F,j,z){return c(R,F,L(R,F,j,z))};return G(E,T,B);function L(Q,R,F,j){return function(z,N){z&&(z.code==="EMFILE"||z.code==="ENFILE")?si([G,[Q,R,F],z,j||Date.now(),Date.now()]):(N&&N.sort&&N.sort(),typeof F=="function"&&F.call(this,z,N))}}}if(process.version.substr(0,4)==="v0.8"){var h=Kp(t);y=h.ReadStream,w=h.WriteStream}var p=t.ReadStream;p&&(y.prototype=Object.create(p.prototype),y.prototype.open=I);var d=t.WriteStream;d&&(w.prototype=Object.create(d.prototype),w.prototype.open=S),Object.defineProperty(t,"ReadStream",{get:function(){return y},set:function(E){y=E},enumerable:!0,configurable:!0}),Object.defineProperty(t,"WriteStream",{get:function(){return w},set:function(E){w=E},enumerable:!0,configurable:!0});var m=y;Object.defineProperty(t,"FileReadStream",{get:function(){return m},set:function(E){m=E},enumerable:!0,configurable:!0});var g=w;Object.defineProperty(t,"FileWriteStream",{get:function(){return g},set:function(E){g=E},enumerable:!0,configurable:!0});function y(E,T){return this instanceof y?(p.apply(this,arguments),this):y.apply(Object.create(y.prototype),arguments)}function I(){var E=this;U(E.path,E.flags,E.mode,function(T,B){T?(E.autoClose&&E.destroy(),E.emit("error",T)):(E.fd=B,E.emit("open",B),E.read())})}function w(E,T){return this instanceof w?(d.apply(this,arguments),this):w.apply(Object.create(w.prototype),arguments)}function S(){var E=this;U(E.path,E.flags,E.mode,function(T,B){T?(E.destroy(),E.emit("error",T)):(E.fd=B,E.emit("open",B))})}function b(E,T){return new t.ReadStream(E,T)}function $(E,T){return new t.WriteStream(E,T)}var C=t.open;t.open=U;function U(E,T,B,G){return typeof B=="function"&&(G=B,B=null),L(E,T,B,G);function L(Q,R,F,j,z){return C(Q,R,F,function(N,Se){N&&(N.code==="EMFILE"||N.code==="ENFILE")?si([L,[Q,R,F,j],N,z||Date.now(),Date.now()]):typeof j=="function"&&j.apply(this,arguments)})}}return t}function si(t){Nt("ENQUEUE",t[0].name,t[1]),Ie[Ue].push(t),_n()}var wr;function Va(){for(var t=Date.now(),e=0;e<Ie[Ue].length;++e)Ie[Ue][e].length>2&&(Ie[Ue][e][3]=t,Ie[Ue][e][4]=t);_n()}function _n(){if(clearTimeout(wr),wr=void 0,Ie[Ue].length!==0){var t=Ie[Ue].shift(),e=t[0],i=t[1],r=t[2],n=t[3],s=t[4];if(n===void 0)Nt("RETRY",e.name,i),e.apply(null,i);else if(Date.now()-n>=6e4){Nt("TIMEOUT",e.name,i);var o=i.pop();typeof o=="function"&&o.call(null,r)}else{var a=Date.now()-s,l=Math.max(s-n,1),c=Math.min(l*1.2,100);a>=c?(Nt("RETRY",e.name,i),e.apply(null,i.concat([n]))):Ie[Ue].push(t)}wr===void 0&&(wr=setTimeout(_n,0))}}});var za=x((C_,Ga)=>{function Qe(t,e){typeof e=="boolean"&&(e={forever:e}),this._originalTimeouts=JSON.parse(JSON.stringify(t)),this._timeouts=t,this._options=e||{},this._maxRetryTime=e&&e.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}Ga.exports=Qe;Qe.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts};Qe.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timeouts=[],this._cachedTimeouts=null};Qe.prototype.retry=function(t){if(this._timeout&&clearTimeout(this._timeout),!t)return!1;var e=new Date().getTime();if(t&&e-this._operationStart>=this._maxRetryTime)return this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(t);var i=this._timeouts.shift();if(i===void 0)if(this._cachedTimeouts)this._errors.splice(this._errors.length-1,this._errors.length),this._timeouts=this._cachedTimeouts.slice(0),i=this._timeouts.shift();else return!1;var r=this,n=setTimeout(function(){r._attempts++,r._operationTimeoutCb&&(r._timeout=setTimeout(function(){r._operationTimeoutCb(r._attempts)},r._operationTimeout),r._options.unref&&r._timeout.unref()),r._fn(r._attempts)},i);return this._options.unref&&n.unref(),!0};Qe.prototype.attempt=function(t,e){this._fn=t,e&&(e.timeout&&(this._operationTimeout=e.timeout),e.cb&&(this._operationTimeoutCb=e.cb));var i=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){i._operationTimeoutCb()},i._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)};Qe.prototype.try=function(t){console.log("Using RetryOperation.try() is deprecated"),this.attempt(t)};Qe.prototype.start=function(t){console.log("Using RetryOperation.start() is deprecated"),this.attempt(t)};Qe.prototype.start=Qe.prototype.try;Qe.prototype.errors=function(){return this._errors};Qe.prototype.attempts=function(){return this._attempts};Qe.prototype.mainError=function(){if(this._errors.length===0)return null;for(var t={},e=null,i=0,r=0;r<this._errors.length;r++){var n=this._errors[r],s=n.message,o=(t[s]||0)+1;t[s]=o,o>=i&&(e=n,i=o)}return e}});var Wa=x(Pt=>{var Qp=za();Pt.operation=function(t){var e=Pt.timeouts(t);return new Qp(e,{forever:t&&t.forever,unref:t&&t.unref,maxRetryTime:t&&t.maxRetryTime})};Pt.timeouts=function(t){if(t instanceof Array)return[].concat(t);var e={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var i in t)e[i]=t[i];if(e.minTimeout>e.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var r=[],n=0;n<e.retries;n++)r.push(this.createTimeout(n,e));return t&&t.forever&&!r.length&&r.push(this.createTimeout(n,e)),r.sort(function(s,o){return s-o}),r};Pt.createTimeout=function(t,e){var i=e.randomize?Math.random()+1:1,r=Math.round(i*e.minTimeout*Math.pow(e.factor,t));return r=Math.min(r,e.maxTimeout),r};Pt.wrap=function(t,e,i){if(e instanceof Array&&(i=e,e=null),!i){i=[];for(var r in t)typeof t[r]=="function"&&i.push(r)}for(var n=0;n<i.length;n++){var s=i[n],o=t[s];t[s]=function(l){var c=Pt.operation(e),u=Array.prototype.slice.call(arguments,1),f=u.pop();u.push(function(h){c.retry(h)||(h&&(arguments[0]=c.mainError()),f.apply(this,arguments))}),c.attempt(function(){l.apply(t,u)})}.bind(t,o),t[s].options=e}}});var Ka=x((I_,Ya)=>{Ya.exports=Wa()});var Za=x((T_,Sr)=>{Sr.exports=["SIGABRT","SIGALRM","SIGHUP","SIGINT","SIGTERM"];process.platform!=="win32"&&Sr.exports.push("SIGVTALRM","SIGXCPU","SIGXFSZ","SIGUSR2","SIGTRAP","SIGSYS","SIGQUIT","SIGIOT");process.platform==="linux"&&Sr.exports.push("SIGIO","SIGPOLL","SIGPWR","SIGSTKFLT","SIGUNUSED")});var tl=x((A_,li)=>{var Ce=global.process,Ft=function(t){return t&&typeof t=="object"&&typeof t.removeListener=="function"&&typeof t.emit=="function"&&typeof t.reallyExit=="function"&&typeof t.listeners=="function"&&typeof t.kill=="function"&&typeof t.pid=="number"&&typeof t.on=="function"};Ft(Ce)?(Xa=__nccwpck_require__(9491),oi=Za(),Qa=/^win/i.test(Ce.platform),Ui=__nccwpck_require__(2361),typeof Ui!="function"&&(Ui=Ui.EventEmitter),Ce.__signal_exit_emitter__?Le=Ce.__signal_exit_emitter__:(Le=Ce.__signal_exit_emitter__=new Ui,Le.count=0,Le.emitted={}),Le.infinite||(Le.setMaxListeners(1/0),Le.infinite=!0),li.exports=function(t,e){if(!Ft(global.process))return function(){};Xa.equal(typeof t,"function","a callback must be provided for exit handler"),ai===!1&&bn();var i="exit";e&&e.alwaysLast&&(i="afterexit");var r=function(){Le.removeListener(i,t),Le.listeners("exit").length===0&&Le.listeners("afterexit").length===0&&kr()};return Le.on(i,t),r},kr=function(){!ai||!Ft(global.process)||(ai=!1,oi.forEach(function(e){try{Ce.removeListener(e,Cr[e])}catch{}}),Ce.emit=Or,Ce.reallyExit=wn,Le.count-=1)},li.exports.unload=kr,Mt=function(e,i,r){Le.emitted[e]||(Le.emitted[e]=!0,Le.emit(e,i,r))},Cr={},oi.forEach(function(t){Cr[t]=function(){if(!!Ft(global.process)){var i=Ce.listeners(t);i.length===Le.count&&(kr(),Mt("exit",null,t),Mt("afterexit",null,t),Qa&&t==="SIGHUP"&&(t="SIGINT"),Ce.kill(Ce.pid,t))}}}),li.exports.signals=function(){return oi},ai=!1,bn=function(){ai||!Ft(global.process)||(ai=!0,Le.count+=1,oi=oi.filter(function(e){try{return Ce.on(e,Cr[e]),!0}catch{return!1}}),Ce.emit=el,Ce.reallyExit=Ja)},li.exports.load=bn,wn=Ce.reallyExit,Ja=function(e){!Ft(global.process)||(Ce.exitCode=e||0,Mt("exit",Ce.exitCode,null),Mt("afterexit",Ce.exitCode,null),wn.call(Ce,Ce.exitCode))},Or=Ce.emit,el=function(e,i){if(e==="exit"&&Ft(global.process)){i!==void 0&&(Ce.exitCode=i);var r=Or.apply(this,arguments);return Mt("exit",Ce.exitCode,null),Mt("afterexit",Ce.exitCode,null),r}else return Or.apply(this,arguments)}):li.exports=function(){return function(){}};var Xa,oi,Qa,Ui,Le,kr,Mt,Cr,ai,bn,wn,Ja,Or,el});var rl=x((R_,En)=>{"use strict";var il=Symbol();function Jp(t,e,i){let r=e[il];if(r)return e.stat(t,(s,o)=>{if(s)return i(s);i(null,o.mtime,r)});let n=new Date(Math.ceil(Date.now()/1e3)*1e3+5);e.utimes(t,n,n,s=>{if(s)return i(s);e.stat(t,(o,a)=>{if(o)return i(o);let l=a.mtime.getTime()%1e3===0?"s":"ms";Object.defineProperty(e,il,{value:l}),i(null,a.mtime,l)})})}function ed(t){let e=Date.now();return t==="s"&&(e=Math.ceil(e/1e3)*1e3),new Date(e)}En.exports.probe=Jp;En.exports.getMtime=ed});var ll=x((B_,ji)=>{"use strict";var td=__nccwpck_require__(1017),Cn=yn(),id=Ka(),rd=tl(),nl=rl(),ft={};function Di(t,e){return e.lockfilePath||`${t}.lock`}function On(t,e,i){if(!e.realpath)return i(null,td.resolve(t));e.fs.realpath(t,i)}function kn(t,e,i){let r=Di(t,e);e.fs.mkdir(r,n=>{if(!n)return nl.probe(r,e.fs,(s,o,a)=>{if(s)return e.fs.rmdir(r,()=>{}),i(s);i(null,o,a)});if(n.code!=="EEXIST")return i(n);if(e.stale<=0)return i(Object.assign(new Error("Lock file is already being held"),{code:"ELOCKED",file:t}));e.fs.stat(r,(s,o)=>{if(s)return s.code==="ENOENT"?kn(t,{...e,stale:0},i):i(s);if(!sl(o,e))return i(Object.assign(new Error("Lock file is already being held"),{code:"ELOCKED",file:t}));ol(t,e,a=>{if(a)return i(a);kn(t,{...e,stale:0},i)})})})}function sl(t,e){return t.mtime.getTime()<Date.now()-e.stale}function ol(t,e,i){e.fs.rmdir(Di(t,e),r=>{if(r&&r.code!=="ENOENT")return i(r);i()})}function Ir(t,e){let i=ft[t];i.updateTimeout||(i.updateDelay=i.updateDelay||e.update,i.updateTimeout=setTimeout(()=>{i.updateTimeout=null,e.fs.stat(i.lockfilePath,(r,n)=>{let s=i.lastUpdate+e.stale<Date.now();if(r)return r.code==="ENOENT"||s?Sn(t,i,Object.assign(r,{code:"ECOMPROMISED"})):(i.updateDelay=1e3,Ir(t,e));if(!(i.mtime.getTime()===n.mtime.getTime()))return Sn(t,i,Object.assign(new Error("Unable to update lock within the stale threshold"),{code:"ECOMPROMISED"}));let a=nl.getMtime(i.mtimePrecision);e.fs.utimes(i.lockfilePath,a,a,l=>{let c=i.lastUpdate+e.stale<Date.now();if(!i.released){if(l)return l.code==="ENOENT"||c?Sn(t,i,Object.assign(l,{code:"ECOMPROMISED"})):(i.updateDelay=1e3,Ir(t,e));i.mtime=a,i.lastUpdate=Date.now(),i.updateDelay=null,Ir(t,e)}})})},i.updateDelay),i.updateTimeout.unref&&i.updateTimeout.unref())}function Sn(t,e,i){e.released=!0,e.updateTimeout&&clearTimeout(e.updateTimeout),ft[t]===e&&delete ft[t],e.options.onCompromised(i)}function nd(t,e,i){e={stale:1e4,update:null,realpath:!0,retries:0,fs:Cn,onCompromised:r=>{throw r},...e},e.retries=e.retries||0,e.retries=typeof e.retries=="number"?{retries:e.retries}:e.retries,e.stale=Math.max(e.stale||0,2e3),e.update=e.update==null?e.stale/2:e.update||0,e.update=Math.max(Math.min(e.update,e.stale/2),1e3),On(t,e,(r,n)=>{if(r)return i(r);let s=id.operation(e.retries);s.attempt(()=>{kn(n,e,(o,a,l)=>{if(s.retry(o))return;if(o)return i(s.mainError());let c=ft[n]={lockfilePath:Di(n,e),mtime:a,mtimePrecision:l,options:e,lastUpdate:Date.now()};Ir(n,e),i(null,u=>{if(c.released)return u&&u(Object.assign(new Error("Lock is already released"),{code:"ERELEASED"}));al(n,{...e,realpath:!1},u)})})})})}function al(t,e,i){e={fs:Cn,realpath:!0,...e},On(t,e,(r,n)=>{if(r)return i(r);let s=ft[n];if(!s)return i(Object.assign(new Error("Lock is not acquired/owned by you"),{code:"ENOTACQUIRED"}));s.updateTimeout&&clearTimeout(s.updateTimeout),s.released=!0,delete ft[n],ol(n,e,i)})}function sd(t,e,i){e={stale:1e4,realpath:!0,fs:Cn,...e},e.stale=Math.max(e.stale||0,2e3),On(t,e,(r,n)=>{if(r)return i(r);e.fs.stat(Di(n,e),(s,o)=>s?s.code==="ENOENT"?i(null,!1):i(s):i(null,!sl(o,e)))})}function od(){return ft}rd(()=>{for(let t in ft){let e=ft[t].options;try{e.fs.rmdirSync(Di(t,e))}catch{}}});ji.exports.lock=nd;ji.exports.unlock=al;ji.exports.check=sd;ji.exports.getLocks=od});var ul=x((L_,cl)=>{"use strict";var ad=yn();function ld(t){let e=["mkdir","realpath","stat","rmdir","utimes"],i={...t};return e.forEach(r=>{i[r]=(...n)=>{let s=n.pop(),o;try{o=t[`${r}Sync`](...n)}catch(a){return s(a)}s(null,o)}}),i}function cd(t){return(...e)=>new Promise((i,r)=>{e.push((n,s)=>{n?r(n):i(s)}),t(...e)})}function ud(t){return(...e)=>{let i,r;if(e.push((n,s)=>{i=n,r=s}),t(...e),i)throw i;return r}}function fd(t){if(t={...t},t.fs=ld(t.fs||ad),typeof t.retries=="number"&&t.retries>0||t.retries&&typeof t.retries.retries=="number"&&t.retries.retries>0)throw Object.assign(new Error("Cannot use retries with the sync api"),{code:"ESYNC"});return t}cl.exports={toPromise:cd,toSync:ud,toSyncOptions:fd}});var hl=x((N_,_t)=>{"use strict";var ci=ll(),{toPromise:Tr,toSync:Ar,toSyncOptions:In}=ul();async function fl(t,e){let i=await Tr(ci.lock)(t,e);return Tr(i)}function hd(t,e){let i=Ar(ci.lock)(t,In(e));return Ar(i)}function pd(t,e){return Tr(ci.unlock)(t,e)}function dd(t,e){return Ar(ci.unlock)(t,In(e))}function md(t,e){return Tr(ci.check)(t,e)}function gd(t,e){return Ar(ci.check)(t,In(e))}_t.exports=fl;_t.exports.lock=fl;_t.exports.unlock=pd;_t.exports.lockSync=hd;_t.exports.unlockSync=dd;_t.exports.check=md;_t.exports.checkSync=gd});var dl=x((P_,pl)=>{"use strict";function Rr(){this._types=Object.create(null),this._extensions=Object.create(null);for(let t=0;t<arguments.length;t++)this.define(arguments[t]);this.define=this.define.bind(this),this.getType=this.getType.bind(this),this.getExtension=this.getExtension.bind(this)}Rr.prototype.define=function(t,e){for(let i in t){let r=t[i].map(function(n){return n.toLowerCase()});i=i.toLowerCase();for(let n=0;n<r.length;n++){let s=r[n];if(s[0]!=="*"){if(!e&&s in this._types)throw new Error('Attempt to change mapping for "'+s+'" extension from "'+this._types[s]+'" to "'+i+'". Pass `force=true` to allow this, otherwise remove "'+s+'" from the list of extensions for "'+i+'".');this._types[s]=i}}if(e||!this._extensions[i]){let n=r[0];this._extensions[i]=n[0]!=="*"?n:n.substr(1)}}};Rr.prototype.getType=function(t){t=String(t);let e=t.replace(/^.*[/\\]/,"").toLowerCase(),i=e.replace(/^.*\./,"").toLowerCase(),r=e.length<t.length;return(i.length<e.length-1||!r)&&this._types[i]||null};Rr.prototype.getExtension=function(t){return t=/^\s*([^;\s]*)/.test(t)&&RegExp.$1,t&&this._extensions[t.toLowerCase()]||null};pl.exports=Rr});var gl=x((F_,ml)=>{ml.exports={"application/andrew-inset":["ez"],"application/applixware":["aw"],"application/atom+xml":["atom"],"application/atomcat+xml":["atomcat"],"application/atomdeleted+xml":["atomdeleted"],"application/atomsvc+xml":["atomsvc"],"application/atsc-dwd+xml":["dwd"],"application/atsc-held+xml":["held"],"application/atsc-rsat+xml":["rsat"],"application/bdoc":["bdoc"],"application/calendar+xml":["xcs"],"application/ccxml+xml":["ccxml"],"application/cdfx+xml":["cdfx"],"application/cdmi-capability":["cdmia"],"application/cdmi-container":["cdmic"],"application/cdmi-domain":["cdmid"],"application/cdmi-object":["cdmio"],"application/cdmi-queue":["cdmiq"],"application/cu-seeme":["cu"],"application/dash+xml":["mpd"],"application/davmount+xml":["davmount"],"application/docbook+xml":["dbk"],"application/dssc+der":["dssc"],"application/dssc+xml":["xdssc"],"application/ecmascript":["es","ecma"],"application/emma+xml":["emma"],"application/emotionml+xml":["emotionml"],"application/epub+zip":["epub"],"application/exi":["exi"],"application/express":["exp"],"application/fdt+xml":["fdt"],"application/font-tdpfr":["pfr"],"application/geo+json":["geojson"],"application/gml+xml":["gml"],"application/gpx+xml":["gpx"],"application/gxf":["gxf"],"application/gzip":["gz"],"application/hjson":["hjson"],"application/hyperstudio":["stk"],"application/inkml+xml":["ink","inkml"],"application/ipfix":["ipfix"],"application/its+xml":["its"],"application/java-archive":["jar","war","ear"],"application/java-serialized-object":["ser"],"application/java-vm":["class"],"application/javascript":["js","mjs"],"application/json":["json","map"],"application/json5":["json5"],"application/jsonml+json":["jsonml"],"application/ld+json":["jsonld"],"application/lgr+xml":["lgr"],"application/lost+xml":["lostxml"],"application/mac-binhex40":["hqx"],"application/mac-compactpro":["cpt"],"application/mads+xml":["mads"],"application/manifest+json":["webmanifest"],"application/marc":["mrc"],"application/marcxml+xml":["mrcx"],"application/mathematica":["ma","nb","mb"],"application/mathml+xml":["mathml"],"application/mbox":["mbox"],"application/mediaservercontrol+xml":["mscml"],"application/metalink+xml":["metalink"],"application/metalink4+xml":["meta4"],"application/mets+xml":["mets"],"application/mmt-aei+xml":["maei"],"application/mmt-usd+xml":["musd"],"application/mods+xml":["mods"],"application/mp21":["m21","mp21"],"application/mp4":["mp4s","m4p"],"application/msword":["doc","dot"],"application/mxf":["mxf"],"application/n-quads":["nq"],"application/n-triples":["nt"],"application/node":["cjs"],"application/octet-stream":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"],"application/oda":["oda"],"application/oebps-package+xml":["opf"],"application/ogg":["ogx"],"application/omdoc+xml":["omdoc"],"application/onenote":["onetoc","onetoc2","onetmp","onepkg"],"application/oxps":["oxps"],"application/p2p-overlay+xml":["relo"],"application/patch-ops-error+xml":["xer"],"application/pdf":["pdf"],"application/pgp-encrypted":["pgp"],"application/pgp-signature":["asc","sig"],"application/pics-rules":["prf"],"application/pkcs10":["p10"],"application/pkcs7-mime":["p7m","p7c"],"application/pkcs7-signature":["p7s"],"application/pkcs8":["p8"],"application/pkix-attr-cert":["ac"],"application/pkix-cert":["cer"],"application/pkix-crl":["crl"],"application/pkix-pkipath":["pkipath"],"application/pkixcmp":["pki"],"application/pls+xml":["pls"],"application/postscript":["ai","eps","ps"],"application/provenance+xml":["provx"],"application/pskc+xml":["pskcxml"],"application/raml+yaml":["raml"],"application/rdf+xml":["rdf","owl"],"application/reginfo+xml":["rif"],"application/relax-ng-compact-syntax":["rnc"],"application/resource-lists+xml":["rl"],"application/resource-lists-diff+xml":["rld"],"application/rls-services+xml":["rs"],"application/route-apd+xml":["rapd"],"application/route-s-tsid+xml":["sls"],"application/route-usd+xml":["rusd"],"application/rpki-ghostbusters":["gbr"],"application/rpki-manifest":["mft"],"application/rpki-roa":["roa"],"application/rsd+xml":["rsd"],"application/rss+xml":["rss"],"application/rtf":["rtf"],"application/sbml+xml":["sbml"],"application/scvp-cv-request":["scq"],"application/scvp-cv-response":["scs"],"application/scvp-vp-request":["spq"],"application/scvp-vp-response":["spp"],"application/sdp":["sdp"],"application/senml+xml":["senmlx"],"application/sensml+xml":["sensmlx"],"application/set-payment-initiation":["setpay"],"application/set-registration-initiation":["setreg"],"application/shf+xml":["shf"],"application/sieve":["siv","sieve"],"application/smil+xml":["smi","smil"],"application/sparql-query":["rq"],"application/sparql-results+xml":["srx"],"application/srgs":["gram"],"application/srgs+xml":["grxml"],"application/sru+xml":["sru"],"application/ssdl+xml":["ssdl"],"application/ssml+xml":["ssml"],"application/swid+xml":["swidtag"],"application/tei+xml":["tei","teicorpus"],"application/thraud+xml":["tfi"],"application/timestamped-data":["tsd"],"application/toml":["toml"],"application/trig":["trig"],"application/ttml+xml":["ttml"],"application/ubjson":["ubj"],"application/urc-ressheet+xml":["rsheet"],"application/urc-targetdesc+xml":["td"],"application/voicexml+xml":["vxml"],"application/wasm":["wasm"],"application/widget":["wgt"],"application/winhlp":["hlp"],"application/wsdl+xml":["wsdl"],"application/wspolicy+xml":["wspolicy"],"application/xaml+xml":["xaml"],"application/xcap-att+xml":["xav"],"application/xcap-caps+xml":["xca"],"application/xcap-diff+xml":["xdf"],"application/xcap-el+xml":["xel"],"application/xcap-ns+xml":["xns"],"application/xenc+xml":["xenc"],"application/xhtml+xml":["xhtml","xht"],"application/xliff+xml":["xlf"],"application/xml":["xml","xsl","xsd","rng"],"application/xml-dtd":["dtd"],"application/xop+xml":["xop"],"application/xproc+xml":["xpl"],"application/xslt+xml":["*xsl","xslt"],"application/xspf+xml":["xspf"],"application/xv+xml":["mxml","xhvml","xvml","xvm"],"application/yang":["yang"],"application/yin+xml":["yin"],"application/zip":["zip"],"audio/3gpp":["*3gpp"],"audio/adpcm":["adp"],"audio/amr":["amr"],"audio/basic":["au","snd"],"audio/midi":["mid","midi","kar","rmi"],"audio/mobile-xmf":["mxmf"],"audio/mp3":["*mp3"],"audio/mp4":["m4a","mp4a"],"audio/mpeg":["mpga","mp2","mp2a","mp3","m2a","m3a"],"audio/ogg":["oga","ogg","spx","opus"],"audio/s3m":["s3m"],"audio/silk":["sil"],"audio/wav":["wav"],"audio/wave":["*wav"],"audio/webm":["weba"],"audio/xm":["xm"],"font/collection":["ttc"],"font/otf":["otf"],"font/ttf":["ttf"],"font/woff":["woff"],"font/woff2":["woff2"],"image/aces":["exr"],"image/apng":["apng"],"image/avif":["avif"],"image/bmp":["bmp"],"image/cgm":["cgm"],"image/dicom-rle":["drle"],"image/emf":["emf"],"image/fits":["fits"],"image/g3fax":["g3"],"image/gif":["gif"],"image/heic":["heic"],"image/heic-sequence":["heics"],"image/heif":["heif"],"image/heif-sequence":["heifs"],"image/hej2k":["hej2"],"image/hsj2":["hsj2"],"image/ief":["ief"],"image/jls":["jls"],"image/jp2":["jp2","jpg2"],"image/jpeg":["jpeg","jpg","jpe"],"image/jph":["jph"],"image/jphc":["jhc"],"image/jpm":["jpm"],"image/jpx":["jpx","jpf"],"image/jxr":["jxr"],"image/jxra":["jxra"],"image/jxrs":["jxrs"],"image/jxs":["jxs"],"image/jxsc":["jxsc"],"image/jxsi":["jxsi"],"image/jxss":["jxss"],"image/ktx":["ktx"],"image/ktx2":["ktx2"],"image/png":["png"],"image/sgi":["sgi"],"image/svg+xml":["svg","svgz"],"image/t38":["t38"],"image/tiff":["tif","tiff"],"image/tiff-fx":["tfx"],"image/webp":["webp"],"image/wmf":["wmf"],"message/disposition-notification":["disposition-notification"],"message/global":["u8msg"],"message/global-delivery-status":["u8dsn"],"message/global-disposition-notification":["u8mdn"],"message/global-headers":["u8hdr"],"message/rfc822":["eml","mime"],"model/3mf":["3mf"],"model/gltf+json":["gltf"],"model/gltf-binary":["glb"],"model/iges":["igs","iges"],"model/mesh":["msh","mesh","silo"],"model/mtl":["mtl"],"model/obj":["obj"],"model/step+xml":["stpx"],"model/step+zip":["stpz"],"model/step-xml+zip":["stpxz"],"model/stl":["stl"],"model/vrml":["wrl","vrml"],"model/x3d+binary":["*x3db","x3dbz"],"model/x3d+fastinfoset":["x3db"],"model/x3d+vrml":["*x3dv","x3dvz"],"model/x3d+xml":["x3d","x3dz"],"model/x3d-vrml":["x3dv"],"text/cache-manifest":["appcache","manifest"],"text/calendar":["ics","ifb"],"text/coffeescript":["coffee","litcoffee"],"text/css":["css"],"text/csv":["csv"],"text/html":["html","htm","shtml"],"text/jade":["jade"],"text/jsx":["jsx"],"text/less":["less"],"text/markdown":["markdown","md"],"text/mathml":["mml"],"text/mdx":["mdx"],"text/n3":["n3"],"text/plain":["txt","text","conf","def","list","log","in","ini"],"text/richtext":["rtx"],"text/rtf":["*rtf"],"text/sgml":["sgml","sgm"],"text/shex":["shex"],"text/slim":["slim","slm"],"text/spdx":["spdx"],"text/stylus":["stylus","styl"],"text/tab-separated-values":["tsv"],"text/troff":["t","tr","roff","man","me","ms"],"text/turtle":["ttl"],"text/uri-list":["uri","uris","urls"],"text/vcard":["vcard"],"text/vtt":["vtt"],"text/xml":["*xml"],"text/yaml":["yaml","yml"],"video/3gpp":["3gp","3gpp"],"video/3gpp2":["3g2"],"video/h261":["h261"],"video/h263":["h263"],"video/h264":["h264"],"video/iso.segment":["m4s"],"video/jpeg":["jpgv"],"video/jpm":["*jpm","jpgm"],"video/mj2":["mj2","mjp2"],"video/mp2t":["ts"],"video/mp4":["mp4","mp4v","mpg4"],"video/mpeg":["mpeg","mpg","mpe","m1v","m2v"],"video/ogg":["ogv"],"video/quicktime":["qt","mov"],"video/webm":["webm"]}});var _l=x((M_,vl)=>{vl.exports={"application/prs.cww":["cww"],"application/vnd.1000minds.decision-model+xml":["1km"],"application/vnd.3gpp.pic-bw-large":["plb"],"application/vnd.3gpp.pic-bw-small":["psb"],"application/vnd.3gpp.pic-bw-var":["pvb"],"application/vnd.3gpp2.tcap":["tcap"],"application/vnd.3m.post-it-notes":["pwn"],"application/vnd.accpac.simply.aso":["aso"],"application/vnd.accpac.simply.imp":["imp"],"application/vnd.acucobol":["acu"],"application/vnd.acucorp":["atc","acutc"],"application/vnd.adobe.air-application-installer-package+zip":["air"],"application/vnd.adobe.formscentral.fcdt":["fcdt"],"application/vnd.adobe.fxp":["fxp","fxpl"],"application/vnd.adobe.xdp+xml":["xdp"],"application/vnd.adobe.xfdf":["xfdf"],"application/vnd.ahead.space":["ahead"],"application/vnd.airzip.filesecure.azf":["azf"],"application/vnd.airzip.filesecure.azs":["azs"],"application/vnd.amazon.ebook":["azw"],"application/vnd.americandynamics.acc":["acc"],"application/vnd.amiga.ami":["ami"],"application/vnd.android.package-archive":["apk"],"application/vnd.anser-web-certificate-issue-initiation":["cii"],"application/vnd.anser-web-funds-transfer-initiation":["fti"],"application/vnd.antix.game-component":["atx"],"application/vnd.apple.installer+xml":["mpkg"],"application/vnd.apple.keynote":["key"],"application/vnd.apple.mpegurl":["m3u8"],"application/vnd.apple.numbers":["numbers"],"application/vnd.apple.pages":["pages"],"application/vnd.apple.pkpass":["pkpass"],"application/vnd.aristanetworks.swi":["swi"],"application/vnd.astraea-software.iota":["iota"],"application/vnd.audiograph":["aep"],"application/vnd.balsamiq.bmml+xml":["bmml"],"application/vnd.blueice.multipass":["mpm"],"application/vnd.bmi":["bmi"],"application/vnd.businessobjects":["rep"],"application/vnd.chemdraw+xml":["cdxml"],"application/vnd.chipnuts.karaoke-mmd":["mmd"],"application/vnd.cinderella":["cdy"],"application/vnd.citationstyles.style+xml":["csl"],"application/vnd.claymore":["cla"],"application/vnd.cloanto.rp9":["rp9"],"application/vnd.clonk.c4group":["c4g","c4d","c4f","c4p","c4u"],"application/vnd.cluetrust.cartomobile-config":["c11amc"],"application/vnd.cluetrust.cartomobile-config-pkg":["c11amz"],"application/vnd.commonspace":["csp"],"application/vnd.contact.cmsg":["cdbcmsg"],"application/vnd.cosmocaller":["cmc"],"application/vnd.crick.clicker":["clkx"],"application/vnd.crick.clicker.keyboard":["clkk"],"application/vnd.crick.clicker.palette":["clkp"],"application/vnd.crick.clicker.template":["clkt"],"application/vnd.crick.clicker.wordbank":["clkw"],"application/vnd.criticaltools.wbs+xml":["wbs"],"application/vnd.ctc-posml":["pml"],"application/vnd.cups-ppd":["ppd"],"application/vnd.curl.car":["car"],"application/vnd.curl.pcurl":["pcurl"],"application/vnd.dart":["dart"],"application/vnd.data-vision.rdz":["rdz"],"application/vnd.dbf":["dbf"],"application/vnd.dece.data":["uvf","uvvf","uvd","uvvd"],"application/vnd.dece.ttml+xml":["uvt","uvvt"],"application/vnd.dece.unspecified":["uvx","uvvx"],"application/vnd.dece.zip":["uvz","uvvz"],"application/vnd.denovo.fcselayout-link":["fe_launch"],"application/vnd.dna":["dna"],"application/vnd.dolby.mlp":["mlp"],"application/vnd.dpgraph":["dpg"],"application/vnd.dreamfactory":["dfac"],"application/vnd.ds-keypoint":["kpxx"],"application/vnd.dvb.ait":["ait"],"application/vnd.dvb.service":["svc"],"application/vnd.dynageo":["geo"],"application/vnd.ecowin.chart":["mag"],"application/vnd.enliven":["nml"],"application/vnd.epson.esf":["esf"],"application/vnd.epson.msf":["msf"],"application/vnd.epson.quickanime":["qam"],"application/vnd.epson.salt":["slt"],"application/vnd.epson.ssf":["ssf"],"application/vnd.eszigno3+xml":["es3","et3"],"application/vnd.ezpix-album":["ez2"],"application/vnd.ezpix-package":["ez3"],"application/vnd.fdf":["fdf"],"application/vnd.fdsn.mseed":["mseed"],"application/vnd.fdsn.seed":["seed","dataless"],"application/vnd.flographit":["gph"],"application/vnd.fluxtime.clip":["ftc"],"application/vnd.framemaker":["fm","frame","maker","book"],"application/vnd.frogans.fnc":["fnc"],"application/vnd.frogans.ltf":["ltf"],"application/vnd.fsc.weblaunch":["fsc"],"application/vnd.fujitsu.oasys":["oas"],"application/vnd.fujitsu.oasys2":["oa2"],"application/vnd.fujitsu.oasys3":["oa3"],"application/vnd.fujitsu.oasysgp":["fg5"],"application/vnd.fujitsu.oasysprs":["bh2"],"application/vnd.fujixerox.ddd":["ddd"],"application/vnd.fujixerox.docuworks":["xdw"],"application/vnd.fujixerox.docuworks.binder":["xbd"],"application/vnd.fuzzysheet":["fzs"],"application/vnd.genomatix.tuxedo":["txd"],"application/vnd.geogebra.file":["ggb"],"application/vnd.geogebra.tool":["ggt"],"application/vnd.geometry-explorer":["gex","gre"],"application/vnd.geonext":["gxt"],"application/vnd.geoplan":["g2w"],"application/vnd.geospace":["g3w"],"application/vnd.gmx":["gmx"],"application/vnd.google-apps.document":["gdoc"],"application/vnd.google-apps.presentation":["gslides"],"application/vnd.google-apps.spreadsheet":["gsheet"],"application/vnd.google-earth.kml+xml":["kml"],"application/vnd.google-earth.kmz":["kmz"],"application/vnd.grafeq":["gqf","gqs"],"application/vnd.groove-account":["gac"],"application/vnd.groove-help":["ghf"],"application/vnd.groove-identity-message":["gim"],"application/vnd.groove-injector":["grv"],"application/vnd.groove-tool-message":["gtm"],"application/vnd.groove-tool-template":["tpl"],"application/vnd.groove-vcard":["vcg"],"application/vnd.hal+xml":["hal"],"application/vnd.handheld-entertainment+xml":["zmm"],"application/vnd.hbci":["hbci"],"application/vnd.hhe.lesson-player":["les"],"application/vnd.hp-hpgl":["hpgl"],"application/vnd.hp-hpid":["hpid"],"application/vnd.hp-hps":["hps"],"application/vnd.hp-jlyt":["jlt"],"application/vnd.hp-pcl":["pcl"],"application/vnd.hp-pclxl":["pclxl"],"application/vnd.hydrostatix.sof-data":["sfd-hdstx"],"application/vnd.ibm.minipay":["mpy"],"application/vnd.ibm.modcap":["afp","listafp","list3820"],"application/vnd.ibm.rights-management":["irm"],"application/vnd.ibm.secure-container":["sc"],"application/vnd.iccprofile":["icc","icm"],"application/vnd.igloader":["igl"],"application/vnd.immervision-ivp":["ivp"],"application/vnd.immervision-ivu":["ivu"],"application/vnd.insors.igm":["igm"],"application/vnd.intercon.formnet":["xpw","xpx"],"application/vnd.intergeo":["i2g"],"application/vnd.intu.qbo":["qbo"],"application/vnd.intu.qfx":["qfx"],"application/vnd.ipunplugged.rcprofile":["rcprofile"],"application/vnd.irepository.package+xml":["irp"],"application/vnd.is-xpr":["xpr"],"application/vnd.isac.fcs":["fcs"],"application/vnd.jam":["jam"],"application/vnd.jcp.javame.midlet-rms":["rms"],"application/vnd.jisp":["jisp"],"application/vnd.joost.joda-archive":["joda"],"application/vnd.kahootz":["ktz","ktr"],"application/vnd.kde.karbon":["karbon"],"application/vnd.kde.kchart":["chrt"],"application/vnd.kde.kformula":["kfo"],"application/vnd.kde.kivio":["flw"],"application/vnd.kde.kontour":["kon"],"application/vnd.kde.kpresenter":["kpr","kpt"],"application/vnd.kde.kspread":["ksp"],"application/vnd.kde.kword":["kwd","kwt"],"application/vnd.kenameaapp":["htke"],"application/vnd.kidspiration":["kia"],"application/vnd.kinar":["kne","knp"],"application/vnd.koan":["skp","skd","skt","skm"],"application/vnd.kodak-descriptor":["sse"],"application/vnd.las.las+xml":["lasxml"],"application/vnd.llamagraphics.life-balance.desktop":["lbd"],"application/vnd.llamagraphics.life-balance.exchange+xml":["lbe"],"application/vnd.lotus-1-2-3":["123"],"application/vnd.lotus-approach":["apr"],"application/vnd.lotus-freelance":["pre"],"application/vnd.lotus-notes":["nsf"],"application/vnd.lotus-organizer":["org"],"application/vnd.lotus-screencam":["scm"],"application/vnd.lotus-wordpro":["lwp"],"application/vnd.macports.portpkg":["portpkg"],"application/vnd.mapbox-vector-tile":["mvt"],"application/vnd.mcd":["mcd"],"application/vnd.medcalcdata":["mc1"],"application/vnd.mediastation.cdkey":["cdkey"],"application/vnd.mfer":["mwf"],"application/vnd.mfmp":["mfm"],"application/vnd.micrografx.flo":["flo"],"application/vnd.micrografx.igx":["igx"],"application/vnd.mif":["mif"],"application/vnd.mobius.daf":["daf"],"application/vnd.mobius.dis":["dis"],"application/vnd.mobius.mbk":["mbk"],"application/vnd.mobius.mqy":["mqy"],"application/vnd.mobius.msl":["msl"],"application/vnd.mobius.plc":["plc"],"application/vnd.mobius.txf":["txf"],"application/vnd.mophun.application":["mpn"],"application/vnd.mophun.certificate":["mpc"],"application/vnd.mozilla.xul+xml":["xul"],"application/vnd.ms-artgalry":["cil"],"application/vnd.ms-cab-compressed":["cab"],"application/vnd.ms-excel":["xls","xlm","xla","xlc","xlt","xlw"],"application/vnd.ms-excel.addin.macroenabled.12":["xlam"],"application/vnd.ms-excel.sheet.binary.macroenabled.12":["xlsb"],"application/vnd.ms-excel.sheet.macroenabled.12":["xlsm"],"application/vnd.ms-excel.template.macroenabled.12":["xltm"],"application/vnd.ms-fontobject":["eot"],"application/vnd.ms-htmlhelp":["chm"],"application/vnd.ms-ims":["ims"],"application/vnd.ms-lrm":["lrm"],"application/vnd.ms-officetheme":["thmx"],"application/vnd.ms-outlook":["msg"],"application/vnd.ms-pki.seccat":["cat"],"application/vnd.ms-pki.stl":["*stl"],"application/vnd.ms-powerpoint":["ppt","pps","pot"],"application/vnd.ms-powerpoint.addin.macroenabled.12":["ppam"],"application/vnd.ms-powerpoint.presentation.macroenabled.12":["pptm"],"application/vnd.ms-powerpoint.slide.macroenabled.12":["sldm"],"application/vnd.ms-powerpoint.slideshow.macroenabled.12":["ppsm"],"application/vnd.ms-powerpoint.template.macroenabled.12":["potm"],"application/vnd.ms-project":["mpp","mpt"],"application/vnd.ms-word.document.macroenabled.12":["docm"],"application/vnd.ms-word.template.macroenabled.12":["dotm"],"application/vnd.ms-works":["wps","wks","wcm","wdb"],"application/vnd.ms-wpl":["wpl"],"application/vnd.ms-xpsdocument":["xps"],"application/vnd.mseq":["mseq"],"application/vnd.musician":["mus"],"application/vnd.muvee.style":["msty"],"application/vnd.mynfc":["taglet"],"application/vnd.neurolanguage.nlu":["nlu"],"application/vnd.nitf":["ntf","nitf"],"application/vnd.noblenet-directory":["nnd"],"application/vnd.noblenet-sealer":["nns"],"application/vnd.noblenet-web":["nnw"],"application/vnd.nokia.n-gage.ac+xml":["*ac"],"application/vnd.nokia.n-gage.data":["ngdat"],"application/vnd.nokia.n-gage.symbian.install":["n-gage"],"application/vnd.nokia.radio-preset":["rpst"],"application/vnd.nokia.radio-presets":["rpss"],"application/vnd.novadigm.edm":["edm"],"application/vnd.novadigm.edx":["edx"],"application/vnd.novadigm.ext":["ext"],"application/vnd.oasis.opendocument.chart":["odc"],"application/vnd.oasis.opendocument.chart-template":["otc"],"application/vnd.oasis.opendocument.database":["odb"],"application/vnd.oasis.opendocument.formula":["odf"],"application/vnd.oasis.opendocument.formula-template":["odft"],"application/vnd.oasis.opendocument.graphics":["odg"],"application/vnd.oasis.opendocument.graphics-template":["otg"],"application/vnd.oasis.opendocument.image":["odi"],"application/vnd.oasis.opendocument.image-template":["oti"],"application/vnd.oasis.opendocument.presentation":["odp"],"application/vnd.oasis.opendocument.presentation-template":["otp"],"application/vnd.oasis.opendocument.spreadsheet":["ods"],"application/vnd.oasis.opendocument.spreadsheet-template":["ots"],"application/vnd.oasis.opendocument.text":["odt"],"application/vnd.oasis.opendocument.text-master":["odm"],"application/vnd.oasis.opendocument.text-template":["ott"],"application/vnd.oasis.opendocument.text-web":["oth"],"application/vnd.olpc-sugar":["xo"],"application/vnd.oma.dd2+xml":["dd2"],"application/vnd.openblox.game+xml":["obgx"],"application/vnd.openofficeorg.extension":["oxt"],"application/vnd.openstreetmap.data+xml":["osm"],"application/vnd.openxmlformats-officedocument.presentationml.presentation":["pptx"],"application/vnd.openxmlformats-officedocument.presentationml.slide":["sldx"],"application/vnd.openxmlformats-officedocument.presentationml.slideshow":["ppsx"],"application/vnd.openxmlformats-officedocument.presentationml.template":["potx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":["xlsx"],"application/vnd.openxmlformats-officedocument.spreadsheetml.template":["xltx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.document":["docx"],"application/vnd.openxmlformats-officedocument.wordprocessingml.template":["dotx"],"application/vnd.osgeo.mapguide.package":["mgp"],"application/vnd.osgi.dp":["dp"],"application/vnd.osgi.subsystem":["esa"],"application/vnd.palm":["pdb","pqa","oprc"],"application/vnd.pawaafile":["paw"],"application/vnd.pg.format":["str"],"application/vnd.pg.osasli":["ei6"],"application/vnd.picsel":["efif"],"application/vnd.pmi.widget":["wg"],"application/vnd.pocketlearn":["plf"],"application/vnd.powerbuilder6":["pbd"],"application/vnd.previewsystems.box":["box"],"application/vnd.proteus.magazine":["mgz"],"application/vnd.publishare-delta-tree":["qps"],"application/vnd.pvi.ptid1":["ptid"],"application/vnd.quark.quarkxpress":["qxd","qxt","qwd","qwt","qxl","qxb"],"application/vnd.rar":["rar"],"application/vnd.realvnc.bed":["bed"],"application/vnd.recordare.musicxml":["mxl"],"application/vnd.recordare.musicxml+xml":["musicxml"],"application/vnd.rig.cryptonote":["cryptonote"],"application/vnd.rim.cod":["cod"],"application/vnd.rn-realmedia":["rm"],"application/vnd.rn-realmedia-vbr":["rmvb"],"application/vnd.route66.link66+xml":["link66"],"application/vnd.sailingtracker.track":["st"],"application/vnd.seemail":["see"],"application/vnd.sema":["sema"],"application/vnd.semd":["semd"],"application/vnd.semf":["semf"],"application/vnd.shana.informed.formdata":["ifm"],"application/vnd.shana.informed.formtemplate":["itp"],"application/vnd.shana.informed.interchange":["iif"],"application/vnd.shana.informed.package":["ipk"],"application/vnd.simtech-mindmapper":["twd","twds"],"application/vnd.smaf":["mmf"],"application/vnd.smart.teacher":["teacher"],"application/vnd.software602.filler.form+xml":["fo"],"application/vnd.solent.sdkm+xml":["sdkm","sdkd"],"application/vnd.spotfire.dxp":["dxp"],"application/vnd.spotfire.sfs":["sfs"],"application/vnd.stardivision.calc":["sdc"],"application/vnd.stardivision.draw":["sda"],"application/vnd.stardivision.impress":["sdd"],"application/vnd.stardivision.math":["smf"],"application/vnd.stardivision.writer":["sdw","vor"],"application/vnd.stardivision.writer-global":["sgl"],"application/vnd.stepmania.package":["smzip"],"application/vnd.stepmania.stepchart":["sm"],"application/vnd.sun.wadl+xml":["wadl"],"application/vnd.sun.xml.calc":["sxc"],"application/vnd.sun.xml.calc.template":["stc"],"application/vnd.sun.xml.draw":["sxd"],"application/vnd.sun.xml.draw.template":["std"],"application/vnd.sun.xml.impress":["sxi"],"application/vnd.sun.xml.impress.template":["sti"],"application/vnd.sun.xml.math":["sxm"],"application/vnd.sun.xml.writer":["sxw"],"application/vnd.sun.xml.writer.global":["sxg"],"application/vnd.sun.xml.writer.template":["stw"],"application/vnd.sus-calendar":["sus","susp"],"application/vnd.svd":["svd"],"application/vnd.symbian.install":["sis","sisx"],"application/vnd.syncml+xml":["xsm"],"application/vnd.syncml.dm+wbxml":["bdm"],"application/vnd.syncml.dm+xml":["xdm"],"application/vnd.syncml.dmddf+xml":["ddf"],"application/vnd.tao.intent-module-archive":["tao"],"application/vnd.tcpdump.pcap":["pcap","cap","dmp"],"application/vnd.tmobile-livetv":["tmo"],"application/vnd.trid.tpt":["tpt"],"application/vnd.triscape.mxs":["mxs"],"application/vnd.trueapp":["tra"],"application/vnd.ufdl":["ufd","ufdl"],"application/vnd.uiq.theme":["utz"],"application/vnd.umajin":["umj"],"application/vnd.unity":["unityweb"],"application/vnd.uoml+xml":["uoml"],"application/vnd.vcx":["vcx"],"application/vnd.visio":["vsd","vst","vss","vsw"],"application/vnd.visionary":["vis"],"application/vnd.vsf":["vsf"],"application/vnd.wap.wbxml":["wbxml"],"application/vnd.wap.wmlc":["wmlc"],"application/vnd.wap.wmlscriptc":["wmlsc"],"application/vnd.webturbo":["wtb"],"application/vnd.wolfram.player":["nbp"],"application/vnd.wordperfect":["wpd"],"application/vnd.wqd":["wqd"],"application/vnd.wt.stf":["stf"],"application/vnd.xara":["xar"],"application/vnd.xfdl":["xfdl"],"application/vnd.yamaha.hv-dic":["hvd"],"application/vnd.yamaha.hv-script":["hvs"],"application/vnd.yamaha.hv-voice":["hvp"],"application/vnd.yamaha.openscoreformat":["osf"],"application/vnd.yamaha.openscoreformat.osfpvg+xml":["osfpvg"],"application/vnd.yamaha.smaf-audio":["saf"],"application/vnd.yamaha.smaf-phrase":["spf"],"application/vnd.yellowriver-custom-menu":["cmp"],"application/vnd.zul":["zir","zirz"],"application/vnd.zzazz.deck+xml":["zaz"],"application/x-7z-compressed":["7z"],"application/x-abiword":["abw"],"application/x-ace-compressed":["ace"],"application/x-apple-diskimage":["*dmg"],"application/x-arj":["arj"],"application/x-authorware-bin":["aab","x32","u32","vox"],"application/x-authorware-map":["aam"],"application/x-authorware-seg":["aas"],"application/x-bcpio":["bcpio"],"application/x-bdoc":["*bdoc"],"application/x-bittorrent":["torrent"],"application/x-blorb":["blb","blorb"],"application/x-bzip":["bz"],"application/x-bzip2":["bz2","boz"],"application/x-cbr":["cbr","cba","cbt","cbz","cb7"],"application/x-cdlink":["vcd"],"application/x-cfs-compressed":["cfs"],"application/x-chat":["chat"],"application/x-chess-pgn":["pgn"],"application/x-chrome-extension":["crx"],"application/x-cocoa":["cco"],"application/x-conference":["nsc"],"application/x-cpio":["cpio"],"application/x-csh":["csh"],"application/x-debian-package":["*deb","udeb"],"application/x-dgc-compressed":["dgc"],"application/x-director":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"],"application/x-doom":["wad"],"application/x-dtbncx+xml":["ncx"],"application/x-dtbook+xml":["dtb"],"application/x-dtbresource+xml":["res"],"application/x-dvi":["dvi"],"application/x-envoy":["evy"],"application/x-eva":["eva"],"application/x-font-bdf":["bdf"],"application/x-font-ghostscript":["gsf"],"application/x-font-linux-psf":["psf"],"application/x-font-pcf":["pcf"],"application/x-font-snf":["snf"],"application/x-font-type1":["pfa","pfb","pfm","afm"],"application/x-freearc":["arc"],"application/x-futuresplash":["spl"],"application/x-gca-compressed":["gca"],"application/x-glulx":["ulx"],"application/x-gnumeric":["gnumeric"],"application/x-gramps-xml":["gramps"],"application/x-gtar":["gtar"],"application/x-hdf":["hdf"],"application/x-httpd-php":["php"],"application/x-install-instructions":["install"],"application/x-iso9660-image":["*iso"],"application/x-iwork-keynote-sffkey":["*key"],"application/x-iwork-numbers-sffnumbers":["*numbers"],"application/x-iwork-pages-sffpages":["*pages"],"application/x-java-archive-diff":["jardiff"],"application/x-java-jnlp-file":["jnlp"],"application/x-keepass2":["kdbx"],"application/x-latex":["latex"],"application/x-lua-bytecode":["luac"],"application/x-lzh-compressed":["lzh","lha"],"application/x-makeself":["run"],"application/x-mie":["mie"],"application/x-mobipocket-ebook":["prc","mobi"],"application/x-ms-application":["application"],"application/x-ms-shortcut":["lnk"],"application/x-ms-wmd":["wmd"],"application/x-ms-wmz":["wmz"],"application/x-ms-xbap":["xbap"],"application/x-msaccess":["mdb"],"application/x-msbinder":["obd"],"application/x-mscardfile":["crd"],"application/x-msclip":["clp"],"application/x-msdos-program":["*exe"],"application/x-msdownload":["*exe","*dll","com","bat","*msi"],"application/x-msmediaview":["mvb","m13","m14"],"application/x-msmetafile":["*wmf","*wmz","*emf","emz"],"application/x-msmoney":["mny"],"application/x-mspublisher":["pub"],"application/x-msschedule":["scd"],"application/x-msterminal":["trm"],"application/x-mswrite":["wri"],"application/x-netcdf":["nc","cdf"],"application/x-ns-proxy-autoconfig":["pac"],"application/x-nzb":["nzb"],"application/x-perl":["pl","pm"],"application/x-pilot":["*prc","*pdb"],"application/x-pkcs12":["p12","pfx"],"application/x-pkcs7-certificates":["p7b","spc"],"application/x-pkcs7-certreqresp":["p7r"],"application/x-rar-compressed":["*rar"],"application/x-redhat-package-manager":["rpm"],"application/x-research-info-systems":["ris"],"application/x-sea":["sea"],"application/x-sh":["sh"],"application/x-shar":["shar"],"application/x-shockwave-flash":["swf"],"application/x-silverlight-app":["xap"],"application/x-sql":["sql"],"application/x-stuffit":["sit"],"application/x-stuffitx":["sitx"],"application/x-subrip":["srt"],"application/x-sv4cpio":["sv4cpio"],"application/x-sv4crc":["sv4crc"],"application/x-t3vm-image":["t3"],"application/x-tads":["gam"],"application/x-tar":["tar"],"application/x-tcl":["tcl","tk"],"application/x-tex":["tex"],"application/x-tex-tfm":["tfm"],"application/x-texinfo":["texinfo","texi"],"application/x-tgif":["*obj"],"application/x-ustar":["ustar"],"application/x-virtualbox-hdd":["hdd"],"application/x-virtualbox-ova":["ova"],"application/x-virtualbox-ovf":["ovf"],"application/x-virtualbox-vbox":["vbox"],"application/x-virtualbox-vbox-extpack":["vbox-extpack"],"application/x-virtualbox-vdi":["vdi"],"application/x-virtualbox-vhd":["vhd"],"application/x-virtualbox-vmdk":["vmdk"],"application/x-wais-source":["src"],"application/x-web-app-manifest+json":["webapp"],"application/x-x509-ca-cert":["der","crt","pem"],"application/x-xfig":["fig"],"application/x-xliff+xml":["*xlf"],"application/x-xpinstall":["xpi"],"application/x-xz":["xz"],"application/x-zmachine":["z1","z2","z3","z4","z5","z6","z7","z8"],"audio/vnd.dece.audio":["uva","uvva"],"audio/vnd.digital-winds":["eol"],"audio/vnd.dra":["dra"],"audio/vnd.dts":["dts"],"audio/vnd.dts.hd":["dtshd"],"audio/vnd.lucent.voice":["lvp"],"audio/vnd.ms-playready.media.pya":["pya"],"audio/vnd.nuera.ecelp4800":["ecelp4800"],"audio/vnd.nuera.ecelp7470":["ecelp7470"],"audio/vnd.nuera.ecelp9600":["ecelp9600"],"audio/vnd.rip":["rip"],"audio/x-aac":["aac"],"audio/x-aiff":["aif","aiff","aifc"],"audio/x-caf":["caf"],"audio/x-flac":["flac"],"audio/x-m4a":["*m4a"],"audio/x-matroska":["mka"],"audio/x-mpegurl":["m3u"],"audio/x-ms-wax":["wax"],"audio/x-ms-wma":["wma"],"audio/x-pn-realaudio":["ram","ra"],"audio/x-pn-realaudio-plugin":["rmp"],"audio/x-realaudio":["*ra"],"audio/x-wav":["*wav"],"chemical/x-cdx":["cdx"],"chemical/x-cif":["cif"],"chemical/x-cmdf":["cmdf"],"chemical/x-cml":["cml"],"chemical/x-csml":["csml"],"chemical/x-xyz":["xyz"],"image/prs.btif":["btif"],"image/prs.pti":["pti"],"image/vnd.adobe.photoshop":["psd"],"image/vnd.airzip.accelerator.azv":["azv"],"image/vnd.dece.graphic":["uvi","uvvi","uvg","uvvg"],"image/vnd.djvu":["djvu","djv"],"image/vnd.dvb.subtitle":["*sub"],"image/vnd.dwg":["dwg"],"image/vnd.dxf":["dxf"],"image/vnd.fastbidsheet":["fbs"],"image/vnd.fpx":["fpx"],"image/vnd.fst":["fst"],"image/vnd.fujixerox.edmics-mmr":["mmr"],"image/vnd.fujixerox.edmics-rlc":["rlc"],"image/vnd.microsoft.icon":["ico"],"image/vnd.ms-dds":["dds"],"image/vnd.ms-modi":["mdi"],"image/vnd.ms-photo":["wdp"],"image/vnd.net-fpx":["npx"],"image/vnd.pco.b16":["b16"],"image/vnd.tencent.tap":["tap"],"image/vnd.valve.source.texture":["vtf"],"image/vnd.wap.wbmp":["wbmp"],"image/vnd.xiff":["xif"],"image/vnd.zbrush.pcx":["pcx"],"image/x-3ds":["3ds"],"image/x-cmu-raster":["ras"],"image/x-cmx":["cmx"],"image/x-freehand":["fh","fhc","fh4","fh5","fh7"],"image/x-icon":["*ico"],"image/x-jng":["jng"],"image/x-mrsid-image":["sid"],"image/x-ms-bmp":["*bmp"],"image/x-pcx":["*pcx"],"image/x-pict":["pic","pct"],"image/x-portable-anymap":["pnm"],"image/x-portable-bitmap":["pbm"],"image/x-portable-graymap":["pgm"],"image/x-portable-pixmap":["ppm"],"image/x-rgb":["rgb"],"image/x-tga":["tga"],"image/x-xbitmap":["xbm"],"image/x-xpixmap":["xpm"],"image/x-xwindowdump":["xwd"],"message/vnd.wfa.wsc":["wsc"],"model/vnd.collada+xml":["dae"],"model/vnd.dwf":["dwf"],"model/vnd.gdl":["gdl"],"model/vnd.gtw":["gtw"],"model/vnd.mts":["mts"],"model/vnd.opengex":["ogex"],"model/vnd.parasolid.transmit.binary":["x_b"],"model/vnd.parasolid.transmit.text":["x_t"],"model/vnd.sap.vds":["vds"],"model/vnd.usdz+zip":["usdz"],"model/vnd.valve.source.compiled-map":["bsp"],"model/vnd.vtu":["vtu"],"text/prs.lines.tag":["dsc"],"text/vnd.curl":["curl"],"text/vnd.curl.dcurl":["dcurl"],"text/vnd.curl.mcurl":["mcurl"],"text/vnd.curl.scurl":["scurl"],"text/vnd.dvb.subtitle":["sub"],"text/vnd.fly":["fly"],"text/vnd.fmi.flexstor":["flx"],"text/vnd.graphviz":["gv"],"text/vnd.in3d.3dml":["3dml"],"text/vnd.in3d.spot":["spot"],"text/vnd.sun.j2me.app-descriptor":["jad"],"text/vnd.wap.wml":["wml"],"text/vnd.wap.wmlscript":["wmls"],"text/x-asm":["s","asm"],"text/x-c":["c","cc","cxx","cpp","h","hh","dic"],"text/x-component":["htc"],"text/x-fortran":["f","for","f77","f90"],"text/x-handlebars-template":["hbs"],"text/x-java-source":["java"],"text/x-lua":["lua"],"text/x-markdown":["mkd"],"text/x-nfo":["nfo"],"text/x-opml":["opml"],"text/x-org":["*org"],"text/x-pascal":["p","pas"],"text/x-processing":["pde"],"text/x-sass":["sass"],"text/x-scss":["scss"],"text/x-setext":["etx"],"text/x-sfv":["sfv"],"text/x-suse-ymp":["ymp"],"text/x-uuencode":["uu"],"text/x-vcalendar":["vcs"],"text/x-vcard":["vcf"],"video/vnd.dece.hd":["uvh","uvvh"],"video/vnd.dece.mobile":["uvm","uvvm"],"video/vnd.dece.pd":["uvp","uvvp"],"video/vnd.dece.sd":["uvs","uvvs"],"video/vnd.dece.video":["uvv","uvvv"],"video/vnd.dvb.file":["dvb"],"video/vnd.fvt":["fvt"],"video/vnd.mpegurl":["mxu","m4u"],"video/vnd.ms-playready.media.pyv":["pyv"],"video/vnd.uvvu.mp4":["uvu","uvvu"],"video/vnd.vivo":["viv"],"video/x-f4v":["f4v"],"video/x-fli":["fli"],"video/x-flv":["flv"],"video/x-m4v":["m4v"],"video/x-matroska":["mkv","mk3d","mks"],"video/x-mng":["mng"],"video/x-ms-asf":["asf","asx"],"video/x-ms-vob":["vob"],"video/x-ms-wm":["wm"],"video/x-ms-wmv":["wmv"],"video/x-ms-wmx":["wmx"],"video/x-ms-wvx":["wvx"],"video/x-msvideo":["avi"],"video/x-sgi-movie":["movie"],"video/x-smv":["smv"],"x-conference/x-cooltalk":["ice"]}});var yl=x((U_,xl)=>{"use strict";var vd=dl();xl.exports=new vd(gl(),_l())});var wl=x((D_,bl)=>{bl.exports=function(t,e){for(var i=[],r=0;r<t.length;r++){var n=e(t[r],r);_d(n)?i.push.apply(i,n):i.push(n)}return i};var _d=Array.isArray||function(t){return Object.prototype.toString.call(t)==="[object Array]"}});var Ol=x((j_,Cl)=>{"use strict";Cl.exports=Sl;function Sl(t,e,i){t instanceof RegExp&&(t=El(t,i)),e instanceof RegExp&&(e=El(e,i));var r=kl(t,e,i);return r&&{start:r[0],end:r[1],pre:i.slice(0,r[0]),body:i.slice(r[0]+t.length,r[1]),post:i.slice(r[1]+e.length)}}function El(t,e){var i=e.match(t);return i?i[0]:null}Sl.range=kl;function kl(t,e,i){var r,n,s,o,a,l=i.indexOf(t),c=i.indexOf(e,l+1),u=l;if(l>=0&&c>0){if(t===e)return[l,c];for(r=[],s=i.length;u>=0&&!a;)u==l?(r.push(u),l=i.indexOf(t,u+1)):r.length==1?a=[r.pop(),c]:(n=r.pop(),n<s&&(s=n,o=c),c=i.indexOf(e,u+1)),u=l<c&&l>=0?l:c;r.length&&(a=[s,o])}return a}});var Pl=x((q_,Nl)=>{var xd=wl(),Il=Ol();Nl.exports=wd;var Tl="\0SLASH"+Math.random()+"\0",Al="\0OPEN"+Math.random()+"\0",An="\0CLOSE"+Math.random()+"\0",Rl="\0COMMA"+Math.random()+"\0",Bl="\0PERIOD"+Math.random()+"\0";function Tn(t){return parseInt(t,10)==t?parseInt(t,10):t.charCodeAt(0)}function yd(t){return t.split("\\\\").join(Tl).split("\\{").join(Al).split("\\}").join(An).split("\\,").join(Rl).split("\\.").join(Bl)}function bd(t){return t.split(Tl).join("\\").split(Al).join("{").split(An).join("}").split(Rl).join(",").split(Bl).join(".")}function Ll(t){if(!t)return[""];var e=[],i=Il("{","}",t);if(!i)return t.split(",");var r=i.pre,n=i.body,s=i.post,o=r.split(",");o[o.length-1]+="{"+n+"}";var a=Ll(s);return s.length&&(o[o.length-1]+=a.shift(),o.push.apply(o,a)),e.push.apply(e,o),e}function wd(t){return t?(t.substr(0,2)==="{}"&&(t="\\{\\}"+t.substr(2)),ui(yd(t),!0).map(bd)):[]}function Ed(t){return"{"+t+"}"}function Sd(t){return/^-?0\d/.test(t)}function kd(t,e){return t<=e}function Cd(t,e){return t>=e}function ui(t,e){var i=[],r=Il("{","}",t);if(!r||/\$$/.test(r.pre))return[t];var n=/^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(r.body),s=/^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(r.body),o=n||s,a=r.body.indexOf(",")>=0;if(!o&&!a)return r.post.match(/,.*\}/)?(t=r.pre+"{"+r.body+An+r.post,ui(t)):[t];var l;if(o)l=r.body.split(/\.\./);else if(l=Ll(r.body),l.length===1&&(l=ui(l[0],!1).map(Ed),l.length===1)){var u=r.post.length?ui(r.post,!1):[""];return u.map(function(B){return r.pre+l[0]+B})}var c=r.pre,u=r.post.length?ui(r.post,!1):[""],f;if(o){var h=Tn(l[0]),p=Tn(l[1]),d=Math.max(l[0].length,l[1].length),m=l.length==3?Math.abs(Tn(l[2])):1,g=kd,y=p<h;y&&(m*=-1,g=Cd);var I=l.some(Sd);f=[];for(var w=h;g(w,p);w+=m){var S;if(s)S=String.fromCharCode(w),S==="\\"&&(S="");else if(S=String(w),I){var b=d-S.length;if(b>0){var $=new Array(b+1).join("0");w<0?S="-"+$+S.slice(1):S=$+S}}f.push(S)}}else f=xd(l,function(T){return ui(T,!1)});for(var C=0;C<f.length;C++)for(var U=0;U<u.length;U++){var E=c+f[C]+u[U];(!e||o||E)&&i.push(E)}return i}});var Hi=x((H_,jl)=>{jl.exports=Ye;Ye.Minimatch=De;var qi=function(){try{return __nccwpck_require__(1017)}catch{}}()||{sep:"/"};Ye.sep=qi.sep;var Ln=Ye.GLOBSTAR=De.GLOBSTAR={},Od=Pl(),Fl={"!":{open:"(?:(?!(?:",close:"))[^/]*?)"},"?":{open:"(?:",close:")?"},"+":{open:"(?:",close:")+"},"*":{open:"(?:",close:")*"},"@":{open:"(?:",close:")"}},Rn="[^/]",Bn=Rn+"*?",Id="(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",Td="(?:(?!(?:\\/|^)\\.).)*?",Ml=Ad("().*{}+?[]^$\\!");function Ad(t){return t.split("").reduce(function(e,i){return e[i]=!0,e},{})}var Ul=/\/+/;Ye.filter=Rd;function Rd(t,e){return e=e||{},function(i,r,n){return Ye(i,t,e)}}function xt(t,e){e=e||{};var i={};return Object.keys(t).forEach(function(r){i[r]=t[r]}),Object.keys(e).forEach(function(r){i[r]=e[r]}),i}Ye.defaults=function(t){if(!t||typeof t!="object"||!Object.keys(t).length)return Ye;var e=Ye,i=function(n,s,o){return e(n,s,xt(t,o))};return i.Minimatch=function(n,s){return new e.Minimatch(n,xt(t,s))},i.Minimatch.defaults=function(n){return e.defaults(xt(t,n)).Minimatch},i.filter=function(n,s){return e.filter(n,xt(t,s))},i.defaults=function(n){return e.defaults(xt(t,n))},i.makeRe=function(n,s){return e.makeRe(n,xt(t,s))},i.braceExpand=function(n,s){return e.braceExpand(n,xt(t,s))},i.match=function(r,n,s){return e.match(r,n,xt(t,s))},i};De.defaults=function(t){return Ye.defaults(t).Minimatch};function Ye(t,e,i){return Lr(e),i||(i={}),!i.nocomment&&e.charAt(0)==="#"?!1:new De(e,i).match(t)}function De(t,e){if(!(this instanceof De))return new De(t,e);Lr(t),e||(e={}),t=t.trim(),!e.allowWindowsEscape&&qi.sep!=="/"&&(t=t.split(qi.sep).join("/")),this.options=e,this.set=[],this.pattern=t,this.regexp=null,this.negate=!1,this.comment=!1,this.empty=!1,this.partial=!!e.partial,this.make()}De.prototype.debug=function(){};De.prototype.make=Bd;function Bd(){var t=this.pattern,e=this.options;if(!e.nocomment&&t.charAt(0)==="#"){this.comment=!0;return}if(!t){this.empty=!0;return}this.parseNegate();var i=this.globSet=this.braceExpand();e.debug&&(this.debug=function(){console.error.apply(console,arguments)}),this.debug(this.pattern,i),i=this.globParts=i.map(function(r){return r.split(Ul)}),this.debug(this.pattern,i),i=i.map(function(r,n,s){return r.map(this.parse,this)},this),this.debug(this.pattern,i),i=i.filter(function(r){return r.indexOf(!1)===-1}),this.debug(this.pattern,i),this.set=i}De.prototype.parseNegate=Ld;function Ld(){var t=this.pattern,e=!1,i=this.options,r=0;if(!i.nonegate){for(var n=0,s=t.length;n<s&&t.charAt(n)==="!";n++)e=!e,r++;r&&(this.pattern=t.substr(r)),this.negate=e}}Ye.braceExpand=function(t,e){return Dl(t,e)};De.prototype.braceExpand=Dl;function Dl(t,e){return e||(this instanceof De?e=this.options:e={}),t=typeof t=="undefined"?this.pattern:t,Lr(t),e.nobrace||!/\{(?:(?!\{).)*\}/.test(t)?[t]:Od(t)}var Nd=1024*64,Lr=function(t){if(typeof t!="string")throw new TypeError("invalid pattern");if(t.length>Nd)throw new TypeError("pattern is too long")};De.prototype.parse=Pd;var Br={};function Pd(t,e){Lr(t);var i=this.options;if(t==="**")if(i.noglobstar)t="*";else return Ln;if(t==="")return"";var r="",n=!!i.nocase,s=!1,o=[],a=[],l,c=!1,u=-1,f=-1,h=t.charAt(0)==="."?"":i.dot?"(?!(?:^|\\/)\\.{1,2}(?:$|\\/))":"(?!\\.)",p=this;function d(){if(l){switch(l){case"*":r+=Bn,n=!0;break;case"?":r+=Rn,n=!0;break;default:r+="\\"+l;break}p.debug("clearStateChar %j %j",l,r),l=!1}}for(var m=0,g=t.length,y;m<g&&(y=t.charAt(m));m++){if(this.debug("%s	%s %s %j",t,m,r,y),s&&Ml[y]){r+="\\"+y,s=!1;continue}switch(y){case"/":return!1;case"\\":d(),s=!0;continue;case"?":case"*":case"+":case"@":case"!":if(this.debug("%s	%s %s %j <-- stateChar",t,m,r,y),c){this.debug("  in class"),y==="!"&&m===f+1&&(y="^"),r+=y;continue}p.debug("call clearStateChar %j",l),d(),l=y,i.noext&&d();continue;case"(":if(c){r+="(";continue}if(!l){r+="\\(";continue}o.push({type:l,start:m-1,reStart:r.length,open:Fl[l].open,close:Fl[l].close}),r+=l==="!"?"(?:(?!(?:":"(?:",this.debug("plType %j %j",l,r),l=!1;continue;case")":if(c||!o.length){r+="\\)";continue}d(),n=!0;var I=o.pop();r+=I.close,I.type==="!"&&a.push(I),I.reEnd=r.length;continue;case"|":if(c||!o.length||s){r+="\\|",s=!1;continue}d(),r+="|";continue;case"[":if(d(),c){r+="\\"+y;continue}c=!0,f=m,u=r.length,r+=y;continue;case"]":if(m===f+1||!c){r+="\\"+y,s=!1;continue}var w=t.substring(f+1,m);try{RegExp("["+w+"]")}catch{var S=this.parse(w,Br);r=r.substr(0,u)+"\\["+S[0]+"\\]",n=n||S[1],c=!1;continue}n=!0,c=!1,r+=y;continue;default:d(),s?s=!1:Ml[y]&&!(y==="^"&&c)&&(r+="\\"),r+=y}}for(c&&(w=t.substr(f+1),S=this.parse(w,Br),r=r.substr(0,u)+"\\["+S[0],n=n||S[1]),I=o.pop();I;I=o.pop()){var b=r.slice(I.reStart+I.open.length);this.debug("setting tail",r,I),b=b.replace(/((?:\\{2}){0,64})(\\?)\|/g,function(Se,ce,re){return re||(re="\\"),ce+ce+re+"|"}),this.debug(`tail=%j
   %s`,b,b,I,r);var $=I.type==="*"?Bn:I.type==="?"?Rn:"\\"+I.type;n=!0,r=r.slice(0,I.reStart)+$+"\\("+b}d(),s&&(r+="\\\\");var C=!1;switch(r.charAt(0)){case"[":case".":case"(":C=!0}for(var U=a.length-1;U>-1;U--){var E=a[U],T=r.slice(0,E.reStart),B=r.slice(E.reStart,E.reEnd-8),G=r.slice(E.reEnd-8,E.reEnd),L=r.slice(E.reEnd);G+=L;var Q=T.split("(").length-1,R=L;for(m=0;m<Q;m++)R=R.replace(/\)[+*?]?/,"");L=R;var F="";L===""&&e!==Br&&(F="$");var j=T+B+L+F+G;r=j}if(r!==""&&n&&(r="(?=.)"+r),C&&(r=h+r),e===Br)return[r,n];if(!n)return Md(t);var z=i.nocase?"i":"";try{var N=new RegExp("^"+r+"$",z)}catch{return new RegExp("$.")}return N._glob=t,N._src=r,N}Ye.makeRe=function(t,e){return new De(t,e||{}).makeRe()};De.prototype.makeRe=Fd;function Fd(){if(this.regexp||this.regexp===!1)return this.regexp;var t=this.set;if(!t.length)return this.regexp=!1,this.regexp;var e=this.options,i=e.noglobstar?Bn:e.dot?Id:Td,r=e.nocase?"i":"",n=t.map(function(s){return s.map(function(o){return o===Ln?i:typeof o=="string"?Ud(o):o._src}).join("\\/")}).join("|");n="^(?:"+n+")$",this.negate&&(n="^(?!"+n+").*$");try{this.regexp=new RegExp(n,r)}catch{this.regexp=!1}return this.regexp}Ye.match=function(t,e,i){i=i||{};var r=new De(e,i);return t=t.filter(function(n){return r.match(n)}),r.options.nonull&&!t.length&&t.push(e),t};De.prototype.match=function(e,i){if(typeof i=="undefined"&&(i=this.partial),this.debug("match",e,this.pattern),this.comment)return!1;if(this.empty)return e==="";if(e==="/"&&i)return!0;var r=this.options;qi.sep!=="/"&&(e=e.split(qi.sep).join("/")),e=e.split(Ul),this.debug(this.pattern,"split",e);var n=this.set;this.debug(this.pattern,"set",n);var s,o;for(o=e.length-1;o>=0&&(s=e[o],!s);o--);for(o=0;o<n.length;o++){var a=n[o],l=e;r.matchBase&&a.length===1&&(l=[s]);var c=this.matchOne(l,a,i);if(c)return r.flipNegate?!0:!this.negate}return r.flipNegate?!1:this.negate};De.prototype.matchOne=function(t,e,i){var r=this.options;this.debug("matchOne",{this:this,file:t,pattern:e}),this.debug("matchOne",t.length,e.length);for(var n=0,s=0,o=t.length,a=e.length;n<o&&s<a;n++,s++){this.debug("matchOne loop");var l=e[s],c=t[n];if(this.debug(e,l,c),l===!1)return!1;if(l===Ln){this.debug("GLOBSTAR",[e,l,c]);var u=n,f=s+1;if(f===a){for(this.debug("** at the end");n<o;n++)if(t[n]==="."||t[n]===".."||!r.dot&&t[n].charAt(0)===".")return!1;return!0}for(;u<o;){var h=t[u];if(this.debug(`
globstar while`,t,u,e,f,h),this.matchOne(t.slice(u),e.slice(f),i))return this.debug("globstar found match!",u,o,h),!0;if(h==="."||h===".."||!r.dot&&h.charAt(0)==="."){this.debug("dot detected!",t,u,e,f);break}this.debug("globstar swallow a segment, and continue"),u++}return!!(i&&(this.debug(`
>>> no match, partial?`,t,u,e,f),u===o))}var p;if(typeof l=="string"?(p=c===l,this.debug("string match",l,c,p)):(p=c.match(l),this.debug("pattern match",l,c,p)),!p)return!1}if(n===o&&s===a)return!0;if(n===o)return i;if(s===a)return n===o-1&&t[n]==="";throw new Error("wtf?")};function Md(t){return t.replace(/\\(.)/g,"$1")}function Ud(t){return t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")}});var Nn=x((V_,Hl)=>{"use strict";var Dd=__nccwpck_require__(3837),ql=__nccwpck_require__(2781),nt=Hl.exports=function(){ql.call(this),this._buffers=[],this._buffered=0,this._reads=[],this._paused=!1,this._encoding="utf8",this.writable=!0};Dd.inherits(nt,ql);nt.prototype.read=function(t,e){this._reads.push({length:Math.abs(t),allowLess:t<0,func:e}),process.nextTick(function(){this._process(),this._paused&&this._reads&&this._reads.length>0&&(this._paused=!1,this.emit("drain"))}.bind(this))};nt.prototype.write=function(t,e){if(!this.writable)return this.emit("error",new Error("Stream not writable")),!1;let i;return Buffer.isBuffer(t)?i=t:i=Buffer.from(t,e||this._encoding),this._buffers.push(i),this._buffered+=i.length,this._process(),this._reads&&this._reads.length===0&&(this._paused=!0),this.writable&&!this._paused};nt.prototype.end=function(t,e){t&&this.write(t,e),this.writable=!1,this._buffers&&(this._buffers.length===0?this._end():(this._buffers.push(null),this._process()))};nt.prototype.destroySoon=nt.prototype.end;nt.prototype._end=function(){this._reads.length>0&&this.emit("error",new Error("Unexpected end of input")),this.destroy()};nt.prototype.destroy=function(){!this._buffers||(this.writable=!1,this._reads=null,this._buffers=null,this.emit("close"))};nt.prototype._processReadAllowingLess=function(t){this._reads.shift();let e=this._buffers[0];e.length>t.length?(this._buffered-=t.length,this._buffers[0]=e.slice(t.length),t.func.call(this,e.slice(0,t.length))):(this._buffered-=e.length,this._buffers.shift(),t.func.call(this,e))};nt.prototype._processRead=function(t){this._reads.shift();let e=0,i=0,r=Buffer.alloc(t.length);for(;e<t.length;){let n=this._buffers[i++],s=Math.min(n.length,t.length-e);n.copy(r,e,0,s),e+=s,s!==n.length&&(this._buffers[--i]=n.slice(s))}i>0&&this._buffers.splice(0,i),this._buffered-=t.length,t.func.call(this,r)};nt.prototype._process=function(){try{for(;this._buffered>0&&this._reads&&this._reads.length>0;){let t=this._reads[0];if(t.allowLess)this._processReadAllowingLess(t);else if(this._buffered>=t.length)this._processRead(t);else break}this._buffers&&!this.writable&&this._end()}catch(t){this.emit("error",t)}}});var Fn=x(Pn=>{"use strict";var yt=[{x:[0],y:[0]},{x:[4],y:[0]},{x:[0,4],y:[4]},{x:[2,6],y:[0,4]},{x:[0,2,4,6],y:[2,6]},{x:[1,3,5,7],y:[0,2,4,6]},{x:[0,1,2,3,4,5,6,7],y:[1,3,5,7]}];Pn.getImagePasses=function(t,e){let i=[],r=t%8,n=e%8,s=(t-r)/8,o=(e-n)/8;for(let a=0;a<yt.length;a++){let l=yt[a],c=s*l.x.length,u=o*l.y.length;for(let f=0;f<l.x.length&&l.x[f]<r;f++)c++;for(let f=0;f<l.y.length&&l.y[f]<n;f++)u++;c>0&&u>0&&i.push({width:c,height:u,index:a})}return i};Pn.getInterlaceIterator=function(t){return function(e,i,r){let n=e%yt[r].x.length,s=(e-n)/yt[r].x.length*8+yt[r].x[n],o=i%yt[r].y.length,a=(i-o)/yt[r].y.length*8+yt[r].y[o];return s*4+a*t*4}}});var Mn=x((G_,Vl)=>{"use strict";Vl.exports=function(e,i,r){let n=e+i-r,s=Math.abs(n-e),o=Math.abs(n-i),a=Math.abs(n-r);return s<=o&&s<=a?e:o<=a?i:r}});var Un=x((z_,Gl)=>{"use strict";var jd=Fn(),qd=Mn();function $l(t,e,i){let r=t*e;return i!==8&&(r=Math.ceil(r/(8/i))),r}var fi=Gl.exports=function(t,e){let i=t.width,r=t.height,n=t.interlace,s=t.bpp,o=t.depth;if(this.read=e.read,this.write=e.write,this.complete=e.complete,this._imageIndex=0,this._images=[],n){let a=jd.getImagePasses(i,r);for(let l=0;l<a.length;l++)this._images.push({byteWidth:$l(a[l].width,s,o),height:a[l].height,lineIndex:0})}else this._images.push({byteWidth:$l(i,s,o),height:r,lineIndex:0});o===8?this._xComparison=s:o===16?this._xComparison=s*2:this._xComparison=1};fi.prototype.start=function(){this.read(this._images[this._imageIndex].byteWidth+1,this._reverseFilterLine.bind(this))};fi.prototype._unFilterType1=function(t,e,i){let r=this._xComparison,n=r-1;for(let s=0;s<i;s++){let o=t[1+s],a=s>n?e[s-r]:0;e[s]=o+a}};fi.prototype._unFilterType2=function(t,e,i){let r=this._lastLine;for(let n=0;n<i;n++){let s=t[1+n],o=r?r[n]:0;e[n]=s+o}};fi.prototype._unFilterType3=function(t,e,i){let r=this._xComparison,n=r-1,s=this._lastLine;for(let o=0;o<i;o++){let a=t[1+o],l=s?s[o]:0,c=o>n?e[o-r]:0,u=Math.floor((c+l)/2);e[o]=a+u}};fi.prototype._unFilterType4=function(t,e,i){let r=this._xComparison,n=r-1,s=this._lastLine;for(let o=0;o<i;o++){let a=t[1+o],l=s?s[o]:0,c=o>n?e[o-r]:0,u=o>n&&s?s[o-r]:0,f=qd(c,l,u);e[o]=a+f}};fi.prototype._reverseFilterLine=function(t){let e=t[0],i,r=this._images[this._imageIndex],n=r.byteWidth;if(e===0)i=t.slice(1,n+1);else switch(i=Buffer.alloc(n),e){case 1:this._unFilterType1(t,i,n);break;case 2:this._unFilterType2(t,i,n);break;case 3:this._unFilterType3(t,i,n);break;case 4:this._unFilterType4(t,i,n);break;default:throw new Error("Unrecognised filter type - "+e)}this.write(i),r.lineIndex++,r.lineIndex>=r.height?(this._lastLine=null,this._imageIndex++,r=this._images[this._imageIndex]):this._lastLine=i,r?this.read(r.byteWidth+1,this._reverseFilterLine.bind(this)):(this._lastLine=null,this.complete())}});var Yl=x((W_,Wl)=>{"use strict";var Hd=__nccwpck_require__(3837),zl=Nn(),Vd=Un(),$d=Wl.exports=function(t){zl.call(this);let e=[],i=this;this._filter=new Vd(t,{read:this.read.bind(this),write:function(r){e.push(r)},complete:function(){i.emit("complete",Buffer.concat(e))}}),this._filter.start()};Hd.inherits($d,zl)});var hi=x((Y_,Kl)=>{"use strict";Kl.exports={PNG_SIGNATURE:[137,80,78,71,13,10,26,10],TYPE_IHDR:1229472850,TYPE_IEND:1229278788,TYPE_IDAT:1229209940,TYPE_PLTE:1347179589,TYPE_tRNS:1951551059,TYPE_gAMA:1732332865,COLORTYPE_GRAYSCALE:0,COLORTYPE_PALETTE:1,COLORTYPE_COLOR:2,COLORTYPE_ALPHA:4,COLORTYPE_PALETTE_COLOR:3,COLORTYPE_COLOR_ALPHA:6,COLORTYPE_TO_BPP_MAP:{0:1,2:3,3:1,4:2,6:4},GAMMA_DIVISION:1e5}});var qn=x((K_,Zl)=>{"use strict";var Dn=[];(function(){for(let t=0;t<256;t++){let e=t;for(let i=0;i<8;i++)e&1?e=3988292384^e>>>1:e=e>>>1;Dn[t]=e}})();var jn=Zl.exports=function(){this._crc=-1};jn.prototype.write=function(t){for(let e=0;e<t.length;e++)this._crc=Dn[(this._crc^t[e])&255]^this._crc>>>8;return!0};jn.prototype.crc32=function(){return this._crc^-1};jn.crc32=function(t){let e=-1;for(let i=0;i<t.length;i++)e=Dn[(e^t[i])&255]^e>>>8;return e^-1}});var Hn=x((Z_,Xl)=>{"use strict";var Ae=hi(),Gd=qn(),Ne=Xl.exports=function(t,e){this._options=t,t.checkCRC=t.checkCRC!==!1,this._hasIHDR=!1,this._hasIEND=!1,this._emittedHeadersFinished=!1,this._palette=[],this._colorType=0,this._chunks={},this._chunks[Ae.TYPE_IHDR]=this._handleIHDR.bind(this),this._chunks[Ae.TYPE_IEND]=this._handleIEND.bind(this),this._chunks[Ae.TYPE_IDAT]=this._handleIDAT.bind(this),this._chunks[Ae.TYPE_PLTE]=this._handlePLTE.bind(this),this._chunks[Ae.TYPE_tRNS]=this._handleTRNS.bind(this),this._chunks[Ae.TYPE_gAMA]=this._handleGAMA.bind(this),this.read=e.read,this.error=e.error,this.metadata=e.metadata,this.gamma=e.gamma,this.transColor=e.transColor,this.palette=e.palette,this.parsed=e.parsed,this.inflateData=e.inflateData,this.finished=e.finished,this.simpleTransparency=e.simpleTransparency,this.headersFinished=e.headersFinished||function(){}};Ne.prototype.start=function(){this.read(Ae.PNG_SIGNATURE.length,this._parseSignature.bind(this))};Ne.prototype._parseSignature=function(t){let e=Ae.PNG_SIGNATURE;for(let i=0;i<e.length;i++)if(t[i]!==e[i]){this.error(new Error("Invalid file signature"));return}this.read(8,this._parseChunkBegin.bind(this))};Ne.prototype._parseChunkBegin=function(t){let e=t.readUInt32BE(0),i=t.readUInt32BE(4),r="";for(let s=4;s<8;s++)r+=String.fromCharCode(t[s]);let n=Boolean(t[4]&32);if(!this._hasIHDR&&i!==Ae.TYPE_IHDR){this.error(new Error("Expected IHDR on beggining"));return}if(this._crc=new Gd,this._crc.write(Buffer.from(r)),this._chunks[i])return this._chunks[i](e);if(!n){this.error(new Error("Unsupported critical chunk type "+r));return}this.read(e+4,this._skipChunk.bind(this))};Ne.prototype._skipChunk=function(){this.read(8,this._parseChunkBegin.bind(this))};Ne.prototype._handleChunkEnd=function(){this.read(4,this._parseChunkEnd.bind(this))};Ne.prototype._parseChunkEnd=function(t){let e=t.readInt32BE(0),i=this._crc.crc32();if(this._options.checkCRC&&i!==e){this.error(new Error("Crc error - "+e+" - "+i));return}this._hasIEND||this.read(8,this._parseChunkBegin.bind(this))};Ne.prototype._handleIHDR=function(t){this.read(t,this._parseIHDR.bind(this))};Ne.prototype._parseIHDR=function(t){this._crc.write(t);let e=t.readUInt32BE(0),i=t.readUInt32BE(4),r=t[8],n=t[9],s=t[10],o=t[11],a=t[12];if(r!==8&&r!==4&&r!==2&&r!==1&&r!==16){this.error(new Error("Unsupported bit depth "+r));return}if(!(n in Ae.COLORTYPE_TO_BPP_MAP)){this.error(new Error("Unsupported color type"));return}if(s!==0){this.error(new Error("Unsupported compression method"));return}if(o!==0){this.error(new Error("Unsupported filter method"));return}if(a!==0&&a!==1){this.error(new Error("Unsupported interlace method"));return}this._colorType=n;let l=Ae.COLORTYPE_TO_BPP_MAP[this._colorType];this._hasIHDR=!0,this.metadata({width:e,height:i,depth:r,interlace:Boolean(a),palette:Boolean(n&Ae.COLORTYPE_PALETTE),color:Boolean(n&Ae.COLORTYPE_COLOR),alpha:Boolean(n&Ae.COLORTYPE_ALPHA),bpp:l,colorType:n}),this._handleChunkEnd()};Ne.prototype._handlePLTE=function(t){this.read(t,this._parsePLTE.bind(this))};Ne.prototype._parsePLTE=function(t){this._crc.write(t);let e=Math.floor(t.length/3);for(let i=0;i<e;i++)this._palette.push([t[i*3],t[i*3+1],t[i*3+2],255]);this.palette(this._palette),this._handleChunkEnd()};Ne.prototype._handleTRNS=function(t){this.simpleTransparency(),this.read(t,this._parseTRNS.bind(this))};Ne.prototype._parseTRNS=function(t){if(this._crc.write(t),this._colorType===Ae.COLORTYPE_PALETTE_COLOR){if(this._palette.length===0){this.error(new Error("Transparency chunk must be after palette"));return}if(t.length>this._palette.length){this.error(new Error("More transparent colors than palette size"));return}for(let e=0;e<t.length;e++)this._palette[e][3]=t[e];this.palette(this._palette)}this._colorType===Ae.COLORTYPE_GRAYSCALE&&this.transColor([t.readUInt16BE(0)]),this._colorType===Ae.COLORTYPE_COLOR&&this.transColor([t.readUInt16BE(0),t.readUInt16BE(2),t.readUInt16BE(4)]),this._handleChunkEnd()};Ne.prototype._handleGAMA=function(t){this.read(t,this._parseGAMA.bind(this))};Ne.prototype._parseGAMA=function(t){this._crc.write(t),this.gamma(t.readUInt32BE(0)/Ae.GAMMA_DIVISION),this._handleChunkEnd()};Ne.prototype._handleIDAT=function(t){this._emittedHeadersFinished||(this._emittedHeadersFinished=!0,this.headersFinished()),this.read(-t,this._parseIDAT.bind(this,t))};Ne.prototype._parseIDAT=function(t,e){if(this._crc.write(e),this._colorType===Ae.COLORTYPE_PALETTE_COLOR&&this._palette.length===0)throw new Error("Expected palette not found");this.inflateData(e);let i=t-e.length;i>0?this._handleIDAT(i):this._handleChunkEnd()};Ne.prototype._handleIEND=function(t){this.read(t,this._parseIEND.bind(this))};Ne.prototype._parseIEND=function(t){this._crc.write(t),this._hasIEND=!0,this._handleChunkEnd(),this.finished&&this.finished()}});var Vn=x(Jl=>{"use strict";var Ql=Fn(),zd=[function(){},function(t,e,i,r){if(r===e.length)throw new Error("Ran out of data");let n=e[r];t[i]=n,t[i+1]=n,t[i+2]=n,t[i+3]=255},function(t,e,i,r){if(r+1>=e.length)throw new Error("Ran out of data");let n=e[r];t[i]=n,t[i+1]=n,t[i+2]=n,t[i+3]=e[r+1]},function(t,e,i,r){if(r+2>=e.length)throw new Error("Ran out of data");t[i]=e[r],t[i+1]=e[r+1],t[i+2]=e[r+2],t[i+3]=255},function(t,e,i,r){if(r+3>=e.length)throw new Error("Ran out of data");t[i]=e[r],t[i+1]=e[r+1],t[i+2]=e[r+2],t[i+3]=e[r+3]}],Wd=[function(){},function(t,e,i,r){let n=e[0];t[i]=n,t[i+1]=n,t[i+2]=n,t[i+3]=r},function(t,e,i){let r=e[0];t[i]=r,t[i+1]=r,t[i+2]=r,t[i+3]=e[1]},function(t,e,i,r){t[i]=e[0],t[i+1]=e[1],t[i+2]=e[2],t[i+3]=r},function(t,e,i){t[i]=e[0],t[i+1]=e[1],t[i+2]=e[2],t[i+3]=e[3]}];function Yd(t,e){let i=[],r=0;function n(){if(r===t.length)throw new Error("Ran out of data");let s=t[r];r++;let o,a,l,c,u,f,h,p;switch(e){default:throw new Error("unrecognised depth");case 16:h=t[r],r++,i.push((s<<8)+h);break;case 4:h=s&15,p=s>>4,i.push(p,h);break;case 2:u=s&3,f=s>>2&3,h=s>>4&3,p=s>>6&3,i.push(p,h,f,u);break;case 1:o=s&1,a=s>>1&1,l=s>>2&1,c=s>>3&1,u=s>>4&1,f=s>>5&1,h=s>>6&1,p=s>>7&1,i.push(p,h,f,u,c,l,a,o);break}}return{get:function(s){for(;i.length<s;)n();let o=i.slice(0,s);return i=i.slice(s),o},resetAfterLine:function(){i.length=0},end:function(){if(r!==t.length)throw new Error("extra data found")}}}function Kd(t,e,i,r,n,s){let o=t.width,a=t.height,l=t.index;for(let c=0;c<a;c++)for(let u=0;u<o;u++){let f=i(u,c,l);zd[r](e,n,f,s),s+=r}return s}function Zd(t,e,i,r,n,s){let o=t.width,a=t.height,l=t.index;for(let c=0;c<a;c++){for(let u=0;u<o;u++){let f=n.get(r),h=i(u,c,l);Wd[r](e,f,h,s)}n.resetAfterLine()}}Jl.dataToBitMap=function(t,e){let i=e.width,r=e.height,n=e.depth,s=e.bpp,o=e.interlace,a;n!==8&&(a=Yd(t,n));let l;n<=8?l=Buffer.alloc(i*r*4):l=new Uint16Array(i*r*4);let c=Math.pow(2,n)-1,u=0,f,h;if(o)f=Ql.getImagePasses(i,r),h=Ql.getInterlaceIterator(i,r);else{let p=0;h=function(){let d=p;return p+=4,d},f=[{width:i,height:r}]}for(let p=0;p<f.length;p++)n===8?u=Kd(f[p],l,h,s,t,u):Zd(f[p],l,h,s,a,c);if(n===8){if(u!==t.length)throw new Error("extra data found")}else a.end();return l}});var $n=x((Q_,ec)=>{"use strict";function Xd(t,e,i,r,n){let s=0;for(let o=0;o<r;o++)for(let a=0;a<i;a++){let l=n[t[s]];if(!l)throw new Error("index "+t[s]+" not in palette");for(let c=0;c<4;c++)e[s+c]=l[c];s+=4}}function Qd(t,e,i,r,n){let s=0;for(let o=0;o<r;o++)for(let a=0;a<i;a++){let l=!1;if(n.length===1?n[0]===t[s]&&(l=!0):n[0]===t[s]&&n[1]===t[s+1]&&n[2]===t[s+2]&&(l=!0),l)for(let c=0;c<4;c++)e[s+c]=0;s+=4}}function Jd(t,e,i,r,n){let s=255,o=Math.pow(2,n)-1,a=0;for(let l=0;l<r;l++)for(let c=0;c<i;c++){for(let u=0;u<4;u++)e[a+u]=Math.floor(t[a+u]*s/o+.5);a+=4}}ec.exports=function(t,e,i=!1){let r=e.depth,n=e.width,s=e.height,o=e.colorType,a=e.transColor,l=e.palette,c=t;return o===3?Xd(t,c,n,s,l):(a&&Qd(t,c,n,s,a),r!==8&&!i&&(r===16&&(c=Buffer.alloc(n*s*4)),Jd(t,c,n,s,r))),c}});var rc=x((J_,ic)=>{"use strict";var em=__nccwpck_require__(3837),Gn=__nccwpck_require__(9796),tc=Nn(),tm=Yl(),im=Hn(),rm=Vn(),nm=$n(),lt=ic.exports=function(t){tc.call(this),this._parser=new im(t,{read:this.read.bind(this),error:this._handleError.bind(this),metadata:this._handleMetaData.bind(this),gamma:this.emit.bind(this,"gamma"),palette:this._handlePalette.bind(this),transColor:this._handleTransColor.bind(this),finished:this._finished.bind(this),inflateData:this._inflateData.bind(this),simpleTransparency:this._simpleTransparency.bind(this),headersFinished:this._headersFinished.bind(this)}),this._options=t,this.writable=!0,this._parser.start()};em.inherits(lt,tc);lt.prototype._handleError=function(t){this.emit("error",t),this.writable=!1,this.destroy(),this._inflate&&this._inflate.destroy&&this._inflate.destroy(),this._filter&&(this._filter.destroy(),this._filter.on("error",function(){})),this.errord=!0};lt.prototype._inflateData=function(t){if(!this._inflate)if(this._bitmapInfo.interlace)this._inflate=Gn.createInflate(),this._inflate.on("error",this.emit.bind(this,"error")),this._filter.on("complete",this._complete.bind(this)),this._inflate.pipe(this._filter);else{let i=((this._bitmapInfo.width*this._bitmapInfo.bpp*this._bitmapInfo.depth+7>>3)+1)*this._bitmapInfo.height,r=Math.max(i,Gn.Z_MIN_CHUNK);this._inflate=Gn.createInflate({chunkSize:r});let n=i,s=this.emit.bind(this,"error");this._inflate.on("error",function(a){!n||s(a)}),this._filter.on("complete",this._complete.bind(this));let o=this._filter.write.bind(this._filter);this._inflate.on("data",function(a){!n||(a.length>n&&(a=a.slice(0,n)),n-=a.length,o(a))}),this._inflate.on("end",this._filter.end.bind(this._filter))}this._inflate.write(t)};lt.prototype._handleMetaData=function(t){this._metaData=t,this._bitmapInfo=Object.create(t),this._filter=new tm(this._bitmapInfo)};lt.prototype._handleTransColor=function(t){this._bitmapInfo.transColor=t};lt.prototype._handlePalette=function(t){this._bitmapInfo.palette=t};lt.prototype._simpleTransparency=function(){this._metaData.alpha=!0};lt.prototype._headersFinished=function(){this.emit("metadata",this._metaData)};lt.prototype._finished=function(){this.errord||(this._inflate?this._inflate.end():this.emit("error","No Inflate block"))};lt.prototype._complete=function(t){if(this.errord)return;let e;try{let i=rm.dataToBitMap(t,this._bitmapInfo);e=nm(i,this._bitmapInfo,this._options.skipRescale),i=null}catch(i){this._handleError(i);return}this.emit("parsed",e)}});var sc=x((ex,nc)=>{"use strict";var Je=hi();nc.exports=function(t,e,i,r){let n=[Je.COLORTYPE_COLOR_ALPHA,Je.COLORTYPE_ALPHA].indexOf(r.colorType)!==-1;if(r.colorType===r.inputColorType){let d=function(){let m=new ArrayBuffer(2);return new DataView(m).setInt16(0,256,!0),new Int16Array(m)[0]!==256}();if(r.bitDepth===8||r.bitDepth===16&&d)return t}let s=r.bitDepth!==16?t:new Uint16Array(t.buffer),o=255,a=Je.COLORTYPE_TO_BPP_MAP[r.inputColorType];a===4&&!r.inputHasAlpha&&(a=3);let l=Je.COLORTYPE_TO_BPP_MAP[r.colorType];r.bitDepth===16&&(o=65535,l*=2);let c=Buffer.alloc(e*i*l),u=0,f=0,h=r.bgColor||{};h.red===void 0&&(h.red=o),h.green===void 0&&(h.green=o),h.blue===void 0&&(h.blue=o);function p(){let d,m,g,y=o;switch(r.inputColorType){case Je.COLORTYPE_COLOR_ALPHA:y=s[u+3],d=s[u],m=s[u+1],g=s[u+2];break;case Je.COLORTYPE_COLOR:d=s[u],m=s[u+1],g=s[u+2];break;case Je.COLORTYPE_ALPHA:y=s[u+1],d=s[u],m=d,g=d;break;case Je.COLORTYPE_GRAYSCALE:d=s[u],m=d,g=d;break;default:throw new Error("input color type:"+r.inputColorType+" is not supported at present")}return r.inputHasAlpha&&(n||(y/=o,d=Math.min(Math.max(Math.round((1-y)*h.red+y*d),0),o),m=Math.min(Math.max(Math.round((1-y)*h.green+y*m),0),o),g=Math.min(Math.max(Math.round((1-y)*h.blue+y*g),0),o))),{red:d,green:m,blue:g,alpha:y}}for(let d=0;d<i;d++)for(let m=0;m<e;m++){let g=p(s,u);switch(r.colorType){case Je.COLORTYPE_COLOR_ALPHA:case Je.COLORTYPE_COLOR:r.bitDepth===8?(c[f]=g.red,c[f+1]=g.green,c[f+2]=g.blue,n&&(c[f+3]=g.alpha)):(c.writeUInt16BE(g.red,f),c.writeUInt16BE(g.green,f+2),c.writeUInt16BE(g.blue,f+4),n&&c.writeUInt16BE(g.alpha,f+6));break;case Je.COLORTYPE_ALPHA:case Je.COLORTYPE_GRAYSCALE:{let y=(g.red+g.green+g.blue)/3;r.bitDepth===8?(c[f]=y,n&&(c[f+1]=g.alpha)):(c.writeUInt16BE(y,f),n&&c.writeUInt16BE(g.alpha,f+2));break}default:throw new Error("unrecognised color Type "+r.colorType)}u+=a,f+=l}return c}});var lc=x((tx,ac)=>{"use strict";var oc=Mn();function sm(t,e,i,r,n){for(let s=0;s<i;s++)r[n+s]=t[e+s]}function om(t,e,i){let r=0,n=e+i;for(let s=e;s<n;s++)r+=Math.abs(t[s]);return r}function am(t,e,i,r,n,s){for(let o=0;o<i;o++){let a=o>=s?t[e+o-s]:0,l=t[e+o]-a;r[n+o]=l}}function lm(t,e,i,r){let n=0;for(let s=0;s<i;s++){let o=s>=r?t[e+s-r]:0,a=t[e+s]-o;n+=Math.abs(a)}return n}function cm(t,e,i,r,n){for(let s=0;s<i;s++){let o=e>0?t[e+s-i]:0,a=t[e+s]-o;r[n+s]=a}}function um(t,e,i){let r=0,n=e+i;for(let s=e;s<n;s++){let o=e>0?t[s-i]:0,a=t[s]-o;r+=Math.abs(a)}return r}function fm(t,e,i,r,n,s){for(let o=0;o<i;o++){let a=o>=s?t[e+o-s]:0,l=e>0?t[e+o-i]:0,c=t[e+o]-(a+l>>1);r[n+o]=c}}function hm(t,e,i,r){let n=0;for(let s=0;s<i;s++){let o=s>=r?t[e+s-r]:0,a=e>0?t[e+s-i]:0,l=t[e+s]-(o+a>>1);n+=Math.abs(l)}return n}function pm(t,e,i,r,n,s){for(let o=0;o<i;o++){let a=o>=s?t[e+o-s]:0,l=e>0?t[e+o-i]:0,c=e>0&&o>=s?t[e+o-(i+s)]:0,u=t[e+o]-oc(a,l,c);r[n+o]=u}}function dm(t,e,i,r){let n=0;for(let s=0;s<i;s++){let o=s>=r?t[e+s-r]:0,a=e>0?t[e+s-i]:0,l=e>0&&s>=r?t[e+s-(i+r)]:0,c=t[e+s]-oc(o,a,l);n+=Math.abs(c)}return n}var mm={0:sm,1:am,2:cm,3:fm,4:pm},gm={0:om,1:lm,2:um,3:hm,4:dm};ac.exports=function(t,e,i,r,n){let s;if(!("filterType"in r)||r.filterType===-1)s=[0,1,2,3,4];else if(typeof r.filterType=="number")s=[r.filterType];else throw new Error("unrecognised filter types");r.bitDepth===16&&(n*=2);let o=e*n,a=0,l=0,c=Buffer.alloc((o+1)*i),u=s[0];for(let f=0;f<i;f++){if(s.length>1){let h=1/0;for(let p=0;p<s.length;p++){let d=gm[s[p]](t,l,o,n);d<h&&(u=s[p],h=d)}}c[a]=u,a++,mm[u](t,l,o,c,a,n),a+=o,l+=o}return c}});var zn=x((ix,cc)=>{"use strict";var qe=hi(),vm=qn(),_m=sc(),xm=lc(),ym=__nccwpck_require__(9796),bt=cc.exports=function(t){if(this._options=t,t.deflateChunkSize=t.deflateChunkSize||32*1024,t.deflateLevel=t.deflateLevel!=null?t.deflateLevel:9,t.deflateStrategy=t.deflateStrategy!=null?t.deflateStrategy:3,t.inputHasAlpha=t.inputHasAlpha!=null?t.inputHasAlpha:!0,t.deflateFactory=t.deflateFactory||ym.createDeflate,t.bitDepth=t.bitDepth||8,t.colorType=typeof t.colorType=="number"?t.colorType:qe.COLORTYPE_COLOR_ALPHA,t.inputColorType=typeof t.inputColorType=="number"?t.inputColorType:qe.COLORTYPE_COLOR_ALPHA,[qe.COLORTYPE_GRAYSCALE,qe.COLORTYPE_COLOR,qe.COLORTYPE_COLOR_ALPHA,qe.COLORTYPE_ALPHA].indexOf(t.colorType)===-1)throw new Error("option color type:"+t.colorType+" is not supported at present");if([qe.COLORTYPE_GRAYSCALE,qe.COLORTYPE_COLOR,qe.COLORTYPE_COLOR_ALPHA,qe.COLORTYPE_ALPHA].indexOf(t.inputColorType)===-1)throw new Error("option input color type:"+t.inputColorType+" is not supported at present");if(t.bitDepth!==8&&t.bitDepth!==16)throw new Error("option bit depth:"+t.bitDepth+" is not supported at present")};bt.prototype.getDeflateOptions=function(){return{chunkSize:this._options.deflateChunkSize,level:this._options.deflateLevel,strategy:this._options.deflateStrategy}};bt.prototype.createDeflate=function(){return this._options.deflateFactory(this.getDeflateOptions())};bt.prototype.filterData=function(t,e,i){let r=_m(t,e,i,this._options),n=qe.COLORTYPE_TO_BPP_MAP[this._options.colorType];return xm(r,e,i,this._options,n)};bt.prototype._packChunk=function(t,e){let i=e?e.length:0,r=Buffer.alloc(i+12);return r.writeUInt32BE(i,0),r.writeUInt32BE(t,4),e&&e.copy(r,8),r.writeInt32BE(vm.crc32(r.slice(4,r.length-4)),r.length-4),r};bt.prototype.packGAMA=function(t){let e=Buffer.alloc(4);return e.writeUInt32BE(Math.floor(t*qe.GAMMA_DIVISION),0),this._packChunk(qe.TYPE_gAMA,e)};bt.prototype.packIHDR=function(t,e){let i=Buffer.alloc(13);return i.writeUInt32BE(t,0),i.writeUInt32BE(e,4),i[8]=this._options.bitDepth,i[9]=this._options.colorType,i[10]=0,i[11]=0,i[12]=0,this._packChunk(qe.TYPE_IHDR,i)};bt.prototype.packIDAT=function(t){return this._packChunk(qe.TYPE_IDAT,t)};bt.prototype.packIEND=function(){return this._packChunk(qe.TYPE_IEND,null)}});var pc=x((rx,hc)=>{"use strict";var bm=__nccwpck_require__(3837),uc=__nccwpck_require__(2781),wm=hi(),Em=zn(),fc=hc.exports=function(t){uc.call(this);let e=t||{};this._packer=new Em(e),this._deflate=this._packer.createDeflate(),this.readable=!0};bm.inherits(fc,uc);fc.prototype.pack=function(t,e,i,r){this.emit("data",Buffer.from(wm.PNG_SIGNATURE)),this.emit("data",this._packer.packIHDR(e,i)),r&&this.emit("data",this._packer.packGAMA(r));let n=this._packer.filterData(t,e,i);this._deflate.on("error",this.emit.bind(this,"error")),this._deflate.on("data",function(s){this.emit("data",this._packer.packIDAT(s))}.bind(this)),this._deflate.on("end",function(){this.emit("data",this._packer.packIEND()),this.emit("end")}.bind(this)),this._deflate.end(n)}});var xc=x((Vi,_c)=>{"use strict";var dc=(__nccwpck_require__(9491).ok),pi=__nccwpck_require__(9796),Sm=__nccwpck_require__(3837),mc=(__nccwpck_require__(4300).kMaxLength);function Ut(t){if(!(this instanceof Ut))return new Ut(t);t&&t.chunkSize<pi.Z_MIN_CHUNK&&(t.chunkSize=pi.Z_MIN_CHUNK),pi.Inflate.call(this,t),this._offset=this._offset===void 0?this._outOffset:this._offset,this._buffer=this._buffer||this._outBuffer,t&&t.maxLength!=null&&(this._maxLength=t.maxLength)}function km(t){return new Ut(t)}function gc(t,e){e&&process.nextTick(e),t._handle&&(t._handle.close(),t._handle=null)}Ut.prototype._processChunk=function(t,e,i){if(typeof i=="function")return pi.Inflate._processChunk.call(this,t,e,i);let r=this,n=t&&t.length,s=this._chunkSize-this._offset,o=this._maxLength,a=0,l=[],c=0,u;this.on("error",function(d){u=d});function f(d,m){if(r._hadError)return;let g=s-m;if(dc(g>=0,"have should not go down"),g>0){let y=r._buffer.slice(r._offset,r._offset+g);if(r._offset+=g,y.length>o&&(y=y.slice(0,o)),l.push(y),c+=y.length,o-=y.length,o===0)return!1}return(m===0||r._offset>=r._chunkSize)&&(s=r._chunkSize,r._offset=0,r._buffer=Buffer.allocUnsafe(r._chunkSize)),m===0?(a+=n-d,n=d,!0):!1}dc(this._handle,"zlib binding closed");let h;do h=this._handle.writeSync(e,t,a,n,this._buffer,this._offset,s),h=h||this._writeState;while(!this._hadError&&f(h[0],h[1]));if(this._hadError)throw u;if(c>=mc)throw gc(this),new RangeError("Cannot create final Buffer. It would be larger than 0x"+mc.toString(16)+" bytes");let p=Buffer.concat(l,c);return gc(this),p};Sm.inherits(Ut,pi.Inflate);function Cm(t,e){if(typeof e=="string"&&(e=Buffer.from(e)),!(e instanceof Buffer))throw new TypeError("Not a string or buffer");let i=t._finishFlushFlag;return i==null&&(i=pi.Z_FINISH),t._processChunk(e,i)}function vc(t,e){return Cm(new Ut(e),t)}_c.exports=Vi=vc;Vi.Inflate=Ut;Vi.createInflate=km;Vi.inflateSync=vc});var Wn=x((nx,bc)=>{"use strict";var yc=bc.exports=function(t){this._buffer=t,this._reads=[]};yc.prototype.read=function(t,e){this._reads.push({length:Math.abs(t),allowLess:t<0,func:e})};yc.prototype.process=function(){for(;this._reads.length>0&&this._buffer.length;){let t=this._reads[0];if(this._buffer.length&&(this._buffer.length>=t.length||t.allowLess)){this._reads.shift();let e=this._buffer;this._buffer=e.slice(t.length),t.func.call(this,e.slice(0,t.length))}else break}if(this._reads.length>0)throw new Error("There are some read requests waitng on finished stream");if(this._buffer.length>0)throw new Error("unrecognised content at end of stream")}});var Ec=x(wc=>{"use strict";var Om=Wn(),Im=Un();wc.process=function(t,e){let i=[],r=new Om(t);return new Im(e,{read:r.read.bind(r),write:function(s){i.push(s)},complete:function(){}}).start(),r.process(),Buffer.concat(i)}});var Oc=x((ox,Cc)=>{"use strict";var Sc=!0,kc=__nccwpck_require__(9796),Tm=xc();kc.deflateSync||(Sc=!1);var Am=Wn(),Rm=Ec(),Bm=Hn(),Lm=Vn(),Nm=$n();Cc.exports=function(t,e){if(!Sc)throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");let i;function r(S){i=S}let n;function s(S){n=S}function o(S){n.transColor=S}function a(S){n.palette=S}function l(){n.alpha=!0}let c;function u(S){c=S}let f=[];function h(S){f.push(S)}let p=new Am(t);if(new Bm(e,{read:p.read.bind(p),error:r,metadata:s,gamma:u,palette:a,transColor:o,inflateData:h,simpleTransparency:l}).start(),p.process(),i)throw i;let m=Buffer.concat(f);f.length=0;let g;if(n.interlace)g=kc.inflateSync(m);else{let b=((n.width*n.bpp*n.depth+7>>3)+1)*n.height;g=Tm(m,{chunkSize:b,maxLength:b})}if(m=null,!g||!g.length)throw new Error("bad png - invalid inflate data response");let y=Rm.process(g,n);m=null;let I=Lm.dataToBitMap(y,n);y=null;let w=Nm(I,n,e.skipRescale);return n.data=w,n.gamma=c||0,n}});var Rc=x((ax,Ac)=>{"use strict";var Ic=!0,Tc=__nccwpck_require__(9796);Tc.deflateSync||(Ic=!1);var Pm=hi(),Fm=zn();Ac.exports=function(t,e){if(!Ic)throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");let i=e||{},r=new Fm(i),n=[];n.push(Buffer.from(Pm.PNG_SIGNATURE)),n.push(r.packIHDR(t.width,t.height)),t.gamma&&n.push(r.packGAMA(t.gamma));let s=r.filterData(t.data,t.width,t.height),o=Tc.deflateSync(s,r.getDeflateOptions());if(s=null,!o||!o.length)throw new Error("bad png - invalid compressed data response");return n.push(r.packIDAT(o)),n.push(r.packIEND()),Buffer.concat(n)}});var Bc=x(Yn=>{"use strict";var Mm=Oc(),Um=Rc();Yn.read=function(t,e){return Mm(t,e||{})};Yn.write=function(t,e){return Um(t,e)}});var Pc=x(Nc=>{"use strict";var Dm=__nccwpck_require__(3837),Lc=__nccwpck_require__(2781),jm=rc(),qm=pc(),Hm=Bc(),$e=Nc.PNG=function(t){Lc.call(this),t=t||{},this.width=t.width|0,this.height=t.height|0,this.data=this.width>0&&this.height>0?Buffer.alloc(4*this.width*this.height):null,t.fill&&this.data&&this.data.fill(0),this.gamma=0,this.readable=this.writable=!0,this._parser=new jm(t),this._parser.on("error",this.emit.bind(this,"error")),this._parser.on("close",this._handleClose.bind(this)),this._parser.on("metadata",this._metadata.bind(this)),this._parser.on("gamma",this._gamma.bind(this)),this._parser.on("parsed",function(e){this.data=e,this.emit("parsed",e)}.bind(this)),this._packer=new qm(t),this._packer.on("data",this.emit.bind(this,"data")),this._packer.on("end",this.emit.bind(this,"end")),this._parser.on("close",this._handleClose.bind(this)),this._packer.on("error",this.emit.bind(this,"error"))};Dm.inherits($e,Lc);$e.sync=Hm;$e.prototype.pack=function(){return!this.data||!this.data.length?(this.emit("error","No data provided"),this):(process.nextTick(function(){this._packer.pack(this.data,this.width,this.height,this.gamma)}.bind(this)),this)};$e.prototype.parse=function(t,e){if(e){let i,r;i=function(n){this.removeListener("error",r),this.data=n,e(null,this)}.bind(this),r=function(n){this.removeListener("parsed",i),e(n,null)}.bind(this),this.once("parsed",i),this.once("error",r)}return this.end(t),this};$e.prototype.write=function(t){return this._parser.write(t),!0};$e.prototype.end=function(t){this._parser.end(t)};$e.prototype._metadata=function(t){this.width=t.width,this.height=t.height,this.emit("metadata",t)};$e.prototype._gamma=function(t){this.gamma=t};$e.prototype._handleClose=function(){!this._parser.writable&&!this._packer.readable&&this.emit("close")};$e.bitblt=function(t,e,i,r,n,s,o,a){if(i|=0,r|=0,n|=0,s|=0,o|=0,a|=0,i>t.width||r>t.height||i+n>t.width||r+s>t.height)throw new Error("bitblt reading outside image");if(o>e.width||a>e.height||o+n>e.width||a+s>e.height)throw new Error("bitblt writing outside image");for(let l=0;l<s;l++)t.data.copy(e.data,(a+l)*e.width+o<<2,(r+l)*t.width+i<<2,(r+l)*t.width+i+n<<2)};$e.prototype.bitblt=function(t,e,i,r,n,s,o){return $e.bitblt(this,t,e,i,r,n,s,o),this};$e.adjustGamma=function(t){if(t.gamma){for(let e=0;e<t.height;e++)for(let i=0;i<t.width;i++){let r=t.width*e+i<<2;for(let n=0;n<3;n++){let s=t.data[r+n]/255;s=Math.pow(s,1/2.2/t.gamma),t.data[r+n]=Math.round(s*255)}}t.gamma=0}};$e.prototype.adjustGamma=function(){$e.adjustGamma(this)}});var $i=x(Zn=>{var Nr=class extends Error{constructor(e,i,r){super(r),Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.code=i,this.exitCode=e,this.nestedError=void 0}},Kn=class extends Nr{constructor(e){super(1,"commander.invalidArgument",e),Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name}};Zn.CommanderError=Nr;Zn.InvalidArgumentError=Kn});var Pr=x(Qn=>{var{InvalidArgumentError:Vm}=$i(),Xn=class{constructor(e,i){switch(this.description=i||"",this.variadic=!1,this.parseArg=void 0,this.defaultValue=void 0,this.defaultValueDescription=void 0,this.argChoices=void 0,e[0]){case"<":this.required=!0,this._name=e.slice(1,-1);break;case"[":this.required=!1,this._name=e.slice(1,-1);break;default:this.required=!0,this._name=e;break}this._name.length>3&&this._name.slice(-3)==="..."&&(this.variadic=!0,this._name=this._name.slice(0,-3))}name(){return this._name}_concatValue(e,i){return i===this.defaultValue||!Array.isArray(i)?[e]:i.concat(e)}default(e,i){return this.defaultValue=e,this.defaultValueDescription=i,this}argParser(e){return this.parseArg=e,this}choices(e){return this.argChoices=e,this.parseArg=(i,r)=>{if(!e.includes(i))throw new Vm(`Allowed choices are ${e.join(", ")}.`);return this.variadic?this._concatValue(i,r):i},this}argRequired(){return this.required=!0,this}argOptional(){return this.required=!1,this}};function $m(t){let e=t.name()+(t.variadic===!0?"...":"");return t.required?"<"+e+">":"["+e+"]"}Qn.Argument=Xn;Qn.humanReadableArgName=$m});var es=x(Fc=>{var{humanReadableArgName:Gm}=Pr(),Jn=class{constructor(){this.helpWidth=void 0,this.sortSubcommands=!1,this.sortOptions=!1}visibleCommands(e){let i=e.commands.filter(r=>!r._hidden);if(e._hasImplicitHelpCommand()){let[,r,n]=e._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/),s=e.createCommand(r).helpOption(!1);s.description(e._helpCommandDescription),n&&s.arguments(n),i.push(s)}return this.sortSubcommands&&i.sort((r,n)=>r.name().localeCompare(n.name())),i}visibleOptions(e){let i=e.options.filter(s=>!s.hidden),r=e._hasHelpOption&&e._helpShortFlag&&!e._findOption(e._helpShortFlag),n=e._hasHelpOption&&!e._findOption(e._helpLongFlag);if(r||n){let s;r?n?s=e.createOption(e._helpFlags,e._helpDescription):s=e.createOption(e._helpShortFlag,e._helpDescription):s=e.createOption(e._helpLongFlag,e._helpDescription),i.push(s)}if(this.sortOptions){let s=o=>o.short?o.short.replace(/^-/,""):o.long.replace(/^--/,"");i.sort((o,a)=>s(o).localeCompare(s(a)))}return i}visibleArguments(e){return e._argsDescription&&e._args.forEach(i=>{i.description=i.description||e._argsDescription[i.name()]||""}),e._args.find(i=>i.description)?e._args:[]}subcommandTerm(e){let i=e._args.map(r=>Gm(r)).join(" ");return e._name+(e._aliases[0]?"|"+e._aliases[0]:"")+(e.options.length?" [options]":"")+(i?" "+i:"")}optionTerm(e){return e.flags}argumentTerm(e){return e.name()}longestSubcommandTermLength(e,i){return i.visibleCommands(e).reduce((r,n)=>Math.max(r,i.subcommandTerm(n).length),0)}longestOptionTermLength(e,i){return i.visibleOptions(e).reduce((r,n)=>Math.max(r,i.optionTerm(n).length),0)}longestArgumentTermLength(e,i){return i.visibleArguments(e).reduce((r,n)=>Math.max(r,i.argumentTerm(n).length),0)}commandUsage(e){let i=e._name;e._aliases[0]&&(i=i+"|"+e._aliases[0]);let r="";for(let n=e.parent;n;n=n.parent)r=n.name()+" "+r;return r+i+" "+e.usage()}commandDescription(e){return e.description()}subcommandDescription(e){return e.description()}optionDescription(e){let i=[];return e.argChoices&&!e.negate&&i.push(`choices: ${e.argChoices.map(r=>JSON.stringify(r)).join(", ")}`),e.defaultValue!==void 0&&!e.negate&&i.push(`default: ${e.defaultValueDescription||JSON.stringify(e.defaultValue)}`),e.envVar!==void 0&&i.push(`env: ${e.envVar}`),i.length>0?`${e.description} (${i.join(", ")})`:e.description}argumentDescription(e){let i=[];if(e.argChoices&&i.push(`choices: ${e.argChoices.map(r=>JSON.stringify(r)).join(", ")}`),e.defaultValue!==void 0&&i.push(`default: ${e.defaultValueDescription||JSON.stringify(e.defaultValue)}`),i.length>0){let r=`(${i.join(", ")})`;return e.description?`${e.description} ${r}`:r}return e.description}formatHelp(e,i){let r=i.padWidth(e,i),n=i.helpWidth||80,s=2,o=2;function a(d,m){if(m){let g=`${d.padEnd(r+o)}${m}`;return i.wrap(g,n-s,r+o)}return d}function l(d){return d.join(`
`).replace(/^/gm," ".repeat(s))}let c=[`Usage: ${i.commandUsage(e)}`,""],u=i.commandDescription(e);u.length>0&&(c=c.concat([u,""]));let f=i.visibleArguments(e).map(d=>a(i.argumentTerm(d),i.argumentDescription(d)));f.length>0&&(c=c.concat(["Arguments:",l(f),""]));let h=i.visibleOptions(e).map(d=>a(i.optionTerm(d),i.optionDescription(d)));h.length>0&&(c=c.concat(["Options:",l(h),""]));let p=i.visibleCommands(e).map(d=>a(i.subcommandTerm(d),i.subcommandDescription(d)));return p.length>0&&(c=c.concat(["Commands:",l(p),""])),c.join(`
`)}padWidth(e,i){return Math.max(i.longestOptionTermLength(e,i),i.longestSubcommandTermLength(e,i),i.longestArgumentTermLength(e,i))}wrap(e,i,r,n=40){if(e.match(/[\n]\s+/))return e;let s=i-r;if(s<n)return e;let o=e.substr(0,r),a=e.substr(r),l=" ".repeat(r),c=new RegExp(".{1,"+(s-1)+"}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)","g"),u=a.match(c)||[];return o+u.map((f,h)=>(f.slice(-1)===`
`&&(f=f.slice(0,f.length-1)),(h>0?l:"")+f.trimRight())).join(`
`)}};Fc.Help=Jn});var rs=x(is=>{var{InvalidArgumentError:zm}=$i(),ts=class{constructor(e,i){this.flags=e,this.description=i||"",this.required=e.includes("<"),this.optional=e.includes("["),this.variadic=/\w\.\.\.[>\]]$/.test(e),this.mandatory=!1;let r=Mc(e);this.short=r.shortFlag,this.long=r.longFlag,this.negate=!1,this.long&&(this.negate=this.long.startsWith("--no-")),this.defaultValue=void 0,this.defaultValueDescription=void 0,this.envVar=void 0,this.parseArg=void 0,this.hidden=!1,this.argChoices=void 0}default(e,i){return this.defaultValue=e,this.defaultValueDescription=i,this}env(e){return this.envVar=e,this}argParser(e){return this.parseArg=e,this}makeOptionMandatory(e=!0){return this.mandatory=!!e,this}hideHelp(e=!0){return this.hidden=!!e,this}_concatValue(e,i){return i===this.defaultValue||!Array.isArray(i)?[e]:i.concat(e)}choices(e){return this.argChoices=e,this.parseArg=(i,r)=>{if(!e.includes(i))throw new zm(`Allowed choices are ${e.join(", ")}.`);return this.variadic?this._concatValue(i,r):i},this}name(){return this.long?this.long.replace(/^--/,""):this.short.replace(/^-/,"")}attributeName(){return Wm(this.name().replace(/^no-/,""))}is(e){return this.short===e||this.long===e}};function Wm(t){return t.split("-").reduce((e,i)=>e+i[0].toUpperCase()+i.slice(1))}function Mc(t){let e,i,r=t.split(/[ |,]+/);return r.length>1&&!/^[[<]/.test(r[1])&&(e=r.shift()),i=r.shift(),!e&&/^-[^-]$/.test(i)&&(e=i,i=void 0),{shortFlag:e,longFlag:i}}is.Option=ts;is.splitOptionFlags=Mc});var Dc=x(Uc=>{function Ym(t,e){if(Math.abs(t.length-e.length)>3)return Math.max(t.length,e.length);let i=[];for(let r=0;r<=t.length;r++)i[r]=[r];for(let r=0;r<=e.length;r++)i[0][r]=r;for(let r=1;r<=e.length;r++)for(let n=1;n<=t.length;n++){let s=1;t[n-1]===e[r-1]?s=0:s=1,i[n][r]=Math.min(i[n-1][r]+1,i[n][r-1]+1,i[n-1][r-1]+s),n>1&&r>1&&t[n-1]===e[r-2]&&t[n-2]===e[r-1]&&(i[n][r]=Math.min(i[n][r],i[n-2][r-2]+1))}return i[t.length][e.length]}function Km(t,e){if(!e||e.length===0)return"";e=Array.from(new Set(e));let i=t.startsWith("--");i&&(t=t.slice(2),e=e.map(o=>o.slice(2)));let r=[],n=3,s=.4;return e.forEach(o=>{if(o.length<=1)return;let a=Ym(t,o),l=Math.max(t.length,o.length);(l-a)/l>s&&(a<n?(n=a,r=[o]):a===n&&r.push(o))}),r.sort((o,a)=>o.localeCompare(a)),i&&(r=r.map(o=>`--${o}`)),r.length>1?`
(Did you mean one of ${r.join(", ")}?)`:r.length===1?`
(Did you mean ${r[0]}?)`:""}Uc.suggestSimilar=Km});var $c=x(Vc=>{var Zm=(__nccwpck_require__(2361).EventEmitter),ns=__nccwpck_require__(2081),Dt=__nccwpck_require__(1017),ss=__nccwpck_require__(7147),{Argument:Xm,humanReadableArgName:Qm}=Pr(),{CommanderError:os}=$i(),{Help:Jm}=es(),{Option:e0,splitOptionFlags:t0}=rs(),{suggestSimilar:jc}=Dc(),Gi=class extends Zm{constructor(e){super(),this.commands=[],this.options=[],this.parent=null,this._allowUnknownOption=!1,this._allowExcessArguments=!0,this._args=[],this.args=[],this.rawArgs=[],this.processedArgs=[],this._scriptPath=null,this._name=e||"",this._optionValues={},this._optionValueSources={},this._storeOptionsAsProperties=!1,this._actionHandler=null,this._executableHandler=!1,this._executableFile=null,this._defaultCommandName=null,this._exitCallback=null,this._aliases=[],this._combineFlagAndOptionalValue=!0,this._description="",this._argsDescription=void 0,this._enablePositionalOptions=!1,this._passThroughOptions=!1,this._lifeCycleHooks={},this._showHelpAfterError=!1,this._showSuggestionAfterError=!1,this._outputConfiguration={writeOut:i=>process.stdout.write(i),writeErr:i=>process.stderr.write(i),getOutHelpWidth:()=>process.stdout.isTTY?process.stdout.columns:void 0,getErrHelpWidth:()=>process.stderr.isTTY?process.stderr.columns:void 0,outputError:(i,r)=>r(i)},this._hidden=!1,this._hasHelpOption=!0,this._helpFlags="-h, --help",this._helpDescription="display help for command",this._helpShortFlag="-h",this._helpLongFlag="--help",this._addImplicitHelpCommand=void 0,this._helpCommandName="help",this._helpCommandnameAndArgs="help [command]",this._helpCommandDescription="display help for command",this._helpConfiguration={}}copyInheritedSettings(e){return this._outputConfiguration=e._outputConfiguration,this._hasHelpOption=e._hasHelpOption,this._helpFlags=e._helpFlags,this._helpDescription=e._helpDescription,this._helpShortFlag=e._helpShortFlag,this._helpLongFlag=e._helpLongFlag,this._helpCommandName=e._helpCommandName,this._helpCommandnameAndArgs=e._helpCommandnameAndArgs,this._helpCommandDescription=e._helpCommandDescription,this._helpConfiguration=e._helpConfiguration,this._exitCallback=e._exitCallback,this._storeOptionsAsProperties=e._storeOptionsAsProperties,this._combineFlagAndOptionalValue=e._combineFlagAndOptionalValue,this._allowExcessArguments=e._allowExcessArguments,this._enablePositionalOptions=e._enablePositionalOptions,this._showHelpAfterError=e._showHelpAfterError,this._showSuggestionAfterError=e._showSuggestionAfterError,this}command(e,i,r){let n=i,s=r;typeof n=="object"&&n!==null&&(s=n,n=null),s=s||{};let[,o,a]=e.match(/([^ ]+) *(.*)/),l=this.createCommand(o);return n&&(l.description(n),l._executableHandler=!0),s.isDefault&&(this._defaultCommandName=l._name),l._hidden=!!(s.noHelp||s.hidden),l._executableFile=s.executableFile||null,a&&l.arguments(a),this.commands.push(l),l.parent=this,l.copyInheritedSettings(this),n?this:l}createCommand(e){return new Gi(e)}createHelp(){return Object.assign(new Jm,this.configureHelp())}configureHelp(e){return e===void 0?this._helpConfiguration:(this._helpConfiguration=e,this)}configureOutput(e){return e===void 0?this._outputConfiguration:(Object.assign(this._outputConfiguration,e),this)}showHelpAfterError(e=!0){return typeof e!="string"&&(e=!!e),this._showHelpAfterError=e,this}showSuggestionAfterError(e=!0){return this._showSuggestionAfterError=!!e,this}addCommand(e,i){if(!e._name)throw new Error("Command passed to .addCommand() must have a name");function r(n){n.forEach(s=>{if(s._executableHandler&&!s._executableFile)throw new Error(`Must specify executableFile for deeply nested executable: ${s.name()}`);r(s.commands)})}return r(e.commands),i=i||{},i.isDefault&&(this._defaultCommandName=e._name),(i.noHelp||i.hidden)&&(e._hidden=!0),this.commands.push(e),e.parent=this,this}createArgument(e,i){return new Xm(e,i)}argument(e,i,r,n){let s=this.createArgument(e,i);return typeof r=="function"?s.default(n).argParser(r):s.default(r),this.addArgument(s),this}arguments(e){return e.split(/ +/).forEach(i=>{this.argument(i)}),this}addArgument(e){let i=this._args.slice(-1)[0];if(i&&i.variadic)throw new Error(`only the last argument can be variadic '${i.name()}'`);if(e.required&&e.defaultValue!==void 0&&e.parseArg===void 0)throw new Error(`a default value for a required argument is never used: '${e.name()}'`);return this._args.push(e),this}addHelpCommand(e,i){return e===!1?this._addImplicitHelpCommand=!1:(this._addImplicitHelpCommand=!0,typeof e=="string"&&(this._helpCommandName=e.split(" ")[0],this._helpCommandnameAndArgs=e),this._helpCommandDescription=i||this._helpCommandDescription),this}_hasImplicitHelpCommand(){return this._addImplicitHelpCommand===void 0?this.commands.length&&!this._actionHandler&&!this._findCommand("help"):this._addImplicitHelpCommand}hook(e,i){let r=["preAction","postAction"];if(!r.includes(e))throw new Error(`Unexpected value for event passed to hook : '${e}'.
Expecting one of '${r.join("', '")}'`);return this._lifeCycleHooks[e]?this._lifeCycleHooks[e].push(i):this._lifeCycleHooks[e]=[i],this}exitOverride(e){return e?this._exitCallback=e:this._exitCallback=i=>{if(i.code!=="commander.executeSubCommandAsync")throw i},this}_exit(e,i,r){this._exitCallback&&this._exitCallback(new os(e,i,r)),process.exit(e)}action(e){let i=r=>{let n=this._args.length,s=r.slice(0,n);return this._storeOptionsAsProperties?s[n]=this:s[n]=this.opts(),s.push(this),e.apply(this,s)};return this._actionHandler=i,this}createOption(e,i){return new e0(e,i)}addOption(e){let i=e.name(),r=e.attributeName(),n=e.defaultValue;if(e.negate||e.optional||e.required||typeof n=="boolean"){if(e.negate){let o=e.long.replace(/^--no-/,"--");n=this._findOption(o)?this.getOptionValue(r):!0}n!==void 0&&this.setOptionValueWithSource(r,n,"default")}this.options.push(e);let s=(o,a,l)=>{let c=this.getOptionValue(r);if(o!==null&&e.parseArg)try{o=e.parseArg(o,c===void 0?n:c)}catch(u){if(u.code==="commander.invalidArgument"){let f=`${a} ${u.message}`;this._displayError(u.exitCode,u.code,f)}throw u}else o!==null&&e.variadic&&(o=e._concatValue(o,c));typeof c=="boolean"||typeof c=="undefined"?o==null?this.setOptionValueWithSource(r,e.negate?!1:n||!0,l):this.setOptionValueWithSource(r,o,l):o!==null&&this.setOptionValueWithSource(r,e.negate?!1:o,l)};return this.on("option:"+i,o=>{let a=`error: option '${e.flags}' argument '${o}' is invalid.`;s(o,a,"cli")}),e.envVar&&this.on("optionEnv:"+i,o=>{let a=`error: option '${e.flags}' value '${o}' from env '${e.envVar}' is invalid.`;s(o,a,"env")}),this}_optionEx(e,i,r,n,s){let o=this.createOption(i,r);if(o.makeOptionMandatory(!!e.mandatory),typeof n=="function")o.default(s).argParser(n);else if(n instanceof RegExp){let a=n;n=(l,c)=>{let u=a.exec(l);return u?u[0]:c},o.default(s).argParser(n)}else o.default(n);return this.addOption(o)}option(e,i,r,n){return this._optionEx({},e,i,r,n)}requiredOption(e,i,r,n){return this._optionEx({mandatory:!0},e,i,r,n)}combineFlagAndOptionalValue(e=!0){return this._combineFlagAndOptionalValue=!!e,this}allowUnknownOption(e=!0){return this._allowUnknownOption=!!e,this}allowExcessArguments(e=!0){return this._allowExcessArguments=!!e,this}enablePositionalOptions(e=!0){return this._enablePositionalOptions=!!e,this}passThroughOptions(e=!0){if(this._passThroughOptions=!!e,!!this.parent&&e&&!this.parent._enablePositionalOptions)throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");return this}storeOptionsAsProperties(e=!0){if(this._storeOptionsAsProperties=!!e,this.options.length)throw new Error("call .storeOptionsAsProperties() before adding options");return this}getOptionValue(e){return this._storeOptionsAsProperties?this[e]:this._optionValues[e]}setOptionValue(e,i){return this._storeOptionsAsProperties?this[e]=i:this._optionValues[e]=i,this}setOptionValueWithSource(e,i,r){return this.setOptionValue(e,i),this._optionValueSources[e]=r,this}getOptionValueSource(e){return this._optionValueSources[e]}_prepareUserArgs(e,i){if(e!==void 0&&!Array.isArray(e))throw new Error("first parameter to parse must be array or undefined");i=i||{},e===void 0&&(e=process.argv,process.versions&&process.versions.electron&&(i.from="electron")),this.rawArgs=e.slice();let r;switch(i.from){case void 0:case"node":this._scriptPath=e[1],r=e.slice(2);break;case"electron":process.defaultApp?(this._scriptPath=e[1],r=e.slice(2)):r=e.slice(1);break;case"user":r=e.slice(0);break;default:throw new Error(`unexpected parse option { from: '${i.from}' }`)}return!this._scriptPath&&require.main&&(this._scriptPath=require.main.filename),this._name=this._name||this._scriptPath&&Dt.basename(this._scriptPath,Dt.extname(this._scriptPath)),r}parse(e,i){let r=this._prepareUserArgs(e,i);return this._parseCommand([],r),this}async parseAsync(e,i){let r=this._prepareUserArgs(e,i);return await this._parseCommand([],r),this}_executeSubCommand(e,i){i=i.slice();let r=!1,n=[".js",".ts",".tsx",".mjs",".cjs"];this._checkForMissingMandatoryOptions();let s=this._scriptPath;!s&&require.main&&(s=require.main.filename);let o;try{let h=ss.realpathSync(s);o=Dt.dirname(h)}catch{o="."}let a=Dt.basename(s,Dt.extname(s))+"-"+e._name;e._executableFile&&(a=e._executableFile);let l=Dt.join(o,a);ss.existsSync(l)?a=l:n.forEach(h=>{ss.existsSync(`${l}${h}`)&&(a=`${l}${h}`)}),r=n.includes(Dt.extname(a));let c;process.platform!=="win32"?r?(i.unshift(a),i=Hc(process.execArgv).concat(i),c=ns.spawn(process.argv[0],i,{stdio:"inherit"})):c=ns.spawn(a,i,{stdio:"inherit"}):(i.unshift(a),i=Hc(process.execArgv).concat(i),c=ns.spawn(process.execPath,i,{stdio:"inherit"})),["SIGUSR1","SIGUSR2","SIGTERM","SIGINT","SIGHUP"].forEach(h=>{process.on(h,()=>{c.killed===!1&&c.exitCode===null&&c.kill(h)})});let f=this._exitCallback;f?c.on("close",()=>{f(new os(process.exitCode||0,"commander.executeSubCommandAsync","(close)"))}):c.on("close",process.exit.bind(process)),c.on("error",h=>{if(h.code==="ENOENT"){let p=`'${a}' does not exist
 - if '${e._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;throw new Error(p)}else if(h.code==="EACCES")throw new Error(`'${a}' not executable`);if(!f)process.exit(1);else{let p=new os(1,"commander.executeSubCommandAsync","(error)");p.nestedError=h,f(p)}}),this.runningCommand=c}_dispatchSubcommand(e,i,r){let n=this._findCommand(e);if(n||this.help({error:!0}),n._executableHandler)this._executeSubCommand(n,i.concat(r));else return n._parseCommand(i,r)}_checkNumberOfArguments(){this._args.forEach((e,i)=>{e.required&&this.args[i]==null&&this.missingArgument(e.name())}),!(this._args.length>0&&this._args[this._args.length-1].variadic)&&this.args.length>this._args.length&&this._excessArguments(this.args)}_processArguments(){let e=(r,n,s)=>{let o=n;if(n!==null&&r.parseArg)try{o=r.parseArg(n,s)}catch(a){if(a.code==="commander.invalidArgument"){let l=`error: command-argument value '${n}' is invalid for argument '${r.name()}'. ${a.message}`;this._displayError(a.exitCode,a.code,l)}throw a}return o};this._checkNumberOfArguments();let i=[];this._args.forEach((r,n)=>{let s=r.defaultValue;r.variadic?n<this.args.length?(s=this.args.slice(n),r.parseArg&&(s=s.reduce((o,a)=>e(r,a,o),r.defaultValue))):s===void 0&&(s=[]):n<this.args.length&&(s=this.args[n],r.parseArg&&(s=e(r,s,r.defaultValue))),i[n]=s}),this.processedArgs=i}_chainOrCall(e,i){return e&&e.then&&typeof e.then=="function"?e.then(()=>i()):i()}_chainOrCallHooks(e,i){let r=e,n=[];return as(this).reverse().filter(s=>s._lifeCycleHooks[i]!==void 0).forEach(s=>{s._lifeCycleHooks[i].forEach(o=>{n.push({hookedCommand:s,callback:o})})}),i==="postAction"&&n.reverse(),n.forEach(s=>{r=this._chainOrCall(r,()=>s.callback(s.hookedCommand,this))}),r}_parseCommand(e,i){let r=this.parseOptions(i);if(this._parseOptionsEnv(),e=e.concat(r.operands),i=r.unknown,this.args=e.concat(i),e&&this._findCommand(e[0]))return this._dispatchSubcommand(e[0],e.slice(1),i);if(this._hasImplicitHelpCommand()&&e[0]===this._helpCommandName)return e.length===1&&this.help(),this._dispatchSubcommand(e[1],[],[this._helpLongFlag]);if(this._defaultCommandName)return qc(this,i),this._dispatchSubcommand(this._defaultCommandName,e,i);this.commands.length&&this.args.length===0&&!this._actionHandler&&!this._defaultCommandName&&this.help({error:!0}),qc(this,r.unknown),this._checkForMissingMandatoryOptions();let n=()=>{r.unknown.length>0&&this.unknownOption(r.unknown[0])},s=`command:${this.name()}`;if(this._actionHandler){n(),this._processArguments();let o;return o=this._chainOrCallHooks(o,"preAction"),o=this._chainOrCall(o,()=>this._actionHandler(this.processedArgs)),this.parent&&this.parent.emit(s,e,i),o=this._chainOrCallHooks(o,"postAction"),o}if(this.parent&&this.parent.listenerCount(s))n(),this._processArguments(),this.parent.emit(s,e,i);else if(e.length){if(this._findCommand("*"))return this._dispatchSubcommand("*",e,i);this.listenerCount("command:*")?this.emit("command:*",e,i):this.commands.length?this.unknownCommand():(n(),this._processArguments())}else this.commands.length?(n(),this.help({error:!0})):(n(),this._processArguments())}_findCommand(e){if(!!e)return this.commands.find(i=>i._name===e||i._aliases.includes(e))}_findOption(e){return this.options.find(i=>i.is(e))}_checkForMissingMandatoryOptions(){for(let e=this;e;e=e.parent)e.options.forEach(i=>{i.mandatory&&e.getOptionValue(i.attributeName())===void 0&&e.missingMandatoryOptionValue(i)})}parseOptions(e){let i=[],r=[],n=i,s=e.slice();function o(l){return l.length>1&&l[0]==="-"}let a=null;for(;s.length;){let l=s.shift();if(l==="--"){n===r&&n.push(l),n.push(...s);break}if(a&&!o(l)){this.emit(`option:${a.name()}`,l);continue}if(a=null,o(l)){let c=this._findOption(l);if(c){if(c.required){let u=s.shift();u===void 0&&this.optionMissingArgument(c),this.emit(`option:${c.name()}`,u)}else if(c.optional){let u=null;s.length>0&&!o(s[0])&&(u=s.shift()),this.emit(`option:${c.name()}`,u)}else this.emit(`option:${c.name()}`);a=c.variadic?c:null;continue}}if(l.length>2&&l[0]==="-"&&l[1]!=="-"){let c=this._findOption(`-${l[1]}`);if(c){c.required||c.optional&&this._combineFlagAndOptionalValue?this.emit(`option:${c.name()}`,l.slice(2)):(this.emit(`option:${c.name()}`),s.unshift(`-${l.slice(2)}`));continue}}if(/^--[^=]+=/.test(l)){let c=l.indexOf("="),u=this._findOption(l.slice(0,c));if(u&&(u.required||u.optional)){this.emit(`option:${u.name()}`,l.slice(c+1));continue}}if(o(l)&&(n=r),(this._enablePositionalOptions||this._passThroughOptions)&&i.length===0&&r.length===0){if(this._findCommand(l)){i.push(l),s.length>0&&r.push(...s);break}else if(l===this._helpCommandName&&this._hasImplicitHelpCommand()){i.push(l),s.length>0&&i.push(...s);break}else if(this._defaultCommandName){r.push(l),s.length>0&&r.push(...s);break}}if(this._passThroughOptions){n.push(l),s.length>0&&n.push(...s);break}n.push(l)}return{operands:i,unknown:r}}opts(){if(this._storeOptionsAsProperties){let e={},i=this.options.length;for(let r=0;r<i;r++){let n=this.options[r].attributeName();e[n]=n===this._versionOptionName?this._version:this[n]}return e}return this._optionValues}_displayError(e,i,r){this._outputConfiguration.outputError(`${r}
`,this._outputConfiguration.writeErr),typeof this._showHelpAfterError=="string"?this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`):this._showHelpAfterError&&(this._outputConfiguration.writeErr(`
`),this.outputHelp({error:!0})),this._exit(e,i,r)}_parseOptionsEnv(){this.options.forEach(e=>{if(e.envVar&&e.envVar in process.env){let i=e.attributeName();(this.getOptionValue(i)===void 0||["default","config","env"].includes(this.getOptionValueSource(i)))&&(e.required||e.optional?this.emit(`optionEnv:${e.name()}`,process.env[e.envVar]):this.emit(`optionEnv:${e.name()}`))}})}missingArgument(e){let i=`error: missing required argument '${e}'`;this._displayError(1,"commander.missingArgument",i)}optionMissingArgument(e){let i=`error: option '${e.flags}' argument missing`;this._displayError(1,"commander.optionMissingArgument",i)}missingMandatoryOptionValue(e){let i=`error: required option '${e.flags}' not specified`;this._displayError(1,"commander.missingMandatoryOptionValue",i)}unknownOption(e){if(this._allowUnknownOption)return;let i="";if(e.startsWith("--")&&this._showSuggestionAfterError){let n=[],s=this;do{let o=s.createHelp().visibleOptions(s).filter(a=>a.long).map(a=>a.long);n=n.concat(o),s=s.parent}while(s&&!s._enablePositionalOptions);i=jc(e,n)}let r=`error: unknown option '${e}'${i}`;this._displayError(1,"commander.unknownOption",r)}_excessArguments(e){if(this._allowExcessArguments)return;let i=this._args.length,r=i===1?"":"s",s=`error: too many arguments${this.parent?` for '${this.name()}'`:""}. Expected ${i} argument${r} but got ${e.length}.`;this._displayError(1,"commander.excessArguments",s)}unknownCommand(){let e=this.args[0],i="";if(this._showSuggestionAfterError){let n=[];this.createHelp().visibleCommands(this).forEach(s=>{n.push(s.name()),s.alias()&&n.push(s.alias())}),i=jc(e,n)}let r=`error: unknown command '${e}'${i}`;this._displayError(1,"commander.unknownCommand",r)}version(e,i,r){if(e===void 0)return this._version;this._version=e,i=i||"-V, --version",r=r||"output the version number";let n=this.createOption(i,r);return this._versionOptionName=n.attributeName(),this.options.push(n),this.on("option:"+n.name(),()=>{this._outputConfiguration.writeOut(`${e}
`),this._exit(0,"commander.version",e)}),this}description(e,i){return e===void 0&&i===void 0?this._description:(this._description=e,i&&(this._argsDescription=i),this)}alias(e){if(e===void 0)return this._aliases[0];let i=this;if(this.commands.length!==0&&this.commands[this.commands.length-1]._executableHandler&&(i=this.commands[this.commands.length-1]),e===i._name)throw new Error("Command alias can't be the same as its name");return i._aliases.push(e),this}aliases(e){return e===void 0?this._aliases:(e.forEach(i=>this.alias(i)),this)}usage(e){if(e===void 0){if(this._usage)return this._usage;let i=this._args.map(r=>Qm(r));return[].concat(this.options.length||this._hasHelpOption?"[options]":[],this.commands.length?"[command]":[],this._args.length?i:[]).join(" ")}return this._usage=e,this}name(e){return e===void 0?this._name:(this._name=e,this)}helpInformation(e){let i=this.createHelp();return i.helpWidth===void 0&&(i.helpWidth=e&&e.error?this._outputConfiguration.getErrHelpWidth():this._outputConfiguration.getOutHelpWidth()),i.formatHelp(this,i)}_getHelpContext(e){e=e||{};let i={error:!!e.error},r;return i.error?r=n=>this._outputConfiguration.writeErr(n):r=n=>this._outputConfiguration.writeOut(n),i.write=e.write||r,i.command=this,i}outputHelp(e){let i;typeof e=="function"&&(i=e,e=void 0);let r=this._getHelpContext(e);as(this).reverse().forEach(s=>s.emit("beforeAllHelp",r)),this.emit("beforeHelp",r);let n=this.helpInformation(r);if(i&&(n=i(n),typeof n!="string"&&!Buffer.isBuffer(n)))throw new Error("outputHelp callback must return a string or a Buffer");r.write(n),this.emit(this._helpLongFlag),this.emit("afterHelp",r),as(this).forEach(s=>s.emit("afterAllHelp",r))}helpOption(e,i){if(typeof e=="boolean")return this._hasHelpOption=e,this;this._helpFlags=e||this._helpFlags,this._helpDescription=i||this._helpDescription;let r=t0(this._helpFlags);return this._helpShortFlag=r.shortFlag,this._helpLongFlag=r.longFlag,this}help(e){this.outputHelp(e);let i=process.exitCode||0;i===0&&e&&typeof e!="function"&&e.error&&(i=1),this._exit(i,"commander.help","(outputHelp)")}addHelpText(e,i){let r=["beforeAll","before","after","afterAll"];if(!r.includes(e))throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${r.join("', '")}'`);let n=`${e}Help`;return this.on(n,s=>{let o;typeof i=="function"?o=i({error:s.error,command:s.command}):o=i,o&&s.write(`${o}
`)}),this}};function qc(t,e){t._hasHelpOption&&e.find(r=>r===t._helpLongFlag||r===t._helpShortFlag)&&(t.outputHelp(),t._exit(0,"commander.helpDisplayed","(outputHelp)"))}function Hc(t){return t.map(e=>{if(!e.startsWith("--inspect"))return e;let i,r="127.0.0.1",n="9229",s;return(s=e.match(/^(--inspect(-brk)?)$/))!==null?i=s[1]:(s=e.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))!==null?(i=s[1],/^\d+$/.test(s[3])?n=s[3]:r=s[3]):(s=e.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/))!==null&&(i=s[1],r=s[3],n=s[4]),i&&n!=="0"?`${i}=${r}:${parseInt(n)+1}`:e})}function as(t){let e=[];for(let i=t;i;i=i.parent)e.push(i);return e}Vc.Command=Gi});var Yc=x((st,Wc)=>{var{Argument:i0}=Pr(),{Command:Gc}=$c(),{CommanderError:r0,InvalidArgumentError:zc}=$i(),{Help:n0}=es(),{Option:s0}=rs();st=Wc.exports=new Gc;st.program=st;st.Argument=i0;st.Command=Gc;st.CommanderError=r0;st.Help=n0;st.InvalidArgumentError=zc;st.InvalidOptionArgumentError=zc;st.Option=s0});var Xc=x((Kc,Zc)=>{Kc=Zc.exports=di;function di(t,e){if(this.stream=e.stream||process.stderr,typeof e=="number"){var i=e;e={},e.total=i}else{if(e=e||{},typeof t!="string")throw new Error("format required");if(typeof e.total!="number")throw new Error("total required")}this.fmt=t,this.curr=e.curr||0,this.total=e.total,this.width=e.width||this.total,this.clear=e.clear,this.chars={complete:e.complete||"=",incomplete:e.incomplete||"-",head:e.head||e.complete||"="},this.renderThrottle=e.renderThrottle!==0?e.renderThrottle||16:0,this.lastRender=-1/0,this.callback=e.callback||function(){},this.tokens={},this.lastDraw=""}di.prototype.tick=function(t,e){if(t!==0&&(t=t||1),typeof t=="object"&&(e=t,t=1),e&&(this.tokens=e),this.curr==0&&(this.start=new Date),this.curr+=t,this.render(),this.curr>=this.total){this.render(void 0,!0),this.complete=!0,this.terminate(),this.callback(this);return}};di.prototype.render=function(t,e){if(e=e!==void 0?e:!1,t&&(this.tokens=t),!!this.stream.isTTY){var i=Date.now(),r=i-this.lastRender;if(!(!e&&r<this.renderThrottle)){this.lastRender=i;var n=this.curr/this.total;n=Math.min(Math.max(n,0),1);var s=Math.floor(n*100),o,a,l,c=new Date-this.start,u=s==100?0:c*(this.total/this.curr-1),f=this.curr/(c/1e3),h=this.fmt.replace(":current",this.curr).replace(":total",this.total).replace(":elapsed",isNaN(c)?"0.0":(c/1e3).toFixed(1)).replace(":eta",isNaN(u)||!isFinite(u)?"0.0":(u/1e3).toFixed(1)).replace(":percent",s.toFixed(0)+"%").replace(":rate",Math.round(f)),p=Math.max(0,this.stream.columns-h.replace(":bar","").length);p&&process.platform==="win32"&&(p=p-1);var d=Math.min(this.width,p);if(l=Math.round(d*n),a=Array(Math.max(0,l+1)).join(this.chars.complete),o=Array(Math.max(0,d-l+1)).join(this.chars.incomplete),l>0&&(a=a.slice(0,-1)+this.chars.head),h=h.replace(":bar",a+o),this.tokens)for(var m in this.tokens)h=h.replace(":"+m,this.tokens[m]);this.lastDraw!==h&&(this.stream.cursorTo(0),this.stream.write(h),this.stream.clearLine(1),this.lastDraw=h)}}};di.prototype.update=function(t,e){var i=Math.floor(t*this.total),r=i-this.curr;this.tick(r,e)};di.prototype.interrupt=function(t){this.stream.clearLine(),this.stream.cursorTo(0),this.stream.write(t),this.stream.write(`
`),this.stream.write(this.lastDraw)};di.prototype.terminate=function(){this.clear?this.stream.clearLine&&(this.stream.clearLine(),this.stream.cursorTo(0)):this.stream.write(`
`)}});var Jc=x((gx,Qc)=>{Qc.exports=Xc()});var eu=x(ls=>{var jt=__nccwpck_require__(1017),Et=process.platform==="win32",wt=__nccwpck_require__(7147),o0=process.env.NODE_DEBUG&&/fs/.test(process.env.NODE_DEBUG);function a0(){var t;if(o0){var e=new Error;t=i}else t=r;return t;function i(n){n&&(e.message=n.message,n=e,r(n))}function r(n){if(n){if(process.throwDeprecation)throw n;if(!process.noDeprecation){var s="fs: missing callback "+(n.stack||n.message);process.traceDeprecation?console.trace(s):console.error(s)}}}}function l0(t){return typeof t=="function"?t:a0()}var vx=jt.normalize;Et?ht=/(.*?)(?:[\/\\]+|$)/g:ht=/(.*?)(?:[\/]+|$)/g;var ht;Et?zi=/^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/:zi=/^[\/]*/;var zi;ls.realpathSync=function(e,i){if(e=jt.resolve(e),i&&Object.prototype.hasOwnProperty.call(i,e))return i[e];var r=e,n={},s={},o,a,l,c;u();function u(){var g=zi.exec(e);o=g[0].length,a=g[0],l=g[0],c="",Et&&!s[l]&&(wt.lstatSync(l),s[l]=!0)}for(;o<e.length;){ht.lastIndex=o;var f=ht.exec(e);if(c=a,a+=f[0],l=c+f[1],o=ht.lastIndex,!(s[l]||i&&i[l]===l)){var h;if(i&&Object.prototype.hasOwnProperty.call(i,l))h=i[l];else{var p=wt.lstatSync(l);if(!p.isSymbolicLink()){s[l]=!0,i&&(i[l]=l);continue}var d=null;if(!Et){var m=p.dev.toString(32)+":"+p.ino.toString(32);n.hasOwnProperty(m)&&(d=n[m])}d===null&&(wt.statSync(l),d=wt.readlinkSync(l)),h=jt.resolve(c,d),i&&(i[l]=h),Et||(n[m]=d)}e=jt.resolve(h,e.slice(o)),u()}}return i&&(i[r]=e),e};ls.realpath=function(e,i,r){if(typeof r!="function"&&(r=l0(i),i=null),e=jt.resolve(e),i&&Object.prototype.hasOwnProperty.call(i,e))return process.nextTick(r.bind(null,null,i[e]));var n=e,s={},o={},a,l,c,u;f();function f(){var g=zi.exec(e);a=g[0].length,l=g[0],c=g[0],u="",Et&&!o[c]?wt.lstat(c,function(y){if(y)return r(y);o[c]=!0,h()}):process.nextTick(h)}function h(){if(a>=e.length)return i&&(i[n]=e),r(null,e);ht.lastIndex=a;var g=ht.exec(e);return u=l,l+=g[0],c=u+g[1],a=ht.lastIndex,o[c]||i&&i[c]===c?process.nextTick(h):i&&Object.prototype.hasOwnProperty.call(i,c)?m(i[c]):wt.lstat(c,p)}function p(g,y){if(g)return r(g);if(!y.isSymbolicLink())return o[c]=!0,i&&(i[c]=c),process.nextTick(h);if(!Et){var I=y.dev.toString(32)+":"+y.ino.toString(32);if(s.hasOwnProperty(I))return d(null,s[I],c)}wt.stat(c,function(w){if(w)return r(w);wt.readlink(c,function(S,b){Et||(s[I]=b),d(S,b)})})}function d(g,y,I){if(g)return r(g);var w=jt.resolve(u,y);i&&(i[I]=w),m(w)}function m(g){e=jt.resolve(g,e.slice(a)),f()}}});var hs=x((xx,nu)=>{nu.exports=St;St.realpath=St;St.sync=fs;St.realpathSync=fs;St.monkeypatch=u0;St.unmonkeypatch=f0;var mi=__nccwpck_require__(7147),cs=mi.realpath,us=mi.realpathSync,c0=process.version,tu=/^v[0-5]\./.test(c0),iu=eu();function ru(t){return t&&t.syscall==="realpath"&&(t.code==="ELOOP"||t.code==="ENOMEM"||t.code==="ENAMETOOLONG")}function St(t,e,i){if(tu)return cs(t,e,i);typeof e=="function"&&(i=e,e=null),cs(t,e,function(r,n){ru(r)?iu.realpath(t,e,i):i(r,n)})}function fs(t,e){if(tu)return us(t,e);try{return us(t,e)}catch(i){if(ru(i))return iu.realpathSync(t,e);throw i}}function u0(){mi.realpath=St,mi.realpathSync=fs}function f0(){mi.realpath=cs,mi.realpathSync=us}});var su=x((yx,ps)=>{typeof Object.create=="function"?ps.exports=function(e,i){i&&(e.super_=i,e.prototype=Object.create(i.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:ps.exports=function(e,i){if(i){e.super_=i;var r=function(){};r.prototype=i.prototype,e.prototype=new r,e.prototype.constructor=e}}});var ou=x((bx,ms)=>{try{if(ds=__nccwpck_require__(3837),typeof ds.inherits!="function")throw"";ms.exports=ds.inherits}catch{ms.exports=su()}var ds});var Mr=x((wx,Fr)=>{"use strict";function au(t){return t.charAt(0)==="/"}function lu(t){var e=/^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/,i=e.exec(t),r=i[1]||"",n=Boolean(r&&r.charAt(1)!==":");return Boolean(i[2]||n)}Fr.exports=process.platform==="win32"?lu:au;Fr.exports.posix=au;Fr.exports.win32=lu});var vs=x(kt=>{kt.setopts=v0;kt.ownProp=cu;kt.makeAbs=Wi;kt.finish=_0;kt.mark=x0;kt.isIgnored=fu;kt.childrenIgnored=y0;function cu(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var h0=__nccwpck_require__(7147),gi=__nccwpck_require__(1017),p0=Hi(),uu=Mr(),gs=p0.Minimatch;function d0(t,e){return t.localeCompare(e,"en")}function m0(t,e){t.ignore=e.ignore||[],Array.isArray(t.ignore)||(t.ignore=[t.ignore]),t.ignore.length&&(t.ignore=t.ignore.map(g0))}function g0(t){var e=null;if(t.slice(-3)==="/**"){var i=t.replace(/(\/\*\*)+$/,"");e=new gs(i,{dot:!0})}return{matcher:new gs(t,{dot:!0}),gmatcher:e}}function v0(t,e,i){if(i||(i={}),i.matchBase&&e.indexOf("/")===-1){if(i.noglobstar)throw new Error("base matching requires globstar");e="**/"+e}t.silent=!!i.silent,t.pattern=e,t.strict=i.strict!==!1,t.realpath=!!i.realpath,t.realpathCache=i.realpathCache||Object.create(null),t.follow=!!i.follow,t.dot=!!i.dot,t.mark=!!i.mark,t.nodir=!!i.nodir,t.nodir&&(t.mark=!0),t.sync=!!i.sync,t.nounique=!!i.nounique,t.nonull=!!i.nonull,t.nosort=!!i.nosort,t.nocase=!!i.nocase,t.stat=!!i.stat,t.noprocess=!!i.noprocess,t.absolute=!!i.absolute,t.fs=i.fs||h0,t.maxLength=i.maxLength||1/0,t.cache=i.cache||Object.create(null),t.statCache=i.statCache||Object.create(null),t.symlinks=i.symlinks||Object.create(null),m0(t,i),t.changedCwd=!1;var r=process.cwd();cu(i,"cwd")?(t.cwd=gi.resolve(i.cwd),t.changedCwd=t.cwd!==r):t.cwd=r,t.root=i.root||gi.resolve(t.cwd,"/"),t.root=gi.resolve(t.root),process.platform==="win32"&&(t.root=t.root.replace(/\\/g,"/")),t.cwdAbs=uu(t.cwd)?t.cwd:Wi(t,t.cwd),process.platform==="win32"&&(t.cwdAbs=t.cwdAbs.replace(/\\/g,"/")),t.nomount=!!i.nomount,i.nonegate=!0,i.nocomment=!0,t.minimatch=new gs(e,i),t.options=t.minimatch.options}function _0(t){for(var e=t.nounique,i=e?[]:Object.create(null),r=0,n=t.matches.length;r<n;r++){var s=t.matches[r];if(!s||Object.keys(s).length===0){if(t.nonull){var o=t.minimatch.globSet[r];e?i.push(o):i[o]=!0}}else{var a=Object.keys(s);e?i.push.apply(i,a):a.forEach(function(l){i[l]=!0})}}if(e||(i=Object.keys(i)),t.nosort||(i=i.sort(d0)),t.mark){for(var r=0;r<i.length;r++)i[r]=t._mark(i[r]);t.nodir&&(i=i.filter(function(l){var c=!/\/$/.test(l),u=t.cache[l]||t.cache[Wi(t,l)];return c&&u&&(c=u!=="DIR"&&!Array.isArray(u)),c}))}t.ignore.length&&(i=i.filter(function(l){return!fu(t,l)})),t.found=i}function x0(t,e){var i=Wi(t,e),r=t.cache[i],n=e;if(r){var s=r==="DIR"||Array.isArray(r),o=e.slice(-1)==="/";if(s&&!o?n+="/":!s&&o&&(n=n.slice(0,-1)),n!==e){var a=Wi(t,n);t.statCache[a]=t.statCache[i],t.cache[a]=t.cache[i]}}return n}function Wi(t,e){var i=e;return e.charAt(0)==="/"?i=gi.join(t.root,e):uu(e)||e===""?i=e:t.changedCwd?i=gi.resolve(t.cwd,e):i=gi.resolve(e),process.platform==="win32"&&(i=i.replace(/\\/g,"/")),i}function fu(t,e){return t.ignore.length?t.ignore.some(function(i){return i.matcher.match(e)||!!(i.gmatcher&&i.gmatcher.match(e))}):!1}function y0(t,e){return t.ignore.length?t.ignore.some(function(i){return!!(i.gmatcher&&i.gmatcher.match(e))}):!1}});var gu=x((Ox,mu)=>{mu.exports=du;du.GlobSync=Re;var b0=hs(),hu=Hi(),Sx=hu.Minimatch,kx=ys().Glob,Cx=__nccwpck_require__(3837),_s=__nccwpck_require__(1017),pu=__nccwpck_require__(9491),Ur=Mr(),qt=vs(),w0=qt.setopts,xs=qt.ownProp,E0=qt.childrenIgnored,S0=qt.isIgnored;function du(t,e){if(typeof e=="function"||arguments.length===3)throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);return new Re(t,e).found}function Re(t,e){if(!t)throw new Error("must provide pattern");if(typeof e=="function"||arguments.length===3)throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);if(!(this instanceof Re))return new Re(t,e);if(w0(this,t,e),this.noprocess)return this;var i=this.minimatch.set.length;this.matches=new Array(i);for(var r=0;r<i;r++)this._process(this.minimatch.set[r],r,!1);this._finish()}Re.prototype._finish=function(){if(pu(this instanceof Re),this.realpath){var t=this;this.matches.forEach(function(e,i){var r=t.matches[i]=Object.create(null);for(var n in e)try{n=t._makeAbs(n);var s=b0.realpathSync(n,t.realpathCache);r[s]=!0}catch(o){if(o.syscall==="stat")r[t._makeAbs(n)]=!0;else throw o}})}qt.finish(this)};Re.prototype._process=function(t,e,i){pu(this instanceof Re);for(var r=0;typeof t[r]=="string";)r++;var n;switch(r){case t.length:this._processSimple(t.join("/"),e);return;case 0:n=null;break;default:n=t.slice(0,r).join("/");break}var s=t.slice(r),o;n===null?o=".":((Ur(n)||Ur(t.join("/")))&&(!n||!Ur(n))&&(n="/"+n),o=n);var a=this._makeAbs(o);if(!E0(this,o)){var l=s[0]===hu.GLOBSTAR;l?this._processGlobStar(n,o,a,s,e,i):this._processReaddir(n,o,a,s,e,i)}};Re.prototype._processReaddir=function(t,e,i,r,n,s){var o=this._readdir(i,s);if(!!o){for(var a=r[0],l=!!this.minimatch.negate,c=a._glob,u=this.dot||c.charAt(0)===".",f=[],h=0;h<o.length;h++){var p=o[h];if(p.charAt(0)!=="."||u){var d;l&&!t?d=!p.match(a):d=p.match(a),d&&f.push(p)}}var m=f.length;if(m!==0){if(r.length===1&&!this.mark&&!this.stat){this.matches[n]||(this.matches[n]=Object.create(null));for(var h=0;h<m;h++){var p=f[h];t&&(t.slice(-1)!=="/"?p=t+"/"+p:p=t+p),p.charAt(0)==="/"&&!this.nomount&&(p=_s.join(this.root,p)),this._emitMatch(n,p)}return}r.shift();for(var h=0;h<m;h++){var p=f[h],g;t?g=[t,p]:g=[p],this._process(g.concat(r),n,s)}}}};Re.prototype._emitMatch=function(t,e){if(!S0(this,e)){var i=this._makeAbs(e);if(this.mark&&(e=this._mark(e)),this.absolute&&(e=i),!this.matches[t][e]){if(this.nodir){var r=this.cache[i];if(r==="DIR"||Array.isArray(r))return}this.matches[t][e]=!0,this.stat&&this._stat(e)}}};Re.prototype._readdirInGlobStar=function(t){if(this.follow)return this._readdir(t,!1);var e,i,r;try{i=this.fs.lstatSync(t)}catch(s){if(s.code==="ENOENT")return null}var n=i&&i.isSymbolicLink();return this.symlinks[t]=n,!n&&i&&!i.isDirectory()?this.cache[t]="FILE":e=this._readdir(t,!1),e};Re.prototype._readdir=function(t,e){var i;if(e&&!xs(this.symlinks,t))return this._readdirInGlobStar(t);if(xs(this.cache,t)){var r=this.cache[t];if(!r||r==="FILE")return null;if(Array.isArray(r))return r}try{return this._readdirEntries(t,this.fs.readdirSync(t))}catch(n){return this._readdirError(t,n),null}};Re.prototype._readdirEntries=function(t,e){if(!this.mark&&!this.stat)for(var i=0;i<e.length;i++){var r=e[i];t==="/"?r=t+r:r=t+"/"+r,this.cache[r]=!0}return this.cache[t]=e,e};Re.prototype._readdirError=function(t,e){switch(e.code){case"ENOTSUP":case"ENOTDIR":var i=this._makeAbs(t);if(this.cache[i]="FILE",i===this.cwdAbs){var r=new Error(e.code+" invalid cwd "+this.cwd);throw r.path=this.cwd,r.code=e.code,r}break;case"ENOENT":case"ELOOP":case"ENAMETOOLONG":case"UNKNOWN":this.cache[this._makeAbs(t)]=!1;break;default:if(this.cache[this._makeAbs(t)]=!1,this.strict)throw e;this.silent||console.error("glob error",e);break}};Re.prototype._processGlobStar=function(t,e,i,r,n,s){var o=this._readdir(i,s);if(!!o){var a=r.slice(1),l=t?[t]:[],c=l.concat(a);this._process(c,n,!1);var u=o.length,f=this.symlinks[i];if(!(f&&s))for(var h=0;h<u;h++){var p=o[h];if(!(p.charAt(0)==="."&&!this.dot)){var d=l.concat(o[h],a);this._process(d,n,!0);var m=l.concat(o[h],r);this._process(m,n,!0)}}}};Re.prototype._processSimple=function(t,e){var i=this._stat(t);if(this.matches[e]||(this.matches[e]=Object.create(null)),!!i){if(t&&Ur(t)&&!this.nomount){var r=/[\/\\]$/.test(t);t.charAt(0)==="/"?t=_s.join(this.root,t):(t=_s.resolve(this.root,t),r&&(t+="/"))}process.platform==="win32"&&(t=t.replace(/\\/g,"/")),this._emitMatch(e,t)}};Re.prototype._stat=function(t){var e=this._makeAbs(t),i=t.slice(-1)==="/";if(t.length>this.maxLength)return!1;if(!this.stat&&xs(this.cache,e)){var o=this.cache[e];if(Array.isArray(o)&&(o="DIR"),!i||o==="DIR")return o;if(i&&o==="FILE")return!1}var r,n=this.statCache[e];if(!n){var s;try{s=this.fs.lstatSync(e)}catch(a){if(a&&(a.code==="ENOENT"||a.code==="ENOTDIR"))return this.statCache[e]=!1,!1}if(s&&s.isSymbolicLink())try{n=this.fs.statSync(e)}catch{n=s}else n=s}this.statCache[e]=n;var o=!0;return n&&(o=n.isDirectory()?"DIR":"FILE"),this.cache[e]=this.cache[e]||o,i&&o==="FILE"?!1:o};Re.prototype._mark=function(t){return qt.mark(this,t)};Re.prototype._makeAbs=function(t){return qt.makeAbs(this,t)}});var bs=x((Ix,_u)=>{_u.exports=vu;function vu(t,e){if(t&&e)return vu(t)(e);if(typeof t!="function")throw new TypeError("need wrapper function");return Object.keys(t).forEach(function(r){i[r]=t[r]}),i;function i(){for(var r=new Array(arguments.length),n=0;n<r.length;n++)r[n]=arguments[n];var s=t.apply(this,r),o=r[r.length-1];return typeof s=="function"&&s!==o&&Object.keys(o).forEach(function(a){s[a]=o[a]}),s}}});var Es=x((Tx,ws)=>{var xu=bs();ws.exports=xu(Dr);ws.exports.strict=xu(yu);Dr.proto=Dr(function(){Object.defineProperty(Function.prototype,"once",{value:function(){return Dr(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return yu(this)},configurable:!0})});function Dr(t){var e=function(){return e.called?e.value:(e.called=!0,e.value=t.apply(this,arguments))};return e.called=!1,e}function yu(t){var e=function(){if(e.called)throw new Error(e.onceError);return e.called=!0,e.value=t.apply(this,arguments)},i=t.name||"Function wrapped with `once`";return e.onceError=i+" shouldn't be called more than once",e.called=!1,e}});var wu=x((Ax,bu)=>{var k0=bs(),Yi=Object.create(null),C0=Es();bu.exports=k0(O0);function O0(t,e){return Yi[t]?(Yi[t].push(e),null):(Yi[t]=[e],I0(t))}function I0(t){return C0(function e(){var i=Yi[t],r=i.length,n=T0(arguments);try{for(var s=0;s<r;s++)i[s].apply(null,n)}finally{i.length>r?(i.splice(0,r),process.nextTick(function(){e.apply(null,n)})):delete Yi[t]}})}function T0(t){for(var e=t.length,i=[],r=0;r<e;r++)i[r]=t[r];return i}});var ys=x((Lx,Su)=>{Su.exports=Ht;var A0=hs(),Eu=Hi(),Rx=Eu.Minimatch,R0=ou(),B0=(__nccwpck_require__(2361).EventEmitter),Ss=__nccwpck_require__(1017),ks=__nccwpck_require__(9491),Ki=Mr(),Os=gu(),Vt=vs(),L0=Vt.setopts,Cs=Vt.ownProp,Is=wu(),Bx=__nccwpck_require__(3837),N0=Vt.childrenIgnored,P0=Vt.isIgnored,F0=Es();function Ht(t,e,i){if(typeof e=="function"&&(i=e,e={}),e||(e={}),e.sync){if(i)throw new TypeError("callback provided to sync glob");return Os(t,e)}return new me(t,e,i)}Ht.sync=Os;var M0=Ht.GlobSync=Os.GlobSync;Ht.glob=Ht;function U0(t,e){if(e===null||typeof e!="object")return t;for(var i=Object.keys(e),r=i.length;r--;)t[i[r]]=e[i[r]];return t}Ht.hasMagic=function(t,e){var i=U0({},e);i.noprocess=!0;var r=new me(t,i),n=r.minimatch.set;if(!t)return!1;if(n.length>1)return!0;for(var s=0;s<n[0].length;s++)if(typeof n[0][s]!="string")return!0;return!1};Ht.Glob=me;R0(me,B0);function me(t,e,i){if(typeof e=="function"&&(i=e,e=null),e&&e.sync){if(i)throw new TypeError("callback provided to sync glob");return new M0(t,e)}if(!(this instanceof me))return new me(t,e,i);L0(this,t,e),this._didRealPath=!1;var r=this.minimatch.set.length;this.matches=new Array(r),typeof i=="function"&&(i=F0(i),this.on("error",i),this.on("end",function(l){i(null,l)}));var n=this;if(this._processing=0,this._emitQueue=[],this._processQueue=[],this.paused=!1,this.noprocess)return this;if(r===0)return a();for(var s=!0,o=0;o<r;o++)this._process(this.minimatch.set[o],o,!1,a);s=!1;function a(){--n._processing,n._processing<=0&&(s?process.nextTick(function(){n._finish()}):n._finish())}}me.prototype._finish=function(){if(ks(this instanceof me),!this.aborted){if(this.realpath&&!this._didRealpath)return this._realpath();Vt.finish(this),this.emit("end",this.found)}};me.prototype._realpath=function(){if(this._didRealpath)return;this._didRealpath=!0;var t=this.matches.length;if(t===0)return this._finish();for(var e=this,i=0;i<this.matches.length;i++)this._realpathSet(i,r);function r(){--t===0&&e._finish()}};me.prototype._realpathSet=function(t,e){var i=this.matches[t];if(!i)return e();var r=Object.keys(i),n=this,s=r.length;if(s===0)return e();var o=this.matches[t]=Object.create(null);r.forEach(function(a,l){a=n._makeAbs(a),A0.realpath(a,n.realpathCache,function(c,u){c?c.syscall==="stat"?o[a]=!0:n.emit("error",c):o[u]=!0,--s===0&&(n.matches[t]=o,e())})})};me.prototype._mark=function(t){return Vt.mark(this,t)};me.prototype._makeAbs=function(t){return Vt.makeAbs(this,t)};me.prototype.abort=function(){this.aborted=!0,this.emit("abort")};me.prototype.pause=function(){this.paused||(this.paused=!0,this.emit("pause"))};me.prototype.resume=function(){if(this.paused){if(this.emit("resume"),this.paused=!1,this._emitQueue.length){var t=this._emitQueue.slice(0);this._emitQueue.length=0;for(var e=0;e<t.length;e++){var i=t[e];this._emitMatch(i[0],i[1])}}if(this._processQueue.length){var r=this._processQueue.slice(0);this._processQueue.length=0;for(var e=0;e<r.length;e++){var n=r[e];this._processing--,this._process(n[0],n[1],n[2],n[3])}}}};me.prototype._process=function(t,e,i,r){if(ks(this instanceof me),ks(typeof r=="function"),!this.aborted){if(this._processing++,this.paused){this._processQueue.push([t,e,i,r]);return}for(var n=0;typeof t[n]=="string";)n++;var s;switch(n){case t.length:this._processSimple(t.join("/"),e,r);return;case 0:s=null;break;default:s=t.slice(0,n).join("/");break}var o=t.slice(n),a;s===null?a=".":((Ki(s)||Ki(t.join("/")))&&(!s||!Ki(s))&&(s="/"+s),a=s);var l=this._makeAbs(a);if(N0(this,a))return r();var c=o[0]===Eu.GLOBSTAR;c?this._processGlobStar(s,a,l,o,e,i,r):this._processReaddir(s,a,l,o,e,i,r)}};me.prototype._processReaddir=function(t,e,i,r,n,s,o){var a=this;this._readdir(i,s,function(l,c){return a._processReaddir2(t,e,i,r,n,s,c,o)})};me.prototype._processReaddir2=function(t,e,i,r,n,s,o,a){if(!o)return a();for(var l=r[0],c=!!this.minimatch.negate,u=l._glob,f=this.dot||u.charAt(0)===".",h=[],p=0;p<o.length;p++){var d=o[p];if(d.charAt(0)!=="."||f){var m;c&&!t?m=!d.match(l):m=d.match(l),m&&h.push(d)}}var g=h.length;if(g===0)return a();if(r.length===1&&!this.mark&&!this.stat){this.matches[n]||(this.matches[n]=Object.create(null));for(var p=0;p<g;p++){var d=h[p];t&&(t!=="/"?d=t+"/"+d:d=t+d),d.charAt(0)==="/"&&!this.nomount&&(d=Ss.join(this.root,d)),this._emitMatch(n,d)}return a()}r.shift();for(var p=0;p<g;p++){var d=h[p],y;t&&(t!=="/"?d=t+"/"+d:d=t+d),this._process([d].concat(r),n,s,a)}a()};me.prototype._emitMatch=function(t,e){if(!this.aborted&&!P0(this,e)){if(this.paused){this._emitQueue.push([t,e]);return}var i=Ki(e)?e:this._makeAbs(e);if(this.mark&&(e=this._mark(e)),this.absolute&&(e=i),!this.matches[t][e]){if(this.nodir){var r=this.cache[i];if(r==="DIR"||Array.isArray(r))return}this.matches[t][e]=!0;var n=this.statCache[i];n&&this.emit("stat",e,n),this.emit("match",e)}}};me.prototype._readdirInGlobStar=function(t,e){if(this.aborted)return;if(this.follow)return this._readdir(t,!1,e);var i="lstat\0"+t,r=this,n=Is(i,s);n&&r.fs.lstat(t,n);function s(o,a){if(o&&o.code==="ENOENT")return e();var l=a&&a.isSymbolicLink();r.symlinks[t]=l,!l&&a&&!a.isDirectory()?(r.cache[t]="FILE",e()):r._readdir(t,!1,e)}};me.prototype._readdir=function(t,e,i){if(!this.aborted&&(i=Is("readdir\0"+t+"\0"+e,i),!!i)){if(e&&!Cs(this.symlinks,t))return this._readdirInGlobStar(t,i);if(Cs(this.cache,t)){var r=this.cache[t];if(!r||r==="FILE")return i();if(Array.isArray(r))return i(null,r)}var n=this;n.fs.readdir(t,D0(this,t,i))}};function D0(t,e,i){return function(r,n){r?t._readdirError(e,r,i):t._readdirEntries(e,n,i)}}me.prototype._readdirEntries=function(t,e,i){if(!this.aborted){if(!this.mark&&!this.stat)for(var r=0;r<e.length;r++){var n=e[r];t==="/"?n=t+n:n=t+"/"+n,this.cache[n]=!0}return this.cache[t]=e,i(null,e)}};me.prototype._readdirError=function(t,e,i){if(!this.aborted){switch(e.code){case"ENOTSUP":case"ENOTDIR":var r=this._makeAbs(t);if(this.cache[r]="FILE",r===this.cwdAbs){var n=new Error(e.code+" invalid cwd "+this.cwd);n.path=this.cwd,n.code=e.code,this.emit("error",n),this.abort()}break;case"ENOENT":case"ELOOP":case"ENAMETOOLONG":case"UNKNOWN":this.cache[this._makeAbs(t)]=!1;break;default:this.cache[this._makeAbs(t)]=!1,this.strict&&(this.emit("error",e),this.abort()),this.silent||console.error("glob error",e);break}return i()}};me.prototype._processGlobStar=function(t,e,i,r,n,s,o){var a=this;this._readdir(i,s,function(l,c){a._processGlobStar2(t,e,i,r,n,s,c,o)})};me.prototype._processGlobStar2=function(t,e,i,r,n,s,o,a){if(!o)return a();var l=r.slice(1),c=t?[t]:[],u=c.concat(l);this._process(u,n,!1,a);var f=this.symlinks[i],h=o.length;if(f&&s)return a();for(var p=0;p<h;p++){var d=o[p];if(!(d.charAt(0)==="."&&!this.dot)){var m=c.concat(o[p],l);this._process(m,n,!0,a);var g=c.concat(o[p],r);this._process(g,n,!0,a)}}a()};me.prototype._processSimple=function(t,e,i){var r=this;this._stat(t,function(n,s){r._processSimple2(t,e,n,s,i)})};me.prototype._processSimple2=function(t,e,i,r,n){if(this.matches[e]||(this.matches[e]=Object.create(null)),!r)return n();if(t&&Ki(t)&&!this.nomount){var s=/[\/\\]$/.test(t);t.charAt(0)==="/"?t=Ss.join(this.root,t):(t=Ss.resolve(this.root,t),s&&(t+="/"))}process.platform==="win32"&&(t=t.replace(/\\/g,"/")),this._emitMatch(e,t),n()};me.prototype._stat=function(t,e){var i=this._makeAbs(t),r=t.slice(-1)==="/";if(t.length>this.maxLength)return e();if(!this.stat&&Cs(this.cache,i)){var n=this.cache[i];if(Array.isArray(n)&&(n="DIR"),!r||n==="DIR")return e(null,n);if(r&&n==="FILE")return e()}var s,o=this.statCache[i];if(o!==void 0){if(o===!1)return e(null,o);var a=o.isDirectory()?"DIR":"FILE";return r&&a==="FILE"?e():e(null,a,o)}var l=this,c=Is("stat\0"+i,u);c&&l.fs.lstat(i,c);function u(f,h){if(h&&h.isSymbolicLink())return l.fs.stat(i,function(p,d){p?l._stat2(t,i,null,h,e):l._stat2(t,i,p,d,e)});l._stat2(t,i,f,h,e)}};me.prototype._stat2=function(t,e,i,r,n){if(i&&(i.code==="ENOENT"||i.code==="ENOTDIR"))return this.statCache[e]=!1,n();var s=t.slice(-1)==="/";if(this.statCache[e]=r,e.slice(-1)==="/"&&r&&!r.isDirectory())return n(null,!1,r);var o=!0;return r&&(o=r.isDirectory()?"DIR":"FILE"),this.cache[e]=this.cache[e]||o,s&&o==="FILE"?n():n(null,o,r)}});var Bu=x((Nx,Ru)=>{var xe=__nccwpck_require__(9491),Iu=__nccwpck_require__(1017),ku=__nccwpck_require__(7147),vi;try{vi=ys()}catch{}var j0={nosort:!0,silent:!0},Ts=0,Zi=process.platform==="win32",Tu=t=>{if(["unlink","chmod","stat","lstat","rmdir","readdir"].forEach(i=>{t[i]=t[i]||ku[i],i=i+"Sync",t[i]=t[i]||ku[i]}),t.maxBusyTries=t.maxBusyTries||3,t.emfileWait=t.emfileWait||1e3,t.glob===!1&&(t.disableGlob=!0),t.disableGlob!==!0&&vi===void 0)throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");t.disableGlob=t.disableGlob||!1,t.glob=t.glob||j0},Rs=(t,e,i)=>{typeof e=="function"&&(i=e,e={}),xe(t,"rimraf: missing path"),xe.equal(typeof t,"string","rimraf: path should be a string"),xe.equal(typeof i,"function","rimraf: callback function required"),xe(e,"rimraf: invalid options argument provided"),xe.equal(typeof e,"object","rimraf: options should be object"),Tu(e);let r=0,n=null,s=0,o=l=>{n=n||l,--s===0&&i(n)},a=(l,c)=>{if(l)return i(l);if(s=c.length,s===0)return i();c.forEach(u=>{let f=h=>{if(h){if((h.code==="EBUSY"||h.code==="ENOTEMPTY"||h.code==="EPERM")&&r<e.maxBusyTries)return r++,setTimeout(()=>As(u,e,f),r*100);if(h.code==="EMFILE"&&Ts<e.emfileWait)return setTimeout(()=>As(u,e,f),Ts++);h.code==="ENOENT"&&(h=null)}Ts=0,o(h)};As(u,e,f)})};if(e.disableGlob||!vi.hasMagic(t))return a(null,[t]);e.lstat(t,(l,c)=>{if(!l)return a(null,[t]);vi(t,e.glob,a)})},As=(t,e,i)=>{xe(t),xe(e),xe(typeof i=="function"),e.lstat(t,(r,n)=>{if(r&&r.code==="ENOENT")return i(null);if(r&&r.code==="EPERM"&&Zi&&Cu(t,e,r,i),n&&n.isDirectory())return jr(t,e,r,i);e.unlink(t,s=>{if(s){if(s.code==="ENOENT")return i(null);if(s.code==="EPERM")return Zi?Cu(t,e,s,i):jr(t,e,s,i);if(s.code==="EISDIR")return jr(t,e,s,i)}return i(s)})})},Cu=(t,e,i,r)=>{xe(t),xe(e),xe(typeof r=="function"),e.chmod(t,438,n=>{n?r(n.code==="ENOENT"?null:i):e.stat(t,(s,o)=>{s?r(s.code==="ENOENT"?null:i):o.isDirectory()?jr(t,e,i,r):e.unlink(t,r)})})},Ou=(t,e,i)=>{xe(t),xe(e);try{e.chmodSync(t,438)}catch(n){if(n.code==="ENOENT")return;throw i}let r;try{r=e.statSync(t)}catch(n){if(n.code==="ENOENT")return;throw i}r.isDirectory()?qr(t,e,i):e.unlinkSync(t)},jr=(t,e,i,r)=>{xe(t),xe(e),xe(typeof r=="function"),e.rmdir(t,n=>{n&&(n.code==="ENOTEMPTY"||n.code==="EEXIST"||n.code==="EPERM")?q0(t,e,r):n&&n.code==="ENOTDIR"?r(i):r(n)})},q0=(t,e,i)=>{xe(t),xe(e),xe(typeof i=="function"),e.readdir(t,(r,n)=>{if(r)return i(r);let s=n.length;if(s===0)return e.rmdir(t,i);let o;n.forEach(a=>{Rs(Iu.join(t,a),e,l=>{if(!o){if(l)return i(o=l);--s===0&&e.rmdir(t,i)}})})})},Au=(t,e)=>{e=e||{},Tu(e),xe(t,"rimraf: missing path"),xe.equal(typeof t,"string","rimraf: path should be a string"),xe(e,"rimraf: missing options"),xe.equal(typeof e,"object","rimraf: options should be object");let i;if(e.disableGlob||!vi.hasMagic(t))i=[t];else try{e.lstatSync(t),i=[t]}catch{i=vi.sync(t,e.glob)}if(!!i.length)for(let r=0;r<i.length;r++){let n=i[r],s;try{s=e.lstatSync(n)}catch(o){if(o.code==="ENOENT")return;o.code==="EPERM"&&Zi&&Ou(n,e,o)}try{s&&s.isDirectory()?qr(n,e,null):e.unlinkSync(n)}catch(o){if(o.code==="ENOENT")return;if(o.code==="EPERM")return Zi?Ou(n,e,o):qr(n,e,o);if(o.code!=="EISDIR")throw o;qr(n,e,o)}}},qr=(t,e,i)=>{xe(t),xe(e);try{e.rmdirSync(t)}catch(r){if(r.code==="ENOENT")return;if(r.code==="ENOTDIR")throw i;(r.code==="ENOTEMPTY"||r.code==="EEXIST"||r.code==="EPERM")&&H0(t,e)}},H0=(t,e)=>{xe(t),xe(e),e.readdirSync(t).forEach(n=>Au(Iu.join(t,n),e));let i=Zi?100:1,r=0;do{let n=!0;try{let s=e.rmdirSync(t,e);return n=!1,s}finally{if(++r<i&&n)continue}}while(!0)};Ru.exports=Rs;Rs.sync=Au});var Nu=x(Lu=>{var H=Lu,{Buffer:Hr}=__nccwpck_require__(4300),V0=__nccwpck_require__(2037);H.toBuffer=function(t,e,i){i=~~i;let r;if(this.isV4Format(t))r=e||Hr.alloc(i+4),t.split(/\./g).map(n=>{r[i++]=parseInt(n,10)&255});else if(this.isV6Format(t)){let n=t.split(":",8),s;for(s=0;s<n.length;s++){let o=this.isV4Format(n[s]),a;o&&(a=this.toBuffer(n[s]),n[s]=a.slice(0,2).toString("hex")),a&&++s<8&&n.splice(s,0,a.slice(2,4).toString("hex"))}if(n[0]==="")for(;n.length<8;)n.unshift("0");else if(n[n.length-1]==="")for(;n.length<8;)n.push("0");else if(n.length<8){for(s=0;s<n.length&&n[s]!=="";s++);let o=[s,1];for(s=9-n.length;s>0;s--)o.push("0");n.splice(...o)}for(r=e||Hr.alloc(i+16),s=0;s<n.length;s++){let o=parseInt(n[s],16);r[i++]=o>>8&255,r[i++]=o&255}}if(!r)throw Error(`Invalid ip address: ${t}`);return r};H.toString=function(t,e,i){e=~~e,i=i||t.length-e;let r=[];if(i===4){for(let n=0;n<i;n++)r.push(t[e+n]);r=r.join(".")}else if(i===16){for(let n=0;n<i;n+=2)r.push(t.readUInt16BE(e+n).toString(16));r=r.join(":"),r=r.replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3"),r=r.replace(/:{3,4}/,"::")}return r};var $0=/^(\d{1,3}\.){3,3}\d{1,3}$/,G0=/^(::)?(((\d{1,3}\.){3}(\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;H.isV4Format=function(t){return $0.test(t)};H.isV6Format=function(t){return G0.test(t)};function Xi(t){return t===4?"ipv4":t===6?"ipv6":t?t.toLowerCase():"ipv4"}H.fromPrefixLen=function(t,e){t>32?e="ipv6":e=Xi(e);let i=4;e==="ipv6"&&(i=16);let r=Hr.alloc(i);for(let n=0,s=r.length;n<s;++n){let o=8;t<8&&(o=t),t-=o,r[n]=~(255>>o)&255}return H.toString(r)};H.mask=function(t,e){t=H.toBuffer(t),e=H.toBuffer(e);let i=Hr.alloc(Math.max(t.length,e.length)),r;if(t.length===e.length)for(r=0;r<t.length;r++)i[r]=t[r]&e[r];else if(e.length===4)for(r=0;r<e.length;r++)i[r]=t[t.length-4+r]&e[r];else{for(r=0;r<i.length-6;r++)i[r]=0;for(i[10]=255,i[11]=255,r=0;r<t.length;r++)i[r+12]=t[r]&e[r+12];r+=12}for(;r<i.length;r++)i[r]=0;return H.toString(i)};H.cidr=function(t){let e=t.split("/"),i=e[0];if(e.length!==2)throw new Error(`invalid CIDR subnet: ${i}`);let r=H.fromPrefixLen(parseInt(e[1],10));return H.mask(i,r)};H.subnet=function(t,e){let i=H.toLong(H.mask(t,e)),r=H.toBuffer(e),n=0;for(let o=0;o<r.length;o++)if(r[o]===255)n+=8;else{let a=r[o]&255;for(;a;)a=a<<1&255,n++}let s=2**(32-n);return{networkAddress:H.fromLong(i),firstAddress:s<=2?H.fromLong(i):H.fromLong(i+1),lastAddress:s<=2?H.fromLong(i+s-1):H.fromLong(i+s-2),broadcastAddress:H.fromLong(i+s-1),subnetMask:e,subnetMaskLength:n,numHosts:s<=2?s:s-2,length:s,contains(o){return i===H.toLong(H.mask(o,e))}}};H.cidrSubnet=function(t){let e=t.split("/"),i=e[0];if(e.length!==2)throw new Error(`invalid CIDR subnet: ${i}`);let r=H.fromPrefixLen(parseInt(e[1],10));return H.subnet(i,r)};H.not=function(t){let e=H.toBuffer(t);for(let i=0;i<e.length;i++)e[i]=255^e[i];return H.toString(e)};H.or=function(t,e){if(t=H.toBuffer(t),e=H.toBuffer(e),t.length===e.length){for(let s=0;s<t.length;++s)t[s]|=e[s];return H.toString(t)}let i=t,r=e;e.length>t.length&&(i=e,r=t);let n=i.length-r.length;for(let s=n;s<i.length;++s)i[s]|=r[s-n];return H.toString(i)};H.isEqual=function(t,e){if(t=H.toBuffer(t),e=H.toBuffer(e),t.length===e.length){for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0}if(e.length===4){let r=e;e=t,t=r}for(let r=0;r<10;r++)if(e[r]!==0)return!1;let i=e.readUInt16BE(10);if(i!==0&&i!==65535)return!1;for(let r=0;r<4;r++)if(t[r]!==e[r+12])return!1;return!0};H.isPrivate=function(t){return/^(::f{4}:)?10\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?192\.168\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?172\.(1[6-9]|2\d|30|31)\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t)||/^(::f{4}:)?169\.254\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(t)||/^f[cd][0-9a-f]{2}:/i.test(t)||/^fe80:/i.test(t)||/^::1$/.test(t)||/^::$/.test(t)};H.isPublic=function(t){return!H.isPrivate(t)};H.isLoopback=function(t){return/^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(t)||/^fe80::1$/.test(t)||/^::1$/.test(t)||/^::$/.test(t)};H.loopback=function(t){if(t=Xi(t),t!=="ipv4"&&t!=="ipv6")throw new Error("family must be ipv4 or ipv6");return t==="ipv4"?"127.0.0.1":"fe80::1"};H.address=function(t,e){let i=V0.networkInterfaces();if(e=Xi(e),t&&t!=="private"&&t!=="public"){let n=i[t].filter(s=>Xi(s.family)===e);return n.length===0?void 0:n[0].address}let r=Object.keys(i).map(n=>{let s=i[n].filter(o=>(o.family=Xi(o.family),o.family!==e||H.isLoopback(o.address)?!1:t?t==="public"?H.isPrivate(o.address):H.isPublic(o.address):!0));return s.length?s[0].address:void 0}).filter(Boolean);return r.length?r[0]:H.loopback(e)};H.toLong=function(t){let e=0;return t.split(".").forEach(i=>{e<<=8,e+=parseInt(i)}),e>>>0};H.fromLong=function(t){return`${t>>>24}.${t>>16&255}.${t>>8&255}.${t&255}`}});var Uu=x(pt=>{"use strict";Object.defineProperty(pt,"__esModule",{value:!0});var Pu=__nccwpck_require__(4300),$t={INVALID_ENCODING:"Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",INVALID_SMARTBUFFER_SIZE:"Invalid size provided. Size must be a valid integer greater than zero.",INVALID_SMARTBUFFER_BUFFER:"Invalid Buffer provided in SmartBufferOptions.",INVALID_SMARTBUFFER_OBJECT:"Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",INVALID_OFFSET:"An invalid offset value was provided.",INVALID_OFFSET_NON_NUMBER:"An invalid offset value was provided. A numeric value is required.",INVALID_LENGTH:"An invalid length value was provided.",INVALID_LENGTH_NON_NUMBER:"An invalid length value was provived. A numeric value is required.",INVALID_TARGET_OFFSET:"Target offset is beyond the bounds of the internal SmartBuffer data.",INVALID_TARGET_LENGTH:"Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",INVALID_READ_BEYOND_BOUNDS:"Attempted to read beyond the bounds of the managed data.",INVALID_WRITE_BEYOND_BOUNDS:"Attempted to write beyond the bounds of the managed data."};pt.ERRORS=$t;function z0(t){if(!Pu.Buffer.isEncoding(t))throw new Error($t.INVALID_ENCODING)}pt.checkEncoding=z0;function Fu(t){return typeof t=="number"&&isFinite(t)&&Z0(t)}pt.isFiniteInteger=Fu;function Mu(t,e){if(typeof t=="number"){if(!Fu(t)||t<0)throw new Error(e?$t.INVALID_OFFSET:$t.INVALID_LENGTH)}else throw new Error(e?$t.INVALID_OFFSET_NON_NUMBER:$t.INVALID_LENGTH_NON_NUMBER)}function W0(t){Mu(t,!1)}pt.checkLengthValue=W0;function Y0(t){Mu(t,!0)}pt.checkOffsetValue=Y0;function K0(t,e){if(t<0||t>e.length)throw new Error($t.INVALID_TARGET_OFFSET)}pt.checkTargetOffset=K0;function Z0(t){return typeof t=="number"&&isFinite(t)&&Math.floor(t)===t}function X0(t){if(typeof BigInt=="undefined")throw new Error("Platform does not support JS BigInt type.");if(typeof Pu.Buffer.prototype[t]=="undefined")throw new Error(`Platform does not support Buffer.prototype.${t}.`)}pt.bigIntAndBufferInt64Check=X0});var ju=x(Bs=>{"use strict";Object.defineProperty(Bs,"__esModule",{value:!0});var ie=Uu(),Du=4096,Q0="utf8",Qi=class{constructor(e){if(this.length=0,this._encoding=Q0,this._writeOffset=0,this._readOffset=0,Qi.isSmartBufferOptions(e))if(e.encoding&&(ie.checkEncoding(e.encoding),this._encoding=e.encoding),e.size)if(ie.isFiniteInteger(e.size)&&e.size>0)this._buff=Buffer.allocUnsafe(e.size);else throw new Error(ie.ERRORS.INVALID_SMARTBUFFER_SIZE);else if(e.buff)if(Buffer.isBuffer(e.buff))this._buff=e.buff,this.length=e.buff.length;else throw new Error(ie.ERRORS.INVALID_SMARTBUFFER_BUFFER);else this._buff=Buffer.allocUnsafe(Du);else{if(typeof e!="undefined")throw new Error(ie.ERRORS.INVALID_SMARTBUFFER_OBJECT);this._buff=Buffer.allocUnsafe(Du)}}static fromSize(e,i){return new this({size:e,encoding:i})}static fromBuffer(e,i){return new this({buff:e,encoding:i})}static fromOptions(e){return new this(e)}static isSmartBufferOptions(e){let i=e;return i&&(i.encoding!==void 0||i.size!==void 0||i.buff!==void 0)}readInt8(e){return this._readNumberValue(Buffer.prototype.readInt8,1,e)}readInt16BE(e){return this._readNumberValue(Buffer.prototype.readInt16BE,2,e)}readInt16LE(e){return this._readNumberValue(Buffer.prototype.readInt16LE,2,e)}readInt32BE(e){return this._readNumberValue(Buffer.prototype.readInt32BE,4,e)}readInt32LE(e){return this._readNumberValue(Buffer.prototype.readInt32LE,4,e)}readBigInt64BE(e){return ie.bigIntAndBufferInt64Check("readBigInt64BE"),this._readNumberValue(Buffer.prototype.readBigInt64BE,8,e)}readBigInt64LE(e){return ie.bigIntAndBufferInt64Check("readBigInt64LE"),this._readNumberValue(Buffer.prototype.readBigInt64LE,8,e)}writeInt8(e,i){return this._writeNumberValue(Buffer.prototype.writeInt8,1,e,i),this}insertInt8(e,i){return this._insertNumberValue(Buffer.prototype.writeInt8,1,e,i)}writeInt16BE(e,i){return this._writeNumberValue(Buffer.prototype.writeInt16BE,2,e,i)}insertInt16BE(e,i){return this._insertNumberValue(Buffer.prototype.writeInt16BE,2,e,i)}writeInt16LE(e,i){return this._writeNumberValue(Buffer.prototype.writeInt16LE,2,e,i)}insertInt16LE(e,i){return this._insertNumberValue(Buffer.prototype.writeInt16LE,2,e,i)}writeInt32BE(e,i){return this._writeNumberValue(Buffer.prototype.writeInt32BE,4,e,i)}insertInt32BE(e,i){return this._insertNumberValue(Buffer.prototype.writeInt32BE,4,e,i)}writeInt32LE(e,i){return this._writeNumberValue(Buffer.prototype.writeInt32LE,4,e,i)}insertInt32LE(e,i){return this._insertNumberValue(Buffer.prototype.writeInt32LE,4,e,i)}writeBigInt64BE(e,i){return ie.bigIntAndBufferInt64Check("writeBigInt64BE"),this._writeNumberValue(Buffer.prototype.writeBigInt64BE,8,e,i)}insertBigInt64BE(e,i){return ie.bigIntAndBufferInt64Check("writeBigInt64BE"),this._insertNumberValue(Buffer.prototype.writeBigInt64BE,8,e,i)}writeBigInt64LE(e,i){return ie.bigIntAndBufferInt64Check("writeBigInt64LE"),this._writeNumberValue(Buffer.prototype.writeBigInt64LE,8,e,i)}insertBigInt64LE(e,i){return ie.bigIntAndBufferInt64Check("writeBigInt64LE"),this._insertNumberValue(Buffer.prototype.writeBigInt64LE,8,e,i)}readUInt8(e){return this._readNumberValue(Buffer.prototype.readUInt8,1,e)}readUInt16BE(e){return this._readNumberValue(Buffer.prototype.readUInt16BE,2,e)}readUInt16LE(e){return this._readNumberValue(Buffer.prototype.readUInt16LE,2,e)}readUInt32BE(e){return this._readNumberValue(Buffer.prototype.readUInt32BE,4,e)}readUInt32LE(e){return this._readNumberValue(Buffer.prototype.readUInt32LE,4,e)}readBigUInt64BE(e){return ie.bigIntAndBufferInt64Check("readBigUInt64BE"),this._readNumberValue(Buffer.prototype.readBigUInt64BE,8,e)}readBigUInt64LE(e){return ie.bigIntAndBufferInt64Check("readBigUInt64LE"),this._readNumberValue(Buffer.prototype.readBigUInt64LE,8,e)}writeUInt8(e,i){return this._writeNumberValue(Buffer.prototype.writeUInt8,1,e,i)}insertUInt8(e,i){return this._insertNumberValue(Buffer.prototype.writeUInt8,1,e,i)}writeUInt16BE(e,i){return this._writeNumberValue(Buffer.prototype.writeUInt16BE,2,e,i)}insertUInt16BE(e,i){return this._insertNumberValue(Buffer.prototype.writeUInt16BE,2,e,i)}writeUInt16LE(e,i){return this._writeNumberValue(Buffer.prototype.writeUInt16LE,2,e,i)}insertUInt16LE(e,i){return this._insertNumberValue(Buffer.prototype.writeUInt16LE,2,e,i)}writeUInt32BE(e,i){return this._writeNumberValue(Buffer.prototype.writeUInt32BE,4,e,i)}insertUInt32BE(e,i){return this._insertNumberValue(Buffer.prototype.writeUInt32BE,4,e,i)}writeUInt32LE(e,i){return this._writeNumberValue(Buffer.prototype.writeUInt32LE,4,e,i)}insertUInt32LE(e,i){return this._insertNumberValue(Buffer.prototype.writeUInt32LE,4,e,i)}writeBigUInt64BE(e,i){return ie.bigIntAndBufferInt64Check("writeBigUInt64BE"),this._writeNumberValue(Buffer.prototype.writeBigUInt64BE,8,e,i)}insertBigUInt64BE(e,i){return ie.bigIntAndBufferInt64Check("writeBigUInt64BE"),this._insertNumberValue(Buffer.prototype.writeBigUInt64BE,8,e,i)}writeBigUInt64LE(e,i){return ie.bigIntAndBufferInt64Check("writeBigUInt64LE"),this._writeNumberValue(Buffer.prototype.writeBigUInt64LE,8,e,i)}insertBigUInt64LE(e,i){return ie.bigIntAndBufferInt64Check("writeBigUInt64LE"),this._insertNumberValue(Buffer.prototype.writeBigUInt64LE,8,e,i)}readFloatBE(e){return this._readNumberValue(Buffer.prototype.readFloatBE,4,e)}readFloatLE(e){return this._readNumberValue(Buffer.prototype.readFloatLE,4,e)}writeFloatBE(e,i){return this._writeNumberValue(Buffer.prototype.writeFloatBE,4,e,i)}insertFloatBE(e,i){return this._insertNumberValue(Buffer.prototype.writeFloatBE,4,e,i)}writeFloatLE(e,i){return this._writeNumberValue(Buffer.prototype.writeFloatLE,4,e,i)}insertFloatLE(e,i){return this._insertNumberValue(Buffer.prototype.writeFloatLE,4,e,i)}readDoubleBE(e){return this._readNumberValue(Buffer.prototype.readDoubleBE,8,e)}readDoubleLE(e){return this._readNumberValue(Buffer.prototype.readDoubleLE,8,e)}writeDoubleBE(e,i){return this._writeNumberValue(Buffer.prototype.writeDoubleBE,8,e,i)}insertDoubleBE(e,i){return this._insertNumberValue(Buffer.prototype.writeDoubleBE,8,e,i)}writeDoubleLE(e,i){return this._writeNumberValue(Buffer.prototype.writeDoubleLE,8,e,i)}insertDoubleLE(e,i){return this._insertNumberValue(Buffer.prototype.writeDoubleLE,8,e,i)}readString(e,i){let r;typeof e=="number"?(ie.checkLengthValue(e),r=Math.min(e,this.length-this._readOffset)):(i=e,r=this.length-this._readOffset),typeof i!="undefined"&&ie.checkEncoding(i);let n=this._buff.slice(this._readOffset,this._readOffset+r).toString(i||this._encoding);return this._readOffset+=r,n}insertString(e,i,r){return ie.checkOffsetValue(i),this._handleString(e,!0,i,r)}writeString(e,i,r){return this._handleString(e,!1,i,r)}readStringNT(e){typeof e!="undefined"&&ie.checkEncoding(e);let i=this.length;for(let n=this._readOffset;n<this.length;n++)if(this._buff[n]===0){i=n;break}let r=this._buff.slice(this._readOffset,i);return this._readOffset=i+1,r.toString(e||this._encoding)}insertStringNT(e,i,r){return ie.checkOffsetValue(i),this.insertString(e,i,r),this.insertUInt8(0,i+e.length),this}writeStringNT(e,i,r){return this.writeString(e,i,r),this.writeUInt8(0,typeof i=="number"?i+e.length:this.writeOffset),this}readBuffer(e){typeof e!="undefined"&&ie.checkLengthValue(e);let i=typeof e=="number"?e:this.length,r=Math.min(this.length,this._readOffset+i),n=this._buff.slice(this._readOffset,r);return this._readOffset=r,n}insertBuffer(e,i){return ie.checkOffsetValue(i),this._handleBuffer(e,!0,i)}writeBuffer(e,i){return this._handleBuffer(e,!1,i)}readBufferNT(){let e=this.length;for(let r=this._readOffset;r<this.length;r++)if(this._buff[r]===0){e=r;break}let i=this._buff.slice(this._readOffset,e);return this._readOffset=e+1,i}insertBufferNT(e,i){return ie.checkOffsetValue(i),this.insertBuffer(e,i),this.insertUInt8(0,i+e.length),this}writeBufferNT(e,i){return typeof i!="undefined"&&ie.checkOffsetValue(i),this.writeBuffer(e,i),this.writeUInt8(0,typeof i=="number"?i+e.length:this._writeOffset),this}clear(){return this._writeOffset=0,this._readOffset=0,this.length=0,this}remaining(){return this.length-this._readOffset}get readOffset(){return this._readOffset}set readOffset(e){ie.checkOffsetValue(e),ie.checkTargetOffset(e,this),this._readOffset=e}get writeOffset(){return this._writeOffset}set writeOffset(e){ie.checkOffsetValue(e),ie.checkTargetOffset(e,this),this._writeOffset=e}get encoding(){return this._encoding}set encoding(e){ie.checkEncoding(e),this._encoding=e}get internalBuffer(){return this._buff}toBuffer(){return this._buff.slice(0,this.length)}toString(e){let i=typeof e=="string"?e:this._encoding;return ie.checkEncoding(i),this._buff.toString(i,0,this.length)}destroy(){return this.clear(),this}_handleString(e,i,r,n){let s=this._writeOffset,o=this._encoding;typeof r=="number"?s=r:typeof r=="string"&&(ie.checkEncoding(r),o=r),typeof n=="string"&&(ie.checkEncoding(n),o=n);let a=Buffer.byteLength(e,o);return i?this.ensureInsertable(a,s):this._ensureWriteable(a,s),this._buff.write(e,s,a,o),i?this._writeOffset+=a:typeof r=="number"?this._writeOffset=Math.max(this._writeOffset,s+a):this._writeOffset+=a,this}_handleBuffer(e,i,r){let n=typeof r=="number"?r:this._writeOffset;return i?this.ensureInsertable(e.length,n):this._ensureWriteable(e.length,n),e.copy(this._buff,n),i?this._writeOffset+=e.length:typeof r=="number"?this._writeOffset=Math.max(this._writeOffset,n+e.length):this._writeOffset+=e.length,this}ensureReadable(e,i){let r=this._readOffset;if(typeof i!="undefined"&&(ie.checkOffsetValue(i),r=i),r<0||r+e>this.length)throw new Error(ie.ERRORS.INVALID_READ_BEYOND_BOUNDS)}ensureInsertable(e,i){ie.checkOffsetValue(i),this._ensureCapacity(this.length+e),i<this.length&&this._buff.copy(this._buff,i+e,i,this._buff.length),i+e>this.length?this.length=i+e:this.length+=e}_ensureWriteable(e,i){let r=typeof i=="number"?i:this._writeOffset;this._ensureCapacity(r+e),r+e>this.length&&(this.length=r+e)}_ensureCapacity(e){let i=this._buff.length;if(e>i){let r=this._buff,n=i*3/2+1;n<e&&(n=e),this._buff=Buffer.allocUnsafe(n),r.copy(this._buff,0,0,i)}}_readNumberValue(e,i,r){this.ensureReadable(i,r);let n=e.call(this._buff,typeof r=="number"?r:this._readOffset);return typeof r=="undefined"&&(this._readOffset+=i),n}_insertNumberValue(e,i,r,n){return ie.checkOffsetValue(n),this.ensureInsertable(i,n),e.call(this._buff,r,n),this._writeOffset+=i,this}_writeNumberValue(e,i,r,n){if(typeof n=="number"){if(n<0)throw new Error(ie.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);ie.checkOffsetValue(n)}let s=typeof n=="number"?n:this._writeOffset;return this._ensureWriteable(i,s),e.call(this._buff,r,s),typeof n=="number"?this._writeOffset=Math.max(this._writeOffset,s+i):this._writeOffset+=i,this}};Bs.SmartBuffer=Qi});var Ds=x(we=>{"use strict";Object.defineProperty(we,"__esModule",{value:!0});we.SOCKS5_NO_ACCEPTABLE_AUTH=we.SOCKS5_CUSTOM_AUTH_END=we.SOCKS5_CUSTOM_AUTH_START=we.SOCKS_INCOMING_PACKET_SIZES=we.SocksClientState=we.Socks5Response=we.Socks5HostType=we.Socks5Auth=we.Socks4Response=we.SocksCommand=we.ERRORS=we.DEFAULT_TIMEOUT=void 0;var J0=3e4;we.DEFAULT_TIMEOUT=J0;var eg={InvalidSocksCommand:"An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",InvalidSocksCommandForOperation:"An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",InvalidSocksCommandChain:"An invalid SOCKS command was provided. Chaining currently only supports the connect command.",InvalidSocksClientOptionsDestination:"An invalid destination host was provided.",InvalidSocksClientOptionsExistingSocket:"An invalid existing socket was provided. This should be an instance of stream.Duplex.",InvalidSocksClientOptionsProxy:"Invalid SOCKS proxy details were provided.",InvalidSocksClientOptionsTimeout:"An invalid timeout value was provided. Please enter a value above 0 (in ms).",InvalidSocksClientOptionsProxiesLength:"At least two socks proxies must be provided for chaining.",InvalidSocksClientOptionsCustomAuthRange:"Custom auth must be a value between 0x80 and 0xFE.",InvalidSocksClientOptionsCustomAuthOptions:"When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",NegotiationError:"Negotiation error",SocketClosed:"Socket closed",ProxyConnectionTimedOut:"Proxy connection timed out",InternalError:"SocksClient internal error (this should not happen)",InvalidSocks4HandshakeResponse:"Received invalid Socks4 handshake response",Socks4ProxyRejectedConnection:"Socks4 Proxy rejected connection",InvalidSocks4IncomingConnectionResponse:"Socks4 invalid incoming connection response",Socks4ProxyRejectedIncomingBoundConnection:"Socks4 Proxy rejected incoming bound connection",InvalidSocks5InitialHandshakeResponse:"Received invalid Socks5 initial handshake response",InvalidSocks5IntiailHandshakeSocksVersion:"Received invalid Socks5 initial handshake (invalid socks version)",InvalidSocks5InitialHandshakeNoAcceptedAuthType:"Received invalid Socks5 initial handshake (no accepted authentication type)",InvalidSocks5InitialHandshakeUnknownAuthType:"Received invalid Socks5 initial handshake (unknown authentication type)",Socks5AuthenticationFailed:"Socks5 Authentication failed",InvalidSocks5FinalHandshake:"Received invalid Socks5 final handshake response",InvalidSocks5FinalHandshakeRejected:"Socks5 proxy rejected connection",InvalidSocks5IncomingConnectionResponse:"Received invalid Socks5 incoming connection response",Socks5ProxyRejectedIncomingBoundConnection:"Socks5 Proxy rejected incoming bound connection"};we.ERRORS=eg;var tg={Socks5InitialHandshakeResponse:2,Socks5UserPassAuthenticationResponse:2,Socks5ResponseHeader:5,Socks5ResponseIPv4:10,Socks5ResponseIPv6:22,Socks5ResponseHostname:t=>t+7,Socks4Response:8};we.SOCKS_INCOMING_PACKET_SIZES=tg;var Ls;(function(t){t[t.connect=1]="connect",t[t.bind=2]="bind",t[t.associate=3]="associate"})(Ls||(Ls={}));we.SocksCommand=Ls;var Ns;(function(t){t[t.Granted=90]="Granted",t[t.Failed=91]="Failed",t[t.Rejected=92]="Rejected",t[t.RejectedIdent=93]="RejectedIdent"})(Ns||(Ns={}));we.Socks4Response=Ns;var Ps;(function(t){t[t.NoAuth=0]="NoAuth",t[t.GSSApi=1]="GSSApi",t[t.UserPass=2]="UserPass"})(Ps||(Ps={}));we.Socks5Auth=Ps;var ig=128;we.SOCKS5_CUSTOM_AUTH_START=ig;var rg=254;we.SOCKS5_CUSTOM_AUTH_END=rg;var ng=255;we.SOCKS5_NO_ACCEPTABLE_AUTH=ng;var Fs;(function(t){t[t.Granted=0]="Granted",t[t.Failure=1]="Failure",t[t.NotAllowed=2]="NotAllowed",t[t.NetworkUnreachable=3]="NetworkUnreachable",t[t.HostUnreachable=4]="HostUnreachable",t[t.ConnectionRefused=5]="ConnectionRefused",t[t.TTLExpired=6]="TTLExpired",t[t.CommandNotSupported=7]="CommandNotSupported",t[t.AddressNotSupported=8]="AddressNotSupported"})(Fs||(Fs={}));we.Socks5Response=Fs;var Ms;(function(t){t[t.IPv4=1]="IPv4",t[t.Hostname=3]="Hostname",t[t.IPv6=4]="IPv6"})(Ms||(Ms={}));we.Socks5HostType=Ms;var Us;(function(t){t[t.Created=0]="Created",t[t.Connecting=1]="Connecting",t[t.Connected=2]="Connected",t[t.SentInitialHandshake=3]="SentInitialHandshake",t[t.ReceivedInitialHandshakeResponse=4]="ReceivedInitialHandshakeResponse",t[t.SentAuthentication=5]="SentAuthentication",t[t.ReceivedAuthenticationResponse=6]="ReceivedAuthenticationResponse",t[t.SentFinalHandshake=7]="SentFinalHandshake",t[t.ReceivedFinalResponse=8]="ReceivedFinalResponse",t[t.BoundWaitingForConnection=9]="BoundWaitingForConnection",t[t.Established=10]="Established",t[t.Disconnected=11]="Disconnected",t[t.Error=99]="Error"})(Us||(Us={}));we.SocksClientState=Us});var qs=x(_i=>{"use strict";Object.defineProperty(_i,"__esModule",{value:!0});_i.shuffleArray=_i.SocksClientError=void 0;var js=class extends Error{constructor(e,i){super(e),this.options=i}};_i.SocksClientError=js;function sg(t){for(let e=t.length-1;e>0;e--){let i=Math.floor(Math.random()*(e+1));[t[e],t[i]]=[t[i],t[e]]}}_i.shuffleArray=sg});var Gu=x(xi=>{"use strict";Object.defineProperty(xi,"__esModule",{value:!0});xi.validateSocksClientChainOptions=xi.validateSocksClientOptions=void 0;var Ge=qs(),Pe=Ds(),og=__nccwpck_require__(2781);function ag(t,e=["connect","bind","associate"]){if(!Pe.SocksCommand[t.command])throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksCommand,t);if(e.indexOf(t.command)===-1)throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksCommandForOperation,t);if(!Hu(t.destination))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsDestination,t);if(!Vu(t.proxy))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsProxy,t);if(qu(t.proxy,t),t.timeout&&!$u(t.timeout))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsTimeout,t);if(t.existing_socket&&!(t.existing_socket instanceof og.Duplex))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsExistingSocket,t)}xi.validateSocksClientOptions=ag;function lg(t){if(t.command!=="connect")throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksCommandChain,t);if(!Hu(t.destination))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsDestination,t);if(!(t.proxies&&Array.isArray(t.proxies)&&t.proxies.length>=2))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsProxiesLength,t);if(t.proxies.forEach(e=>{if(!Vu(e))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsProxy,t);qu(e,t)}),t.timeout&&!$u(t.timeout))throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsTimeout,t)}xi.validateSocksClientChainOptions=lg;function qu(t,e){if(t.custom_auth_method!==void 0){if(t.custom_auth_method<Pe.SOCKS5_CUSTOM_AUTH_START||t.custom_auth_method>Pe.SOCKS5_CUSTOM_AUTH_END)throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsCustomAuthRange,e);if(t.custom_auth_request_handler===void 0||typeof t.custom_auth_request_handler!="function")throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,e);if(t.custom_auth_response_size===void 0)throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,e);if(t.custom_auth_response_handler===void 0||typeof t.custom_auth_response_handler!="function")throw new Ge.SocksClientError(Pe.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,e)}}function Hu(t){return t&&typeof t.host=="string"&&typeof t.port=="number"&&t.port>=0&&t.port<=65535}function Vu(t){return t&&(typeof t.host=="string"||typeof t.ipaddress=="string")&&typeof t.port=="number"&&t.port>=0&&t.port<=65535&&(t.type===4||t.type===5)}function $u(t){return typeof t=="number"&&t>0}});var zu=x(Vr=>{"use strict";Object.defineProperty(Vr,"__esModule",{value:!0});Vr.ReceiveBuffer=void 0;var Hs=class{constructor(e=4096){this.buffer=Buffer.allocUnsafe(e),this.offset=0,this.originalSize=e}get length(){return this.offset}append(e){if(!Buffer.isBuffer(e))throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");if(this.offset+e.length>=this.buffer.length){let i=this.buffer;this.buffer=Buffer.allocUnsafe(Math.max(this.buffer.length+this.originalSize,this.buffer.length+e.length)),i.copy(this.buffer)}return e.copy(this.buffer,this.offset),this.offset+=e.length}peek(e){if(e>this.offset)throw new Error("Attempted to read beyond the bounds of the managed internal data.");return this.buffer.slice(0,e)}get(e){if(e>this.offset)throw new Error("Attempted to read beyond the bounds of the managed internal data.");let i=Buffer.allocUnsafe(e);return this.buffer.slice(0,e).copy(i),this.buffer.copyWithin(0,e,e+this.offset-e),this.offset-=e,i}};Vr.ReceiveBuffer=Hs});var Wu=x(Ct=>{"use strict";var yi=Ct&&Ct.__awaiter||function(t,e,i,r){function n(s){return s instanceof i?s:new i(function(o){o(s)})}return new(i||(i=Promise))(function(s,o){function a(u){try{c(r.next(u))}catch(f){o(f)}}function l(u){try{c(r.throw(u))}catch(f){o(f)}}function c(u){u.done?s(u.value):n(u.value).then(a,l)}c((r=r.apply(t,e||[])).next())})};Object.defineProperty(Ct,"__esModule",{value:!0});Ct.SocksClientError=Ct.SocksClient=void 0;var cg=__nccwpck_require__(2361),bi=__nccwpck_require__(1808),Ke=Nu(),ze=ju(),k=Ds(),Vs=Gu(),ug=zu(),$s=qs();Object.defineProperty(Ct,"SocksClientError",{enumerable:!0,get:function(){return $s.SocksClientError}});var wi=class extends cg.EventEmitter{constructor(e){super(),this.options=Object.assign({},e),(0,Vs.validateSocksClientOptions)(e),this.setState(k.SocksClientState.Created)}static createConnection(e,i){return new Promise((r,n)=>{try{(0,Vs.validateSocksClientOptions)(e,["connect"])}catch(o){return typeof i=="function"?(i(o),r(o)):n(o)}let s=new wi(e);s.connect(e.existing_socket),s.once("established",o=>{s.removeAllListeners(),typeof i=="function"&&i(null,o),r(o)}),s.once("error",o=>{s.removeAllListeners(),typeof i=="function"?(i(o),r(o)):n(o)})})}static createConnectionChain(e,i){return new Promise((r,n)=>yi(this,void 0,void 0,function*(){try{(0,Vs.validateSocksClientChainOptions)(e)}catch(o){return typeof i=="function"?(i(o),r(o)):n(o)}let s;e.randomizeChain&&(0,$s.shuffleArray)(e.proxies);try{for(let o=0;o<e.proxies.length;o++){let a=e.proxies[o],l=o===e.proxies.length-1?e.destination:{host:e.proxies[o+1].host||e.proxies[o+1].ipaddress,port:e.proxies[o+1].port},c=yield wi.createConnection({command:"connect",proxy:a,destination:l});s||(s=c.socket)}typeof i=="function"?(i(null,{socket:s}),r({socket:s})):r({socket:s})}catch(o){typeof i=="function"?(i(o),r(o)):n(o)}}))}static createUDPFrame(e){let i=new ze.SmartBuffer;return i.writeUInt16BE(0),i.writeUInt8(e.frameNumber||0),bi.isIPv4(e.remoteHost.host)?(i.writeUInt8(k.Socks5HostType.IPv4),i.writeUInt32BE(Ke.toLong(e.remoteHost.host))):bi.isIPv6(e.remoteHost.host)?(i.writeUInt8(k.Socks5HostType.IPv6),i.writeBuffer(Ke.toBuffer(e.remoteHost.host))):(i.writeUInt8(k.Socks5HostType.Hostname),i.writeUInt8(Buffer.byteLength(e.remoteHost.host)),i.writeString(e.remoteHost.host)),i.writeUInt16BE(e.remoteHost.port),i.writeBuffer(e.data),i.toBuffer()}static parseUDPFrame(e){let i=ze.SmartBuffer.fromBuffer(e);i.readOffset=2;let r=i.readUInt8(),n=i.readUInt8(),s;n===k.Socks5HostType.IPv4?s=Ke.fromLong(i.readUInt32BE()):n===k.Socks5HostType.IPv6?s=Ke.toString(i.readBuffer(16)):s=i.readString(i.readUInt8());let o=i.readUInt16BE();return{frameNumber:r,remoteHost:{host:s,port:o},data:i.readBuffer()}}setState(e){this.state!==k.SocksClientState.Error&&(this.state=e)}connect(e){this.onDataReceived=r=>this.onDataReceivedHandler(r),this.onClose=()=>this.onCloseHandler(),this.onError=r=>this.onErrorHandler(r),this.onConnect=()=>this.onConnectHandler();let i=setTimeout(()=>this.onEstablishedTimeout(),this.options.timeout||k.DEFAULT_TIMEOUT);i.unref&&typeof i.unref=="function"&&i.unref(),e?this.socket=e:this.socket=new bi.Socket,this.socket.once("close",this.onClose),this.socket.once("error",this.onError),this.socket.once("connect",this.onConnect),this.socket.on("data",this.onDataReceived),this.setState(k.SocksClientState.Connecting),this.receiveBuffer=new ug.ReceiveBuffer,e?this.socket.emit("connect"):(this.socket.connect(this.getSocketOptions()),this.options.set_tcp_nodelay!==void 0&&this.options.set_tcp_nodelay!==null&&this.socket.setNoDelay(!!this.options.set_tcp_nodelay)),this.prependOnceListener("established",r=>{setImmediate(()=>{if(this.receiveBuffer.length>0){let n=this.receiveBuffer.get(this.receiveBuffer.length);r.socket.emit("data",n)}r.socket.resume()})})}getSocketOptions(){return Object.assign(Object.assign({},this.options.socket_options),{host:this.options.proxy.host||this.options.proxy.ipaddress,port:this.options.proxy.port})}onEstablishedTimeout(){this.state!==k.SocksClientState.Established&&this.state!==k.SocksClientState.BoundWaitingForConnection&&this.closeSocket(k.ERRORS.ProxyConnectionTimedOut)}onConnectHandler(){this.setState(k.SocksClientState.Connected),this.options.proxy.type===4?this.sendSocks4InitialHandshake():this.sendSocks5InitialHandshake(),this.setState(k.SocksClientState.SentInitialHandshake)}onDataReceivedHandler(e){this.receiveBuffer.append(e),this.processData()}processData(){for(;this.state!==k.SocksClientState.Established&&this.state!==k.SocksClientState.Error&&this.receiveBuffer.length>=this.nextRequiredPacketBufferSize;)if(this.state===k.SocksClientState.SentInitialHandshake)this.options.proxy.type===4?this.handleSocks4FinalHandshakeResponse():this.handleInitialSocks5HandshakeResponse();else if(this.state===k.SocksClientState.SentAuthentication)this.handleInitialSocks5AuthenticationHandshakeResponse();else if(this.state===k.SocksClientState.SentFinalHandshake)this.handleSocks5FinalHandshakeResponse();else if(this.state===k.SocksClientState.BoundWaitingForConnection)this.options.proxy.type===4?this.handleSocks4IncomingConnectionResponse():this.handleSocks5IncomingConnectionResponse();else{this.closeSocket(k.ERRORS.InternalError);break}}onCloseHandler(){this.closeSocket(k.ERRORS.SocketClosed)}onErrorHandler(e){this.closeSocket(e.message)}removeInternalSocketHandlers(){this.socket.pause(),this.socket.removeListener("data",this.onDataReceived),this.socket.removeListener("close",this.onClose),this.socket.removeListener("error",this.onError),this.socket.removeListener("connect",this.onConnect)}closeSocket(e){this.state!==k.SocksClientState.Error&&(this.setState(k.SocksClientState.Error),this.socket.destroy(),this.removeInternalSocketHandlers(),this.emit("error",new $s.SocksClientError(e,this.options)))}sendSocks4InitialHandshake(){let e=this.options.proxy.userId||"",i=new ze.SmartBuffer;i.writeUInt8(4),i.writeUInt8(k.SocksCommand[this.options.command]),i.writeUInt16BE(this.options.destination.port),bi.isIPv4(this.options.destination.host)?(i.writeBuffer(Ke.toBuffer(this.options.destination.host)),i.writeStringNT(e)):(i.writeUInt8(0),i.writeUInt8(0),i.writeUInt8(0),i.writeUInt8(1),i.writeStringNT(e),i.writeStringNT(this.options.destination.host)),this.nextRequiredPacketBufferSize=k.SOCKS_INCOMING_PACKET_SIZES.Socks4Response,this.socket.write(i.toBuffer())}handleSocks4FinalHandshakeResponse(){let e=this.receiveBuffer.get(8);if(e[1]!==k.Socks4Response.Granted)this.closeSocket(`${k.ERRORS.Socks4ProxyRejectedConnection} - (${k.Socks4Response[e[1]]})`);else if(k.SocksCommand[this.options.command]===k.SocksCommand.bind){let i=ze.SmartBuffer.fromBuffer(e);i.readOffset=2;let r={port:i.readUInt16BE(),host:Ke.fromLong(i.readUInt32BE())};r.host==="0.0.0.0"&&(r.host=this.options.proxy.ipaddress),this.setState(k.SocksClientState.BoundWaitingForConnection),this.emit("bound",{remoteHost:r,socket:this.socket})}else this.setState(k.SocksClientState.Established),this.removeInternalSocketHandlers(),this.emit("established",{socket:this.socket})}handleSocks4IncomingConnectionResponse(){let e=this.receiveBuffer.get(8);if(e[1]!==k.Socks4Response.Granted)this.closeSocket(`${k.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${k.Socks4Response[e[1]]})`);else{let i=ze.SmartBuffer.fromBuffer(e);i.readOffset=2;let r={port:i.readUInt16BE(),host:Ke.fromLong(i.readUInt32BE())};this.setState(k.SocksClientState.Established),this.removeInternalSocketHandlers(),this.emit("established",{remoteHost:r,socket:this.socket})}}sendSocks5InitialHandshake(){let e=new ze.SmartBuffer,i=[k.Socks5Auth.NoAuth];(this.options.proxy.userId||this.options.proxy.password)&&i.push(k.Socks5Auth.UserPass),this.options.proxy.custom_auth_method!==void 0&&i.push(this.options.proxy.custom_auth_method),e.writeUInt8(5),e.writeUInt8(i.length);for(let r of i)e.writeUInt8(r);this.nextRequiredPacketBufferSize=k.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse,this.socket.write(e.toBuffer()),this.setState(k.SocksClientState.SentInitialHandshake)}handleInitialSocks5HandshakeResponse(){let e=this.receiveBuffer.get(2);e[0]!==5?this.closeSocket(k.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion):e[1]===k.SOCKS5_NO_ACCEPTABLE_AUTH?this.closeSocket(k.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType):e[1]===k.Socks5Auth.NoAuth?(this.socks5ChosenAuthType=k.Socks5Auth.NoAuth,this.sendSocks5CommandRequest()):e[1]===k.Socks5Auth.UserPass?(this.socks5ChosenAuthType=k.Socks5Auth.UserPass,this.sendSocks5UserPassAuthentication()):e[1]===this.options.proxy.custom_auth_method?(this.socks5ChosenAuthType=this.options.proxy.custom_auth_method,this.sendSocks5CustomAuthentication()):this.closeSocket(k.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType)}sendSocks5UserPassAuthentication(){let e=this.options.proxy.userId||"",i=this.options.proxy.password||"",r=new ze.SmartBuffer;r.writeUInt8(1),r.writeUInt8(Buffer.byteLength(e)),r.writeString(e),r.writeUInt8(Buffer.byteLength(i)),r.writeString(i),this.nextRequiredPacketBufferSize=k.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse,this.socket.write(r.toBuffer()),this.setState(k.SocksClientState.SentAuthentication)}sendSocks5CustomAuthentication(){return yi(this,void 0,void 0,function*(){this.nextRequiredPacketBufferSize=this.options.proxy.custom_auth_response_size,this.socket.write(yield this.options.proxy.custom_auth_request_handler()),this.setState(k.SocksClientState.SentAuthentication)})}handleSocks5CustomAuthHandshakeResponse(e){return yi(this,void 0,void 0,function*(){return yield this.options.proxy.custom_auth_response_handler(e)})}handleSocks5AuthenticationNoAuthHandshakeResponse(e){return yi(this,void 0,void 0,function*(){return e[1]===0})}handleSocks5AuthenticationUserPassHandshakeResponse(e){return yi(this,void 0,void 0,function*(){return e[1]===0})}handleInitialSocks5AuthenticationHandshakeResponse(){return yi(this,void 0,void 0,function*(){this.setState(k.SocksClientState.ReceivedAuthenticationResponse);let e=!1;this.socks5ChosenAuthType===k.Socks5Auth.NoAuth?e=yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2)):this.socks5ChosenAuthType===k.Socks5Auth.UserPass?e=yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2)):this.socks5ChosenAuthType===this.options.proxy.custom_auth_method&&(e=yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size))),e?this.sendSocks5CommandRequest():this.closeSocket(k.ERRORS.Socks5AuthenticationFailed)})}sendSocks5CommandRequest(){let e=new ze.SmartBuffer;e.writeUInt8(5),e.writeUInt8(k.SocksCommand[this.options.command]),e.writeUInt8(0),bi.isIPv4(this.options.destination.host)?(e.writeUInt8(k.Socks5HostType.IPv4),e.writeBuffer(Ke.toBuffer(this.options.destination.host))):bi.isIPv6(this.options.destination.host)?(e.writeUInt8(k.Socks5HostType.IPv6),e.writeBuffer(Ke.toBuffer(this.options.destination.host))):(e.writeUInt8(k.Socks5HostType.Hostname),e.writeUInt8(this.options.destination.host.length),e.writeString(this.options.destination.host)),e.writeUInt16BE(this.options.destination.port),this.nextRequiredPacketBufferSize=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader,this.socket.write(e.toBuffer()),this.setState(k.SocksClientState.SentFinalHandshake)}handleSocks5FinalHandshakeResponse(){let e=this.receiveBuffer.peek(5);if(e[0]!==5||e[1]!==k.Socks5Response.Granted)this.closeSocket(`${k.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${k.Socks5Response[e[1]]}`);else{let i=e[3],r,n;if(i===k.Socks5HostType.IPv4){let s=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;if(this.receiveBuffer.length<s){this.nextRequiredPacketBufferSize=s;return}n=ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)),r={host:Ke.fromLong(n.readUInt32BE()),port:n.readUInt16BE()},r.host==="0.0.0.0"&&(r.host=this.options.proxy.ipaddress)}else if(i===k.Socks5HostType.Hostname){let s=e[4],o=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(s);if(this.receiveBuffer.length<o){this.nextRequiredPacketBufferSize=o;return}n=ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(o).slice(5)),r={host:n.readString(s),port:n.readUInt16BE()}}else if(i===k.Socks5HostType.IPv6){let s=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;if(this.receiveBuffer.length<s){this.nextRequiredPacketBufferSize=s;return}n=ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)),r={host:Ke.toString(n.readBuffer(16)),port:n.readUInt16BE()}}this.setState(k.SocksClientState.ReceivedFinalResponse),k.SocksCommand[this.options.command]===k.SocksCommand.connect?(this.setState(k.SocksClientState.Established),this.removeInternalSocketHandlers(),this.emit("established",{remoteHost:r,socket:this.socket})):k.SocksCommand[this.options.command]===k.SocksCommand.bind?(this.setState(k.SocksClientState.BoundWaitingForConnection),this.nextRequiredPacketBufferSize=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader,this.emit("bound",{remoteHost:r,socket:this.socket})):k.SocksCommand[this.options.command]===k.SocksCommand.associate&&(this.setState(k.SocksClientState.Established),this.removeInternalSocketHandlers(),this.emit("established",{remoteHost:r,socket:this.socket}))}}handleSocks5IncomingConnectionResponse(){let e=this.receiveBuffer.peek(5);if(e[0]!==5||e[1]!==k.Socks5Response.Granted)this.closeSocket(`${k.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${k.Socks5Response[e[1]]}`);else{let i=e[3],r,n;if(i===k.Socks5HostType.IPv4){let s=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;if(this.receiveBuffer.length<s){this.nextRequiredPacketBufferSize=s;return}n=ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)),r={host:Ke.fromLong(n.readUInt32BE()),port:n.readUInt16BE()},r.host==="0.0.0.0"&&(r.host=this.options.proxy.ipaddress)}else if(i===k.Socks5HostType.Hostname){let s=e[4],o=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(s);if(this.receiveBuffer.length<o){this.nextRequiredPacketBufferSize=o;return}n=ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(o).slice(5)),r={host:n.readString(s),port:n.readUInt16BE()}}else if(i===k.Socks5HostType.IPv6){let s=k.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;if(this.receiveBuffer.length<s){this.nextRequiredPacketBufferSize=s;return}n=ze.SmartBuffer.fromBuffer(this.receiveBuffer.get(s).slice(4)),r={host:Ke.toString(n.readBuffer(16)),port:n.readUInt16BE()}}this.setState(k.SocksClientState.Established),this.removeInternalSocketHandlers(),this.emit("established",{remoteHost:r,socket:this.socket})}}get socksClientOptions(){return Object.assign({},this.options)}};Ct.SocksClient=wi});var Yu=x(Gt=>{"use strict";var fg=Gt&&Gt.__createBinding||(Object.create?function(t,e,i,r){r===void 0&&(r=i);var n=Object.getOwnPropertyDescriptor(e,i);(!n||("get"in n?!e.__esModule:n.writable||n.configurable))&&(n={enumerable:!0,get:function(){return e[i]}}),Object.defineProperty(t,r,n)}:function(t,e,i,r){r===void 0&&(r=i),t[r]=e[i]}),hg=Gt&&Gt.__exportStar||function(t,e){for(var i in t)i!=="default"&&!Object.prototype.hasOwnProperty.call(e,i)&&fg(e,t,i)};Object.defineProperty(Gt,"__esModule",{value:!0});hg(Wu(),Gt)});var Ku=x(zt=>{"use strict";var pg=zt&&zt.__awaiter||function(t,e,i,r){function n(s){return s instanceof i?s:new i(function(o){o(s)})}return new(i||(i=Promise))(function(s,o){function a(u){try{c(r.next(u))}catch(f){o(f)}}function l(u){try{c(r.throw(u))}catch(f){o(f)}}function c(u){u.done?s(u.value):n(u.value).then(a,l)}c((r=r.apply(t,e||[])).next())})},$r=zt&&zt.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(zt,"__esModule",{value:!0});var dg=$r(__nccwpck_require__(9523)),mg=$r(__nccwpck_require__(4404)),gg=$r(__nccwpck_require__(7310)),vg=$r(ii()),_g=cn(),xg=Yu(),Gs=vg.default("socks-proxy-agent");function yg(t){return new Promise((e,i)=>{dg.default.lookup(t,(r,n)=>{r?i(r):e(n)})})}function bg(t){let e=0,i=!1,r=5,n=t.hostname||t.host;if(!n)throw new TypeError('No "host"');if(typeof t.port=="number"?e=t.port:typeof t.port=="string"&&(e=parseInt(t.port,10)),e||(e=1080),t.protocol)switch(t.protocol.replace(":","")){case"socks4":i=!0;case"socks4a":r=4;break;case"socks5":i=!0;case"socks":case"socks5h":r=5;break;default:throw new TypeError(`A "socks" protocol must be specified! Got: ${t.protocol}`)}if(typeof t.type!="undefined")if(t.type===4||t.type===5)r=t.type;else throw new TypeError(`"type" must be 4 or 5, got: ${t.type}`);let s={host:n,port:e,type:r},o=t.userId||t.username,a=t.password;if(t.auth){let l=t.auth.split(":");o=l[0],a=l[1]}return o&&Object.defineProperty(s,"userId",{value:o,enumerable:!1}),a&&Object.defineProperty(s,"password",{value:a,enumerable:!1}),{lookup:i,proxy:s}}var zs=class extends _g.Agent{constructor(e){let i;if(typeof e=="string"?i=gg.default.parse(e):i=e,!i)throw new TypeError("a SOCKS proxy server `host` and `port` must be specified!");super(i);let r=bg(i);this.lookup=r.lookup,this.proxy=r.proxy,this.tlsConnectionOptions=i.tls||{}}callback(e,i){return pg(this,void 0,void 0,function*(){let{lookup:r,proxy:n}=this,{host:s,port:o,timeout:a}=i;if(!s)throw new Error("No `host` defined!");r&&(s=yield yg(s));let l={proxy:n,destination:{host:s,port:o},command:"connect",timeout:a};Gs("Creating socks proxy connection: %o",l);let{socket:c}=yield xg.SocksClient.createConnection(l);if(Gs("Successfully created socks proxy connection"),i.secureEndpoint){Gs("Upgrading socket connection to TLS");let u=i.servername||i.host;return mg.default.connect(Object.assign(Object.assign(Object.assign({},wg(i,"host","hostname","path","port")),{socket:c,servername:u}),this.tlsConnectionOptions))}return c})}};zt.default=zs;function wg(t,...e){let i={},r;for(r in t)e.includes(r)||(i[r]=t[r]);return i}});var Xu=x((Ks,Zu)=>{"use strict";var Eg=Ks&&Ks.__importDefault||function(t){return t&&t.__esModule?t:{default:t}},Ws=Eg(Ku());function Ys(t){return new Ws.default(t)}(function(t){t.SocksProxyAgent=Ws.default,t.prototype=Ws.default.prototype})(Ys||(Ys={}));Zu.exports=Ys});var Ju=x((Gx,Qu)=>{"use strict";var Sg=/[|\\{}()[\]^$+*?.-]/g;Qu.exports=t=>{if(typeof t!="string")throw new TypeError("Expected a string");return t.replace(Sg,"\\$&")}});var nf=x((zx,rf)=>{"use strict";var kg=Ju(),Cg=typeof process=="object"&&process&&typeof process.cwd=="function"?process.cwd():".",tf=[].concat((__nccwpck_require__(8188).builtinModules),"bootstrap_node","node").map(t=>new RegExp(`(?:\\((?:node:)?${t}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${t}(?:\\.js)?:\\d+:\\d+$)`));tf.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/,/\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/,/\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);var Ji=class{constructor(e){e={ignoredPackages:[],...e},"internals"in e||(e.internals=Ji.nodeInternals()),"cwd"in e||(e.cwd=Cg),this._cwd=e.cwd.replace(/\\/g,"/"),this._internals=[].concat(e.internals,Og(e.ignoredPackages)),this._wrapCallSite=e.wrapCallSite||!1}static nodeInternals(){return[...tf]}clean(e,i=0){i=" ".repeat(i),Array.isArray(e)||(e=e.split(`
`)),!/^\s*at /.test(e[0])&&/^\s*at /.test(e[1])&&(e=e.slice(1));let r=!1,n=null,s=[];return e.forEach(o=>{if(o=o.replace(/\\/g,"/"),this._internals.some(l=>l.test(o)))return;let a=/^\s*at /.test(o);r?o=o.trimEnd().replace(/^(\s+)at /,"$1"):(o=o.trim(),a&&(o=o.slice(3))),o=o.replace(`${this._cwd}/`,""),o&&(a?(n&&(s.push(n),n=null),s.push(o)):(r=!0,n=o))}),s.map(o=>`${i}${o}
`).join("")}captureString(e,i=this.captureString){typeof e=="function"&&(i=e,e=1/0);let{stackTraceLimit:r}=Error;e&&(Error.stackTraceLimit=e);let n={};Error.captureStackTrace(n,i);let{stack:s}=n;return Error.stackTraceLimit=r,this.clean(s)}capture(e,i=this.capture){typeof e=="function"&&(i=e,e=1/0);let{prepareStackTrace:r,stackTraceLimit:n}=Error;Error.prepareStackTrace=(a,l)=>this._wrapCallSite?l.map(this._wrapCallSite):l,e&&(Error.stackTraceLimit=e);let s={};Error.captureStackTrace(s,i);let{stack:o}=s;return Object.assign(Error,{prepareStackTrace:r,stackTraceLimit:n}),o}at(e=this.at){let[i]=this.capture(1,e);if(!i)return{};let r={line:i.getLineNumber(),column:i.getColumnNumber()};ef(r,i.getFileName(),this._cwd),i.isConstructor()&&(r.constructor=!0),i.isEval()&&(r.evalOrigin=i.getEvalOrigin()),i.isNative()&&(r.native=!0);let n;try{n=i.getTypeName()}catch{}n&&n!=="Object"&&n!=="[object Object]"&&(r.type=n);let s=i.getFunctionName();s&&(r.function=s);let o=i.getMethodName();return o&&s!==o&&(r.method=o),r}parseLine(e){let i=e&&e.match(Ig);if(!i)return null;let r=i[1]==="new",n=i[2],s=i[3],o=i[4],a=Number(i[5]),l=Number(i[6]),c=i[7],u=i[8],f=i[9],h=i[10]==="native",p=i[11]===")",d,m={};if(u&&(m.line=Number(u)),f&&(m.column=Number(f)),p&&c){let g=0;for(let y=c.length-1;y>0;y--)if(c.charAt(y)===")")g++;else if(c.charAt(y)==="("&&c.charAt(y-1)===" "&&(g--,g===-1&&c.charAt(y-1)===" ")){let I=c.slice(0,y-1);c=c.slice(y+1),n+=` (${I}`;break}}if(n){let g=n.match(Tg);g&&(n=g[1],d=g[2])}return ef(m,c,this._cwd),r&&(m.constructor=!0),s&&(m.evalOrigin=s,m.evalLine=a,m.evalColumn=l,m.evalFile=o&&o.replace(/\\/g,"/")),h&&(m.native=!0),n&&(m.function=n),d&&n!==d&&(m.method=d),m}};function ef(t,e,i){e&&(e=e.replace(/\\/g,"/"),e.startsWith(`${i}/`)&&(e=e.slice(i.length+1)),t.file=e)}function Og(t){if(t.length===0)return[];let e=t.map(i=>kg(i));return new RegExp(`[/\\\\]node_modules[/\\\\](?:${e.join("|")})[/\\\\][^:]+:\\d+:\\d+`)}var Ig=new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$"),Tg=/^(.*?) \[as (.*?)\]$/;rf.exports=Ji});var lf=x((Wx,af)=>{"use strict";var{Duplex:Ag}=__nccwpck_require__(2781);function sf(t){t.emit("close")}function Rg(){!this.destroyed&&this._writableState.finished&&this.destroy()}function of(t){this.removeListener("error",of),this.destroy(),this.listenerCount("error")===0&&this.emit("error",t)}function Bg(t,e){let i=!0,r=new Ag({...e,autoDestroy:!1,emitClose:!1,objectMode:!1,writableObjectMode:!1});return t.on("message",function(s,o){let a=!o&&r._readableState.objectMode?s.toString():s;r.push(a)||t.pause()}),t.once("error",function(s){r.destroyed||(i=!1,r.destroy(s))}),t.once("close",function(){r.destroyed||r.push(null)}),r._destroy=function(n,s){if(t.readyState===t.CLOSED){s(n),process.nextTick(sf,r);return}let o=!1;t.once("error",function(l){o=!0,s(l)}),t.once("close",function(){o||s(n),process.nextTick(sf,r)}),i&&t.terminate()},r._final=function(n){if(t.readyState===t.CONNECTING){t.once("open",function(){r._final(n)});return}t._socket!==null&&(t._socket._writableState.finished?(n(),r._readableState.endEmitted&&r.destroy()):(t._socket.once("finish",function(){n()}),t.close()))},r._read=function(){t.isPaused&&t.resume()},r._write=function(n,s,o){if(t.readyState===t.CONNECTING){t.once("open",function(){r._write(n,s,o)});return}t.send(n,o)},r.on("end",Rg),r.on("error",of),r}af.exports=Bg});var Ot=x((Yx,cf)=>{"use strict";cf.exports={BINARY_TYPES:["nodebuffer","arraybuffer","fragments"],EMPTY_BUFFER:Buffer.alloc(0),GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",kForOnEventAttribute:Symbol("kIsForOnEventAttribute"),kListener:Symbol("kListener"),kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),NOOP:()=>{}}});var er=x((Kx,Zs)=>{"use strict";var{EMPTY_BUFFER:Lg}=Ot();function uf(t,e){if(t.length===0)return Lg;if(t.length===1)return t[0];let i=Buffer.allocUnsafe(e),r=0;for(let n=0;n<t.length;n++){let s=t[n];i.set(s,r),r+=s.length}return r<e?i.slice(0,r):i}function ff(t,e,i,r,n){for(let s=0;s<n;s++)i[r+s]=t[s]^e[s&3]}function hf(t,e){for(let i=0;i<t.length;i++)t[i]^=e[i&3]}function pf(t){return t.byteLength===t.buffer.byteLength?t.buffer:t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}function Gr(t){if(Gr.readOnly=!0,Buffer.isBuffer(t))return t;let e;return t instanceof ArrayBuffer?e=Buffer.from(t):ArrayBuffer.isView(t)?e=Buffer.from(t.buffer,t.byteOffset,t.byteLength):(e=Buffer.from(t),Gr.readOnly=!1),e}try{let t=__nccwpck_require__(1269);Zs.exports={concat:uf,mask(e,i,r,n,s){s<48?ff(e,i,r,n,s):t.mask(e,i,r,n,s)},toArrayBuffer:pf,toBuffer:Gr,unmask(e,i){e.length<32?hf(e,i):t.unmask(e,i)}}}catch{Zs.exports={concat:uf,mask:ff,toArrayBuffer:pf,toBuffer:Gr,unmask:hf}}});var gf=x((Zx,mf)=>{"use strict";var df=Symbol("kDone"),Xs=Symbol("kRun"),Qs=class{constructor(e){this[df]=()=>{this.pending--,this[Xs]()},this.concurrency=e||1/0,this.jobs=[],this.pending=0}add(e){this.jobs.push(e),this[Xs]()}[Xs](){if(this.pending!==this.concurrency&&this.jobs.length){let e=this.jobs.shift();this.pending++,e(this[df])}}};mf.exports=Qs});var rr=x((Xx,yf)=>{"use strict";var tr=__nccwpck_require__(9796),vf=er(),Ng=gf(),{kStatusCode:_f}=Ot(),Pg=Buffer.from([0,0,255,255]),Yr=Symbol("permessage-deflate"),dt=Symbol("total-length"),ir=Symbol("callback"),It=Symbol("buffers"),Wr=Symbol("error"),zr,Js=class{constructor(e,i,r){if(this._maxPayload=r|0,this._options=e||{},this._threshold=this._options.threshold!==void 0?this._options.threshold:1024,this._isServer=!!i,this._deflate=null,this._inflate=null,this.params=null,!zr){let n=this._options.concurrencyLimit!==void 0?this._options.concurrencyLimit:10;zr=new Ng(n)}}static get extensionName(){return"permessage-deflate"}offer(){let e={};return this._options.serverNoContextTakeover&&(e.server_no_context_takeover=!0),this._options.clientNoContextTakeover&&(e.client_no_context_takeover=!0),this._options.serverMaxWindowBits&&(e.server_max_window_bits=this._options.serverMaxWindowBits),this._options.clientMaxWindowBits?e.client_max_window_bits=this._options.clientMaxWindowBits:this._options.clientMaxWindowBits==null&&(e.client_max_window_bits=!0),e}accept(e){return e=this.normalizeParams(e),this.params=this._isServer?this.acceptAsServer(e):this.acceptAsClient(e),this.params}cleanup(){if(this._inflate&&(this._inflate.close(),this._inflate=null),this._deflate){let e=this._deflate[ir];this._deflate.close(),this._deflate=null,e&&e(new Error("The deflate stream was closed while data was being processed"))}}acceptAsServer(e){let i=this._options,r=e.find(n=>!(i.serverNoContextTakeover===!1&&n.server_no_context_takeover||n.server_max_window_bits&&(i.serverMaxWindowBits===!1||typeof i.serverMaxWindowBits=="number"&&i.serverMaxWindowBits>n.server_max_window_bits)||typeof i.clientMaxWindowBits=="number"&&!n.client_max_window_bits));if(!r)throw new Error("None of the extension offers can be accepted");return i.serverNoContextTakeover&&(r.server_no_context_takeover=!0),i.clientNoContextTakeover&&(r.client_no_context_takeover=!0),typeof i.serverMaxWindowBits=="number"&&(r.server_max_window_bits=i.serverMaxWindowBits),typeof i.clientMaxWindowBits=="number"?r.client_max_window_bits=i.clientMaxWindowBits:(r.client_max_window_bits===!0||i.clientMaxWindowBits===!1)&&delete r.client_max_window_bits,r}acceptAsClient(e){let i=e[0];if(this._options.clientNoContextTakeover===!1&&i.client_no_context_takeover)throw new Error('Unexpected parameter "client_no_context_takeover"');if(!i.client_max_window_bits)typeof this._options.clientMaxWindowBits=="number"&&(i.client_max_window_bits=this._options.clientMaxWindowBits);else if(this._options.clientMaxWindowBits===!1||typeof this._options.clientMaxWindowBits=="number"&&i.client_max_window_bits>this._options.clientMaxWindowBits)throw new Error('Unexpected or invalid parameter "client_max_window_bits"');return i}normalizeParams(e){return e.forEach(i=>{Object.keys(i).forEach(r=>{let n=i[r];if(n.length>1)throw new Error(`Parameter "${r}" must have only a single value`);if(n=n[0],r==="client_max_window_bits"){if(n!==!0){let s=+n;if(!Number.isInteger(s)||s<8||s>15)throw new TypeError(`Invalid value for parameter "${r}": ${n}`);n=s}else if(!this._isServer)throw new TypeError(`Invalid value for parameter "${r}": ${n}`)}else if(r==="server_max_window_bits"){let s=+n;if(!Number.isInteger(s)||s<8||s>15)throw new TypeError(`Invalid value for parameter "${r}": ${n}`);n=s}else if(r==="client_no_context_takeover"||r==="server_no_context_takeover"){if(n!==!0)throw new TypeError(`Invalid value for parameter "${r}": ${n}`)}else throw new Error(`Unknown parameter "${r}"`);i[r]=n})}),e}decompress(e,i,r){zr.add(n=>{this._decompress(e,i,(s,o)=>{n(),r(s,o)})})}compress(e,i,r){zr.add(n=>{this._compress(e,i,(s,o)=>{n(),r(s,o)})})}_decompress(e,i,r){let n=this._isServer?"client":"server";if(!this._inflate){let s=`${n}_max_window_bits`,o=typeof this.params[s]!="number"?tr.Z_DEFAULT_WINDOWBITS:this.params[s];this._inflate=tr.createInflateRaw({...this._options.zlibInflateOptions,windowBits:o}),this._inflate[Yr]=this,this._inflate[dt]=0,this._inflate[It]=[],this._inflate.on("error",Mg),this._inflate.on("data",xf)}this._inflate[ir]=r,this._inflate.write(e),i&&this._inflate.write(Pg),this._inflate.flush(()=>{let s=this._inflate[Wr];if(s){this._inflate.close(),this._inflate=null,r(s);return}let o=vf.concat(this._inflate[It],this._inflate[dt]);this._inflate._readableState.endEmitted?(this._inflate.close(),this._inflate=null):(this._inflate[dt]=0,this._inflate[It]=[],i&&this.params[`${n}_no_context_takeover`]&&this._inflate.reset()),r(null,o)})}_compress(e,i,r){let n=this._isServer?"server":"client";if(!this._deflate){let s=`${n}_max_window_bits`,o=typeof this.params[s]!="number"?tr.Z_DEFAULT_WINDOWBITS:this.params[s];this._deflate=tr.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits:o}),this._deflate[dt]=0,this._deflate[It]=[],this._deflate.on("data",Fg)}this._deflate[ir]=r,this._deflate.write(e),this._deflate.flush(tr.Z_SYNC_FLUSH,()=>{if(!this._deflate)return;let s=vf.concat(this._deflate[It],this._deflate[dt]);i&&(s=s.slice(0,s.length-4)),this._deflate[ir]=null,this._deflate[dt]=0,this._deflate[It]=[],i&&this.params[`${n}_no_context_takeover`]&&this._deflate.reset(),r(null,s)})}};yf.exports=Js;function Fg(t){this[It].push(t),this[dt]+=t.length}function xf(t){if(this[dt]+=t.length,this[Yr]._maxPayload<1||this[dt]<=this[Yr]._maxPayload){this[It].push(t);return}this[Wr]=new RangeError("Max payload size exceeded"),this[Wr].code="WS_ERR_UNSUPPORTED_MESSAGE_LENGTH",this[Wr][_f]=1009,this.removeListener("data",xf),this.reset()}function Mg(t){this[Yr]._inflate=null,t[_f]=1007,this[ir](t)}});var nr=x((Qx,eo)=>{"use strict";var bf=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function wf(t){return t>=1e3&&t<=1014&&t!==1004&&t!==1005&&t!==1006||t>=3e3&&t<=4999}function Ef(t){let e=t.length,i=0;for(;i<e;)if((t[i]&128)===0)i++;else if((t[i]&224)===192){if(i+1===e||(t[i+1]&192)!==128||(t[i]&254)===192)return!1;i+=2}else if((t[i]&240)===224){if(i+2>=e||(t[i+1]&192)!==128||(t[i+2]&192)!==128||t[i]===224&&(t[i+1]&224)===128||t[i]===237&&(t[i+1]&224)===160)return!1;i+=3}else if((t[i]&248)===240){if(i+3>=e||(t[i+1]&192)!==128||(t[i+2]&192)!==128||(t[i+3]&192)!==128||t[i]===240&&(t[i+1]&240)===128||t[i]===244&&t[i+1]>143||t[i]>244)return!1;i+=4}else return!1;return!0}try{let t=__nccwpck_require__(4592);eo.exports={isValidStatusCode:wf,isValidUTF8(e){return e.length<150?Ef(e):t(e)},tokenChars:bf}}catch{eo.exports={isValidStatusCode:wf,isValidUTF8:Ef,tokenChars:bf}}});var no=x((Jx,Af)=>{"use strict";var{Writable:Ug}=__nccwpck_require__(2781),Sf=rr(),{BINARY_TYPES:Dg,EMPTY_BUFFER:kf,kStatusCode:jg,kWebSocket:qg}=Ot(),{concat:to,toArrayBuffer:Hg,unmask:Vg}=er(),{isValidStatusCode:$g,isValidUTF8:Cf}=nr(),sr=0,Of=1,If=2,Tf=3,io=4,Gg=5,ro=class extends Ug{constructor(e={}){super(),this._binaryType=e.binaryType||Dg[0],this._extensions=e.extensions||{},this._isServer=!!e.isServer,this._maxPayload=e.maxPayload|0,this._skipUTF8Validation=!!e.skipUTF8Validation,this[qg]=void 0,this._bufferedBytes=0,this._buffers=[],this._compressed=!1,this._payloadLength=0,this._mask=void 0,this._fragmented=0,this._masked=!1,this._fin=!1,this._opcode=0,this._totalPayloadLength=0,this._messageLength=0,this._fragments=[],this._state=sr,this._loop=!1}_write(e,i,r){if(this._opcode===8&&this._state==sr)return r();this._bufferedBytes+=e.length,this._buffers.push(e),this.startLoop(r)}consume(e){if(this._bufferedBytes-=e,e===this._buffers[0].length)return this._buffers.shift();if(e<this._buffers[0].length){let r=this._buffers[0];return this._buffers[0]=r.slice(e),r.slice(0,e)}let i=Buffer.allocUnsafe(e);do{let r=this._buffers[0],n=i.length-e;e>=r.length?i.set(this._buffers.shift(),n):(i.set(new Uint8Array(r.buffer,r.byteOffset,e),n),this._buffers[0]=r.slice(e)),e-=r.length}while(e>0);return i}startLoop(e){let i;this._loop=!0;do switch(this._state){case sr:i=this.getInfo();break;case Of:i=this.getPayloadLength16();break;case If:i=this.getPayloadLength64();break;case Tf:this.getMask();break;case io:i=this.getData(e);break;default:this._loop=!1;return}while(this._loop);e(i)}getInfo(){if(this._bufferedBytes<2){this._loop=!1;return}let e=this.consume(2);if((e[0]&48)!==0)return this._loop=!1,Be(RangeError,"RSV2 and RSV3 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_2_3");let i=(e[0]&64)===64;if(i&&!this._extensions[Sf.extensionName])return this._loop=!1,Be(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._fin=(e[0]&128)===128,this._opcode=e[0]&15,this._payloadLength=e[1]&127,this._opcode===0){if(i)return this._loop=!1,Be(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(!this._fragmented)return this._loop=!1,Be(RangeError,"invalid opcode 0",!0,1002,"WS_ERR_INVALID_OPCODE");this._opcode=this._fragmented}else if(this._opcode===1||this._opcode===2){if(this._fragmented)return this._loop=!1,Be(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");this._compressed=i}else if(this._opcode>7&&this._opcode<11){if(!this._fin)return this._loop=!1,Be(RangeError,"FIN must be set",!0,1002,"WS_ERR_EXPECTED_FIN");if(i)return this._loop=!1,Be(RangeError,"RSV1 must be clear",!0,1002,"WS_ERR_UNEXPECTED_RSV_1");if(this._payloadLength>125)return this._loop=!1,Be(RangeError,`invalid payload length ${this._payloadLength}`,!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH")}else return this._loop=!1,Be(RangeError,`invalid opcode ${this._opcode}`,!0,1002,"WS_ERR_INVALID_OPCODE");if(!this._fin&&!this._fragmented&&(this._fragmented=this._opcode),this._masked=(e[1]&128)===128,this._isServer){if(!this._masked)return this._loop=!1,Be(RangeError,"MASK must be set",!0,1002,"WS_ERR_EXPECTED_MASK")}else if(this._masked)return this._loop=!1,Be(RangeError,"MASK must be clear",!0,1002,"WS_ERR_UNEXPECTED_MASK");if(this._payloadLength===126)this._state=Of;else if(this._payloadLength===127)this._state=If;else return this.haveLength()}getPayloadLength16(){if(this._bufferedBytes<2){this._loop=!1;return}return this._payloadLength=this.consume(2).readUInt16BE(0),this.haveLength()}getPayloadLength64(){if(this._bufferedBytes<8){this._loop=!1;return}let e=this.consume(8),i=e.readUInt32BE(0);return i>Math.pow(2,53-32)-1?(this._loop=!1,Be(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",!1,1009,"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH")):(this._payloadLength=i*Math.pow(2,32)+e.readUInt32BE(4),this.haveLength())}haveLength(){if(this._payloadLength&&this._opcode<8&&(this._totalPayloadLength+=this._payloadLength,this._totalPayloadLength>this._maxPayload&&this._maxPayload>0))return this._loop=!1,Be(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");this._masked?this._state=Tf:this._state=io}getMask(){if(this._bufferedBytes<4){this._loop=!1;return}this._mask=this.consume(4),this._state=io}getData(e){let i=kf;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength){this._loop=!1;return}i=this.consume(this._payloadLength),this._masked&&(this._mask[0]|this._mask[1]|this._mask[2]|this._mask[3])!==0&&Vg(i,this._mask)}if(this._opcode>7)return this.controlMessage(i);if(this._compressed){this._state=Gg,this.decompress(i,e);return}return i.length&&(this._messageLength=this._totalPayloadLength,this._fragments.push(i)),this.dataMessage()}decompress(e,i){this._extensions[Sf.extensionName].decompress(e,this._fin,(n,s)=>{if(n)return i(n);if(s.length){if(this._messageLength+=s.length,this._messageLength>this._maxPayload&&this._maxPayload>0)return i(Be(RangeError,"Max payload size exceeded",!1,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));this._fragments.push(s)}let o=this.dataMessage();if(o)return i(o);this.startLoop(i)})}dataMessage(){if(this._fin){let e=this._messageLength,i=this._fragments;if(this._totalPayloadLength=0,this._messageLength=0,this._fragmented=0,this._fragments=[],this._opcode===2){let r;this._binaryType==="nodebuffer"?r=to(i,e):this._binaryType==="arraybuffer"?r=Hg(to(i,e)):r=i,this.emit("message",r,!0)}else{let r=to(i,e);if(!this._skipUTF8Validation&&!Cf(r))return this._loop=!1,Be(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("message",r,!1)}}this._state=sr}controlMessage(e){if(this._opcode===8)if(this._loop=!1,e.length===0)this.emit("conclude",1005,kf),this.end();else{if(e.length===1)return Be(RangeError,"invalid payload length 1",!0,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");{let i=e.readUInt16BE(0);if(!$g(i))return Be(RangeError,`invalid status code ${i}`,!0,1002,"WS_ERR_INVALID_CLOSE_CODE");let r=e.slice(2);if(!this._skipUTF8Validation&&!Cf(r))return Be(Error,"invalid UTF-8 sequence",!0,1007,"WS_ERR_INVALID_UTF8");this.emit("conclude",i,r),this.end()}}else this._opcode===9?this.emit("ping",e):this.emit("pong",e);this._state=sr}};Af.exports=ro;function Be(t,e,i,r,n){let s=new t(i?`Invalid WebSocket frame: ${e}`:e);return Error.captureStackTrace(s,Be),s.code=n,s[jg]=r,s}});var so=x((iy,Lf)=>{"use strict";var ey=__nccwpck_require__(1808),ty=__nccwpck_require__(4404),{randomFillSync:zg}=__nccwpck_require__(6113),Rf=rr(),{EMPTY_BUFFER:Wg}=Ot(),{isValidStatusCode:Yg}=nr(),{mask:Bf,toBuffer:Ei}=er(),ot=Symbol("kByteLength"),Kg=Buffer.alloc(4),ct=class{constructor(e,i,r){this._extensions=i||{},r&&(this._generateMask=r,this._maskBuffer=Buffer.alloc(4)),this._socket=e,this._firstFragment=!0,this._compress=!1,this._bufferedBytes=0,this._deflating=!1,this._queue=[]}static frame(e,i){let r,n=!1,s=2,o=!1;i.mask&&(r=i.maskBuffer||Kg,i.generateMask?i.generateMask(r):zg(r,0,4),o=(r[0]|r[1]|r[2]|r[3])===0,s=6);let a;typeof e=="string"?(!i.mask||o)&&i[ot]!==void 0?a=i[ot]:(e=Buffer.from(e),a=e.length):(a=e.length,n=i.mask&&i.readOnly&&!o);let l=a;a>=65536?(s+=8,l=127):a>125&&(s+=2,l=126);let c=Buffer.allocUnsafe(n?a+s:s);return c[0]=i.fin?i.opcode|128:i.opcode,i.rsv1&&(c[0]|=64),c[1]=l,l===126?c.writeUInt16BE(a,2):l===127&&(c[2]=c[3]=0,c.writeUIntBE(a,4,6)),i.mask?(c[1]|=128,c[s-4]=r[0],c[s-3]=r[1],c[s-2]=r[2],c[s-1]=r[3],o?[c,e]:n?(Bf(e,r,c,s,a),[c]):(Bf(e,r,e,0,a),[c,e])):[c,e]}close(e,i,r,n){let s;if(e===void 0)s=Wg;else{if(typeof e!="number"||!Yg(e))throw new TypeError("First argument must be a valid error code number");if(i===void 0||!i.length)s=Buffer.allocUnsafe(2),s.writeUInt16BE(e,0);else{let a=Buffer.byteLength(i);if(a>123)throw new RangeError("The message must not be greater than 123 bytes");s=Buffer.allocUnsafe(2+a),s.writeUInt16BE(e,0),typeof i=="string"?s.write(i,2):s.set(i,2)}}let o={[ot]:s.length,fin:!0,generateMask:this._generateMask,mask:r,maskBuffer:this._maskBuffer,opcode:8,readOnly:!1,rsv1:!1};this._deflating?this.enqueue([this.dispatch,s,!1,o,n]):this.sendFrame(ct.frame(s,o),n)}ping(e,i,r){let n,s;if(typeof e=="string"?(n=Buffer.byteLength(e),s=!1):(e=Ei(e),n=e.length,s=Ei.readOnly),n>125)throw new RangeError("The data size must not be greater than 125 bytes");let o={[ot]:n,fin:!0,generateMask:this._generateMask,mask:i,maskBuffer:this._maskBuffer,opcode:9,readOnly:s,rsv1:!1};this._deflating?this.enqueue([this.dispatch,e,!1,o,r]):this.sendFrame(ct.frame(e,o),r)}pong(e,i,r){let n,s;if(typeof e=="string"?(n=Buffer.byteLength(e),s=!1):(e=Ei(e),n=e.length,s=Ei.readOnly),n>125)throw new RangeError("The data size must not be greater than 125 bytes");let o={[ot]:n,fin:!0,generateMask:this._generateMask,mask:i,maskBuffer:this._maskBuffer,opcode:10,readOnly:s,rsv1:!1};this._deflating?this.enqueue([this.dispatch,e,!1,o,r]):this.sendFrame(ct.frame(e,o),r)}send(e,i,r){let n=this._extensions[Rf.extensionName],s=i.binary?2:1,o=i.compress,a,l;if(typeof e=="string"?(a=Buffer.byteLength(e),l=!1):(e=Ei(e),a=e.length,l=Ei.readOnly),this._firstFragment?(this._firstFragment=!1,o&&n&&n.params[n._isServer?"server_no_context_takeover":"client_no_context_takeover"]&&(o=a>=n._threshold),this._compress=o):(o=!1,s=0),i.fin&&(this._firstFragment=!0),n){let c={[ot]:a,fin:i.fin,generateMask:this._generateMask,mask:i.mask,maskBuffer:this._maskBuffer,opcode:s,readOnly:l,rsv1:o};this._deflating?this.enqueue([this.dispatch,e,this._compress,c,r]):this.dispatch(e,this._compress,c,r)}else this.sendFrame(ct.frame(e,{[ot]:a,fin:i.fin,generateMask:this._generateMask,mask:i.mask,maskBuffer:this._maskBuffer,opcode:s,readOnly:l,rsv1:!1}),r)}dispatch(e,i,r,n){if(!i){this.sendFrame(ct.frame(e,r),n);return}let s=this._extensions[Rf.extensionName];this._bufferedBytes+=r[ot],this._deflating=!0,s.compress(e,r.fin,(o,a)=>{if(this._socket.destroyed){let l=new Error("The socket was closed while data was being compressed");typeof n=="function"&&n(l);for(let c=0;c<this._queue.length;c++){let u=this._queue[c],f=u[u.length-1];typeof f=="function"&&f(l)}return}this._bufferedBytes-=r[ot],this._deflating=!1,r.readOnly=!1,this.sendFrame(ct.frame(a,r),n),this.dequeue()})}dequeue(){for(;!this._deflating&&this._queue.length;){let e=this._queue.shift();this._bufferedBytes-=e[3][ot],Reflect.apply(e[0],this,e.slice(1))}}enqueue(e){this._bufferedBytes+=e[3][ot],this._queue.push(e)}sendFrame(e,i){e.length===2?(this._socket.cork(),this._socket.write(e[0]),this._socket.write(e[1],i),this._socket.uncork()):this._socket.write(e[0],i)}};Lf.exports=ct});var Vf=x((ry,Hf)=>{"use strict";var{kForOnEventAttribute:oo,kListener:Nf}=Ot(),Pf=Symbol("kCode"),Ff=Symbol("kData"),Mf=Symbol("kError"),Uf=Symbol("kMessage"),Df=Symbol("kReason"),Si=Symbol("kTarget"),jf=Symbol("kType"),qf=Symbol("kWasClean"),mt=class{constructor(e){this[Si]=null,this[jf]=e}get target(){return this[Si]}get type(){return this[jf]}};Object.defineProperty(mt.prototype,"target",{enumerable:!0});Object.defineProperty(mt.prototype,"type",{enumerable:!0});var Wt=class extends mt{constructor(e,i={}){super(e),this[Pf]=i.code===void 0?0:i.code,this[Df]=i.reason===void 0?"":i.reason,this[qf]=i.wasClean===void 0?!1:i.wasClean}get code(){return this[Pf]}get reason(){return this[Df]}get wasClean(){return this[qf]}};Object.defineProperty(Wt.prototype,"code",{enumerable:!0});Object.defineProperty(Wt.prototype,"reason",{enumerable:!0});Object.defineProperty(Wt.prototype,"wasClean",{enumerable:!0});var ki=class extends mt{constructor(e,i={}){super(e),this[Mf]=i.error===void 0?null:i.error,this[Uf]=i.message===void 0?"":i.message}get error(){return this[Mf]}get message(){return this[Uf]}};Object.defineProperty(ki.prototype,"error",{enumerable:!0});Object.defineProperty(ki.prototype,"message",{enumerable:!0});var or=class extends mt{constructor(e,i={}){super(e),this[Ff]=i.data===void 0?null:i.data}get data(){return this[Ff]}};Object.defineProperty(or.prototype,"data",{enumerable:!0});var Zg={addEventListener(t,e,i={}){let r;if(t==="message")r=function(s,o){let a=new or("message",{data:o?s:s.toString()});a[Si]=this,e.call(this,a)};else if(t==="close")r=function(s,o){let a=new Wt("close",{code:s,reason:o.toString(),wasClean:this._closeFrameReceived&&this._closeFrameSent});a[Si]=this,e.call(this,a)};else if(t==="error")r=function(s){let o=new ki("error",{error:s,message:s.message});o[Si]=this,e.call(this,o)};else if(t==="open")r=function(){let s=new mt("open");s[Si]=this,e.call(this,s)};else return;r[oo]=!!i[oo],r[Nf]=e,i.once?this.once(t,r):this.on(t,r)},removeEventListener(t,e){for(let i of this.listeners(t))if(i[Nf]===e&&!i[oo]){this.removeListener(t,i);break}}};Hf.exports={CloseEvent:Wt,ErrorEvent:ki,Event:mt,EventTarget:Zg,MessageEvent:or}});var ao=x((ny,$f)=>{"use strict";var{tokenChars:ar}=nr();function ut(t,e,i){t[e]===void 0?t[e]=[i]:t[e].push(i)}function Xg(t){let e=Object.create(null),i=Object.create(null),r=!1,n=!1,s=!1,o,a,l=-1,c=-1,u=-1,f=0;for(;f<t.length;f++)if(c=t.charCodeAt(f),o===void 0)if(u===-1&&ar[c]===1)l===-1&&(l=f);else if(f!==0&&(c===32||c===9))u===-1&&l!==-1&&(u=f);else if(c===59||c===44){if(l===-1)throw new SyntaxError(`Unexpected character at index ${f}`);u===-1&&(u=f);let p=t.slice(l,u);c===44?(ut(e,p,i),i=Object.create(null)):o=p,l=u=-1}else throw new SyntaxError(`Unexpected character at index ${f}`);else if(a===void 0)if(u===-1&&ar[c]===1)l===-1&&(l=f);else if(c===32||c===9)u===-1&&l!==-1&&(u=f);else if(c===59||c===44){if(l===-1)throw new SyntaxError(`Unexpected character at index ${f}`);u===-1&&(u=f),ut(i,t.slice(l,u),!0),c===44&&(ut(e,o,i),i=Object.create(null),o=void 0),l=u=-1}else if(c===61&&l!==-1&&u===-1)a=t.slice(l,f),l=u=-1;else throw new SyntaxError(`Unexpected character at index ${f}`);else if(n){if(ar[c]!==1)throw new SyntaxError(`Unexpected character at index ${f}`);l===-1?l=f:r||(r=!0),n=!1}else if(s)if(ar[c]===1)l===-1&&(l=f);else if(c===34&&l!==-1)s=!1,u=f;else if(c===92)n=!0;else throw new SyntaxError(`Unexpected character at index ${f}`);else if(c===34&&t.charCodeAt(f-1)===61)s=!0;else if(u===-1&&ar[c]===1)l===-1&&(l=f);else if(l!==-1&&(c===32||c===9))u===-1&&(u=f);else if(c===59||c===44){if(l===-1)throw new SyntaxError(`Unexpected character at index ${f}`);u===-1&&(u=f);let p=t.slice(l,u);r&&(p=p.replace(/\\/g,""),r=!1),ut(i,a,p),c===44&&(ut(e,o,i),i=Object.create(null),o=void 0),a=void 0,l=u=-1}else throw new SyntaxError(`Unexpected character at index ${f}`);if(l===-1||s||c===32||c===9)throw new SyntaxError("Unexpected end of input");u===-1&&(u=f);let h=t.slice(l,u);return o===void 0?ut(e,h,i):(a===void 0?ut(i,h,!0):r?ut(i,a,h.replace(/\\/g,"")):ut(i,a,h),ut(e,o,i)),e}function Qg(t){return Object.keys(t).map(e=>{let i=t[e];return Array.isArray(i)||(i=[i]),i.map(r=>[e].concat(Object.keys(r).map(n=>{let s=r[n];return Array.isArray(s)||(s=[s]),s.map(o=>o===!0?n:`${n}=${o}`).join("; ")})).join("; ")).join(", ")}).join(", ")}$f.exports={format:Qg,parse:Xg}});var po=x((oy,eh)=>{"use strict";var Jg=__nccwpck_require__(2361),ev=__nccwpck_require__(5687),tv=__nccwpck_require__(3685),Wf=__nccwpck_require__(1808),iv=__nccwpck_require__(4404),{randomBytes:rv,createHash:nv}=__nccwpck_require__(6113),{Readable:sy}=__nccwpck_require__(2781),{URL:lo}=__nccwpck_require__(7310),Tt=rr(),sv=no(),ov=so(),{BINARY_TYPES:Gf,EMPTY_BUFFER:Kr,GUID:av,kForOnEventAttribute:co,kListener:lv,kStatusCode:cv,kWebSocket:He,NOOP:Yf}=Ot(),{EventTarget:{addEventListener:uv,removeEventListener:fv}}=Vf(),{format:hv,parse:pv}=ao(),{toBuffer:dv}=er(),gt=["CONNECTING","OPEN","CLOSING","CLOSED"],mv=/^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/,uo=[8,13],gv=30*1e3,X=class extends Jg{constructor(e,i,r){super(),this._binaryType=Gf[0],this._closeCode=1006,this._closeFrameReceived=!1,this._closeFrameSent=!1,this._closeMessage=Kr,this._closeTimer=null,this._extensions={},this._paused=!1,this._protocol="",this._readyState=X.CONNECTING,this._receiver=null,this._sender=null,this._socket=null,e!==null?(this._bufferedAmount=0,this._isServer=!1,this._redirects=0,i===void 0?i=[]:Array.isArray(i)||(typeof i=="object"&&i!==null?(r=i,i=[]):i=[i]),Kf(this,e,i,r)):this._isServer=!0}get binaryType(){return this._binaryType}set binaryType(e){!Gf.includes(e)||(this._binaryType=e,this._receiver&&(this._receiver._binaryType=e))}get bufferedAmount(){return this._socket?this._socket._writableState.length+this._sender._bufferedBytes:this._bufferedAmount}get extensions(){return Object.keys(this._extensions).join()}get isPaused(){return this._paused}get onclose(){return null}get onerror(){return null}get onopen(){return null}get onmessage(){return null}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket(e,i,r){let n=new sv({binaryType:this.binaryType,extensions:this._extensions,isServer:this._isServer,maxPayload:r.maxPayload,skipUTF8Validation:r.skipUTF8Validation});this._sender=new ov(e,this._extensions,r.generateMask),this._receiver=n,this._socket=e,n[He]=this,e[He]=this,n.on("conclude",xv),n.on("drain",yv),n.on("error",bv),n.on("message",wv),n.on("ping",Ev),n.on("pong",Sv),e.setTimeout(0),e.setNoDelay(),i.length>0&&e.unshift(i),e.on("close",Xf),e.on("data",Zr),e.on("end",Qf),e.on("error",Jf),this._readyState=X.OPEN,this.emit("open")}emitClose(){if(!this._socket){this._readyState=X.CLOSED,this.emit("close",this._closeCode,this._closeMessage);return}this._extensions[Tt.extensionName]&&this._extensions[Tt.extensionName].cleanup(),this._receiver.removeAllListeners(),this._readyState=X.CLOSED,this.emit("close",this._closeCode,this._closeMessage)}close(e,i){if(this.readyState!==X.CLOSED){if(this.readyState===X.CONNECTING){let r="WebSocket was closed before the connection was established";return et(this,this._req,r)}if(this.readyState===X.CLOSING){this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end();return}this._readyState=X.CLOSING,this._sender.close(e,i,!this._isServer,r=>{r||(this._closeFrameSent=!0,(this._closeFrameReceived||this._receiver._writableState.errorEmitted)&&this._socket.end())}),this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),gv)}}pause(){this.readyState===X.CONNECTING||this.readyState===X.CLOSED||(this._paused=!0,this._socket.pause())}ping(e,i,r){if(this.readyState===X.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof e=="function"?(r=e,e=i=void 0):typeof i=="function"&&(r=i,i=void 0),typeof e=="number"&&(e=e.toString()),this.readyState!==X.OPEN){ho(this,e,r);return}i===void 0&&(i=!this._isServer),this._sender.ping(e||Kr,i,r)}pong(e,i,r){if(this.readyState===X.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof e=="function"?(r=e,e=i=void 0):typeof i=="function"&&(r=i,i=void 0),typeof e=="number"&&(e=e.toString()),this.readyState!==X.OPEN){ho(this,e,r);return}i===void 0&&(i=!this._isServer),this._sender.pong(e||Kr,i,r)}resume(){this.readyState===X.CONNECTING||this.readyState===X.CLOSED||(this._paused=!1,this._receiver._writableState.needDrain||this._socket.resume())}send(e,i,r){if(this.readyState===X.CONNECTING)throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");if(typeof i=="function"&&(r=i,i={}),typeof e=="number"&&(e=e.toString()),this.readyState!==X.OPEN){ho(this,e,r);return}let n={binary:typeof e!="string",mask:!this._isServer,compress:!0,fin:!0,...i};this._extensions[Tt.extensionName]||(n.compress=!1),this._sender.send(e||Kr,n,r)}terminate(){if(this.readyState!==X.CLOSED){if(this.readyState===X.CONNECTING){let e="WebSocket was closed before the connection was established";return et(this,this._req,e)}this._socket&&(this._readyState=X.CLOSING,this._socket.destroy())}}};Object.defineProperty(X,"CONNECTING",{enumerable:!0,value:gt.indexOf("CONNECTING")});Object.defineProperty(X.prototype,"CONNECTING",{enumerable:!0,value:gt.indexOf("CONNECTING")});Object.defineProperty(X,"OPEN",{enumerable:!0,value:gt.indexOf("OPEN")});Object.defineProperty(X.prototype,"OPEN",{enumerable:!0,value:gt.indexOf("OPEN")});Object.defineProperty(X,"CLOSING",{enumerable:!0,value:gt.indexOf("CLOSING")});Object.defineProperty(X.prototype,"CLOSING",{enumerable:!0,value:gt.indexOf("CLOSING")});Object.defineProperty(X,"CLOSED",{enumerable:!0,value:gt.indexOf("CLOSED")});Object.defineProperty(X.prototype,"CLOSED",{enumerable:!0,value:gt.indexOf("CLOSED")});["binaryType","bufferedAmount","extensions","isPaused","protocol","readyState","url"].forEach(t=>{Object.defineProperty(X.prototype,t,{enumerable:!0})});["open","error","close","message"].forEach(t=>{Object.defineProperty(X.prototype,`on${t}`,{enumerable:!0,get(){for(let e of this.listeners(t))if(e[co])return e[lv];return null},set(e){for(let i of this.listeners(t))if(i[co]){this.removeListener(t,i);break}typeof e=="function"&&this.addEventListener(t,e,{[co]:!0})}})});X.prototype.addEventListener=uv;X.prototype.removeEventListener=fv;eh.exports=X;function Kf(t,e,i,r){let n={protocolVersion:uo[1],maxPayload:104857600,skipUTF8Validation:!1,perMessageDeflate:!0,followRedirects:!1,maxRedirects:10,...r,createConnection:void 0,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:void 0,host:void 0,path:void 0,port:void 0};if(!uo.includes(n.protocolVersion))throw new RangeError(`Unsupported protocol version: ${n.protocolVersion} (supported versions: ${uo.join(", ")})`);let s;if(e instanceof lo)s=e,t._url=e.href;else{try{s=new lo(e)}catch{throw new SyntaxError(`Invalid URL: ${e}`)}t._url=e}let o=s.protocol==="wss:",a=s.protocol==="ws+unix:",l;if(s.protocol!=="ws:"&&!o&&!a?l=`The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`:a&&!s.pathname?l="The URL's pathname is empty":s.hash&&(l="The URL contains a fragment identifier"),l){let m=new SyntaxError(l);if(t._redirects===0)throw m;fo(t,m);return}let c=o?443:80,u=rv(16).toString("base64"),f=o?ev.get:tv.get,h=new Set,p;if(n.createConnection=o?_v:vv,n.defaultPort=n.defaultPort||c,n.port=s.port||c,n.host=s.hostname.startsWith("[")?s.hostname.slice(1,-1):s.hostname,n.headers={"Sec-WebSocket-Version":n.protocolVersion,"Sec-WebSocket-Key":u,Connection:"Upgrade",Upgrade:"websocket",...n.headers},n.path=s.pathname+s.search,n.timeout=n.handshakeTimeout,n.perMessageDeflate&&(p=new Tt(n.perMessageDeflate!==!0?n.perMessageDeflate:{},!1,n.maxPayload),n.headers["Sec-WebSocket-Extensions"]=hv({[Tt.extensionName]:p.offer()})),i.length){for(let m of i){if(typeof m!="string"||!mv.test(m)||h.has(m))throw new SyntaxError("An invalid or duplicated subprotocol was specified");h.add(m)}n.headers["Sec-WebSocket-Protocol"]=i.join(",")}if(n.origin&&(n.protocolVersion<13?n.headers["Sec-WebSocket-Origin"]=n.origin:n.headers.Origin=n.origin),(s.username||s.password)&&(n.auth=`${s.username}:${s.password}`),a){let m=n.path.split(":");n.socketPath=m[0],n.path=m[1]}let d=t._req=f(n);n.timeout&&d.on("timeout",()=>{et(t,d,"Opening handshake has timed out")}),d.on("error",m=>{d===null||d.aborted||(d=t._req=null,fo(t,m))}),d.on("response",m=>{let g=m.headers.location,y=m.statusCode;if(g&&n.followRedirects&&y>=300&&y<400){if(++t._redirects>n.maxRedirects){et(t,d,"Maximum redirects exceeded");return}d.abort();let I;try{I=new lo(g,e)}catch{let S=new SyntaxError(`Invalid URL: ${g}`);fo(t,S);return}Kf(t,I,i,r)}else t.emit("unexpected-response",d,m)||et(t,d,`Unexpected server response: ${m.statusCode}`)}),d.on("upgrade",(m,g,y)=>{if(t.emit("upgrade",m),t.readyState!==X.CONNECTING)return;d=t._req=null;let I=nv("sha1").update(u+av).digest("base64");if(m.headers["sec-websocket-accept"]!==I){et(t,g,"Invalid Sec-WebSocket-Accept header");return}let w=m.headers["sec-websocket-protocol"],S;if(w!==void 0?h.size?h.has(w)||(S="Server sent an invalid subprotocol"):S="Server sent a subprotocol but none was requested":h.size&&(S="Server sent no subprotocol"),S){et(t,g,S);return}w&&(t._protocol=w);let b=m.headers["sec-websocket-extensions"];if(b!==void 0){if(!p){et(t,g,"Server sent a Sec-WebSocket-Extensions header but no extension was requested");return}let $;try{$=pv(b)}catch{et(t,g,"Invalid Sec-WebSocket-Extensions header");return}let C=Object.keys($);if(C.length!==1||C[0]!==Tt.extensionName){et(t,g,"Server indicated an extension that was not requested");return}try{p.accept($[Tt.extensionName])}catch{et(t,g,"Invalid Sec-WebSocket-Extensions header");return}t._extensions[Tt.extensionName]=p}t.setSocket(g,y,{generateMask:n.generateMask,maxPayload:n.maxPayload,skipUTF8Validation:n.skipUTF8Validation})})}function fo(t,e){t._readyState=X.CLOSING,t.emit("error",e),t.emitClose()}function vv(t){return t.path=t.socketPath,Wf.connect(t)}function _v(t){return t.path=void 0,!t.servername&&t.servername!==""&&(t.servername=Wf.isIP(t.host)?"":t.host),iv.connect(t)}function et(t,e,i){t._readyState=X.CLOSING;let r=new Error(i);Error.captureStackTrace(r,et),e.setHeader?(e.abort(),e.socket&&!e.socket.destroyed&&e.socket.destroy(),e.once("abort",t.emitClose.bind(t)),t.emit("error",r)):(e.destroy(r),e.once("error",t.emit.bind(t,"error")),e.once("close",t.emitClose.bind(t)))}function ho(t,e,i){if(e){let r=dv(e).length;t._socket?t._sender._bufferedBytes+=r:t._bufferedAmount+=r}if(i){let r=new Error(`WebSocket is not open: readyState ${t.readyState} (${gt[t.readyState]})`);i(r)}}function xv(t,e){let i=this[He];i._closeFrameReceived=!0,i._closeMessage=e,i._closeCode=t,i._socket[He]!==void 0&&(i._socket.removeListener("data",Zr),process.nextTick(Zf,i._socket),t===1005?i.close():i.close(t,e))}function yv(){let t=this[He];t.isPaused||t._socket.resume()}function bv(t){let e=this[He];e._socket[He]!==void 0&&(e._socket.removeListener("data",Zr),process.nextTick(Zf,e._socket),e.close(t[cv])),e.emit("error",t)}function zf(){this[He].emitClose()}function wv(t,e){this[He].emit("message",t,e)}function Ev(t){let e=this[He];e.pong(t,!e._isServer,Yf),e.emit("ping",t)}function Sv(t){this[He].emit("pong",t)}function Zf(t){t.resume()}function Xf(){let t=this[He];this.removeListener("close",Xf),this.removeListener("data",Zr),this.removeListener("end",Qf),t._readyState=X.CLOSING;let e;!this._readableState.endEmitted&&!t._closeFrameReceived&&!t._receiver._writableState.errorEmitted&&(e=t._socket.read())!==null&&t._receiver.write(e),t._receiver.end(),this[He]=void 0,clearTimeout(t._closeTimer),t._receiver._writableState.finished||t._receiver._writableState.errorEmitted?t.emitClose():(t._receiver.on("error",zf),t._receiver.on("finish",zf))}function Zr(t){this[He]._receiver.write(t)||this.pause()}function Qf(){let t=this[He];t._readyState=X.CLOSING,t._receiver.end(),this.end()}function Jf(){let t=this[He];this.removeListener("error",Jf),this.on("error",Yf),t&&(t._readyState=X.CLOSING,this.destroy())}});var ih=x((ay,th)=>{"use strict";var{tokenChars:kv}=nr();function Cv(t){let e=new Set,i=-1,r=-1,n=0;for(n;n<t.length;n++){let o=t.charCodeAt(n);if(r===-1&&kv[o]===1)i===-1&&(i=n);else if(n!==0&&(o===32||o===9))r===-1&&i!==-1&&(r=n);else if(o===44){if(i===-1)throw new SyntaxError(`Unexpected character at index ${n}`);r===-1&&(r=n);let a=t.slice(i,r);if(e.has(a))throw new SyntaxError(`The "${a}" subprotocol is duplicated`);e.add(a),i=r=-1}else throw new SyntaxError(`Unexpected character at index ${n}`)}if(i===-1||r!==-1)throw new SyntaxError("Unexpected end of input");let s=t.slice(i,n);if(e.has(s))throw new SyntaxError(`The "${s}" subprotocol is duplicated`);return e.add(s),e}th.exports={parse:Cv}});var lh=x((fy,ah)=>{"use strict";var Ov=__nccwpck_require__(2361),Xr=__nccwpck_require__(3685),ly=__nccwpck_require__(5687),cy=__nccwpck_require__(1808),uy=__nccwpck_require__(4404),{createHash:Iv}=__nccwpck_require__(6113),rh=ao(),Yt=rr(),Tv=ih(),Av=po(),{GUID:Rv,kWebSocket:Bv}=Ot(),Lv=/^[+/0-9A-Za-z]{22}==$/,nh=0,sh=1,oh=2,mo=class extends Ov{constructor(e,i){if(super(),e={maxPayload:100*1024*1024,skipUTF8Validation:!1,perMessageDeflate:!1,handleProtocols:null,clientTracking:!0,verifyClient:null,noServer:!1,backlog:null,server:null,host:null,path:null,port:null,...e},e.port==null&&!e.server&&!e.noServer||e.port!=null&&(e.server||e.noServer)||e.server&&e.noServer)throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');if(e.port!=null?(this._server=Xr.createServer((r,n)=>{let s=Xr.STATUS_CODES[426];n.writeHead(426,{"Content-Length":s.length,"Content-Type":"text/plain"}),n.end(s)}),this._server.listen(e.port,e.host,e.backlog,i)):e.server&&(this._server=e.server),this._server){let r=this.emit.bind(this,"connection");this._removeListeners=Nv(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(n,s,o)=>{this.handleUpgrade(n,s,o,r)}})}e.perMessageDeflate===!0&&(e.perMessageDeflate={}),e.clientTracking&&(this.clients=new Set,this._shouldEmitClose=!1),this.options=e,this._state=nh}address(){if(this.options.noServer)throw new Error('The server is operating in "noServer" mode');return this._server?this._server.address():null}close(e){if(this._state===oh){e&&this.once("close",()=>{e(new Error("The server is not running"))}),process.nextTick(lr,this);return}if(e&&this.once("close",e),this._state!==sh)if(this._state=sh,this.options.noServer||this.options.server)this._server&&(this._removeListeners(),this._removeListeners=this._server=null),this.clients?this.clients.size?this._shouldEmitClose=!0:process.nextTick(lr,this):process.nextTick(lr,this);else{let i=this._server;this._removeListeners(),this._removeListeners=this._server=null,i.close(()=>{lr(this)})}}shouldHandle(e){if(this.options.path){let i=e.url.indexOf("?");if((i!==-1?e.url.slice(0,i):e.url)!==this.options.path)return!1}return!0}handleUpgrade(e,i,r,n){i.on("error",go);let s=e.headers["sec-websocket-key"]!==void 0?e.headers["sec-websocket-key"]:!1,o=+e.headers["sec-websocket-version"];if(e.method!=="GET"||e.headers.upgrade.toLowerCase()!=="websocket"||!s||!Lv.test(s)||o!==8&&o!==13||!this.shouldHandle(e))return Ci(i,400);let a=e.headers["sec-websocket-protocol"],l=new Set;if(a!==void 0)try{l=Tv.parse(a)}catch{return Ci(i,400)}let c=e.headers["sec-websocket-extensions"],u={};if(this.options.perMessageDeflate&&c!==void 0){let f=new Yt(this.options.perMessageDeflate,!0,this.options.maxPayload);try{let h=rh.parse(c);h[Yt.extensionName]&&(f.accept(h[Yt.extensionName]),u[Yt.extensionName]=f)}catch{return Ci(i,400)}}if(this.options.verifyClient){let f={origin:e.headers[`${o===8?"sec-websocket-origin":"origin"}`],secure:!!(e.socket.authorized||e.socket.encrypted),req:e};if(this.options.verifyClient.length===2){this.options.verifyClient(f,(h,p,d,m)=>{if(!h)return Ci(i,p||401,d,m);this.completeUpgrade(u,s,l,e,i,r,n)});return}if(!this.options.verifyClient(f))return Ci(i,401)}this.completeUpgrade(u,s,l,e,i,r,n)}completeUpgrade(e,i,r,n,s,o,a){if(!s.readable||!s.writable)return s.destroy();if(s[Bv])throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");if(this._state>nh)return Ci(s,503);let l=Iv("sha1").update(i+Rv).digest("base64"),c=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${l}`],u=new Av(null);if(r.size){let f=this.options.handleProtocols?this.options.handleProtocols(r,n):r.values().next().value;f&&(c.push(`Sec-WebSocket-Protocol: ${f}`),u._protocol=f)}if(e[Yt.extensionName]){let f=e[Yt.extensionName].params,h=rh.format({[Yt.extensionName]:[f]});c.push(`Sec-WebSocket-Extensions: ${h}`),u._extensions=e}this.emit("headers",c,n),s.write(c.concat(`\r
`).join(`\r
`)),s.removeListener("error",go),u.setSocket(s,o,{maxPayload:this.options.maxPayload,skipUTF8Validation:this.options.skipUTF8Validation}),this.clients&&(this.clients.add(u),u.on("close",()=>{this.clients.delete(u),this._shouldEmitClose&&!this.clients.size&&process.nextTick(lr,this)})),a(u,n)}};ah.exports=mo;function Nv(t,e){for(let i of Object.keys(e))t.on(i,e[i]);return function(){for(let r of Object.keys(e))t.removeListener(r,e[r])}}function lr(t){t._state=oh,t.emit("close")}function go(){this.destroy()}function Ci(t,e,i,r){t.writable&&(i=i||Xr.STATUS_CODES[e],r={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(i),...r},t.write(`HTTP/1.1 ${e} ${Xr.STATUS_CODES[e]}\r
`+Object.keys(r).map(n=>`${n}: ${r[n]}`).join(`\r
`)+`\r
\r
`+i)),t.removeListener("error",go),t.destroy()}});var Zv={};Bh(Zv,{HttpsProxyAgent:()=>wh.HttpsProxyAgent,PNG:()=>Eh.PNG,SocksProxyAgent:()=>kh.SocksProxyAgent,StackUtils:()=>Gv,colors:()=>Fv,debug:()=>Mv,getProxyForUrl:()=>bh.getProxyForUrl,jpegjs:()=>Uv,lockfile:()=>Dv,mime:()=>jv,minimatch:()=>qv,ms:()=>Hv,program:()=>Sh.program,progress:()=>Vv,rimraf:()=>$v,ws:()=>zv,wsReceiver:()=>Yv,wsSender:()=>Kv,wsServer:()=>Wv});module.exports=Lh(Zv);var fh=Te(aa()),hh=Te(ii()),bh=Te(_a()),wh=Te(Oa()),ph=Te(Na()),dh=Te(hl()),mh=Te(yl()),gh=Te(Hi()),vh=Te(tn()),Eh=Te(Pc()),Sh=Te(Yc()),_h=Te(Jc()),xh=Te(Bu()),kh=Te(Xu()),yh=Te(nf());var Pv=Te(lf(),1),vo=Te(no(),1),_o=Te(so(),1),ch=Te(po(),1),xo=Te(lh(),1);var uh=ch.default;var Fv=fh.default,Mv=hh.default,Uv=ph.default,Dv=dh.default,jv=mh.default,qv=gh.default,Hv=vh.default,Vv=_h.default,$v=xh.default,Gv=yh.default,zv=uh,Wv=xo.default,Yv=vo.default,Kv=_o.default;0&&(0);
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */


/***/ }),

/***/ 6383:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.yazl = exports.yauzl = exports.extract = void 0;

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const yazl = (__nccwpck_require__(1916).yazl);

exports.yazl = yazl;

const yauzl = (__nccwpck_require__(1916).yauzl);

exports.yauzl = yauzl;

const extract = (__nccwpck_require__(1916).extract);

exports.extract = extract;

/***/ }),

/***/ 1916:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

"use strict";
var ht=Object.create;var ae=Object.defineProperty;var pt=Object.getOwnPropertyDescriptor;var mt=Object.getOwnPropertyNames;var xt=Object.getPrototypeOf,vt=Object.prototype.hasOwnProperty;var E=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports),Et=(e,r)=>{for(var t in r)ae(e,t,{get:r[t],enumerable:!0})},or=(e,r,t,n)=>{if(r&&typeof r=="object"||typeof r=="function")for(let i of mt(r))!vt.call(e,i)&&i!==t&&ae(e,i,{get:()=>r[i],enumerable:!(n=pt(r,i))||n.enumerable});return e};var Ue=(e,r,t)=>(t=e!=null?ht(xt(e)):{},or(r||!e||!e.__esModule?ae(t,"default",{value:e,enumerable:!0}):t,e)),wt=e=>or(ae({},"__esModule",{value:!0}),e);var Be=E((An,fr)=>{var T=(__nccwpck_require__(4300).Buffer),Te=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,936918e3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117];typeof Int32Array!="undefined"&&(Te=new Int32Array(Te));function sr(e){if(T.isBuffer(e))return e;var r=typeof T.alloc=="function"&&typeof T.from=="function";if(typeof e=="number")return r?T.alloc(e):new T(e);if(typeof e=="string")return r?T.from(e):new T(e);throw new Error("input must be buffer, number, or string, received "+typeof e)}function gt(e){var r=sr(4);return r.writeInt32BE(e,0),r}function Ne(e,r){e=sr(e),T.isBuffer(r)&&(r=r.readUInt32BE(0));for(var t=~~r^-1,n=0;n<e.length;n++)t=Te[(t^e[n])&255]^t>>>8;return t^-1}function Me(){return gt(Ne.apply(null,arguments))}Me.signed=function(){return Ne.apply(null,arguments)};Me.unsigned=function(){return Ne.apply(null,arguments)>>>0};fr.exports=Me});var br=E(Ge=>{var ar=__nccwpck_require__(7147),he=(__nccwpck_require__(2781).Transform),ur=(__nccwpck_require__(2781).PassThrough),cr=__nccwpck_require__(9796),We=__nccwpck_require__(3837),yt=(__nccwpck_require__(2361).EventEmitter),dr=Be();Ge.ZipFile=W;Ge.dateToDosDateTime=Cr;We.inherits(W,yt);function W(){this.outputStream=new ur,this.entries=[],this.outputStreamCursor=0,this.ended=!1,this.allDone=!1,this.forceZip64Eocd=!1}W.prototype.addFile=function(e,r,t){var n=this;r=pe(r,!1),t==null&&(t={});var i=new m(r,!1,t);n.entries.push(i),ar.stat(e,function(o,s){if(o)return n.emit("error",o);if(!s.isFile())return n.emit("error",new Error("not a file: "+e));i.uncompressedSize=s.size,t.mtime==null&&i.setLastModDate(s.mtime),t.mode==null&&i.setFileAttributesMode(s.mode),i.setFileDataPumpFunction(function(){var f=ar.createReadStream(e);i.state=m.FILE_DATA_IN_PROGRESS,f.on("error",function(u){n.emit("error",u)}),lr(n,i,f)}),M(n)})};W.prototype.addReadStream=function(e,r,t){var n=this;r=pe(r,!1),t==null&&(t={});var i=new m(r,!1,t);n.entries.push(i),i.setFileDataPumpFunction(function(){i.state=m.FILE_DATA_IN_PROGRESS,lr(n,i,e)}),M(n)};W.prototype.addBuffer=function(e,r,t){var n=this;if(r=pe(r,!1),e.length>1073741823)throw new Error("buffer too large: "+e.length+" > "+1073741823);if(t==null&&(t={}),t.size!=null)throw new Error("options.size not allowed");var i=new m(r,!1,t);i.uncompressedSize=e.length,i.crc32=dr.unsigned(e),i.crcAndFileSizeKnown=!0,n.entries.push(i),i.compress?cr.deflateRaw(e,function(s,f){o(f)}):o(e);function o(s){i.compressedSize=s.length,i.setFileDataPumpFunction(function(){Z(n,s),Z(n,i.getDataDescriptor()),i.state=m.FILE_DATA_DONE,setImmediate(function(){M(n)})}),M(n)}};W.prototype.addEmptyDirectory=function(e,r){var t=this;if(e=pe(e,!0),r==null&&(r={}),r.size!=null)throw new Error("options.size not allowed");if(r.compress!=null)throw new Error("options.compress not allowed");var n=new m(e,!0,r);t.entries.push(n),n.setFileDataPumpFunction(function(){Z(t,n.getDataDescriptor()),n.state=m.FILE_DATA_DONE,M(t)}),M(t)};var Ct=N([80,75,5,6]);W.prototype.end=function(e,r){if(typeof e=="function"&&(r=e,e=null),e==null&&(e={}),!this.ended){if(this.ended=!0,this.finalSizeCallback=r,this.forceZip64Eocd=!!e.forceZip64Format,e.comment){if(typeof e.comment=="string"?this.comment=St(e.comment):this.comment=e.comment,this.comment.length>65535)throw new Error("comment is too large");if(te(this.comment,Ct))throw new Error("comment contains end of central directory record signature")}else this.comment=me;M(this)}};function Z(e,r){e.outputStream.write(r),e.outputStreamCursor+=r.length}function lr(e,r,t){var n=new He,i=new le,o=r.compress?new cr.DeflateRaw:new ur,s=new le;t.pipe(n).pipe(i).pipe(o).pipe(s).pipe(e.outputStream,{end:!1}),s.on("end",function(){if(r.crc32=n.crc32,r.uncompressedSize==null)r.uncompressedSize=i.byteCount;else if(r.uncompressedSize!==i.byteCount)return e.emit("error",new Error("file data stream has unexpected number of bytes"));r.compressedSize=s.byteCount,e.outputStreamCursor+=r.compressedSize,Z(e,r.getDataDescriptor()),r.state=m.FILE_DATA_DONE,M(e)})}function M(e){if(e.allDone)return;if(e.ended&&e.finalSizeCallback!=null){var r=bt(e);r!=null&&(e.finalSizeCallback(r),e.finalSizeCallback=null)}var t=n();function n(){for(var o=0;o<e.entries.length;o++){var s=e.entries[o];if(s.state<m.FILE_DATA_DONE)return s}return null}if(t!=null){if(t.state<m.READY_TO_PUMP_FILE_DATA||t.state===m.FILE_DATA_IN_PROGRESS)return;t.relativeOffsetOfLocalHeader=e.outputStreamCursor;var i=t.getLocalFileHeader();Z(e,i),t.doFileDataPump()}else e.ended&&(e.offsetOfStartOfCentralDirectory=e.outputStreamCursor,e.entries.forEach(function(o){var s=o.getCentralDirectoryRecord();Z(e,s)}),Z(e,Ft(e)),e.outputStream.end(),e.allDone=!0)}function bt(e){for(var r=0,t=0,n=0;n<e.entries.length;n++){var i=e.entries[n];if(i.compress)return-1;if(i.state>=m.READY_TO_PUMP_FILE_DATA){if(i.uncompressedSize==null)return-1}else if(i.uncompressedSize==null)return null;i.relativeOffsetOfLocalHeader=r;var o=i.useZip64Format();r+=hr+i.utf8FileName.length,r+=i.uncompressedSize,i.crcAndFileSizeKnown||(o?r+=gr:r+=wr),t+=yr+i.utf8FileName.length+i.fileComment.length,o&&(t+=Pe)}var s=0;return(e.forceZip64Eocd||e.entries.length>=65535||t>=65535||r>=4294967295)&&(s+=ce+qe),s+=de+e.comment.length,r+t+s}var ce=56,qe=20,de=22;function Ft(e,r){var t=!1,n=e.entries.length;(e.forceZip64Eocd||e.entries.length>=65535)&&(n=65535,t=!0);var i=e.outputStreamCursor-e.offsetOfStartOfCentralDirectory,o=i;(e.forceZip64Eocd||i>=4294967295)&&(o=4294967295,t=!0);var s=e.offsetOfStartOfCentralDirectory;if((e.forceZip64Eocd||e.offsetOfStartOfCentralDirectory>=4294967295)&&(s=4294967295,t=!0),r)return t?ce+qe+de:de;var f=F(de+e.comment.length);if(f.writeUInt32LE(101010256,0),f.writeUInt16LE(0,4),f.writeUInt16LE(0,6),f.writeUInt16LE(n,8),f.writeUInt16LE(n,10),f.writeUInt32LE(o,12),f.writeUInt32LE(s,16),f.writeUInt16LE(e.comment.length,20),e.comment.copy(f,22),!t)return f;var u=F(ce);u.writeUInt32LE(101075792,0),I(u,ce-12,4),u.writeUInt16LE(xr,12),u.writeUInt16LE(mr,14),u.writeUInt32LE(0,16),u.writeUInt32LE(0,20),I(u,e.entries.length,24),I(u,e.entries.length,32),I(u,i,40),I(u,e.offsetOfStartOfCentralDirectory,48);var d=F(qe);return d.writeUInt32LE(117853008,0),d.writeUInt32LE(0,4),I(d,e.outputStreamCursor,8),d.writeUInt32LE(1,16),Buffer.concat([u,d,f])}function pe(e,r){if(e==="")throw new Error("empty metadataPath");if(e=e.replace(/\\/g,"/"),/^[a-zA-Z]:/.test(e)||/^\//.test(e))throw new Error("absolute path: "+e);if(e.split("/").indexOf("..")!==-1)throw new Error("invalid relative path: "+e);var t=/\/$/.test(e);if(r)t||(e+="/");else if(t)throw new Error("file path cannot end with '/': "+e);return e}var me=F(0);function m(e,r,t){if(this.utf8FileName=N(e),this.utf8FileName.length>65535)throw new Error("utf8 file name too long. "+utf8FileName.length+" > "+65535);if(this.isDirectory=r,this.state=m.WAITING_FOR_METADATA,this.setLastModDate(t.mtime!=null?t.mtime:new Date),t.mode!=null?this.setFileAttributesMode(t.mode):this.setFileAttributesMode(r?16893:33204),r?(this.crcAndFileSizeKnown=!0,this.crc32=0,this.uncompressedSize=0,this.compressedSize=0):(this.crcAndFileSizeKnown=!1,this.crc32=null,this.uncompressedSize=null,this.compressedSize=null,t.size!=null&&(this.uncompressedSize=t.size)),r?this.compress=!1:(this.compress=!0,t.compress!=null&&(this.compress=!!t.compress)),this.forceZip64Format=!!t.forceZip64Format,t.fileComment){if(typeof t.fileComment=="string"?this.fileComment=N(t.fileComment,"utf-8"):this.fileComment=t.fileComment,this.fileComment.length>65535)throw new Error("fileComment is too large")}else this.fileComment=me}m.WAITING_FOR_METADATA=0;m.READY_TO_PUMP_FILE_DATA=1;m.FILE_DATA_IN_PROGRESS=2;m.FILE_DATA_DONE=3;m.prototype.setLastModDate=function(e){var r=Cr(e);this.lastModFileTime=r.time,this.lastModFileDate=r.date};m.prototype.setFileAttributesMode=function(e){if((e&65535)!==e)throw new Error("invalid mode. expected: 0 <= "+e+" <= "+65535);this.externalFileAttributes=e<<16>>>0};m.prototype.setFileDataPumpFunction=function(e){this.doFileDataPump=e,this.state=m.READY_TO_PUMP_FILE_DATA};m.prototype.useZip64Format=function(){return this.forceZip64Format||this.uncompressedSize!=null&&this.uncompressedSize>4294967294||this.compressedSize!=null&&this.compressedSize>4294967294||this.relativeOffsetOfLocalHeader!=null&&this.relativeOffsetOfLocalHeader>4294967294};var hr=30,pr=20,mr=45,xr=3<<8|63,vr=1<<11,Er=1<<3;m.prototype.getLocalFileHeader=function(){var e=0,r=0,t=0;this.crcAndFileSizeKnown&&(e=this.crc32,r=this.compressedSize,t=this.uncompressedSize);var n=F(hr),i=vr;return this.crcAndFileSizeKnown||(i|=Er),n.writeUInt32LE(67324752,0),n.writeUInt16LE(pr,4),n.writeUInt16LE(i,6),n.writeUInt16LE(this.getCompressionMethod(),8),n.writeUInt16LE(this.lastModFileTime,10),n.writeUInt16LE(this.lastModFileDate,12),n.writeUInt32LE(e,14),n.writeUInt32LE(r,18),n.writeUInt32LE(t,22),n.writeUInt16LE(this.utf8FileName.length,26),n.writeUInt16LE(0,28),Buffer.concat([n,this.utf8FileName])};var wr=16,gr=24;m.prototype.getDataDescriptor=function(){if(this.crcAndFileSizeKnown)return me;if(this.useZip64Format()){var e=F(gr);return e.writeUInt32LE(134695760,0),e.writeUInt32LE(this.crc32,4),I(e,this.compressedSize,8),I(e,this.uncompressedSize,16),e}else{var e=F(wr);return e.writeUInt32LE(134695760,0),e.writeUInt32LE(this.crc32,4),e.writeUInt32LE(this.compressedSize,8),e.writeUInt32LE(this.uncompressedSize,12),e}};var yr=46,Pe=28;m.prototype.getCentralDirectoryRecord=function(){var e=F(yr),r=vr;this.crcAndFileSizeKnown||(r|=Er);var t=this.compressedSize,n=this.uncompressedSize,i=this.relativeOffsetOfLocalHeader,o,s;return this.useZip64Format()?(t=4294967295,n=4294967295,i=4294967295,o=mr,s=F(Pe),s.writeUInt16LE(1,0),s.writeUInt16LE(Pe-4,2),I(s,this.uncompressedSize,4),I(s,this.compressedSize,12),I(s,this.relativeOffsetOfLocalHeader,20)):(o=pr,s=me),e.writeUInt32LE(33639248,0),e.writeUInt16LE(xr,4),e.writeUInt16LE(o,6),e.writeUInt16LE(r,8),e.writeUInt16LE(this.getCompressionMethod(),10),e.writeUInt16LE(this.lastModFileTime,12),e.writeUInt16LE(this.lastModFileDate,14),e.writeUInt32LE(this.crc32,16),e.writeUInt32LE(t,20),e.writeUInt32LE(n,24),e.writeUInt16LE(this.utf8FileName.length,28),e.writeUInt16LE(s.length,30),e.writeUInt16LE(this.fileComment.length,32),e.writeUInt16LE(0,34),e.writeUInt16LE(0,36),e.writeUInt32LE(this.externalFileAttributes,38),e.writeUInt32LE(i,42),Buffer.concat([e,this.utf8FileName,s,this.fileComment])};m.prototype.getCompressionMethod=function(){var e=0,r=8;return this.compress?r:e};function Cr(e){var r=0;r|=e.getDate()&31,r|=(e.getMonth()+1&15)<<5,r|=(e.getFullYear()-1980&127)<<9;var t=0;return t|=Math.floor(e.getSeconds()/2),t|=(e.getMinutes()&63)<<5,t|=(e.getHours()&31)<<11,{date:r,time:t}}function I(e,r,t){var n=Math.floor(r/4294967296),i=r%4294967296;e.writeUInt32LE(i,t),e.writeUInt32LE(n,t+4)}We.inherits(le,he);function le(e){he.call(this,e),this.byteCount=0}le.prototype._transform=function(e,r,t){this.byteCount+=e.length,t(null,e)};We.inherits(He,he);function He(e){he.call(this,e),this.crc32=0}He.prototype._transform=function(e,r,t){this.crc32=dr.unsigned(e,this.crc32),t(null,e)};var Ze="\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";if(Ze.length!==256)throw new Error("assertion failure");var ue=null;function St(e){if(/^[\x20-\x7e]*$/.test(e))return N(e,"utf-8");if(ue==null){ue={};for(var r=0;r<Ze.length;r++)ue[Ze[r]]=r}for(var t=F(e.length),r=0;r<e.length;r++){var n=ue[e[r]];if(n==null)throw new Error("character not encodable in CP437: "+JSON.stringify(e[r]));t[r]=n}return t}function F(e){F=r;try{return F(e)}catch{return F=t,F(e)}function r(n){return Buffer.allocUnsafe(n)}function t(n){return new Buffer(n)}}function N(e,r){N=t;try{return N(e,r)}catch{return N=n,N(e,r)}function t(i,o){return Buffer.from(i,o)}function n(i,o){return new Buffer(i,o)}}function te(e,r){te=t;try{return te(e,r)}catch{return te=n,te(e,r)}function t(i,o){return i.includes(o)}function n(i,o){for(var s=0;s<=i.length-o.length;s++)for(var f=0;;f++){if(f===o.length)return!0;if(i[s+f]!==o[f])break}return!1}}});var Lr=E((Dn,Ir)=>{Ir.exports=xe;function xe(){this.pending=0,this.max=1/0,this.listeners=[],this.waiting=[],this.error=null}xe.prototype.go=function(e){this.pending<this.max?Sr(this,e):this.waiting.push(e)};xe.prototype.wait=function(e){this.pending===0?e(this.error):this.listeners.push(e)};xe.prototype.hold=function(){return Fr(this)};function Fr(e){e.pending+=1;var r=!1;return t;function t(i){if(r)throw new Error("callback called twice");if(r=!0,e.error=e.error||i,e.pending-=1,e.waiting.length>0&&e.pending<e.max)Sr(e,e.waiting.shift());else if(e.pending===0){var o=e.listeners;e.listeners=[],o.forEach(n)}}function n(i){i(e.error)}}function Sr(e,r){r(Fr(e))}});var zr=E(ie=>{var ne=__nccwpck_require__(7147),ve=__nccwpck_require__(3837),Ye=__nccwpck_require__(2781),Or=Ye.Readable,$e=Ye.Writable,It=Ye.PassThrough,Lt=Lr(),Ee=(__nccwpck_require__(2361).EventEmitter);ie.createFromBuffer=Ot;ie.createFromFd=zt;ie.BufferSlicer=D;ie.FdSlicer=R;ve.inherits(R,Ee);function R(e,r){r=r||{},Ee.call(this),this.fd=e,this.pend=new Lt,this.pend.max=1,this.refCount=0,this.autoClose=!!r.autoClose}R.prototype.read=function(e,r,t,n,i){var o=this;o.pend.go(function(s){ne.read(o.fd,e,r,t,n,function(f,u,d){s(),i(f,u,d)})})};R.prototype.write=function(e,r,t,n,i){var o=this;o.pend.go(function(s){ne.write(o.fd,e,r,t,n,function(f,u,d){s(),i(f,u,d)})})};R.prototype.createReadStream=function(e){return new we(this,e)};R.prototype.createWriteStream=function(e){return new ge(this,e)};R.prototype.ref=function(){this.refCount+=1};R.prototype.unref=function(){var e=this;if(e.refCount-=1,e.refCount>0)return;if(e.refCount<0)throw new Error("invalid unref");e.autoClose&&ne.close(e.fd,r);function r(t){t?e.emit("error",t):e.emit("close")}};ve.inherits(we,Or);function we(e,r){r=r||{},Or.call(this,r),this.context=e,this.context.ref(),this.start=r.start||0,this.endOffset=r.end,this.pos=this.start,this.destroyed=!1}we.prototype._read=function(e){var r=this;if(!r.destroyed){var t=Math.min(r._readableState.highWaterMark,e);if(r.endOffset!=null&&(t=Math.min(t,r.endOffset-r.pos)),t<=0){r.destroyed=!0,r.push(null),r.context.unref();return}r.context.pend.go(function(n){if(r.destroyed)return n();var i=Buffer.alloc(t);ne.read(r.context.fd,i,0,t,r.pos,function(o,s){o?r.destroy(o):s===0?(r.destroyed=!0,r.push(null),r.context.unref()):(r.pos+=s,r.push(i.slice(0,s))),n()})})}};we.prototype.destroy=function(e){this.destroyed||(e=e||new Error("stream destroyed"),this.destroyed=!0,this.emit("error",e),this.context.unref())};ve.inherits(ge,$e);function ge(e,r){r=r||{},$e.call(this,r),this.context=e,this.context.ref(),this.start=r.start||0,this.endOffset=r.end==null?1/0:+r.end,this.bytesWritten=0,this.pos=this.start,this.destroyed=!1,this.on("finish",this.destroy.bind(this))}ge.prototype._write=function(e,r,t){var n=this;if(!n.destroyed){if(n.pos+e.length>n.endOffset){var i=new Error("maximum file length exceeded");i.code="ETOOBIG",n.destroy(),t(i);return}n.context.pend.go(function(o){if(n.destroyed)return o();ne.write(n.context.fd,e,0,e.length,n.pos,function(s,f){s?(n.destroy(),o(),t(s)):(n.bytesWritten+=f,n.pos+=f,n.emit("progress"),o(),t())})})}};ge.prototype.destroy=function(){this.destroyed||(this.destroyed=!0,this.context.unref())};ve.inherits(D,Ee);function D(e,r){Ee.call(this),r=r||{},this.refCount=0,this.buffer=e,this.maxChunkSize=r.maxChunkSize||Number.MAX_SAFE_INTEGER}D.prototype.read=function(e,r,t,n,i){var o=n+t,s=o-this.buffer.length,f=s>0?s:t;this.buffer.copy(e,r,n,o),setImmediate(function(){i(null,f)})};D.prototype.write=function(e,r,t,n,i){e.copy(this.buffer,n,r,r+t),setImmediate(function(){i(null,t,e)})};D.prototype.createReadStream=function(e){e=e||{};var r=new It(e);r.destroyed=!1,r.start=e.start||0,r.endOffset=e.end,r.pos=r.endOffset||this.buffer.length;for(var t=this.buffer.slice(r.start,r.pos),n=0;;){var i=n+this.maxChunkSize;if(i>=t.length){n<t.length&&r.write(t.slice(n,t.length));break}r.write(t.slice(n,i)),n=i}return r.end(),r.destroy=function(){r.destroyed=!0},r};D.prototype.createWriteStream=function(e){var r=this;e=e||{};var t=new $e(e);return t.start=e.start||0,t.endOffset=e.end==null?this.buffer.length:+e.end,t.bytesWritten=0,t.pos=t.start,t.destroyed=!1,t._write=function(n,i,o){if(!t.destroyed){var s=t.pos+n.length;if(s>t.endOffset){var f=new Error("maximum file length exceeded");f.code="ETOOBIG",t.destroyed=!0,o(f);return}n.copy(r.buffer,t.pos,0,n.length),t.bytesWritten+=n.length,t.pos=s,t.emit("progress"),o()}},t.destroy=function(){t.destroyed=!0},t};D.prototype.ref=function(){this.refCount+=1};D.prototype.unref=function(){if(this.refCount-=1,this.refCount<0)throw new Error("invalid unref")};function Ot(e,r){return new D(e,r)}function zt(e,r){return new R(e,r)}});var Xe=E(A=>{var je=__nccwpck_require__(7147),_t=__nccwpck_require__(9796),_r=zr(),At=Be(),be=__nccwpck_require__(3837),Fe=(__nccwpck_require__(2361).EventEmitter),Ar=(__nccwpck_require__(2781).Transform),Ve=(__nccwpck_require__(2781).PassThrough),Rt=(__nccwpck_require__(2781).Writable);A.open=Dt;A.fromFd=Rr;A.fromBuffer=Ut;A.fromRandomAccessReader=Ke;A.dosDateTimeToDate=Ur;A.validateFileName=Tr;A.ZipFile=B;A.Entry=oe;A.RandomAccessReader=q;function Dt(e,r,t){typeof r=="function"&&(t=r,r=null),r==null&&(r={}),r.autoClose==null&&(r.autoClose=!0),r.lazyEntries==null&&(r.lazyEntries=!1),r.decodeStrings==null&&(r.decodeStrings=!0),r.validateEntrySizes==null&&(r.validateEntrySizes=!0),r.strictFileNames==null&&(r.strictFileNames=!1),t==null&&(t=Ce),je.open(e,"r",function(n,i){if(n)return t(n);Rr(i,r,function(o,s){o&&je.close(i,Ce),t(o,s)})})}function Rr(e,r,t){typeof r=="function"&&(t=r,r=null),r==null&&(r={}),r.autoClose==null&&(r.autoClose=!1),r.lazyEntries==null&&(r.lazyEntries=!1),r.decodeStrings==null&&(r.decodeStrings=!0),r.validateEntrySizes==null&&(r.validateEntrySizes=!0),r.strictFileNames==null&&(r.strictFileNames=!1),t==null&&(t=Ce),je.fstat(e,function(n,i){if(n)return t(n);var o=_r.createFromFd(e,{autoClose:!0});Ke(o,i.size,r,t)})}function Ut(e,r,t){typeof r=="function"&&(t=r,r=null),r==null&&(r={}),r.autoClose=!1,r.lazyEntries==null&&(r.lazyEntries=!1),r.decodeStrings==null&&(r.decodeStrings=!0),r.validateEntrySizes==null&&(r.validateEntrySizes=!0),r.strictFileNames==null&&(r.strictFileNames=!1);var n=_r.createFromBuffer(e,{maxChunkSize:65536});Ke(n,e.length,r,t)}function Ke(e,r,t,n){typeof t=="function"&&(n=t,t=null),t==null&&(t={}),t.autoClose==null&&(t.autoClose=!0),t.lazyEntries==null&&(t.lazyEntries=!1),t.decodeStrings==null&&(t.decodeStrings=!0);var i=!!t.decodeStrings;if(t.validateEntrySizes==null&&(t.validateEntrySizes=!0),t.strictFileNames==null&&(t.strictFileNames=!1),n==null&&(n=Ce),typeof r!="number")throw new Error("expected totalSize parameter to be a number");if(r>Number.MAX_SAFE_INTEGER)throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");e.ref();var o=22,s=65535,f=Math.min(o+s,r),u=_(f),d=r-u.length;$(e,u,0,f,d,function(a){if(a)return n(a);for(var c=f-o;c>=0;c-=1)if(u.readUInt32LE(c)===101010256){var l=u.slice(c),x=l.readUInt16LE(4);if(x!==0)return n(new Error("multi-disk zip files are not supported: found disk number: "+x));var g=l.readUInt16LE(10),p=l.readUInt32LE(16),h=l.readUInt16LE(20),v=l.length-o;if(h!==v)return n(new Error("invalid comment length. expected: "+v+". found: "+h));var w=i?ye(l,22,l.length,!1):l.slice(22);if(!(g===65535||p===4294967295))return n(null,new B(e,p,r,g,w,t.autoClose,t.lazyEntries,i,t.validateEntrySizes,t.strictFileNames));var b=_(20),U=d+c-b.length;$(e,b,0,b.length,U,function(Y){if(Y)return n(Y);if(b.readUInt32LE(0)!==117853008)return n(new Error("invalid zip64 end of central directory locator signature"));var ee=j(b,8),P=_(56);$(e,P,0,P.length,ee,function(re){return re?n(re):P.readUInt32LE(0)!==101075792?n(new Error("invalid zip64 end of central directory record signature")):(g=j(P,32),p=j(P,48),n(null,new B(e,p,r,g,w,t.autoClose,t.lazyEntries,i,t.validateEntrySizes,t.strictFileNames)))})});return}n(new Error("end of central directory record signature not found"))})}be.inherits(B,Fe);function B(e,r,t,n,i,o,s,f,u,d){var a=this;Fe.call(a),a.reader=e,a.reader.on("error",function(c){Dr(a,c)}),a.reader.once("close",function(){a.emit("close")}),a.readEntryCursor=r,a.fileSize=t,a.entryCount=n,a.comment=i,a.entriesRead=0,a.autoClose=!!o,a.lazyEntries=!!s,a.decodeStrings=!!f,a.validateEntrySizes=!!u,a.strictFileNames=!!d,a.isOpen=!0,a.emittedError=!1,a.lazyEntries||a._readEntry()}B.prototype.close=function(){!this.isOpen||(this.isOpen=!1,this.reader.unref())};function L(e,r){e.autoClose&&e.close(),Dr(e,r)}function Dr(e,r){e.emittedError||(e.emittedError=!0,e.emit("error",r))}B.prototype.readEntry=function(){if(!this.lazyEntries)throw new Error("readEntry() called without lazyEntries:true");this._readEntry()};B.prototype._readEntry=function(){var e=this;if(e.entryCount===e.entriesRead){setImmediate(function(){e.autoClose&&e.close(),!e.emittedError&&e.emit("end")});return}if(!e.emittedError){var r=_(46);$(e.reader,r,0,r.length,e.readEntryCursor,function(t){if(t)return L(e,t);if(!e.emittedError){var n=new oe,i=r.readUInt32LE(0);if(i!==33639248)return L(e,new Error("invalid central directory file header signature: 0x"+i.toString(16)));if(n.versionMadeBy=r.readUInt16LE(4),n.versionNeededToExtract=r.readUInt16LE(6),n.generalPurposeBitFlag=r.readUInt16LE(8),n.compressionMethod=r.readUInt16LE(10),n.lastModFileTime=r.readUInt16LE(12),n.lastModFileDate=r.readUInt16LE(14),n.crc32=r.readUInt32LE(16),n.compressedSize=r.readUInt32LE(20),n.uncompressedSize=r.readUInt32LE(24),n.fileNameLength=r.readUInt16LE(28),n.extraFieldLength=r.readUInt16LE(30),n.fileCommentLength=r.readUInt16LE(32),n.internalFileAttributes=r.readUInt16LE(36),n.externalFileAttributes=r.readUInt32LE(38),n.relativeOffsetOfLocalHeader=r.readUInt32LE(42),n.generalPurposeBitFlag&64)return L(e,new Error("strong encryption is not supported"));e.readEntryCursor+=46,r=_(n.fileNameLength+n.extraFieldLength+n.fileCommentLength),$(e.reader,r,0,r.length,e.readEntryCursor,function(o){if(o)return L(e,o);if(!e.emittedError){var s=(n.generalPurposeBitFlag&2048)!==0;n.fileName=e.decodeStrings?ye(r,0,n.fileNameLength,s):r.slice(0,n.fileNameLength);var f=n.fileNameLength+n.extraFieldLength,u=r.slice(n.fileNameLength,f);n.extraFields=[];for(var d=0;d<u.length-3;){var a=u.readUInt16LE(d+0),c=u.readUInt16LE(d+2),l=d+4,x=l+c;if(x>u.length)return L(e,new Error("extra field length exceeds extra field buffer size"));var g=_(c);u.copy(g,0,l,x),n.extraFields.push({id:a,data:g}),d=x}if(n.fileComment=e.decodeStrings?ye(r,f,f+n.fileCommentLength,s):r.slice(f,f+n.fileCommentLength),n.comment=n.fileComment,e.readEntryCursor+=r.length,e.entriesRead+=1,n.uncompressedSize===4294967295||n.compressedSize===4294967295||n.relativeOffsetOfLocalHeader===4294967295){for(var p=null,d=0;d<n.extraFields.length;d++){var h=n.extraFields[d];if(h.id===1){p=h.data;break}}if(p==null)return L(e,new Error("expected zip64 extended information extra field"));var v=0;if(n.uncompressedSize===4294967295){if(v+8>p.length)return L(e,new Error("zip64 extended information extra field does not include uncompressed size"));n.uncompressedSize=j(p,v),v+=8}if(n.compressedSize===4294967295){if(v+8>p.length)return L(e,new Error("zip64 extended information extra field does not include compressed size"));n.compressedSize=j(p,v),v+=8}if(n.relativeOffsetOfLocalHeader===4294967295){if(v+8>p.length)return L(e,new Error("zip64 extended information extra field does not include relative header offset"));n.relativeOffsetOfLocalHeader=j(p,v),v+=8}}if(e.decodeStrings)for(var d=0;d<n.extraFields.length;d++){var h=n.extraFields[d];if(h.id===28789){if(h.data.length<6||h.data.readUInt8(0)!==1)continue;var w=h.data.readUInt32LE(1);if(At.unsigned(r.slice(0,n.fileNameLength))!==w)continue;n.fileName=ye(h.data,5,h.data.length,!0);break}}if(e.validateEntrySizes&&n.compressionMethod===0){var b=n.uncompressedSize;if(n.isEncrypted()&&(b+=12),n.compressedSize!==b){var U="compressed/uncompressed size mismatch for stored file: "+n.compressedSize+" != "+n.uncompressedSize;return L(e,new Error(U))}}if(e.decodeStrings){e.strictFileNames||(n.fileName=n.fileName.replace(/\\/g,"/"));var Y=Tr(n.fileName,e.validateFileNameOptions);if(Y!=null)return L(e,new Error(Y))}e.emit("entry",n),e.lazyEntries||e._readEntry()}})}})}};B.prototype.openReadStream=function(e,r,t){var n=this,i=0,o=e.compressedSize;if(t==null)t=r,r={};else{if(r.decrypt!=null){if(!e.isEncrypted())throw new Error("options.decrypt can only be specified for encrypted entries");if(r.decrypt!==!1)throw new Error("invalid options.decrypt value: "+r.decrypt);if(e.isCompressed()&&r.decompress!==!1)throw new Error("entry is encrypted and compressed, and options.decompress !== false")}if(r.decompress!=null){if(!e.isCompressed())throw new Error("options.decompress can only be specified for compressed entries");if(!(r.decompress===!1||r.decompress===!0))throw new Error("invalid options.decompress value: "+r.decompress)}if(r.start!=null||r.end!=null){if(e.isCompressed()&&r.decompress!==!1)throw new Error("start/end range not allowed for compressed entry without options.decompress === false");if(e.isEncrypted()&&r.decrypt!==!1)throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false")}if(r.start!=null){if(i=r.start,i<0)throw new Error("options.start < 0");if(i>e.compressedSize)throw new Error("options.start > entry.compressedSize")}if(r.end!=null){if(o=r.end,o<0)throw new Error("options.end < 0");if(o>e.compressedSize)throw new Error("options.end > entry.compressedSize");if(o<i)throw new Error("options.end < options.start")}}if(!n.isOpen)return t(new Error("closed"));if(e.isEncrypted()&&r.decrypt!==!1)return t(new Error("entry is encrypted, and options.decrypt !== false"));n.reader.ref();var s=_(30);$(n.reader,s,0,s.length,e.relativeOffsetOfLocalHeader,function(f){try{if(f)return t(f);var u=s.readUInt32LE(0);if(u!==67324752)return t(new Error("invalid local file header signature: 0x"+u.toString(16)));var d=s.readUInt16LE(26),a=s.readUInt16LE(28),c=e.relativeOffsetOfLocalHeader+s.length+d+a,l;if(e.compressionMethod===0)l=!1;else if(e.compressionMethod===8)l=r.decompress!=null?r.decompress:!0;else return t(new Error("unsupported compression method: "+e.compressionMethod));var x=c,g=x+e.compressedSize;if(e.compressedSize!==0&&g>n.fileSize)return t(new Error("file data overflows file bounds: "+x+" + "+e.compressedSize+" > "+n.fileSize));var p=n.reader.createReadStream({start:x+i,end:x+o}),h=p;if(l){var v=!1,w=_t.createInflateRaw();p.on("error",function(b){setImmediate(function(){v||w.emit("error",b)})}),p.pipe(w),n.validateEntrySizes?(h=new se(e.uncompressedSize),w.on("error",function(b){setImmediate(function(){v||h.emit("error",b)})}),w.pipe(h)):h=w,h.destroy=function(){v=!0,w!==h&&w.unpipe(h),p.unpipe(w),p.destroy()}}t(null,h)}finally{n.reader.unref()}})};function oe(){}oe.prototype.getLastModDate=function(){return Ur(this.lastModFileDate,this.lastModFileTime)};oe.prototype.isEncrypted=function(){return(this.generalPurposeBitFlag&1)!==0};oe.prototype.isCompressed=function(){return this.compressionMethod===8};function Ur(e,r){var t=e&31,n=(e>>5&15)-1,i=(e>>9&127)+1980,o=0,s=(r&31)*2,f=r>>5&63,u=r>>11&31;return new Date(i,n,t,u,f,s,o)}function Tr(e){return e.indexOf("\\")!==-1?"invalid characters in fileName: "+e:/^[a-zA-Z]:/.test(e)||/^\//.test(e)?"absolute path: "+e:e.split("/").indexOf("..")!==-1?"invalid relative path: "+e:null}function $(e,r,t,n,i,o){if(n===0)return setImmediate(function(){o(null,_(0))});e.read(r,t,n,i,function(s,f){if(s)return o(s);if(f<n)return o(new Error("unexpected EOF"));o()})}be.inherits(se,Ar);function se(e){Ar.call(this),this.actualByteCount=0,this.expectedByteCount=e}se.prototype._transform=function(e,r,t){if(this.actualByteCount+=e.length,this.actualByteCount>this.expectedByteCount){var n="too many bytes in the stream. expected "+this.expectedByteCount+". got at least "+this.actualByteCount;return t(new Error(n))}t(null,e)};se.prototype._flush=function(e){if(this.actualByteCount<this.expectedByteCount){var r="not enough bytes in the stream. expected "+this.expectedByteCount+". got only "+this.actualByteCount;return e(new Error(r))}e()};be.inherits(q,Fe);function q(){Fe.call(this),this.refCount=0}q.prototype.ref=function(){this.refCount+=1};q.prototype.unref=function(){var e=this;if(e.refCount-=1,e.refCount>0)return;if(e.refCount<0)throw new Error("invalid unref");e.close(r);function r(t){if(t)return e.emit("error",t);e.emit("close")}};q.prototype.createReadStream=function(e){var r=e.start,t=e.end;if(r===t){var n=new Ve;return setImmediate(function(){n.end()}),n}var i=this._readStreamForRange(r,t),o=!1,s=new Se(this);i.on("error",function(u){setImmediate(function(){o||s.emit("error",u)})}),s.destroy=function(){i.unpipe(s),s.unref(),i.destroy()};var f=new se(t-r);return s.on("error",function(u){setImmediate(function(){o||f.emit("error",u)})}),f.destroy=function(){o=!0,s.unpipe(f),s.destroy()},i.pipe(s).pipe(f)};q.prototype._readStreamForRange=function(e,r){throw new Error("not implemented")};q.prototype.read=function(e,r,t,n,i){var o=this.createReadStream({start:n,end:n+t}),s=new Rt,f=0;s._write=function(u,d,a){u.copy(e,r+f,0,u.length),f+=u.length,a()},s.on("finish",i),o.on("error",function(u){i(u)}),o.pipe(s)};q.prototype.close=function(e){setImmediate(e)};be.inherits(Se,Ve);function Se(e){Ve.call(this),this.context=e,this.context.ref(),this.unreffedYet=!1}Se.prototype._flush=function(e){this.unref(),e()};Se.prototype.unref=function(e){this.unreffedYet||(this.unreffedYet=!0,this.context.unref())};var Tt="\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";function ye(e,r,t,n){if(n)return e.toString("utf8",r,t);for(var i="",o=r;o<t;o++)i+=Tt[e[o]];return i}function j(e,r){var t=e.readUInt32LE(r),n=e.readUInt32LE(r+4);return n*4294967296+t}var _;typeof Buffer.allocUnsafe=="function"?_=function(e){return Buffer.allocUnsafe(e)}:_=function(e){return new Buffer(e)};function Ce(e){if(e)throw e}});var Mr=E((Nn,Nr)=>{var V=1e3,K=V*60,X=K*60,H=X*24,Nt=H*7,Mt=H*365.25;Nr.exports=function(e,r){r=r||{};var t=typeof e;if(t==="string"&&e.length>0)return Bt(e);if(t==="number"&&isFinite(e))return r.long?Pt(e):qt(e);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(e))};function Bt(e){if(e=String(e),!(e.length>100)){var r=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);if(!!r){var t=parseFloat(r[1]),n=(r[2]||"ms").toLowerCase();switch(n){case"years":case"year":case"yrs":case"yr":case"y":return t*Mt;case"weeks":case"week":case"w":return t*Nt;case"days":case"day":case"d":return t*H;case"hours":case"hour":case"hrs":case"hr":case"h":return t*X;case"minutes":case"minute":case"mins":case"min":case"m":return t*K;case"seconds":case"second":case"secs":case"sec":case"s":return t*V;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function qt(e){var r=Math.abs(e);return r>=H?Math.round(e/H)+"d":r>=X?Math.round(e/X)+"h":r>=K?Math.round(e/K)+"m":r>=V?Math.round(e/V)+"s":e+"ms"}function Pt(e){var r=Math.abs(e);return r>=H?Ie(e,r,H,"day"):r>=X?Ie(e,r,X,"hour"):r>=K?Ie(e,r,K,"minute"):r>=V?Ie(e,r,V,"second"):e+" ms"}function Ie(e,r,t,n){var i=r>=t*1.5;return Math.round(e/t)+" "+n+(i?"s":"")}});var Je=E((Mn,Br)=>{function Zt(e){t.debug=t,t.default=t,t.coerce=u,t.disable=o,t.enable=i,t.enabled=s,t.humanize=Mr(),t.destroy=d,Object.keys(e).forEach(a=>{t[a]=e[a]}),t.names=[],t.skips=[],t.formatters={};function r(a){let c=0;for(let l=0;l<a.length;l++)c=(c<<5)-c+a.charCodeAt(l),c|=0;return t.colors[Math.abs(c)%t.colors.length]}t.selectColor=r;function t(a){let c,l=null,x,g;function p(...h){if(!p.enabled)return;let v=p,w=Number(new Date),b=w-(c||w);v.diff=b,v.prev=c,v.curr=w,c=w,h[0]=t.coerce(h[0]),typeof h[0]!="string"&&h.unshift("%O");let U=0;h[0]=h[0].replace(/%([a-zA-Z%])/g,(ee,P)=>{if(ee==="%%")return"%";U++;let re=t.formatters[P];if(typeof re=="function"){let lt=h[U];ee=re.call(v,lt),h.splice(U,1),U--}return ee}),t.formatArgs.call(v,h),(v.log||t.log).apply(v,h)}return p.namespace=a,p.useColors=t.useColors(),p.color=t.selectColor(a),p.extend=n,p.destroy=t.destroy,Object.defineProperty(p,"enabled",{enumerable:!0,configurable:!1,get:()=>l!==null?l:(x!==t.namespaces&&(x=t.namespaces,g=t.enabled(a)),g),set:h=>{l=h}}),typeof t.init=="function"&&t.init(p),p}function n(a,c){let l=t(this.namespace+(typeof c=="undefined"?":":c)+a);return l.log=this.log,l}function i(a){t.save(a),t.namespaces=a,t.names=[],t.skips=[];let c,l=(typeof a=="string"?a:"").split(/[\s,]+/),x=l.length;for(c=0;c<x;c++)!l[c]||(a=l[c].replace(/\*/g,".*?"),a[0]==="-"?t.skips.push(new RegExp("^"+a.slice(1)+"$")):t.names.push(new RegExp("^"+a+"$")))}function o(){let a=[...t.names.map(f),...t.skips.map(f).map(c=>"-"+c)].join(",");return t.enable(""),a}function s(a){if(a[a.length-1]==="*")return!0;let c,l;for(c=0,l=t.skips.length;c<l;c++)if(t.skips[c].test(a))return!1;for(c=0,l=t.names.length;c<l;c++)if(t.names[c].test(a))return!0;return!1}function f(a){return a.toString().substring(2,a.toString().length-2).replace(/\.\*\?$/,"*")}function u(a){return a instanceof Error?a.stack||a.message:a}function d(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}Br.exports=Zt});var qr=E((S,Le)=>{S.formatArgs=Ht;S.save=Gt;S.load=Yt;S.useColors=Wt;S.storage=$t();S.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})();S.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Wt(){return typeof window!="undefined"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document!="undefined"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window!="undefined"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function Ht(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+Le.exports.humanize(this.diff),!this.useColors)return;let r="color: "+this.color;e.splice(1,0,r,"color: inherit");let t=0,n=0;e[0].replace(/%[a-zA-Z%]/g,i=>{i!=="%%"&&(t++,i==="%c"&&(n=t))}),e.splice(n,0,r)}S.log=console.debug||console.log||(()=>{});function Gt(e){try{e?S.storage.setItem("debug",e):S.storage.removeItem("debug")}catch{}}function Yt(){let e;try{e=S.storage.getItem("debug")}catch{}return!e&&typeof process!="undefined"&&"env"in process&&(e=process.env.DEBUG),e}function $t(){try{return localStorage}catch{}}Le.exports=Je()(S);var{formatters:jt}=Le.exports;jt.j=function(e){try{return JSON.stringify(e)}catch(r){return"[UnexpectedJSONParseError]: "+r.message}}});var Zr=E((Bn,Pr)=>{"use strict";Pr.exports=(e,r)=>{r=r||process.argv;let t=e.startsWith("-")?"":e.length===1?"-":"--",n=r.indexOf(t+e),i=r.indexOf("--");return n!==-1&&(i===-1?!0:n<i)}});var Hr=E((qn,Wr)=>{"use strict";var Vt=__nccwpck_require__(2037),O=Zr(),C=process.env,J;O("no-color")||O("no-colors")||O("color=false")?J=!1:(O("color")||O("colors")||O("color=true")||O("color=always"))&&(J=!0);"FORCE_COLOR"in C&&(J=C.FORCE_COLOR.length===0||parseInt(C.FORCE_COLOR,10)!==0);function Kt(e){return e===0?!1:{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}function Xt(e){if(J===!1)return 0;if(O("color=16m")||O("color=full")||O("color=truecolor"))return 3;if(O("color=256"))return 2;if(e&&!e.isTTY&&J!==!0)return 0;let r=J?1:0;if(process.platform==="win32"){let t=Vt.release().split(".");return Number(process.versions.node.split(".")[0])>=8&&Number(t[0])>=10&&Number(t[2])>=10586?Number(t[2])>=14931?3:2:1}if("CI"in C)return["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI"].some(t=>t in C)||C.CI_NAME==="codeship"?1:r;if("TEAMCITY_VERSION"in C)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(C.TEAMCITY_VERSION)?1:0;if(C.COLORTERM==="truecolor")return 3;if("TERM_PROGRAM"in C){let t=parseInt((C.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(C.TERM_PROGRAM){case"iTerm.app":return t>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(C.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(C.TERM)||"COLORTERM"in C?1:(C.TERM==="dumb",r)}function Qe(e){let r=Xt(e);return Kt(r)}Wr.exports={supportsColor:Qe,stdout:Qe(process.stdout),stderr:Qe(process.stderr)}});var Yr=E((y,ze)=>{var Jt=__nccwpck_require__(6224),Oe=__nccwpck_require__(3837);y.init=on;y.log=rn;y.formatArgs=kt;y.save=tn;y.load=nn;y.useColors=Qt;y.destroy=Oe.deprecate(()=>{},"Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");y.colors=[6,2,3,4,5,1];try{let e=Hr();e&&(e.stderr||e).level>=2&&(y.colors=[20,21,26,27,32,33,38,39,40,41,42,43,44,45,56,57,62,63,68,69,74,75,76,77,78,79,80,81,92,93,98,99,112,113,128,129,134,135,148,149,160,161,162,163,164,165,166,167,168,169,170,171,172,173,178,179,184,185,196,197,198,199,200,201,202,203,204,205,206,207,208,209,214,215,220,221])}catch{}y.inspectOpts=Object.keys(process.env).filter(e=>/^debug_/i.test(e)).reduce((e,r)=>{let t=r.substring(6).toLowerCase().replace(/_([a-z])/g,(i,o)=>o.toUpperCase()),n=process.env[r];return/^(yes|on|true|enabled)$/i.test(n)?n=!0:/^(no|off|false|disabled)$/i.test(n)?n=!1:n==="null"?n=null:n=Number(n),e[t]=n,e},{});function Qt(){return"colors"in y.inspectOpts?Boolean(y.inspectOpts.colors):Jt.isatty(process.stderr.fd)}function kt(e){let{namespace:r,useColors:t}=this;if(t){let n=this.color,i="\x1B[3"+(n<8?n:"8;5;"+n),o=`  ${i};1m${r} \x1B[0m`;e[0]=o+e[0].split(`
`).join(`
`+o),e.push(i+"m+"+ze.exports.humanize(this.diff)+"\x1B[0m")}else e[0]=en()+r+" "+e[0]}function en(){return y.inspectOpts.hideDate?"":new Date().toISOString()+" "}function rn(...e){return process.stderr.write(Oe.format(...e)+`
`)}function tn(e){e?process.env.DEBUG=e:delete process.env.DEBUG}function nn(){return process.env.DEBUG}function on(e){e.inspectOpts={};let r=Object.keys(y.inspectOpts);for(let t=0;t<r.length;t++)e.inspectOpts[r[t]]=y.inspectOpts[r[t]]}ze.exports=Je()(y);var{formatters:Gr}=ze.exports;Gr.o=function(e){return this.inspectOpts.colors=this.useColors,Oe.inspect(e,this.inspectOpts).split(`
`).map(r=>r.trim()).join(" ")};Gr.O=function(e){return this.inspectOpts.colors=this.useColors,Oe.inspect(e,this.inspectOpts)}});var $r=E((Pn,ke)=>{typeof process=="undefined"||process.type==="renderer"||process.browser===!0||process.__nwjs?ke.exports=qr():ke.exports=Yr()});var Kr=E((Zn,Vr)=>{Vr.exports=jr;function jr(e,r){if(e&&r)return jr(e)(r);if(typeof e!="function")throw new TypeError("need wrapper function");return Object.keys(e).forEach(function(n){t[n]=e[n]}),t;function t(){for(var n=new Array(arguments.length),i=0;i<n.length;i++)n[i]=arguments[i];var o=e.apply(this,n),s=n[n.length-1];return typeof o=="function"&&o!==s&&Object.keys(s).forEach(function(f){o[f]=s[f]}),o}}});var rr=E((Wn,er)=>{var Xr=Kr();er.exports=Xr(_e);er.exports.strict=Xr(Jr);_e.proto=_e(function(){Object.defineProperty(Function.prototype,"once",{value:function(){return _e(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return Jr(this)},configurable:!0})});function _e(e){var r=function(){return r.called?r.value:(r.called=!0,r.value=e.apply(this,arguments))};return r.called=!1,r}function Jr(e){var r=function(){if(r.called)throw new Error(r.onceError);return r.called=!0,r.value=e.apply(this,arguments)},t=e.name||"Function wrapped with `once`";return r.onceError=t+" shouldn't be called more than once",r.called=!1,r}});var et=E((Hn,kr)=>{var sn=rr(),fn=function(){},an=function(e){return e.setHeader&&typeof e.abort=="function"},un=function(e){return e.stdio&&Array.isArray(e.stdio)&&e.stdio.length===3},Qr=function(e,r,t){if(typeof r=="function")return Qr(e,null,r);r||(r={}),t=sn(t||fn);var n=e._writableState,i=e._readableState,o=r.readable||r.readable!==!1&&e.readable,s=r.writable||r.writable!==!1&&e.writable,f=!1,u=function(){e.writable||d()},d=function(){s=!1,o||t.call(e)},a=function(){o=!1,s||t.call(e)},c=function(h){t.call(e,h?new Error("exited with error code: "+h):null)},l=function(h){t.call(e,h)},x=function(){process.nextTick(g)},g=function(){if(!f){if(o&&!(i&&i.ended&&!i.destroyed))return t.call(e,new Error("premature close"));if(s&&!(n&&n.ended&&!n.destroyed))return t.call(e,new Error("premature close"))}},p=function(){e.req.on("finish",d)};return an(e)?(e.on("complete",d),e.on("abort",x),e.req?p():e.on("request",p)):s&&!n&&(e.on("end",u),e.on("close",u)),un(e)&&e.on("exit",c),e.on("end",a),e.on("finish",d),r.error!==!1&&e.on("error",l),e.on("close",x),function(){f=!0,e.removeListener("complete",d),e.removeListener("abort",x),e.removeListener("request",p),e.req&&e.req.removeListener("finish",d),e.removeListener("end",u),e.removeListener("close",u),e.removeListener("finish",d),e.removeListener("exit",c),e.removeListener("end",a),e.removeListener("error",l),e.removeListener("close",x)}};kr.exports=Qr});var nt=E((Gn,tt)=>{var cn=rr(),dn=et(),tr=__nccwpck_require__(7147),fe=function(){},ln=/^v?\.0/.test(process.version),Ae=function(e){return typeof e=="function"},hn=function(e){return!ln||!tr?!1:(e instanceof(tr.ReadStream||fe)||e instanceof(tr.WriteStream||fe))&&Ae(e.close)},pn=function(e){return e.setHeader&&Ae(e.abort)},mn=function(e,r,t,n){n=cn(n);var i=!1;e.on("close",function(){i=!0}),dn(e,{readable:r,writable:t},function(s){if(s)return n(s);i=!0,n()});var o=!1;return function(s){if(!i&&!o){if(o=!0,hn(e))return e.close(fe);if(pn(e))return e.abort();if(Ae(e.destroy))return e.destroy();n(s||new Error("stream was destroyed"))}}},rt=function(e){e()},xn=function(e,r){return e.pipe(r)},vn=function(){var e=Array.prototype.slice.call(arguments),r=Ae(e[e.length-1]||fe)&&e.pop()||fe;if(Array.isArray(e[0])&&(e=e[0]),e.length<2)throw new Error("pump requires two streams per minimum");var t,n=e.map(function(i,o){var s=o<e.length-1,f=o>0;return mn(i,s,f,function(u){t||(t=u),u&&n.forEach(rt),!s&&(n.forEach(rt),r(t))})});return e.reduce(xn)};tt.exports=vn});var ot=E((Yn,it)=>{"use strict";var{PassThrough:En}=__nccwpck_require__(2781);it.exports=e=>{e={...e};let{array:r}=e,{encoding:t}=e,n=t==="buffer",i=!1;r?i=!(t||n):t=t||"utf8",n&&(t=null);let o=new En({objectMode:i});t&&o.setEncoding(t);let s=0,f=[];return o.on("data",u=>{f.push(u),i?s=f.length:s+=u.length}),o.getBufferedValue=()=>r?f:n?Buffer.concat(f,s):f.join(""),o.getBufferedLength=()=>s,o}});var st=E(($n,Q)=>{"use strict";var{constants:wn}=__nccwpck_require__(4300),gn=nt(),yn=ot(),Re=class extends Error{constructor(){super("maxBuffer exceeded"),this.name="MaxBufferError"}};async function De(e,r){if(!e)return Promise.reject(new Error("Expected a stream"));r={maxBuffer:1/0,...r};let{maxBuffer:t}=r,n;return await new Promise((i,o)=>{let s=f=>{f&&n.getBufferedLength()<=wn.MAX_LENGTH&&(f.bufferedData=n.getBufferedValue()),o(f)};n=gn(e,yn(r),f=>{if(f){s(f);return}i()}),n.on("data",()=>{n.getBufferedLength()>t&&s(new Re)})}),n.getBufferedValue()}Q.exports=De;Q.exports.default=De;Q.exports.buffer=(e,r)=>De(e,{...r,encoding:"buffer"});Q.exports.array=(e,r)=>De(e,{...r,array:!0});Q.exports.MaxBufferError=Re});var at=E((jn,ft)=>{var z=$r()("extract-zip"),{createWriteStream:Cn,promises:k}=__nccwpck_require__(7147),bn=st(),G=__nccwpck_require__(1017),{promisify:ir}=__nccwpck_require__(3837),Fn=__nccwpck_require__(2781),Sn=Xe(),In=ir(Sn.open),Ln=ir(Fn.pipeline),nr=class{constructor(r,t){this.zipPath=r,this.opts=t}async extract(){return z("opening",this.zipPath,"with opts",this.opts),this.zipfile=await In(this.zipPath,{lazyEntries:!0}),this.canceled=!1,new Promise((r,t)=>{this.zipfile.on("error",n=>{this.canceled=!0,t(n)}),this.zipfile.readEntry(),this.zipfile.on("close",()=>{this.canceled||(z("zip extraction complete"),r())}),this.zipfile.on("entry",async n=>{if(this.canceled){z("skipping entry",n.fileName,{cancelled:this.canceled});return}if(z("zipfile entry",n.fileName),n.fileName.startsWith("__MACOSX/")){this.zipfile.readEntry();return}let i=G.dirname(G.join(this.opts.dir,n.fileName));try{await k.mkdir(i,{recursive:!0});let o=await k.realpath(i);if(G.relative(this.opts.dir,o).split(G.sep).includes(".."))throw new Error(`Out of bound path "${o}" found while processing file ${n.fileName}`);await this.extractEntry(n),z("finished processing",n.fileName),this.zipfile.readEntry()}catch(o){this.canceled=!0,this.zipfile.close(),t(o)}})})}async extractEntry(r){if(this.canceled){z("skipping entry extraction",r.fileName,{cancelled:this.canceled});return}this.opts.onEntry&&this.opts.onEntry(r,this.zipfile);let t=G.join(this.opts.dir,r.fileName),n=r.externalFileAttributes>>16&65535,i=61440,o=16384,s=40960,f=(n&i)===s,u=(n&i)===o;!u&&r.fileName.endsWith("/")&&(u=!0);let d=r.versionMadeBy>>8;u||(u=d===0&&r.externalFileAttributes===16),z("extracting entry",{filename:r.fileName,isDir:u,isSymlink:f});let a=this.getExtractedMode(n,u)&511,c=u?t:G.dirname(t),l={recursive:!0};if(u&&(l.mode=a),z("mkdir",{dir:c,...l}),await k.mkdir(c,l),u)return;z("opening read stream",t);let x=await ir(this.zipfile.openReadStream.bind(this.zipfile))(r);if(f){let g=await bn(x);z("creating symlink",g,t),await k.symlink(g,t)}else await Ln(x,Cn(t,{mode:a}))}getExtractedMode(r,t){let n=r;return n===0&&(t?(this.opts.defaultDirMode&&(n=parseInt(this.opts.defaultDirMode,10)),n||(n=493)):(this.opts.defaultFileMode&&(n=parseInt(this.opts.defaultFileMode,10)),n||(n=420))),n}};ft.exports=async function(e,r){if(z("creating target directory",r.dir),!G.isAbsolute(r.dir))throw new Error("Target directory is expected to be absolute");return await k.mkdir(r.dir,{recursive:!0}),r.dir=await k.realpath(r.dir),new nr(e,r).extract()}});var zn={};Et(zn,{extract:()=>On,yauzl:()=>dt,yazl:()=>ct});module.exports=wt(zn);var ct=Ue(br()),dt=Ue(Xe()),ut=Ue(at()),On=ut.default;0&&(0);


/***/ }),

/***/ 2205:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = __nccwpck_require__(6570);


/***/ }),

/***/ 1269:
/***/ ((module) => {

module.exports = eval("require")("bufferutil");


/***/ }),

/***/ 4964:
/***/ ((module) => {

module.exports = eval("require")("electron/index.js");


/***/ }),

/***/ 4592:
/***/ ((module) => {

module.exports = eval("require")("utf-8-validate");


/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 4300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 2057:
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 9523:
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1405:
/***/ ((module) => {

"use strict";
module.exports = require("inspector");

/***/ }),

/***/ 8188:
/***/ ((module) => {

"use strict";
module.exports = require("module");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 4521:
/***/ ((module) => {

"use strict";
module.exports = require("readline");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 6224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 4655:
/***/ ((module) => {

"use strict";
module.exports = require("v8");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 1065:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"comment":"Do not edit this file, use utils/roll_browser.js","browsers":[{"name":"chromium","revision":"1019","installByDefault":true,"browserVersion":"105.0.5195.19"},{"name":"chromium-with-symbols","revision":"1019","installByDefault":false,"browserVersion":"105.0.5195.19"},{"name":"chromium-tip-of-tree","revision":"1031","installByDefault":false,"browserVersion":"106.0.5218.0"},{"name":"firefox","revision":"1344","installByDefault":true,"browserVersion":"103.0"},{"name":"firefox-beta","revision":"1343","installByDefault":false,"browserVersion":"103.0b5"},{"name":"webkit","revision":"1699","installByDefault":true,"revisionOverrides":{"mac10.14":"1446","mac10.15":"1616"},"browserVersion":"16.0"},{"name":"ffmpeg","revision":"1007","installByDefault":true}]}');

/***/ }),

/***/ 9870:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"Blackberry PlayBook":{"userAgent":"Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/16.0 Safari/536.2+","viewport":{"width":600,"height":1024},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Blackberry PlayBook landscape":{"userAgent":"Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/16.0 Safari/536.2+","viewport":{"width":1024,"height":600},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"BlackBerry Z30":{"userAgent":"Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/16.0 Mobile Safari/537.10+","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"BlackBerry Z30 landscape":{"userAgent":"Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/16.0 Mobile Safari/537.10+","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note 3":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/16.0 Mobile Safari/534.30","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note 3 landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/16.0 Mobile Safari/534.30","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note II":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/16.0 Mobile Safari/534.30","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy Note II landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/16.0 Mobile Safari/534.30","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy S III":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/16.0 Mobile Safari/534.30","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy S III landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/16.0 Mobile Safari/534.30","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Galaxy S5":{"userAgent":"Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S5 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S8":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":360,"height":740},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S8 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":740,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S9+":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":320,"height":658},"deviceScaleFactor":4.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy S9+ landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":658,"height":320},"deviceScaleFactor":4.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy Tab S4":{"userAgent":"Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","viewport":{"width":712,"height":1138},"deviceScaleFactor":2.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Galaxy Tab S4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","viewport":{"width":1138,"height":712},"deviceScaleFactor":2.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"iPad (gen 6)":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":768,"height":1024},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad (gen 6) landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":1024,"height":768},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad (gen 7)":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":810,"height":1080},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad (gen 7) landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":1080,"height":810},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Mini":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":768,"height":1024},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Mini landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":1024,"height":768},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Pro 11":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":834,"height":1194},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPad Pro 11 landscape":{"userAgent":"Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":1194,"height":834},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":667},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":667,"height":375},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6 Plus":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":414,"height":736},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 6 Plus landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":736,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":667},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":667,"height":375},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7 Plus":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":414,"height":736},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 7 Plus landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":736,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":667},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":667,"height":375},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8 Plus":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":414,"height":736},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 8 Plus landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":736,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone SE":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/16.0 Mobile/14E304 Safari/602.1","viewport":{"width":320,"height":568},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone SE landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/16.0 Mobile/14E304 Safari/602.1","viewport":{"width":568,"height":320},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone X":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":375,"height":812},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone X landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/16.0 Mobile/15A372 Safari/604.1","viewport":{"width":812,"height":375},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone XR":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":414,"height":896},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone XR landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","viewport":{"width":896,"height":414},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":414,"height":715},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":800,"height":364},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":375,"height":635},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":724,"height":325},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro Max":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":414,"height":715},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 11 Pro Max landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":414,"height":896},"viewport":{"width":808,"height":364},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":390,"height":664},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":750,"height":340},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":390,"height":664},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":750,"height":340},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro Max":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":428,"height":926},"viewport":{"width":428,"height":746},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Pro Max landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":428,"height":926},"viewport":{"width":832,"height":378},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Mini":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":375,"height":629},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 12 Mini landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":712,"height":325},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":390,"height":664},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":750,"height":342},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 Pro":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":390,"height":664},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 Pro landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":390,"height":844},"viewport":{"width":750,"height":342},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 Pro Max":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":428,"height":926},"viewport":{"width":428,"height":746},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 Pro Max landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":428,"height":926},"viewport":{"width":832,"height":380},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 Mini":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":375,"height":629},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"iPhone 13 Mini landscape":{"userAgent":"Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1","screen":{"width":375,"height":812},"viewport":{"width":712,"height":327},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"JioPhone 2":{"userAgent":"Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:103.0) Gecko/48.0 Firefox/103.0 KAIOS/2.5","viewport":{"width":240,"height":320},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"firefox"},"JioPhone 2 landscape":{"userAgent":"Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:103.0) Gecko/48.0 Firefox/103.0 KAIOS/2.5","viewport":{"width":320,"height":240},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"firefox"},"Kindle Fire HDX":{"userAgent":"Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true","viewport":{"width":800,"height":1280},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Kindle Fire HDX landscape":{"userAgent":"Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true","viewport":{"width":1280,"height":800},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"LG Optimus L70":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":384,"height":640},"deviceScaleFactor":1.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"LG Optimus L70 landscape":{"userAgent":"Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":640,"height":384},"deviceScaleFactor":1.25,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 550":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":640,"height":360},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 550 landscape":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":360,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 950":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":360,"height":640},"deviceScaleFactor":4,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Microsoft Lumia 950 landscape":{"userAgent":"Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36 Edge/14.14263","viewport":{"width":640,"height":360},"deviceScaleFactor":4,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 10":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","viewport":{"width":800,"height":1280},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 10 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","viewport":{"width":1280,"height":800},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 4":{"userAgent":"Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":384,"height":640},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":640,"height":384},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5X":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":412,"height":732},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 5X landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":732,"height":412},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6":{"userAgent":"Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":412,"height":732},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":732,"height":412},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6P":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":412,"height":732},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 6P landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":732,"height":412},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 7":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","viewport":{"width":600,"height":960},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nexus 7 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","viewport":{"width":960,"height":600},"deviceScaleFactor":2,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nokia Lumia 520":{"userAgent":"Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)","viewport":{"width":320,"height":533},"deviceScaleFactor":1.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nokia Lumia 520 landscape":{"userAgent":"Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)","viewport":{"width":533,"height":320},"deviceScaleFactor":1.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Nokia N9":{"userAgent":"Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13","viewport":{"width":480,"height":854},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Nokia N9 landscape":{"userAgent":"Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13","viewport":{"width":854,"height":480},"deviceScaleFactor":1,"isMobile":true,"hasTouch":true,"defaultBrowserType":"webkit"},"Pixel 2":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":411,"height":731},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 2 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":731,"height":411},"deviceScaleFactor":2.625,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 2 XL":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":411,"height":823},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 2 XL landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":823,"height":411},"deviceScaleFactor":3.5,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 3":{"userAgent":"Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":393,"height":786},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 3 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":786,"height":393},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4":{"userAgent":"Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":353,"height":745},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":745,"height":353},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4a (5G)":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","screen":{"width":412,"height":892},"viewport":{"width":412,"height":765},"deviceScaleFactor":2.63,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 4a (5G) landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","screen":{"height":892,"width":412},"viewport":{"width":840,"height":312},"deviceScaleFactor":2.63,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 5":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","screen":{"width":393,"height":851},"viewport":{"width":393,"height":727},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Pixel 5 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","screen":{"width":851,"height":393},"viewport":{"width":802,"height":293},"deviceScaleFactor":2.75,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Moto G4":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":360,"height":640},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Moto G4 landscape":{"userAgent":"Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Mobile Safari/537.36","viewport":{"width":640,"height":360},"deviceScaleFactor":3,"isMobile":true,"hasTouch":true,"defaultBrowserType":"chromium"},"Desktop Chrome HiDPI":{"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","screen":{"width":1792,"height":1120},"viewport":{"width":1280,"height":720},"deviceScaleFactor":2,"isMobile":false,"hasTouch":false,"defaultBrowserType":"chromium"},"Desktop Edge HiDPI":{"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36 Edg/105.0.5195.19","screen":{"width":1792,"height":1120},"viewport":{"width":1280,"height":720},"deviceScaleFactor":2,"isMobile":false,"hasTouch":false,"defaultBrowserType":"chromium"},"Desktop Firefox HiDPI":{"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:103.0) Gecko/20100101 Firefox/103.0","screen":{"width":1792,"height":1120},"viewport":{"width":1280,"height":720},"deviceScaleFactor":2,"isMobile":false,"hasTouch":false,"defaultBrowserType":"firefox"},"Desktop Safari":{"userAgent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Safari/605.1.15","screen":{"width":1792,"height":1120},"viewport":{"width":1280,"height":720},"deviceScaleFactor":2,"isMobile":false,"hasTouch":false,"defaultBrowserType":"webkit"},"Desktop Chrome":{"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36","screen":{"width":1920,"height":1080},"viewport":{"width":1280,"height":720},"deviceScaleFactor":1,"isMobile":false,"hasTouch":false,"defaultBrowserType":"chromium"},"Desktop Edge":{"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.5195.19 Safari/537.36 Edg/105.0.5195.19","screen":{"width":1920,"height":1080},"viewport":{"width":1280,"height":720},"deviceScaleFactor":1,"isMobile":false,"hasTouch":false,"defaultBrowserType":"chromium"},"Desktop Firefox":{"userAgent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:103.0) Gecko/20100101 Firefox/103.0","screen":{"width":1920,"height":1080},"viewport":{"width":1280,"height":720},"deviceScaleFactor":1,"isMobile":false,"hasTouch":false,"defaultBrowserType":"firefox"}}');

/***/ }),

/***/ 9415:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"playwright-core","version":"1.25.1","description":"A high-level API to automate web browsers","repository":"github:Microsoft/playwright","homepage":"https://playwright.dev","engines":{"node":">=14"},"author":{"name":"Microsoft Corporation"},"license":"Apache-2.0","exports":{".":{"types":"./index.d.ts","import":"./index.mjs","require":"./index.js","default":"./index.js"},"./cli":"./cli.js","./package.json":"./package.json","./lib/grid/gridServer":"./lib/grid/gridServer.js","./lib/outofprocess":"./lib/outofprocess.js","./lib/utils":"./lib/utils/index.js","./lib/utils/comparators":"./lib/utils/comparators.js","./lib/utils/eventsHelper":"./lib/utils/eventsHelper.js","./lib/utils/fileUtils":"./lib/utils/fileUtils.js","./lib/utils/httpServer":"./lib/utils/httpServer.js","./lib/utils/hostPlatform":"./lib/utils/hostPlatform.js","./lib/utils/manualPromise":"./lib/utils/manualPromise.js","./lib/utils/mimeType":"./lib/utils/mimeType.js","./lib/utils/multimap":"./lib/utils/multimap.js","./lib/utils/processLauncher":"./lib/utils/processLauncher.js","./lib/utils/processLauncherCleanupEntrypoint":"./lib/utils/processLauncherCleanupEntrypoint.js","./lib/utils/spawnAsync":"./lib/utils/spawnAsync.js","./lib/utils/stackTrace":"./lib/utils/stackTrace.js","./lib/utils/timeoutRunner":"./lib/utils/timeoutRunner.js","./lib/remote/playwrightServer":"./lib/remote/playwrightServer.js","./lib/server":"./lib/server/index.js","./lib/utilsBundle":"./lib/utilsBundle.js","./lib/zipBundle":"./lib/zipBundle.js","./types/protocol":"./types/protocol.d.ts","./types/structs":"./types/structs.d.ts"},"types":"types/types.d.ts","bin":{"playwright":"./cli.js"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId](module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
const playwright = __nccwpck_require__(2205);

const fs = __nccwpck_require__(7147);

(async () => {
  // const url = process.argv[3];

  const browser = await playwright.chromium.launch();
  const page = await browser.newPage();

  // // const reportUrl = `https://validator.nu/?doc=${url}`;
  const reportUrl =
    'https://validator.nu/?doc=https://accessibilitydemo.teamtailor.app';
  console.log('Navigating to', reportUrl);
  await page.goto(reportUrl);

  await page.waitForSelector('#results');
  const errorsCount = await page.locator('#results .error').count();
  await browser.close();

  console.log('Errors count', errorsCount);

  fs.writeFileSync('errors-count.txt', errorsCount);
  fs.writeFileSync('report-url.txt', reportUrl);
})();

})();

module.exports = __webpack_exports__;
/******/ })()
;